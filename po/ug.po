msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-10-08 09:10+0000\n"
"Last-Translator:  <Hyper-Hack@outlook.com>\n"
"Language-Team: Uighur\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ug\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "The Rust Programming Language"
msgstr "ÿ±ÿßÿ≥ÿ™ Ÿæÿ±Ÿà⁄Øÿ±ÿßŸÖŸÖÿß ÿ™€êŸÑŸâ ÿØ€ïÿ±Ÿâÿ≥ŸÑŸâŸÉŸâ"

#: src/SUMMARY.md:4
msgid "Foreword"
msgstr "ÿ¶Ÿâÿ≤ÿß⁄æÿßÿ™"

#: src/SUMMARY.md:5
msgid "Introduction"
msgstr "ÿ™ŸàŸÜ€áÿ¥ÿ™€áÿ±€áÿ¥"

#: src/SUMMARY.md:9
msgid "Getting Started"
msgstr "ÿ®ÿßÿ¥ŸÑÿßÿ¥"

#: src/SUMMARY.md:10
msgid "Installation"
msgstr "ŸÇÿß⁄ÜŸâŸÑÿßÿ¥"

#: src/SUMMARY.md:11
msgid "Hello, World!"
msgstr "ÿ≥ÿßŸÑÿßŸÖÿå ÿØ€áŸÜŸäÿß!"

#: src/SUMMARY.md:12
msgid "Hello, Cargo!"
msgstr ""

#: src/SUMMARY.md:14
msgid "Programming a Guessing Game"
msgstr ""

#: src/SUMMARY.md:16
msgid "Common Programming Concepts"
msgstr ""

#: src/SUMMARY.md:17
msgid "Variables and Mutability"
msgstr ""

#: src/SUMMARY.md:18
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md:19
msgid "Functions"
msgstr ""

#: src/SUMMARY.md:20
msgid "Comments"
msgstr ""

#: src/SUMMARY.md:21
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md:23
msgid "Understanding Ownership"
msgstr ""

#: src/SUMMARY.md:24
msgid "What is Ownership?"
msgstr ""

#: src/SUMMARY.md:25
msgid "References and Borrowing"
msgstr ""

#: src/SUMMARY.md:26
msgid "The Slice Type"
msgstr ""

#: src/SUMMARY.md:28
msgid "Using Structs to Structure Related Data"
msgstr ""

#: src/SUMMARY.md:29
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/SUMMARY.md:30
msgid "An Example Program Using Structs"
msgstr ""

#: src/SUMMARY.md:31
msgid "Method Syntax"
msgstr ""

#: src/SUMMARY.md:33
msgid "Enums and Pattern Matching"
msgstr ""

#: src/SUMMARY.md:34
msgid "Defining an Enum"
msgstr ""

#: src/SUMMARY.md:35
msgid "The match Control Flow Construct"
msgstr ""

#: src/SUMMARY.md:36
msgid "Concise Control Flow with if let"
msgstr ""

#: src/SUMMARY.md:40
msgid "Managing Growing Projects with Packages, Crates, and Modules"
msgstr ""

#: src/SUMMARY.md:41
msgid "Packages and Crates"
msgstr ""

#: src/SUMMARY.md:42
msgid "Defining Modules to Control Scope and Privacy"
msgstr ""

#: src/SUMMARY.md:43
msgid "Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/SUMMARY.md:44
msgid "Bringing Paths Into Scope with the use Keyword"
msgstr ""

#: src/SUMMARY.md:45
msgid "Separating Modules into Different Files"
msgstr ""

#: src/SUMMARY.md:47
msgid "Common Collections"
msgstr ""

#: src/SUMMARY.md:48
msgid "Storing Lists of Values with Vectors"
msgstr ""

#: src/SUMMARY.md:49
msgid "Storing UTF-8 Encoded Text with Strings"
msgstr ""

#: src/SUMMARY.md:50
msgid "Storing Keys with Associated Values in Hash Maps"
msgstr ""

#: src/SUMMARY.md:52
msgid "Error Handling"
msgstr ""

#: src/SUMMARY.md:53
msgid "Unrecoverable Errors with panic!"
msgstr ""

#: src/SUMMARY.md:54
msgid "Recoverable Errors with Result"
msgstr ""

#: src/SUMMARY.md:55
msgid "To panic! or Not to panic!"
msgstr ""

#: src/SUMMARY.md:57
msgid "Generic Types, Traits, and Lifetimes"
msgstr ""

#: src/SUMMARY.md:58
msgid "Generic Data Types"
msgstr ""

#: src/SUMMARY.md:59
msgid "Traits: Defining Shared Behavior"
msgstr ""

#: src/SUMMARY.md:60
msgid "Validating References with Lifetimes"
msgstr ""

#: src/SUMMARY.md:62
msgid "Writing Automated Tests"
msgstr ""

#: src/SUMMARY.md:63
msgid "How to Write Tests"
msgstr ""

#: src/SUMMARY.md:64
msgid "Controlling How Tests Are Run"
msgstr ""

#: src/SUMMARY.md:65
msgid "Test Organization"
msgstr ""

#: src/SUMMARY.md:67
msgid "An I/O Project: Building a Command Line Program"
msgstr ""

#: src/SUMMARY.md:68
msgid "Accepting Command Line Arguments"
msgstr ""

#: src/SUMMARY.md:69
msgid "Reading a File"
msgstr ""

#: src/SUMMARY.md:70
msgid "Refactoring to Improve Modularity and Error Handling"
msgstr ""

#: src/SUMMARY.md:71
msgid "Developing the Library‚Äôs Functionality with Test Driven Development"
msgstr ""

#: src/SUMMARY.md:72
msgid "Working with Environment Variables"
msgstr ""

#: src/SUMMARY.md:73
msgid "Writing Error Messages to Standard Error Instead of Standard Output"
msgstr ""

#: src/SUMMARY.md:77
msgid "Functional Language Features: Iterators and Closures"
msgstr ""

#: src/SUMMARY.md:78
msgid "Closures: Anonymous Functions that Capture Their Environment"
msgstr ""

#: src/SUMMARY.md:79
msgid "Processing a Series of Items with Iterators"
msgstr ""

#: src/SUMMARY.md:80
msgid "Improving Our I/O Project"
msgstr ""

#: src/SUMMARY.md:81
msgid "Comparing Performance: Loops vs. Iterators"
msgstr ""

#: src/SUMMARY.md:83
msgid "More about Cargo and Crates.io"
msgstr ""

#: src/SUMMARY.md:84
msgid "Customizing Builds with Release Profiles"
msgstr ""

#: src/SUMMARY.md:85
msgid "Publishing a Crate to Crates.io"
msgstr ""

#: src/SUMMARY.md:86
msgid "Cargo Workspaces"
msgstr ""

#: src/SUMMARY.md:87
msgid "Installing Binaries from Crates.io with`cargo install"
msgstr ""

#: src/SUMMARY.md:88
msgid "Extending Cargo with Custom Commands"
msgstr ""

#: src/SUMMARY.md:90
msgid "Smart Pointers"
msgstr ""

#: src/SUMMARY.md:91
msgid "Using Box'T' to Point to Data on the Heap"
msgstr ""

#: src/SUMMARY.md:92
msgid "Treating Smart Pointers Like Regular References with the Deref Trait"
msgstr ""

#: src/SUMMARY.md:93
msgid "Running Code on Cleanup with the Drop Trait"
msgstr ""

#: src/SUMMARY.md:94
msgid "Rc'T', the Reference Counted Smart Pointer"
msgstr ""

#: src/SUMMARY.md:95
msgid "RefCell'T' and the Interior Mutability Pattern"
msgstr ""

#: src/SUMMARY.md:96
msgid "Reference Cycles Can Leak Memory"
msgstr ""

#: src/SUMMARY.md:98
msgid "Fearless Concurrency"
msgstr ""

#: src/SUMMARY.md:99
msgid "Using Threads to Run Code Simultaneously"
msgstr ""

#: src/SUMMARY.md:100
msgid "Using Message Passing to Transfer Data Between Threads"
msgstr ""

#: src/SUMMARY.md:101
msgid "Shared-State Concurrency"
msgstr ""

#: src/SUMMARY.md:102
msgid "Extensible Concurrency with the Sync and Send Traits"
msgstr ""

#: src/SUMMARY.md:104
msgid "Object Oriented Programming Features of Rust"
msgstr ""

#: src/SUMMARY.md:105
msgid "Characteristics of Object-Oriented Languages"
msgstr ""

#: src/SUMMARY.md:106
msgid "Using Trait Objects That Allow for Values of Different Types"
msgstr ""

#: src/SUMMARY.md:107
msgid "Implementing an Object-Oriented Design Pattern"
msgstr ""

#: src/SUMMARY.md:111
msgid "Patterns and Matching"
msgstr ""

#: src/SUMMARY.md:112
msgid "All the Places Patterns Can Be Used"
msgstr ""

#: src/SUMMARY.md:113
msgid "Refutability: Whether a Pattern Might Fail to Match"
msgstr ""

#: src/SUMMARY.md:114
msgid "Pattern Syntax"
msgstr ""

#: src/SUMMARY.md:116
msgid "Advanced Features"
msgstr ""

#: src/SUMMARY.md:117
msgid "Unsafe Rust"
msgstr ""

#: src/SUMMARY.md:118
msgid "Advanced Traits"
msgstr ""

#: src/SUMMARY.md:119
msgid "Advanced Types"
msgstr ""

#: src/SUMMARY.md:120
msgid "Advanced Functions and Closures"
msgstr ""

#: src/SUMMARY.md:121
msgid "Macros"
msgstr ""

#: src/SUMMARY.md:123
msgid "Final Project: Building a Multithreaded Web Server"
msgstr ""

#: src/SUMMARY.md:124
msgid "Building a Single-Threaded Web Server"
msgstr ""

#: src/SUMMARY.md:125
msgid "Turning Our Single-Threaded Server into a Multithreaded Server"
msgstr ""

#: src/SUMMARY.md:126
msgid "Graceful Shutdown and Cleanup"
msgstr ""

#: src/SUMMARY.md:128
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md:129
msgid "A - Keywords"
msgstr ""

#: src/SUMMARY.md:130
msgid "B - Operators and Symbols"
msgstr ""

#: src/SUMMARY.md:131
msgid "C - Derivable Traits"
msgstr ""

#: src/SUMMARY.md:132
msgid "D - Useful Development Tools"
msgstr ""

#: src/SUMMARY.md:133
msgid "E - Editions"
msgstr ""

#: src/SUMMARY.md:134
msgid "F - Translations of the Book"
msgstr ""

#: src/SUMMARY.md:135
msgid "G - How Rust is Made and ‚ÄúNightly Rust‚Äù"
msgstr ""

#: src/title-page.md:1
msgid "# The Rust Programming Language"
msgstr ""

#: src/title-page.md:3
msgid ""
"*by Steve Klabnik and Carol Nichols, with contributions from the Rust "
"Community*"
msgstr ""

#: src/title-page.md:5
msgid ""
"This version of the text assumes you‚Äôre using Rust 1.67.1 (released "
"2023-02-09)\n"
"or later. See the [‚ÄúInstallation‚Äù section of Chapter 1][install]<!-- ignore "
"-->\n"
"to install or update Rust."
msgstr ""

#: src/title-page.md:9
msgid ""
"The HTML format is available online at\n"
"[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/"
"book/)\n"
"and offline with installations of Rust made with `rustup`; run `rustup docs\n"
"--book` to open."
msgstr ""

#: src/title-page.md:14
msgid "Several community [translations] are also available."
msgstr ""

#: src/title-page.md:16
msgid ""
"This text is available in [paperback and ebook format from No Starch\n"
"Press][nsprust]."
msgstr ""

#: src/title-page.md:24
msgid ""
"> **üö® Want a more interactive learning experience? Try out a different "
"version\n"
"> of the Rust Book, featuring: quizzes, highlighting, visualizations, and\n"
"> more**: <https://rust-book.cs.brown.edu>"
msgstr ""

#: src/foreword.md:1
msgid "# Foreword"
msgstr ""

#: src/foreword.md:3
msgid ""
"It wasn‚Äôt always so clear, but the Rust programming language is "
"fundamentally\n"
"about *empowerment*: no matter what kind of code you are writing now, Rust\n"
"empowers you to reach farther, to program with confidence in a wider variety "
"of\n"
"domains than you did before."
msgstr ""

#: src/foreword.md:8
msgid ""
"Take, for example, ‚Äúsystems-level‚Äù work that deals with low-level details "
"of\n"
"memory management, data representation, and concurrency. Traditionally, "
"this\n"
"realm of programming is seen as arcane, accessible only to a select few who\n"
"have devoted the necessary years learning to avoid its infamous pitfalls. "
"And\n"
"even those who practice it do so with caution, lest their code be open to\n"
"exploits, crashes, or corruption."
msgstr ""

#: src/foreword.md:15
msgid ""
"Rust breaks down these barriers by eliminating the old pitfalls and "
"providing a\n"
"friendly, polished set of tools to help you along the way. Programmers who "
"need\n"
"to ‚Äúdip down‚Äù into lower-level control can do so with Rust, without taking "
"on\n"
"the customary risk of crashes or security holes, and without having to "
"learn\n"
"the fine points of a fickle toolchain. Better yet, the language is designed "
"to\n"
"guide you naturally towards reliable code that is efficient in terms of "
"speed\n"
"and memory usage."
msgstr ""

#: src/foreword.md:23
msgid ""
"Programmers who are already working with low-level code can use Rust to "
"raise\n"
"their ambitions. For example, introducing parallelism in Rust is a "
"relatively\n"
"low-risk operation: the compiler will catch the classical mistakes for you. "
"And\n"
"you can tackle more aggressive optimizations in your code with the "
"confidence\n"
"that you won‚Äôt accidentally introduce crashes or vulnerabilities."
msgstr ""

#: src/foreword.md:29
msgid ""
"But Rust isn‚Äôt limited to low-level systems programming. It‚Äôs expressive "
"and\n"
"ergonomic enough to make CLI apps, web servers, and many other kinds of "
"code\n"
"quite pleasant to write ‚Äî you‚Äôll find simple examples of both later in the\n"
"book. Working with Rust allows you to build skills that transfer from one\n"
"domain to another; you can learn Rust by writing a web app, then apply "
"those\n"
"same skills to target your Raspberry Pi."
msgstr ""

#: src/foreword.md:36
msgid ""
"This book fully embraces the potential of Rust to empower its users. It‚Äôs a\n"
"friendly and approachable text intended to help you level up not just your\n"
"knowledge of Rust, but also your reach and confidence as a programmer in\n"
"general. So dive in, get ready to learn‚Äîand welcome to the Rust community!"
msgstr ""

#: src/foreword.md:41
msgid "‚Äî Nicholas Matsakis and Aaron Turon"
msgstr ""

#: src/ch00-00-introduction.md:1
msgid "# Introduction"
msgstr ""

#: src/ch00-00-introduction.md:3
msgid ""
"> Note: This edition of the book is the same as [The Rust Programming\n"
"> Language][nsprust] available in print and ebook format from [No Starch\n"
"> Press][nsp]."
msgstr ""

#: src/ch00-00-introduction.md:10
msgid ""
"Welcome to *The Rust Programming Language*, an introductory book about "
"Rust.\n"
"The Rust programming language helps you write faster, more reliable "
"software.\n"
"High-level ergonomics and low-level control are often at odds in "
"programming\n"
"language design; Rust challenges that conflict. Through balancing powerful\n"
"technical capacity and a great developer experience, Rust gives you the "
"option\n"
"to control low-level details (such as memory usage) without all the hassle\n"
"traditionally associated with such control."
msgstr ""

#: src/ch00-00-introduction.md:18
msgid "## Who Rust Is For"
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"Rust is ideal for many people for a variety of reasons. Let‚Äôs look at a few "
"of\n"
"the most important groups."
msgstr ""

#: src/ch00-00-introduction.md:23
msgid "### Teams of Developers"
msgstr ""

#: src/ch00-00-introduction.md:25
msgid ""
"Rust is proving to be a productive tool for collaborating among large teams "
"of\n"
"developers with varying levels of systems programming knowledge. Low-level "
"code\n"
"is prone to various subtle bugs, which in most other languages can be "
"caught\n"
"only through extensive testing and careful code review by experienced\n"
"developers. In Rust, the compiler plays a gatekeeper role by refusing to\n"
"compile code with these elusive bugs, including concurrency bugs. By "
"working\n"
"alongside the compiler, the team can spend their time focusing on the "
"program‚Äôs\n"
"logic rather than chasing down bugs."
msgstr ""

#: src/ch00-00-introduction.md:34
msgid ""
"Rust also brings contemporary developer tools to the systems programming "
"world:"
msgstr ""

#: src/ch00-00-introduction.md:36
msgid ""
"* Cargo, the included dependency manager and build tool, makes adding,\n"
"  compiling, and managing dependencies painless and consistent across the "
"Rust\n"
"  ecosystem.\n"
"* The Rustfmt formatting tool ensures a consistent coding style across\n"
"  developers.\n"
"* The Rust Language Server powers Integrated Development Environment (IDE)\n"
"  integration for code completion and inline error messages."
msgstr ""

#: src/ch00-00-introduction.md:44
msgid ""
"By using these and other tools in the Rust ecosystem, developers can be\n"
"productive while writing systems-level code."
msgstr ""

#: src/ch00-00-introduction.md:47
msgid "### Students"
msgstr ""

#: src/ch00-00-introduction.md:49
msgid ""
"Rust is for students and those who are interested in learning about systems\n"
"concepts. Using Rust, many people have learned about topics like operating\n"
"systems development. The community is very welcoming and happy to answer\n"
"student questions. Through efforts such as this book, the Rust teams want "
"to\n"
"make systems concepts more accessible to more people, especially those new "
"to\n"
"programming."
msgstr ""

#: src/ch00-00-introduction.md:56
msgid "### Companies"
msgstr ""

#: src/ch00-00-introduction.md:58
msgid ""
"Hundreds of companies, large and small, use Rust in production for a variety "
"of\n"
"tasks, including command line tools, web services, DevOps tooling, embedded\n"
"devices, audio and video analysis and transcoding, cryptocurrencies,\n"
"bioinformatics, search engines, Internet of Things applications, machine\n"
"learning, and even major parts of the Firefox web browser."
msgstr ""

#: src/ch00-00-introduction.md:64
msgid "### Open Source Developers"
msgstr ""

#: src/ch00-00-introduction.md:66
msgid ""
"Rust is for people who want to build the Rust programming language, "
"community,\n"
"developer tools, and libraries. We‚Äôd love to have you contribute to the "
"Rust\n"
"language."
msgstr ""

#: src/ch00-00-introduction.md:70
msgid "### People Who Value Speed and Stability"
msgstr ""

#: src/ch00-00-introduction.md:72
msgid ""
"Rust is for people who crave speed and stability in a language. By speed, "
"we\n"
"mean both how quickly Rust code can run and the speed at which Rust lets "
"you\n"
"write programs. The Rust compiler‚Äôs checks ensure stability through feature\n"
"additions and refactoring. This is in contrast to the brittle legacy code "
"in\n"
"languages without these checks, which developers are often afraid to modify. "
"By\n"
"striving for zero-cost abstractions, higher-level features that compile to\n"
"lower-level code as fast as code written manually, Rust endeavors to make "
"safe\n"
"code be fast code as well."
msgstr ""

#: src/ch00-00-introduction.md:81
msgid ""
"The Rust language hopes to support many other users as well; those "
"mentioned\n"
"here are merely some of the biggest stakeholders. Overall, Rust‚Äôs greatest\n"
"ambition is to eliminate the trade-offs that programmers have accepted for\n"
"decades by providing safety *and* productivity, speed *and* ergonomics. "
"Give\n"
"Rust a try and see if its choices work for you."
msgstr ""

#: src/ch00-00-introduction.md:87
msgid "## Who This Book Is For"
msgstr ""

#: src/ch00-00-introduction.md:89
msgid ""
"This book assumes that you‚Äôve written code in another programming language "
"but\n"
"doesn‚Äôt make any assumptions about which one. We‚Äôve tried to make the "
"material\n"
"broadly accessible to those from a wide variety of programming backgrounds. "
"We\n"
"don‚Äôt spend a lot of time talking about what programming *is* or how to "
"think\n"
"about it. If you‚Äôre entirely new to programming, you would be better served "
"by\n"
"reading a book that specifically provides an introduction to programming."
msgstr ""

#: src/ch00-00-introduction.md:96
msgid "## How to Use This Book"
msgstr ""

#: src/ch00-00-introduction.md:98
msgid ""
"In general, this book assumes that you‚Äôre reading it in sequence from front "
"to\n"
"back. Later chapters build on concepts in earlier chapters, and earlier\n"
"chapters might not delve into details on a particular topic but will "
"revisit\n"
"the topic in a later chapter."
msgstr ""

#: src/ch00-00-introduction.md:103
msgid ""
"You‚Äôll find two kinds of chapters in this book: concept chapters and "
"project\n"
"chapters. In concept chapters, you‚Äôll learn about an aspect of Rust. In "
"project\n"
"chapters, we‚Äôll build small programs together, applying what you‚Äôve learned "
"so\n"
"far. Chapters 2, 12, and 20 are project chapters; the rest are concept "
"chapters."
msgstr ""

#: src/ch00-00-introduction.md:108
msgid ""
"Chapter 1 explains how to install Rust, how to write a ‚ÄúHello, world!‚Äù "
"program,\n"
"and how to use Cargo, Rust‚Äôs package manager and build tool. Chapter 2 is a\n"
"hands-on introduction to writing a program in Rust, having you build up a\n"
"number guessing game. Here we cover concepts at a high level, and later\n"
"chapters will provide additional detail. If you want to get your hands "
"dirty\n"
"right away, Chapter 2 is the place for that. Chapter 3 covers Rust features\n"
"that are similar to those of other programming languages, and in Chapter 4\n"
"you‚Äôll learn about Rust‚Äôs ownership system. If you‚Äôre a particularly "
"meticulous\n"
"learner who prefers to learn every detail before moving on to the next, you\n"
"might want to skip Chapter 2 and go straight to Chapter 3, returning to "
"Chapter\n"
"2 when you‚Äôd like to work on a project applying the details you‚Äôve learned."
msgstr ""

#: src/ch00-00-introduction.md:120
msgid ""
"Chapter 5 discusses structs and methods, and Chapter 6 covers enums, "
"`match`\n"
"expressions, and the `if let` control flow construct. You‚Äôll use structs "
"and\n"
"enums to make custom types in Rust."
msgstr ""

#: src/ch00-00-introduction.md:124
msgid ""
"In Chapter 7, you‚Äôll learn about Rust‚Äôs module system and about privacy "
"rules\n"
"for organizing your code and its public Application Programming Interface\n"
"(API). Chapter 8 discusses some common collection data structures that the\n"
"standard library provides, such as vectors, strings, and hash maps. Chapter "
"9\n"
"explores Rust‚Äôs error-handling philosophy and techniques."
msgstr ""

#: src/ch00-00-introduction.md:130
msgid ""
"Chapter 10 digs into generics, traits, and lifetimes, which give you the "
"power\n"
"to define code that applies to multiple types. Chapter 11 is all about "
"testing,\n"
"which even with Rust‚Äôs safety guarantees is necessary to ensure your "
"program‚Äôs\n"
"logic is correct. In Chapter 12, we‚Äôll build our own implementation of a "
"subset\n"
"of functionality from the `grep` command line tool that searches for text\n"
"within files. For this, we‚Äôll use many of the concepts we discussed in the\n"
"previous chapters."
msgstr ""

#: src/ch00-00-introduction.md:138
msgid ""
"Chapter 13 explores closures and iterators: features of Rust that come from\n"
"functional programming languages. In Chapter 14, we‚Äôll examine Cargo in "
"more\n"
"depth and talk about best practices for sharing your libraries with others.\n"
"Chapter 15 discusses smart pointers that the standard library provides and "
"the\n"
"traits that enable their functionality."
msgstr ""

#: src/ch00-00-introduction.md:144
msgid ""
"In Chapter 16, we‚Äôll walk through different models of concurrent "
"programming\n"
"and talk about how Rust helps you to program in multiple threads "
"fearlessly.\n"
"Chapter 17 looks at how Rust idioms compare to object-oriented programming\n"
"principles you might be familiar with."
msgstr ""

#: src/ch00-00-introduction.md:149
msgid ""
"Chapter 18 is a reference on patterns and pattern matching, which are "
"powerful\n"
"ways of expressing ideas throughout Rust programs. Chapter 19 contains a\n"
"smorgasbord of advanced topics of interest, including unsafe Rust, macros, "
"and\n"
"more about lifetimes, traits, types, functions, and closures."
msgstr ""

#: src/ch00-00-introduction.md:154
msgid ""
"In Chapter 20, we‚Äôll complete a project in which we‚Äôll implement a low-"
"level\n"
"multithreaded web server!"
msgstr ""

#: src/ch00-00-introduction.md:157
msgid ""
"Finally, some appendices contain useful information about the language in a\n"
"more reference-like format. Appendix A covers Rust‚Äôs keywords, Appendix B\n"
"covers Rust‚Äôs operators and symbols, Appendix C covers derivable traits\n"
"provided by the standard library, Appendix D covers some useful development\n"
"tools, and Appendix E explains Rust editions. In Appendix F, you can find\n"
"translations of the book, and in Appendix G we‚Äôll cover how Rust is made "
"and\n"
"what nightly Rust is."
msgstr ""

#: src/ch00-00-introduction.md:165
msgid ""
"There is no wrong way to read this book: if you want to skip ahead, go for "
"it!\n"
"You might have to jump back to earlier chapters if you experience any\n"
"confusion. But do whatever works for you."
msgstr ""

#: src/ch00-00-introduction.md:169
msgid "<span id=\"ferris\"></span>"
msgstr ""

#: src/ch00-00-introduction.md:171
msgid ""
"An important part of the process of learning Rust is learning how to read "
"the\n"
"error messages the compiler displays: these will guide you toward working "
"code.\n"
"As such, we‚Äôll provide many examples that don‚Äôt compile along with the "
"error\n"
"message the compiler will show you in each situation. Know that if you "
"enter\n"
"and run a random example, it may not compile! Make sure you read the\n"
"surrounding text to see whether the example you‚Äôre trying to run is meant "
"to\n"
"error. Ferris will also help you distinguish code that isn‚Äôt meant to work:"
msgstr ""

#: src/ch00-00-introduction.md:179
msgid ""
"| "
"Ferris                                                                                                           "
"| Meaning                                          |\n"
"|------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|\n"
"| <img src=\"img/ferris/does_not_compile.svg\" class=\"ferris-explain\" "
"alt=\"Ferris with a question mark\"/>            | This code does not "
"compile!                      |\n"
"| <img src=\"img/ferris/panics.svg\" class=\"ferris-explain\" alt=\"Ferris "
"throwing up their hands\"/>                   | This code "
"panics!                                |\n"
"| <img src=\"img/ferris/not_desired_behavior.svg\" class=\"ferris-explain\" "
"alt=\"Ferris with one claw up, shrugging\"/> | This code does not produce "
"the desired behavior. |"
msgstr ""

#: src/ch00-00-introduction.md:185
msgid ""
"In most situations, we‚Äôll lead you to the correct version of any code that\n"
"doesn‚Äôt compile."
msgstr ""

#: src/ch00-00-introduction.md:188
msgid "## Source Code"
msgstr ""

#: src/ch00-00-introduction.md:190
msgid ""
"The source files from which this book is generated can be found on\n"
"[GitHub][book]."
msgstr ""

#: src/ch01-00-getting-started.md:1
msgid "# Getting Started"
msgstr ""

#: src/ch01-00-getting-started.md:3
msgid ""
"Let‚Äôs start your Rust journey! There‚Äôs a lot to learn, but every journey "
"starts\n"
"somewhere. In this chapter, we‚Äôll discuss:"
msgstr ""

#: src/ch01-00-getting-started.md:6
msgid ""
"* Installing Rust on Linux, macOS, and Windows\n"
"* Writing a program that prints `Hello, world!`\n"
"* Using `cargo`, Rust‚Äôs package manager and build system"
msgstr ""

#: src/ch01-01-installation.md:1
msgid "## Installation"
msgstr ""

#: src/ch01-01-installation.md:3
msgid ""
"The first step is to install Rust. We‚Äôll download Rust through `rustup`, a\n"
"command line tool for managing Rust versions and associated tools. You‚Äôll "
"need\n"
"an internet connection for the download."
msgstr ""

#: src/ch01-01-installation.md:7
msgid ""
"> Note: If you prefer not to use `rustup` for some reason, please see the\n"
"> [Other Rust Installation Methods page][otherinstall] for more options."
msgstr ""

#: src/ch01-01-installation.md:10
msgid ""
"The following steps install the latest stable version of the Rust compiler.\n"
"Rust‚Äôs stability guarantees ensure that all the examples in the book that\n"
"compile will continue to compile with newer Rust versions. The output might\n"
"differ slightly between versions because Rust often improves error messages "
"and\n"
"warnings. In other words, any newer, stable version of Rust you install "
"using\n"
"these steps should work as expected with the content of this book."
msgstr ""

#: src/ch01-01-installation.md:17
msgid ""
"> ### Command Line Notation\n"
">\n"
"> In this chapter and throughout the book, we‚Äôll show some commands used in "
"the\n"
"> terminal. Lines that you should enter in a terminal all start with `$`. "
"You\n"
"> don‚Äôt need to type the `$` character; it‚Äôs the command line prompt shown "
"to\n"
"> indicate the start of each command. Lines that don‚Äôt start with `$` "
"typically\n"
"> show the output of the previous command. Additionally, PowerShell-"
"specific\n"
"> examples will use `>` rather than `$`."
msgstr ""

#: src/ch01-01-installation.md:26
msgid "### Installing `rustup` on Linux or macOS"
msgstr ""

#: src/ch01-01-installation.md:28
msgid ""
"If you‚Äôre using Linux or macOS, open a terminal and enter the following "
"command:"
msgstr ""

#: src/ch01-01-installation.md:30
msgid ""
"```console\n"
"$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:34
msgid ""
"The command downloads a script and starts the installation of the `rustup`\n"
"tool, which installs the latest stable version of Rust. You might be "
"prompted\n"
"for your password. If the install is successful, the following line will "
"appear:"
msgstr ""

#: src/ch01-01-installation.md:38
msgid ""
"```text\n"
"Rust is installed now. Great!\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:42
msgid ""
"You will also need a *linker*, which is a program that Rust uses to join "
"its\n"
"compiled outputs into one file. It is likely you already have one. If you "
"get\n"
"linker errors, you should install a C compiler, which will typically include "
"a\n"
"linker. A C compiler is also useful because some common Rust packages depend "
"on\n"
"C code and will need a C compiler."
msgstr ""

#: src/ch01-01-installation.md:48
msgid "On macOS, you can get a C compiler by running:"
msgstr ""

#: src/ch01-01-installation.md:50
msgid ""
"```console\n"
"$ xcode-select --install\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:54
msgid ""
"Linux users should generally install GCC or Clang, according to their\n"
"distribution‚Äôs documentation. For example, if you use Ubuntu, you can "
"install\n"
"the `build-essential` package."
msgstr ""

#: src/ch01-01-installation.md:58
msgid "### Installing `rustup` on Windows"
msgstr ""

#: src/ch01-01-installation.md:60
msgid ""
"On Windows, go to [https://www.rust-lang.org/tools/install][install] and "
"follow\n"
"the instructions for installing Rust. At some point in the installation, "
"you‚Äôll\n"
"receive a message explaining that you‚Äôll also need the MSVC build tools for\n"
"Visual Studio 2013 or later."
msgstr ""

#: src/ch01-01-installation.md:65
msgid ""
"To acquire the build tools, you‚Äôll need to install [Visual Studio\n"
"2022][visualstudio]. When asked which workloads to install, include:"
msgstr ""

#: src/ch01-01-installation.md:68
msgid ""
"* ‚ÄúDesktop Development with C++‚Äù\n"
"* The Windows 10 or 11 SDK\n"
"* The English language pack component, along with any other language pack "
"of\n"
"  your choosing"
msgstr ""

#: src/ch01-01-installation.md:73
msgid ""
"The rest of this book uses commands that work in both *cmd.exe* and "
"PowerShell.\n"
"If there are specific differences, we‚Äôll explain which to use."
msgstr ""

#: src/ch01-01-installation.md:76
msgid "### Troubleshooting"
msgstr ""

#: src/ch01-01-installation.md:78
msgid ""
"To check whether you have Rust installed correctly, open a shell and enter "
"this\n"
"line:"
msgstr ""

#: src/ch01-01-installation.md:81
msgid ""
"```console\n"
"$ rustc --version\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:85
msgid ""
"You should see the version number, commit hash, and commit date for the "
"latest\n"
"stable version that has been released, in the following format:"
msgstr ""

#: src/ch01-01-installation.md:88
msgid ""
"```text\n"
"rustc x.y.z (abcabcabc yyyy-mm-dd)\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:92
msgid ""
"If you see this information, you have installed Rust successfully! If you "
"don‚Äôt\n"
"see this information, check that Rust is in your `%PATH%` system variable "
"as\n"
"follows."
msgstr ""

#: src/ch01-01-installation.md:96
msgid "In Windows CMD, use:"
msgstr ""

#: src/ch01-01-installation.md:98
msgid ""
"```console\n"
"> echo %PATH%\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:102
msgid "In PowerShell, use:"
msgstr ""

#: src/ch01-01-installation.md:104
msgid ""
"```powershell\n"
"> echo $env:Path\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:108
msgid "In Linux and macOS, use:"
msgstr ""

#: src/ch01-01-installation.md:110
msgid ""
"```console\n"
"$ echo $PATH\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:114
msgid ""
"If that‚Äôs all correct and Rust still isn‚Äôt working, there are a number of\n"
"places you can get help. Find out how to get in touch with other Rustaceans "
"(a\n"
"silly nickname we call ourselves) on [the community page][community]."
msgstr ""

#: src/ch01-01-installation.md:118
msgid "### Updating and Uninstalling"
msgstr ""

#: src/ch01-01-installation.md:120
msgid ""
"Once Rust is installed via `rustup`, updating to a newly released version "
"is\n"
"easy. From your shell, run the following update script:"
msgstr ""

#: src/ch01-01-installation.md:123
msgid ""
"```console\n"
"$ rustup update\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:127
msgid ""
"To uninstall Rust and `rustup`, run the following uninstall script from "
"your\n"
"shell:"
msgstr ""

#: src/ch01-01-installation.md:130
msgid ""
"```console\n"
"$ rustup self uninstall\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:134
msgid "### Local Documentation"
msgstr ""

#: src/ch01-01-installation.md:136
msgid ""
"The installation of Rust also includes a local copy of the documentation so\n"
"that you can read it offline. Run `rustup doc` to open the local "
"documentation\n"
"in your browser."
msgstr ""

#: src/ch01-01-installation.md:140
msgid ""
"Any time a type or function is provided by the standard library and you‚Äôre "
"not\n"
"sure what it does or how to use it, use the application programming "
"interface\n"
"(API) documentation to find out!"
msgstr ""

#: src/ch01-02-hello-world.md:1
msgid "## Hello, World!"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you‚Äôve installed Rust, it‚Äôs time to write your first Rust program.\n"
"It‚Äôs traditional when learning a new language to write a little program "
"that\n"
"prints the text `Hello, world!` to the screen, so we‚Äôll do the same here!"
msgstr ""

#: src/ch01-02-hello-world.md:7
msgid ""
"> Note: This book assumes basic familiarity with the command line. Rust "
"makes\n"
"> no specific demands about your editing or tooling or where your code "
"lives, so\n"
"> if you prefer to use an integrated development environment (IDE) instead "
"of\n"
"> the command line, feel free to use your favorite IDE. Many IDEs now have "
"some\n"
"> degree of Rust support; check the IDE‚Äôs documentation for details. The "
"Rust\n"
"> team has been focusing on enabling great IDE support via `rust-analyzer`. "
"See\n"
"> [Appendix D][devtools]<!-- ignore --> for more details."
msgstr ""

#: src/ch01-02-hello-world.md:15
msgid "### Creating a Project Directory"
msgstr ""

#: src/ch01-02-hello-world.md:17
msgid ""
"You‚Äôll start by making a directory to store your Rust code. It doesn‚Äôt "
"matter\n"
"to Rust where your code lives, but for the exercises and projects in this "
"book,\n"
"we suggest making a *projects* directory in your home directory and keeping "
"all\n"
"your projects there."
msgstr ""

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a *projects* "
"directory\n"
"and a directory for the ‚ÄúHello, world!‚Äù project within the *projects* "
"directory."
msgstr ""

#: src/ch01-02-hello-world.md:25
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:27
msgid ""
"```console\n"
"$ mkdir ~/projects\n"
"$ cd ~/projects\n"
"$ mkdir hello_world\n"
"$ cd hello_world\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:34
msgid "For Windows CMD, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:36
msgid ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\projects\"\n"
"> cd /d \"%USERPROFILE%\\projects\"\n"
"> mkdir hello_world\n"
"> cd hello_world\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:43
msgid "### Writing and Running a Rust Program"
msgstr ""

#: src/ch01-02-hello-world.md:45
msgid ""
"Next, make a new source file and call it *main.rs*. Rust files always end "
"with\n"
"the *.rs* extension. If you‚Äôre using more than one word in your filename, "
"the\n"
"convention is to use an underscore to separate them. For example, use\n"
"*hello_world.rs* rather than *helloworld.rs*."
msgstr ""

#: src/ch01-02-hello-world.md:50
msgid ""
"Now open the *main.rs* file you just created and enter the code in Listing "
"1-1."
msgstr ""

#: src/ch01-02-hello-world.md:52
msgid "<span class=\"filename\">Filename: main.rs</span>"
msgstr ""

#: src/ch01-02-hello-world.md:54 src/ch01-03-hello-cargo.md:97
#: src/ch02-00-guessing-game-tutorial.md:59
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello, world!\");\n"
"}\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:60
msgid ""
"<span class=\"caption\">Listing 1-1: A program that prints `Hello, world!`</"
"span>"
msgstr ""

#: src/ch01-02-hello-world.md:62
msgid ""
"Save the file and go back to your terminal window in the\n"
"*~/projects/hello_world* directory. On Linux or macOS, enter the following\n"
"commands to compile and run the file:"
msgstr ""

#: src/ch01-02-hello-world.md:66
msgid ""
"```console\n"
"$ rustc main.rs\n"
"$ ./main\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:72
msgid "On Windows, enter the command `.\\main.exe` instead of `./main`:"
msgstr ""

#: src/ch01-02-hello-world.md:74
msgid ""
"```powershell\n"
"> rustc main.rs\n"
"> .\\main.exe\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:80
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to\n"
"the terminal. If you don‚Äôt see this output, refer back to the\n"
"[‚ÄúTroubleshooting‚Äù][troubleshooting]<!-- ignore --> part of the "
"Installation\n"
"section for ways to get help."
msgstr ""

#: src/ch01-02-hello-world.md:85
msgid ""
"If `Hello, world!` did print, congratulations! You‚Äôve officially written a "
"Rust\n"
"program. That makes you a Rust programmer‚Äîwelcome!"
msgstr ""

#: src/ch01-02-hello-world.md:88
msgid "### Anatomy of a Rust Program"
msgstr ""

#: src/ch01-02-hello-world.md:90
msgid ""
"Let‚Äôs review this ‚ÄúHello, world!‚Äù program in detail. Here‚Äôs the first piece "
"of\n"
"the puzzle:"
msgstr ""

#: src/ch01-02-hello-world.md:93
msgid ""
"```rust\n"
"fn main() {\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:99
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it\n"
"is always the first code that runs in every executable Rust program. Here, "
"the\n"
"first line declares a function named `main` that has no parameters and "
"returns\n"
"nothing. If there were parameters, they would go inside the parentheses `()`."
msgstr ""

#: src/ch01-02-hello-world.md:104
msgid ""
"The function body is wrapped in `{}`. Rust requires curly brackets around "
"all\n"
"function bodies. It‚Äôs good style to place the opening curly bracket on the "
"same\n"
"line as the function declaration, adding one space in between."
msgstr ""

#: src/ch01-02-hello-world.md:108
msgid ""
"> Note: If you want to stick to a standard style across Rust projects, you "
"can\n"
"> use an automatic formatter tool called `rustfmt` to format your code in a\n"
"> particular style (more on `rustfmt` in\n"
"> [Appendix D][devtools]<!-- ignore -->). The Rust team has included this "
"tool\n"
"> with the standard Rust distribution, as `rustc` is, so it should already "
"be\n"
"> installed on your computer!"
msgstr ""

#: src/ch01-02-hello-world.md:115
msgid "The body of the `main` function holds the following code:"
msgstr ""

#: src/ch01-02-hello-world.md:117
msgid ""
"```rust\n"
"    println!(\"Hello, world!\");\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:121
msgid ""
"This line does all the work in this little program: it prints text to the\n"
"screen. There are four important details to notice here."
msgstr ""

#: src/ch01-02-hello-world.md:124
msgid "First, Rust style is to indent with four spaces, not a tab."
msgstr ""

#: src/ch01-02-hello-world.md:126
msgid ""
"Second, `println!` calls a Rust macro. If it had called a function instead, "
"it\n"
"would be entered as `println` (without the `!`). We‚Äôll discuss Rust macros "
"in\n"
"more detail in Chapter 19. For now, you just need to know that using a `!`\n"
"means that you‚Äôre calling a macro instead of a normal function and that "
"macros\n"
"don‚Äôt always follow the same rules as functions."
msgstr ""

#: src/ch01-02-hello-world.md:132
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument\n"
"to `println!`, and the string is printed to the screen."
msgstr ""

#: src/ch01-02-hello-world.md:135
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this\n"
"expression is over and the next one is ready to begin. Most lines of Rust "
"code\n"
"end with a semicolon."
msgstr ""

#: src/ch01-02-hello-world.md:139
msgid "### Compiling and Running Are Separate Steps"
msgstr ""

#: src/ch01-02-hello-world.md:141
msgid ""
"You‚Äôve just run a newly created program, so let‚Äôs examine each step in the\n"
"process."
msgstr ""

#: src/ch01-02-hello-world.md:144
msgid ""
"Before running a Rust program, you must compile it using the Rust compiler "
"by\n"
"entering the `rustc` command and passing it the name of your source file, "
"like\n"
"this:"
msgstr ""

#: src/ch01-02-hello-world.md:148
msgid ""
"```console\n"
"$ rustc main.rs\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:152
msgid ""
"If you have a C or C++ background, you‚Äôll notice that this is similar to "
"`gcc`\n"
"or `clang`. After compiling successfully, Rust outputs a binary executable."
msgstr ""

#: src/ch01-02-hello-world.md:155
msgid ""
"On Linux, macOS, and PowerShell on Windows, you can see the executable by\n"
"entering the `ls` command in your shell:"
msgstr ""

#: src/ch01-02-hello-world.md:158
msgid ""
"```console\n"
"$ ls\n"
"main  main.rs\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:163
msgid ""
"On Linux and macOS, you‚Äôll see two files. With PowerShell on Windows, "
"you‚Äôll\n"
"see the same three files that you would see using CMD. With CMD on Windows, "
"you\n"
"would enter the following:"
msgstr ""

#: src/ch01-02-hello-world.md:167
msgid ""
"```cmd\n"
"> dir /B %= the /B option says to only show the file names =%\n"
"main.exe\n"
"main.pdb\n"
"main.rs\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:174
msgid ""
"This shows the source code file with the *.rs* extension, the executable "
"file\n"
"(*main.exe* on Windows, but *main* on all other platforms), and, when using\n"
"Windows, a file containing debugging information with the *.pdb* extension.\n"
"From here, you run the *main* or *main.exe* file, like this:"
msgstr ""

#: src/ch01-02-hello-world.md:179
msgid ""
"```console\n"
"$ ./main # or .\\main.exe on Windows\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:183
msgid ""
"If your *main.rs* is your ‚ÄúHello, world!‚Äù program, this line prints `Hello,\n"
"world!` to your terminal."
msgstr ""

#: src/ch01-02-hello-world.md:186
msgid ""
"If you‚Äôre more familiar with a dynamic language, such as Ruby, Python, or\n"
"JavaScript, you might not be used to compiling and running a program as\n"
"separate steps. Rust is an *ahead-of-time compiled* language, meaning you "
"can\n"
"compile a program and give the executable to someone else, and they can run "
"it\n"
"even without having Rust installed. If you give someone a *.rb*, *.py*, or\n"
"*.js* file, they need to have a Ruby, Python, or JavaScript implementation\n"
"installed (respectively). But in those languages, you only need one command "
"to\n"
"compile and run your program. Everything is a trade-off in language design."
msgstr ""

#: src/ch01-02-hello-world.md:195
msgid ""
"Just compiling with `rustc` is fine for simple programs, but as your "
"project\n"
"grows, you‚Äôll want to manage all the options and make it easy to share your\n"
"code. Next, we‚Äôll introduce you to the Cargo tool, which will help you "
"write\n"
"real-world Rust programs."
msgstr ""

#: src/ch01-03-hello-cargo.md:1
msgid "## Hello, Cargo!"
msgstr ""

#: src/ch01-03-hello-cargo.md:3
msgid ""
"Cargo is Rust‚Äôs build system and package manager. Most Rustaceans use this "
"tool\n"
"to manage their Rust projects because Cargo handles a lot of tasks for you,\n"
"such as building your code, downloading the libraries your code depends on, "
"and\n"
"building those libraries. (We call the libraries that your code needs\n"
"*dependencies*.)"
msgstr ""

#: src/ch01-03-hello-cargo.md:9
msgid ""
"The simplest Rust programs, like the one we‚Äôve written so far, don‚Äôt have "
"any\n"
"dependencies. If we had built the ‚ÄúHello, world!‚Äù project with Cargo, it "
"would\n"
"only use the part of Cargo that handles building your code. As you write "
"more\n"
"complex Rust programs, you‚Äôll add dependencies, and if you start a project\n"
"using Cargo, adding dependencies will be much easier to do."
msgstr ""

#: src/ch01-03-hello-cargo.md:15
msgid ""
"Because the vast majority of Rust projects use Cargo, the rest of this book\n"
"assumes that you‚Äôre using Cargo too. Cargo comes installed with Rust if you\n"
"used the official installers discussed in the\n"
"[‚ÄúInstallation‚Äù][installation]<!-- ignore --> section. If you installed "
"Rust\n"
"through some other means, check whether Cargo is installed by entering the\n"
"following in your terminal:"
msgstr ""

#: src/ch01-03-hello-cargo.md:22
msgid ""
"```console\n"
"$ cargo --version\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:26
msgid ""
"If you see a version number, you have it! If you see an error, such as "
"`command\n"
"not found`, look at the documentation for your method of installation to\n"
"determine how to install Cargo separately."
msgstr ""

#: src/ch01-03-hello-cargo.md:30
msgid "### Creating a Project with Cargo"
msgstr ""

#: src/ch01-03-hello-cargo.md:32
msgid ""
"Let‚Äôs create a new project using Cargo and look at how it differs from our\n"
"original ‚ÄúHello, world!‚Äù project. Navigate back to your *projects* "
"directory\n"
"(or wherever you decided to store your code). Then, on any operating "
"system,\n"
"run the following:"
msgstr ""

#: src/ch01-03-hello-cargo.md:37
msgid ""
"```console\n"
"$ cargo new hello_cargo\n"
"$ cd hello_cargo\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:42
msgid ""
"The first command creates a new directory and project called *hello_cargo*.\n"
"We‚Äôve named our project *hello_cargo*, and Cargo creates its files in a\n"
"directory of the same name."
msgstr ""

#: src/ch01-03-hello-cargo.md:46
msgid ""
"Go into the *hello_cargo* directory and list the files. You‚Äôll see that "
"Cargo\n"
"has generated two files and one directory for us: a *Cargo.toml* file and a\n"
"*src* directory with a *main.rs* file inside."
msgstr ""

#: src/ch01-03-hello-cargo.md:50
msgid ""
"It has also initialized a new Git repository along with a *.gitignore* "
"file.\n"
"Git files won‚Äôt be generated if you run `cargo new` within an existing Git\n"
"repository; you can override this behavior by using `cargo new --vcs=git`."
msgstr ""

#: src/ch01-03-hello-cargo.md:54
msgid ""
"> Note: Git is a common version control system. You can change `cargo new` "
"to\n"
"> use a different version control system or no version control system by "
"using\n"
"> the `--vcs` flag. Run `cargo new --help` to see the available options."
msgstr ""

#: src/ch01-03-hello-cargo.md:58
msgid ""
"Open *Cargo.toml* in your text editor of choice. It should look similar to "
"the\n"
"code in Listing 1-2."
msgstr ""

#: src/ch01-03-hello-cargo.md:61 src/ch02-00-guessing-game-tutorial.md:41
#: src/ch02-00-guessing-game-tutorial.md:486
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:275
#: src/ch14-01-release-profiles.md:37 src/ch14-01-release-profiles.md:62
#: src/ch14-02-publishing-to-crates-io.md:411
#: src/ch14-02-publishing-to-crates-io.md:448
#: src/ch14-02-publishing-to-crates-io.md:470
#: src/ch14-03-cargo-workspaces.md:32 src/ch14-03-cargo-workspaces.md:87
msgid "<span class=\"filename\">Filename: Cargo.toml</span>"
msgstr ""

#: src/ch01-03-hello-cargo.md:63
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_cargo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"# See more keys and their definitions at https://doc.rust-lang.org/cargo/"
"reference/manifest.html\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:74
msgid ""
"<span class=\"caption\">Listing 1-2: Contents of *Cargo.toml* generated by "
"`cargo\n"
"new`</span>"
msgstr ""

#: src/ch01-03-hello-cargo.md:77
msgid ""
"This file is in the [*TOML*][toml]<!-- ignore --> (*Tom‚Äôs Obvious, Minimal\n"
"Language*) format, which is Cargo‚Äôs configuration format."
msgstr ""

#: src/ch01-03-hello-cargo.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the\n"
"following statements are configuring a package. As we add more information "
"to\n"
"this file, we‚Äôll add other sections."
msgstr ""

#: src/ch01-03-hello-cargo.md:84
msgid ""
"The next three lines set the configuration information Cargo needs to "
"compile\n"
"your program: the name, the version, and the edition of Rust to use. We‚Äôll "
"talk\n"
"about the `edition` key in [Appendix E][appendix-e]<!-- ignore -->."
msgstr ""

#: src/ch01-03-hello-cargo.md:88
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any\n"
"of your project‚Äôs dependencies. In Rust, packages of code are referred to "
"as\n"
"*crates*. We won‚Äôt need any other crates for this project, but we will in "
"the\n"
"first project in Chapter 2, so we‚Äôll use this dependencies section then."
msgstr ""

#: src/ch01-03-hello-cargo.md:93
msgid "Now open *src/main.rs* and take a look:"
msgstr ""

#: src/ch01-03-hello-cargo.md:95 src/ch02-00-guessing-game-tutorial.md:57
#: src/ch02-00-guessing-game-tutorial.md:89
#: src/ch02-00-guessing-game-tutorial.md:649
#: src/ch02-00-guessing-game-tutorial.md:745
#: src/ch02-00-guessing-game-tutorial.md:867
#: src/ch02-00-guessing-game-tutorial.md:990
#: src/ch02-00-guessing-game-tutorial.md:1085
#: src/ch02-00-guessing-game-tutorial.md:1137
#: src/ch02-00-guessing-game-tutorial.md:1247
#: src/ch03-01-variables-and-mutability.md:18
#: src/ch03-01-variables-and-mutability.md:79
#: src/ch03-01-variables-and-mutability.md:164 src/ch03-02-data-types.md:152
#: src/ch03-02-data-types.md:172 src/ch03-02-data-types.md:205
#: src/ch03-02-data-types.md:224 src/ch03-02-data-types.md:261
#: src/ch03-02-data-types.md:273 src/ch03-02-data-types.md:294
#: src/ch03-02-data-types.md:326 src/ch03-02-data-types.md:381
#: src/ch03-02-data-types.md:402 src/ch03-03-how-functions-work.md:12
#: src/ch03-03-how-functions-work.md:66 src/ch03-03-how-functions-work.md:102
#: src/ch03-03-how-functions-work.md:152 src/ch03-03-how-functions-work.md:168
#: src/ch03-03-how-functions-work.md:235 src/ch03-03-how-functions-work.md:275
#: src/ch03-03-how-functions-work.md:318 src/ch03-03-how-functions-work.md:336
#: src/ch03-04-comments.md:26 src/ch03-04-comments.md:37
#: src/ch03-05-control-flow.md:17 src/ch03-05-control-flow.md:85
#: src/ch03-05-control-flow.md:120 src/ch03-05-control-flow.md:139
#: src/ch03-05-control-flow.md:184 src/ch03-05-control-flow.md:217
#: src/ch03-05-control-flow.md:274 src/ch03-05-control-flow.md:420
#: src/ch03-05-control-flow.md:449 src/ch03-05-control-flow.md:498
#: src/ch03-05-control-flow.md:533 src/ch04-01-what-is-ownership.md:492
#: src/ch04-01-what-is-ownership.md:534 src/ch04-01-what-is-ownership.md:584
#: src/ch04-02-references-and-borrowing.md:15
#: src/ch04-02-references-and-borrowing.md:101
#: src/ch04-02-references-and-borrowing.md:142
#: src/ch04-02-references-and-borrowing.md:165
#: src/ch04-02-references-and-borrowing.md:321
#: src/ch04-02-references-and-borrowing.md:368 src/ch04-03-slices.md:24
#: src/ch04-03-slices.md:124 src/ch04-03-slices.md:253
#: src/ch04-03-slices.md:296 src/ch04-03-slices.md:428
#: src/ch05-01-defining-structs.md:16 src/ch05-01-defining-structs.md:41
#: src/ch05-01-defining-structs.md:70 src/ch05-01-defining-structs.md:104
#: src/ch05-01-defining-structs.md:149 src/ch05-01-defining-structs.md:196
#: src/ch05-01-defining-structs.md:232 src/ch05-01-defining-structs.md:295
#: src/ch05-01-defining-structs.md:326 src/ch05-02-example-structs.md:12
#: src/ch05-02-example-structs.md:76 src/ch05-02-example-structs.md:114
#: src/ch05-02-example-structs.md:169 src/ch05-02-example-structs.md:238
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:90
#: src/ch05-03-method-syntax.md:187 src/ch05-03-method-syntax.md:235
#: src/ch05-03-method-syntax.md:298
#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:69
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:135
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:339
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:378
#: src/ch09-01-unrecoverable-errors-with-panic.md:34
#: src/ch09-01-unrecoverable-errors-with-panic.md:74
#: src/ch09-02-recoverable-errors-with-result.md:32
#: src/ch09-02-recoverable-errors-with-result.md:66
#: src/ch09-02-recoverable-errors-with-result.md:119
#: src/ch09-02-recoverable-errors-with-result.md:211
#: src/ch09-02-recoverable-errors-with-result.md:241
#: src/ch09-02-recoverable-errors-with-result.md:287
#: src/ch09-02-recoverable-errors-with-result.md:374
#: src/ch09-02-recoverable-errors-with-result.md:430
#: src/ch09-02-recoverable-errors-with-result.md:463
#: src/ch09-02-recoverable-errors-with-result.md:502 src/ch10-00-generics.md:45
#: src/ch10-00-generics.md:80 src/ch10-00-generics.md:127
#: src/ch10-01-syntax.md:19 src/ch10-01-syntax.md:97 src/ch10-01-syntax.md:167
#: src/ch10-01-syntax.md:195 src/ch10-01-syntax.md:234
#: src/ch10-01-syntax.md:307 src/ch10-01-syntax.md:350
#: src/ch10-01-syntax.md:393 src/ch10-01-syntax.md:470
#: src/ch10-03-lifetime-syntax.md:146 src/ch10-03-lifetime-syntax.md:171
#: src/ch10-03-lifetime-syntax.md:274 src/ch10-03-lifetime-syntax.md:340
#: src/ch10-03-lifetime-syntax.md:379 src/ch10-03-lifetime-syntax.md:450
#: src/ch10-03-lifetime-syntax.md:478 src/ch10-03-lifetime-syntax.md:533
#: src/ch12-01-accepting-command-line-arguments.md:42
#: src/ch12-01-accepting-command-line-arguments.md:123
#: src/ch12-02-reading-a-file.md:30
#: src/ch12-03-improving-error-handling-and-modularity.md:73
#: src/ch12-03-improving-error-handling-and-modularity.md:139
#: src/ch12-03-improving-error-handling-and-modularity.md:235
#: src/ch12-03-improving-error-handling-and-modularity.md:308
#: src/ch12-03-improving-error-handling-and-modularity.md:399
#: src/ch12-03-improving-error-handling-and-modularity.md:466
#: src/ch12-03-improving-error-handling-and-modularity.md:560
#: src/ch12-03-improving-error-handling-and-modularity.md:628
#: src/ch12-03-improving-error-handling-and-modularity.md:751
#: src/ch12-03-improving-error-handling-and-modularity.md:878
#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:57
#: src/ch13-01-closures.md:38 src/ch13-01-closures.md:164
#: src/ch13-01-closures.md:236 src/ch13-01-closures.md:291
#: src/ch13-01-closures.md:332 src/ch13-01-closures.md:379
#: src/ch13-01-closures.md:498 src/ch13-01-closures.md:554
#: src/ch13-01-closures.md:623 src/ch13-02-iterators.md:179
#: src/ch13-02-iterators.md:224 src/ch13-03-improving-our-io-project.md:150
#: src/ch13-03-improving-our-io-project.md:179
#: src/ch14-02-publishing-to-crates-io.md:260
#: src/ch14-02-publishing-to-crates-io.md:345 src/ch15-01-box.md:38
#: src/ch15-01-box.md:112 src/ch15-01-box.md:134 src/ch15-01-box.md:258
#: src/ch15-02-deref.md:32 src/ch15-02-deref.md:94 src/ch15-02-deref.md:128
#: src/ch15-02-deref.md:154 src/ch15-02-deref.md:205 src/ch15-02-deref.md:302
#: src/ch15-02-deref.md:319 src/ch15-02-deref.md:365 src/ch15-03-drop.md:31
#: src/ch15-03-drop.md:106 src/ch15-03-drop.md:170 src/ch15-04-rc.md:51
#: src/ch15-04-rc.md:111 src/ch15-04-rc.md:157
#: src/ch15-05-interior-mutability.md:602 src/ch15-06-reference-cycles.md:18
#: src/ch15-06-reference-cycles.md:59 src/ch15-06-reference-cycles.md:220
#: src/ch15-06-reference-cycles.md:255 src/ch15-06-reference-cycles.md:308
#: src/ch15-06-reference-cycles.md:346 src/ch15-06-reference-cycles.md:427
#: src/ch16-01-threads.md:42 src/ch16-01-threads.md:113
#: src/ch16-01-threads.md:171 src/ch16-01-threads.md:236
#: src/ch16-01-threads.md:296 src/ch16-01-threads.md:343
#: src/ch16-02-message-passing.md:36 src/ch16-02-message-passing.md:73
#: src/ch16-02-message-passing.md:106 src/ch16-02-message-passing.md:169
#: src/ch16-02-message-passing.md:231 src/ch16-02-message-passing.md:298
#: src/ch16-03-shared-state.md:55 src/ch16-03-shared-state.md:112
#: src/ch16-03-shared-state.md:187 src/ch16-03-shared-state.md:292
#: src/ch17-02-trait-objects.md:227 src/ch17-02-trait-objects.md:256
#: src/ch17-02-trait-objects.md:327 src/ch17-03-oo-design-patterns.md:43
#: src/ch17-03-oo-design-patterns.md:750 src/ch17-03-oo-design-patterns.md:912
#: src/ch18-01-all-the-places-for-patterns.md:66
#: src/ch18-01-all-the-places-for-patterns.md:290
#: src/ch18-03-pattern-syntax.md:41 src/ch18-03-pattern-syntax.md:165
#: src/ch18-03-pattern-syntax.md:197 src/ch18-03-pattern-syntax.md:230
#: src/ch18-03-pattern-syntax.md:278 src/ch18-03-pattern-syntax.md:414
#: src/ch18-03-pattern-syntax.md:512 src/ch18-03-pattern-syntax.md:606
#: src/ch18-03-pattern-syntax.md:631 src/ch18-03-pattern-syntax.md:718
#: src/ch19-01-unsafe-rust.md:407 src/ch19-01-unsafe-rust.md:465
#: src/ch19-01-unsafe-rust.md:495 src/ch19-03-advanced-traits.md:129
#: src/ch19-03-advanced-traits.md:252 src/ch19-03-advanced-traits.md:293
#: src/ch19-03-advanced-traits.md:340 src/ch19-03-advanced-traits.md:413
#: src/ch19-03-advanced-traits.md:466 src/ch19-03-advanced-traits.md:526
#: src/ch19-03-advanced-traits.md:614 src/ch19-03-advanced-traits.md:647
#: src/ch19-03-advanced-traits.md:703 src/ch19-03-advanced-traits.md:765
#: src/ch19-05-advanced-functions-and-closures.md:25 src/ch19-06-macros.md:216
#: src/ch20-01-single-threaded.md:37 src/ch20-01-single-threaded.md:140
#: src/ch20-01-single-threaded.md:310 src/ch20-01-single-threaded.md:389
#: src/ch20-01-single-threaded.md:462 src/ch20-01-single-threaded.md:530
#: src/ch20-01-single-threaded.md:621 src/ch20-02-multithreaded.md:18
#: src/ch20-02-multithreaded.md:152 src/ch20-02-multithreaded.md:218
#: src/ch20-02-multithreaded.md:316
#: src/ch20-03-graceful-shutdown-and-cleanup.md:668
#: src/ch20-03-graceful-shutdown-and-cleanup.md:789
#: src/appendix-01-keywords.md:89 src/appendix-01-keywords.md:111
#: src/appendix-04-useful-development-tools.md:39
#: src/appendix-04-useful-development-tools.md:83
#: src/appendix-04-useful-development-tools.md:120
#: src/appendix-04-useful-development-tools.md:149
msgid "<span class=\"filename\">Filename: src/main.rs</span>"
msgstr ""

#: src/ch01-03-hello-cargo.md:103
msgid ""
"Cargo has generated a ‚ÄúHello, world!‚Äù program for you, just like the one we\n"
"wrote in Listing 1-1! So far, the differences between our project and the\n"
"project Cargo generated are that Cargo placed the code in the *src* "
"directory\n"
"and we have a *Cargo.toml* configuration file in the top directory."
msgstr ""

#: src/ch01-03-hello-cargo.md:108
msgid ""
"Cargo expects your source files to live inside the *src* directory. The\n"
"top-level project directory is just for README files, license information,\n"
"configuration files, and anything else not related to your code. Using "
"Cargo\n"
"helps you organize your projects. There‚Äôs a place for everything, and\n"
"everything is in its place."
msgstr ""

#: src/ch01-03-hello-cargo.md:114
msgid ""
"If you started a project that doesn‚Äôt use Cargo, as we did with the ‚ÄúHello,\n"
"world!‚Äù project, you can convert it to a project that does use Cargo. Move "
"the\n"
"project code into the *src* directory and create an appropriate *Cargo."
"toml*\n"
"file."
msgstr ""

#: src/ch01-03-hello-cargo.md:119
msgid "### Building and Running a Cargo Project"
msgstr ""

#: src/ch01-03-hello-cargo.md:121
msgid ""
"Now let‚Äôs look at what‚Äôs different when we build and run the ‚ÄúHello, "
"world!‚Äù\n"
"program with Cargo! From your *hello_cargo* directory, build your project "
"by\n"
"entering the following command:"
msgstr ""

#: src/ch01-03-hello-cargo.md:125
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:131
msgid ""
"This command creates an executable file in *target/debug/hello_cargo* (or\n"
"*target\\debug\\hello_cargo.exe* on Windows) rather than in your current\n"
"directory. Because the default build is a debug build, Cargo puts the binary "
"in\n"
"a directory named *debug*. You can run the executable with this command:"
msgstr ""

#: src/ch01-03-hello-cargo.md:136
msgid ""
"```console\n"
"$ ./target/debug/hello_cargo # or .\\target\\debug\\hello_cargo.exe on "
"Windows\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:141
msgid ""
"If all goes well, `Hello, world!` should print to the terminal. Running "
"`cargo\n"
"build` for the first time also causes Cargo to create a new file at the top\n"
"level: *Cargo.lock*. This file keeps track of the exact versions of\n"
"dependencies in your project. This project doesn‚Äôt have dependencies, so "
"the\n"
"file is a bit sparse. You won‚Äôt ever need to change this file manually; "
"Cargo\n"
"manages its contents for you."
msgstr ""

#: src/ch01-03-hello-cargo.md:148
msgid ""
"We just built a project with `cargo build` and ran it with\n"
"`./target/debug/hello_cargo`, but we can also use `cargo run` to compile "
"the\n"
"code and then run the resultant executable all in one command:"
msgstr ""

#: src/ch01-03-hello-cargo.md:152
msgid ""
"```console\n"
"$ cargo run\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n"
"     Running `target/debug/hello_cargo`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:159
msgid ""
"Using `cargo run` is more convenient than having to remember to run `cargo\n"
"build` and then use the whole path to the binary, so most developers use "
"`cargo\n"
"run`."
msgstr ""

#: src/ch01-03-hello-cargo.md:163
msgid ""
"Notice that this time we didn‚Äôt see output indicating that Cargo was "
"compiling\n"
"`hello_cargo`. Cargo figured out that the files hadn‚Äôt changed, so it "
"didn‚Äôt\n"
"rebuild but just ran the binary. If you had modified your source code, "
"Cargo\n"
"would have rebuilt the project before running it, and you would have seen "
"this\n"
"output:"
msgstr ""

#: src/ch01-03-hello-cargo.md:169
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n"
"     Running `target/debug/hello_cargo`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:177
msgid ""
"Cargo also provides a command called `cargo check`. This command quickly "
"checks\n"
"your code to make sure it compiles but doesn‚Äôt produce an executable:"
msgstr ""

#: src/ch01-03-hello-cargo.md:180
msgid ""
"```console\n"
"$ cargo check\n"
"   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:186
msgid ""
"Why would you not want an executable? Often, `cargo check` is much faster "
"than\n"
"`cargo build` because it skips the step of producing an executable. If "
"you‚Äôre\n"
"continually checking your work while writing the code, using `cargo check` "
"will\n"
"speed up the process of letting you know if your project is still compiling! "
"As\n"
"such, many Rustaceans run `cargo check` periodically as they write their\n"
"program to make sure it compiles. Then they run `cargo build` when they‚Äôre\n"
"ready to use the executable."
msgstr ""

#: src/ch01-03-hello-cargo.md:194
msgid "Let‚Äôs recap what we‚Äôve learned so far about Cargo:"
msgstr ""

#: src/ch01-03-hello-cargo.md:196
msgid ""
"* We can create a project using `cargo new`.\n"
"* We can build a project using `cargo build`.\n"
"* We can build and run a project in one step using `cargo run`.\n"
"* We can build a project without producing a binary to check for errors "
"using\n"
"  `cargo check`.\n"
"* Instead of saving the result of the build in the same directory as our "
"code,\n"
"  Cargo stores it in the *target/debug* directory."
msgstr ""

#: src/ch01-03-hello-cargo.md:204
msgid ""
"An additional advantage of using Cargo is that the commands are the same no\n"
"matter which operating system you‚Äôre working on. So, at this point, we‚Äôll "
"no\n"
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""

#: src/ch01-03-hello-cargo.md:208
msgid "### Building for Release"
msgstr ""

#: src/ch01-03-hello-cargo.md:210
msgid ""
"When your project is finally ready for release, you can use `cargo build\n"
"--release` to compile it with optimizations. This command will create an\n"
"executable in *target/release* instead of *target/debug*. The optimizations\n"
"make your Rust code run faster, but turning them on lengthens the time it "
"takes\n"
"for your program to compile. This is why there are two different profiles: "
"one\n"
"for development, when you want to rebuild quickly and often, and another "
"for\n"
"building the final program you‚Äôll give to a user that won‚Äôt be rebuilt\n"
"repeatedly and that will run as fast as possible. If you‚Äôre benchmarking "
"your\n"
"code‚Äôs running time, be sure to run `cargo build --release` and benchmark "
"with\n"
"the executable in *target/release*."
msgstr ""

#: src/ch01-03-hello-cargo.md:221
msgid "### Cargo as Convention"
msgstr ""

#: src/ch01-03-hello-cargo.md:223
msgid ""
"With simple projects, Cargo doesn‚Äôt provide a lot of value over just using\n"
"`rustc`, but it will prove its worth as your programs become more "
"intricate.\n"
"Once programs grow to multiple files or need a dependency, it‚Äôs much easier "
"to\n"
"let Cargo coordinate the build."
msgstr ""

#: src/ch01-03-hello-cargo.md:228
msgid ""
"Even though the `hello_cargo` project is simple, it now uses much of the "
"real\n"
"tooling you‚Äôll use in the rest of your Rust career. In fact, to work on any\n"
"existing projects, you can use the following commands to check out the code\n"
"using Git, change to that project‚Äôs directory, and build:"
msgstr ""

#: src/ch01-03-hello-cargo.md:233
msgid ""
"```console\n"
"$ git clone example.org/someproject\n"
"$ cd someproject\n"
"$ cargo build\n"
"```"
msgstr ""

#: src/ch01-03-hello-cargo.md:239
msgid "For more information about Cargo, check out [its documentation][cargo]."
msgstr ""

#: src/ch01-03-hello-cargo.md:241 src/ch02-00-guessing-game-tutorial.md:1291
#: src/ch03-05-control-flow.md:546 src/ch04-03-slices.md:490
#: src/ch05-03-method-syntax.md:382 src/ch06-03-if-let.md:121
#: src/ch07-05-separating-modules-into-different-files.md:123
#: src/ch08-03-hash-maps.md:285 src/ch09-03-to-panic-or-not-to-panic.md:270
#: src/ch10-03-lifetime-syntax.md:873 src/ch11-03-test-organization.md:349
#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:114
#: src/ch13-04-performance.md:84 src/ch14-05-extending-cargo.md:10
#: src/ch15-06-reference-cycles.md:513
#: src/ch16-04-extensible-concurrency-sync-and-send.md:63
#: src/ch17-03-oo-design-patterns.md:955 src/ch18-03-pattern-syntax.md:847
#: src/ch19-06-macros.md:570 src/ch20-03-graceful-shutdown-and-cleanup.md:953
msgid "## Summary"
msgstr ""

#: src/ch01-03-hello-cargo.md:243
msgid ""
"You‚Äôre already off to a great start on your Rust journey! In this chapter,\n"
"you‚Äôve learned how to:"
msgstr ""

#: src/ch01-03-hello-cargo.md:246
msgid ""
"* Install the latest stable version of Rust using `rustup`\n"
"* Update to a newer Rust version\n"
"* Open locally installed documentation\n"
"* Write and run a ‚ÄúHello, world!‚Äù program using `rustc` directly\n"
"* Create and run a new project using the conventions of Cargo"
msgstr ""

#: src/ch01-03-hello-cargo.md:252
msgid ""
"This is a great time to build a more substantial program to get used to "
"reading\n"
"and writing Rust code. So, in Chapter 2, we‚Äôll build a guessing game "
"program.\n"
"If you would rather start by learning how common programming concepts work "
"in\n"
"Rust, see Chapter 3 and then return to Chapter 2."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1
msgid "# Programming a Guessing Game"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:3
msgid ""
"Let‚Äôs jump into Rust by working through a hands-on project together! This\n"
"chapter introduces you to a few common Rust concepts by showing you how to "
"use\n"
"them in a real program. You‚Äôll learn about `let`, `match`, methods, "
"associated\n"
"functions, external crates, and more! In the following chapters, we‚Äôll "
"explore\n"
"these ideas in more detail. In this chapter, you‚Äôll just practice the\n"
"fundamentals."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:10
msgid ""
"We‚Äôll implement a classic beginner programming problem: a guessing game. "
"Here‚Äôs\n"
"how it works: the program will generate a random integer between 1 and 100. "
"It\n"
"will then prompt the player to enter a guess. After a guess is entered, the\n"
"program will indicate whether the guess is too low or too high. If the guess "
"is\n"
"correct, the game will print a congratulatory message and exit."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:16
msgid "## Setting Up a New Project"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:18
msgid ""
"To set up a new project, go to the *projects* directory that you created in\n"
"Chapter 1 and make a new project using Cargo, like so:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:21
msgid ""
"```console\n"
"$ cargo new guessing_game\n"
"$ cd guessing_game\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:26
msgid ""
"The first command, `cargo new`, takes the name of the project "
"(`guessing_game`)\n"
"as the first argument. The second command changes to the new project‚Äôs\n"
"directory."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:30
msgid "Look at the generated *Cargo.toml* file:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:32
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial\n"
"rm -rf no-listing-01-cargo-new\n"
"cargo new no-listing-01-cargo-new --name guessing_game\n"
"cd no-listing-01-cargo-new\n"
"cargo run > output.txt 2>&1\n"
"cd ../../..\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:43
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"# See more keys and their definitions at https://doc.rust-lang.org/cargo/"
"reference/manifest.html\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:54
msgid ""
"As you saw in Chapter 1, `cargo new` generates a ‚ÄúHello, world!‚Äù program "
"for\n"
"you. Check out the *src/main.rs* file:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:65
msgid ""
"Now let‚Äôs compile this ‚ÄúHello, world!‚Äù program and run it in the same step\n"
"using the `cargo run` command:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:68
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.50s\n"
"     Running `target/debug/guessing_game`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:76
msgid ""
"The `run` command comes in handy when you need to rapidly iterate on a "
"project,\n"
"as we‚Äôll do in this game, quickly testing each iteration before moving on "
"to\n"
"the next one."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:80
msgid ""
"Reopen the *src/main.rs* file. You‚Äôll be writing all the code in this file."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:82
msgid "## Processing a Guess"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:84
msgid ""
"The first part of the guessing game program will ask for user input, "
"process\n"
"that input, and check that the input is in the expected form. To start, "
"we‚Äôll\n"
"allow the player to input a guess. Enter the code in Listing 2-1 into\n"
"*src/main.rs*."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:91
msgid ""
"```rust,ignore\n"
"use std::io;\n"
"\n"
"fn main() {\n"
"    println!(\"Guess the number!\");\n"
"\n"
"    println!(\"Please input your guess.\");\n"
"\n"
"    let mut guess = String::new();\n"
"\n"
"    io::stdin()\n"
"        .read_line(&mut guess)\n"
"        .expect(\"Failed to read line\");\n"
"\n"
"    println!(\"You guessed: {guess}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:109
msgid ""
"<span class=\"caption\">Listing 2-1: Code that gets a guess from the user "
"and\n"
"prints it</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:112
msgid ""
"This code contains a lot of information, so let‚Äôs go over it line by line. "
"To\n"
"obtain user input and then print the result as output, we need to bring the\n"
"`io` input/output library into scope. The `io` library comes from the "
"standard\n"
"library, known as `std`:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:117
msgid ""
"```rust,ignore\n"
"use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:135
msgid ""
"By default, Rust has a set of items defined in the standard library that it\n"
"brings into the scope of every program. This set is called the *prelude*, "
"and\n"
"you can see everything in it [in the standard library documentation]"
"[prelude]."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:139
msgid ""
"If a type you want to use isn‚Äôt in the prelude, you have to bring that type\n"
"into scope explicitly with a `use` statement. Using the `std::io` library\n"
"provides you with a number of useful features, including the ability to "
"accept\n"
"user input."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:144
msgid ""
"As you saw in Chapter 1, the `main` function is the entry point into the\n"
"program:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:147
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:165
msgid ""
"The `fn` syntax declares a new function; the parentheses, `()`, indicate "
"there\n"
"are no parameters; and the curly bracket, `{`, starts the body of the "
"function."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:168
msgid ""
"As you also learned in Chapter 1, `println!` is a macro that prints a string "
"to\n"
"the screen:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:171
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"    println!(\"Guess the number!\");\n"
"\n"
"    println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:189
msgid ""
"This code is printing a prompt stating what the game is and requesting "
"input\n"
"from the user."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:192
msgid "### Storing Values with Variables"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:194
msgid "Next, we‚Äôll create a *variable* to store the user input, like this:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:196
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"    let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:214
msgid ""
"Now the program is getting interesting! There‚Äôs a lot going on in this "
"little\n"
"line. We use the `let` statement to create the variable. Here‚Äôs another "
"example:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:217
msgid ""
"```rust,ignore\n"
"let apples = 5;\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:221
msgid ""
"This line creates a new variable named `apples` and binds it to the value 5. "
"In\n"
"Rust, variables are immutable by default, meaning once we give the variable "
"a\n"
"value, the value won‚Äôt change. We‚Äôll be discussing this concept in detail "
"in\n"
"the [‚ÄúVariables and Mutability‚Äù][variables-and-mutability]<!-- ignore -->\n"
"section in Chapter 3. To make a variable mutable, we add `mut` before the\n"
"variable name:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:228
msgid ""
"```rust,ignore\n"
"let apples = 5; // immutable\n"
"let mut bananas = 5; // mutable\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:233
msgid ""
"> Note: The `//` syntax starts a comment that continues until the end of "
"the\n"
"> line. Rust ignores everything in comments. We‚Äôll discuss comments in more\n"
"> detail in [Chapter 3][comments]<!-- ignore -->."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:237
msgid ""
"Returning to the guessing game program, you now know that `let mut guess` "
"will\n"
"introduce a mutable variable named `guess`. The equal sign (`=`) tells Rust "
"we\n"
"want to bind something to the variable now. On the right of the equal sign "
"is\n"
"the value that `guess` is bound to, which is the result of calling\n"
"`String::new`, a function that returns a new instance of a `String`.\n"
"[`String`][string]<!-- ignore --> is a string type provided by the standard\n"
"library that is a growable, UTF-8 encoded bit of text."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:245
msgid ""
"The `::` syntax in the `::new` line indicates that `new` is an associated\n"
"function of the `String` type. An *associated function* is a function "
"that‚Äôs\n"
"implemented on a type, in this case `String`. This `new` function creates a\n"
"new, empty string. You‚Äôll find a `new` function on many types because it‚Äôs "
"a\n"
"common name for a function that makes a new value of some kind."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:251
msgid ""
"In full, the `let mut guess = String::new();` line has created a mutable\n"
"variable that is currently bound to a new, empty instance of a `String`. "
"Whew!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:254
msgid "### Receiving User Input"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:256
msgid ""
"Recall that we included the input/output functionality from the standard\n"
"library with `use std::io;` on the first line of the program. Now we‚Äôll "
"call\n"
"the `stdin` function from the `io` module, which will allow us to handle "
"user\n"
"input:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:261
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"    io::stdin()\n"
"        .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:279
msgid ""
"If we hadn‚Äôt imported the `io` library with `use std::io;` at the beginning "
"of\n"
"the program, we could still use the function by writing this function call "
"as\n"
"`std::io::stdin`. The `stdin` function returns an instance of\n"
"[`std::io::Stdin`][iostdin]<!-- ignore -->, which is a type that represents "
"a\n"
"handle to the standard input for your terminal."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:285
msgid ""
"Next, the line `.read_line(&mut guess)` calls the [`read_line`]"
"[read_line]<!--\n"
"ignore --> method on the standard input handle to get input from the user.\n"
"We‚Äôre also passing `&mut guess` as the argument to `read_line` to tell it "
"what\n"
"string to store the user input in. The full job of `read_line` is to take\n"
"whatever the user types into standard input and append that into a string\n"
"(without overwriting its contents), so we therefore pass that string as an\n"
"argument. The string argument needs to be mutable so the method can change "
"the\n"
"string‚Äôs content."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:294
msgid ""
"The `&` indicates that this argument is a *reference*, which gives you a way "
"to\n"
"let multiple parts of your code access one piece of data without needing to\n"
"copy that data into memory multiple times. References are a complex "
"feature,\n"
"and one of Rust‚Äôs major advantages is how safe and easy it is to use\n"
"references. You don‚Äôt need to know a lot of those details to finish this\n"
"program. For now, all you need to know is that, like variables, references "
"are\n"
"immutable by default. Hence, you need to write `&mut guess` rather than\n"
"`&guess` to make it mutable. (Chapter 4 will explain references more\n"
"thoroughly.)"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:304
#: src/ch04-01-what-is-ownership.md:253 src/ch04-01-what-is-ownership.md:407
#: src/ch04-03-slices.md:352 src/ch05-01-defining-structs.md:139
#: src/ch06-02-match.md:1 src/ch13-01-closures.md:1
msgid "<!-- Old heading. Do not remove or links may break. -->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:305
msgid "<a id=\"handling-potential-failure-with-the-result-type\"></a>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:307
msgid "### Handling Potential Failure with `Result`"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:309
msgid ""
"We‚Äôre still working on this line of code. We‚Äôre now discussing a third line "
"of\n"
"text, but note that it‚Äôs still part of a single logical line of code. The "
"next\n"
"part is this method:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:313
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"        .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:331
msgid "We could have written this code as:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:333
msgid ""
"```rust,ignore\n"
"io::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:337
msgid ""
"However, one long line is difficult to read, so it‚Äôs best to divide it. "
"It‚Äôs\n"
"often wise to introduce a newline and other whitespace to help break up "
"long\n"
"lines when you call a method with the `.method_name()` syntax. Now let‚Äôs\n"
"discuss what this line does."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:342
msgid ""
"As mentioned earlier, `read_line` puts whatever the user enters into the "
"string\n"
"we pass to it, but it also returns a `Result` value. [`Result`][result]<!--\n"
"ignore --> is an [*enumeration*][enums]<!-- ignore -->, often called an "
"*enum*,\n"
"which is a type that can be in one of multiple possible states. We call "
"each\n"
"possible state a *variant*."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:348
msgid ""
"[Chapter 6][enums]<!-- ignore --> will cover enums in more detail. The "
"purpose\n"
"of these `Result` types is to encode error-handling information."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:351
msgid ""
"`Result`‚Äôs variants are `Ok` and `Err`. The `Ok` variant indicates the\n"
"operation was successful, and inside `Ok` is the successfully generated "
"value.\n"
"The `Err` variant means the operation failed, and `Err` contains "
"information\n"
"about how or why the operation failed."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:356
msgid ""
"Values of the `Result` type, like values of any type, have methods defined "
"on\n"
"them. An instance of `Result` has an [`expect` method][expect]<!-- ignore --"
">\n"
"that you can call. If this instance of `Result` is an `Err` value, `expect`\n"
"will cause the program to crash and display the message that you passed as "
"an\n"
"argument to `expect`. If the `read_line` method returns an `Err`, it would\n"
"likely be the result of an error coming from the underlying operating "
"system.\n"
"If this instance of `Result` is an `Ok` value, `expect` will take the "
"return\n"
"value that `Ok` is holding and return just that value to you so you can use "
"it.\n"
"In this case, that value is the number of bytes in the user‚Äôs input."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:366
msgid ""
"If you don‚Äôt call `expect`, the program will compile, but you‚Äôll get a "
"warning:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:368
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"warning: unused `Result` that must be used\n"
"  --> src/main.rs:10:5\n"
"   |\n"
"10 |     io::stdin().read_line(&mut guess);\n"
"   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"   |\n"
"   = note: this `Result` may be an `Err` variant, which should be handled\n"
"   = note: `#[warn(unused_must_use)]` on by default\n"
"\n"
"warning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:384
msgid ""
"Rust warns that you haven‚Äôt used the `Result` value returned from "
"`read_line`,\n"
"indicating that the program hasn‚Äôt handled a possible error."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:387
msgid ""
"The right way to suppress the warning is to actually write error-handling "
"code,\n"
"but in our case we just want to crash this program when a problem occurs, so "
"we\n"
"can use `expect`. You‚Äôll learn about recovering from errors in [Chapter\n"
"9][recover]<!-- ignore -->."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:392
msgid "### Printing Values with `println!` Placeholders"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:394
msgid ""
"Aside from the closing curly bracket, there‚Äôs only one more line to discuss "
"in\n"
"the code so far:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:397
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"    println!(\"You guessed: {guess}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:415
msgid ""
"This line prints the string that now contains the user‚Äôs input. The `{}` set "
"of\n"
"curly brackets is a placeholder: think of `{}` as little crab pincers that "
"hold\n"
"a value in place. When printing the value of a variable, the variable name "
"can\n"
"go inside the curly brackets. When printing the result of evaluating an\n"
"expression, place empty curly brackets in the format string, then follow "
"the\n"
"format string with a comma-separated list of expressions to print in each "
"empty\n"
"curly bracket placeholder in the same order. Printing a variable and the "
"result\n"
"of an expression in one call to `println!` would look like this:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:424
msgid ""
"```rust\n"
"let x = 5;\n"
"let y = 10;\n"
"\n"
"println!(\"x = {x} and y + 2 = {}\", y + 2);\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:431
msgid "This code would print `x = 5 and y + 2 = 12`."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:433
msgid "### Testing the First Part"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:435
msgid ""
"Let‚Äôs test the first part of the guessing game. Run it using `cargo run`:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:437
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-01/\n"
"cargo clean\n"
"cargo run\n"
"input 6 -->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:443
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 6.44s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"Please input your guess.\n"
"6\n"
"You guessed: 6\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:454
msgid ""
"At this point, the first part of the game is done: we‚Äôre getting input from "
"the\n"
"keyboard and then printing it."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:457
msgid "## Generating a Secret Number"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:459
msgid ""
"Next, we need to generate a secret number that the user will try to guess. "
"The\n"
"secret number should be different every time so the game is fun to play "
"more\n"
"than once. We‚Äôll use a random number between 1 and 100 so the game isn‚Äôt "
"too\n"
"difficult. Rust doesn‚Äôt yet include random number functionality in its "
"standard\n"
"library. However, the Rust team does provide a [`rand` crate][randcrate] "
"with\n"
"said functionality."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:466
msgid "### Using a Crate to Get More Functionality"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:468
msgid ""
"Remember that a crate is a collection of Rust source code files. The "
"project\n"
"we‚Äôve been building is a *binary crate*, which is an executable. The `rand`\n"
"crate is a *library crate*, which contains code that is intended to be used "
"in\n"
"other programs and can‚Äôt be executed on its own."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:473
msgid ""
"Cargo‚Äôs coordination of external crates is where Cargo really shines. Before "
"we\n"
"can write code that uses `rand`, we need to modify the *Cargo.toml* file to\n"
"include the `rand` crate as a dependency. Open that file now and add the\n"
"following line to the bottom, beneath the `[dependencies]` section header "
"that\n"
"Cargo created for you. Be sure to specify `rand` exactly as we have here, "
"with\n"
"this version number, or the code examples in this tutorial may not work:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:480
msgid ""
"<!-- When updating the version of `rand` used, also update the version of\n"
"`rand` used in these files so they all match:\n"
"* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md\n"
"* ch14-03-cargo-workspaces.md\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:488
#: src/ch14-03-cargo-workspaces.md:226
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.8.5\"\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:493
msgid ""
"In the *Cargo.toml* file, everything that follows a header is part of that\n"
"section that continues until another section starts. In `[dependencies]` "
"you\n"
"tell Cargo which external crates your project depends on and which versions "
"of\n"
"those crates you require. In this case, we specify the `rand` crate with "
"the\n"
"semantic version specifier `0.8.5`. Cargo understands [Semantic\n"
"Versioning][semver]<!-- ignore --> (sometimes called *SemVer*), which is a\n"
"standard for writing version numbers. The specifier `0.8.5` is actually\n"
"shorthand for `^0.8.5`, which means any version that is at least 0.8.5 but\n"
"below 0.9.0."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:503
msgid ""
"Cargo considers these versions to have public APIs compatible with version\n"
"0.8.5, and this specification ensures you‚Äôll get the latest patch release "
"that\n"
"will still compile with the code in this chapter. Any version 0.9.0 or "
"greater\n"
"is not guaranteed to have the same API as what the following examples use."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:508
msgid ""
"Now, without changing any of the code, let‚Äôs build the project, as shown in\n"
"Listing 2-2."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:511
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-02/\n"
"rm Cargo.lock\n"
"cargo clean\n"
"cargo build -->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:517
msgid ""
"```console\n"
"$ cargo build\n"
"    Updating crates.io index\n"
"  Downloaded rand v0.8.5\n"
"  Downloaded libc v0.2.127\n"
"  Downloaded getrandom v0.2.7\n"
"  Downloaded cfg-if v1.0.0\n"
"  Downloaded ppv-lite86 v0.2.16\n"
"  Downloaded rand_chacha v0.3.1\n"
"  Downloaded rand_core v0.6.3\n"
"   Compiling libc v0.2.127\n"
"   Compiling getrandom v0.2.7\n"
"   Compiling cfg-if v1.0.0\n"
"   Compiling ppv-lite86 v0.2.16\n"
"   Compiling rand_core v0.6.3\n"
"   Compiling rand_chacha v0.3.1\n"
"   Compiling rand v0.8.5\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 2.53s\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:538
msgid ""
"<span class=\"caption\">Listing 2-2: The output from running `cargo build` "
"after\n"
"adding the rand crate as a dependency</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:541
msgid ""
"You may see different version numbers (but they will all be compatible with "
"the\n"
"code, thanks to SemVer!) and different lines (depending on the operating\n"
"system), and the lines may be in a different order."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:545
msgid ""
"When we include an external dependency, Cargo fetches the latest versions "
"of\n"
"everything that dependency needs from the *registry*, which is a copy of "
"data\n"
"from [Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem\n"
"post their open source Rust projects for others to use."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:550
msgid ""
"After updating the registry, Cargo checks the `[dependencies]` section and\n"
"downloads any crates listed that aren‚Äôt already downloaded. In this case,\n"
"although we only listed `rand` as a dependency, Cargo also grabbed other "
"crates\n"
"that `rand` depends on to work. After downloading the crates, Rust compiles\n"
"them and then compiles the project with the dependencies available."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:556
msgid ""
"If you immediately run `cargo build` again without making any changes, you\n"
"won‚Äôt get any output aside from the `Finished` line. Cargo knows it has "
"already\n"
"downloaded and compiled the dependencies, and you haven‚Äôt changed anything\n"
"about them in your *Cargo.toml* file. Cargo also knows that you haven‚Äôt "
"changed\n"
"anything about your code, so it doesn‚Äôt recompile that either. With nothing "
"to\n"
"do, it simply exits."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:563
msgid ""
"If you open the *src/main.rs* file, make a trivial change, and then save it "
"and\n"
"build again, you‚Äôll only see two lines of output:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:566
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-02/\n"
"touch src/main.rs\n"
"cargo build -->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:571
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:577
msgid ""
"These lines show that Cargo only updates the build with your tiny change to "
"the\n"
"*src/main.rs* file. Your dependencies haven‚Äôt changed, so Cargo knows it "
"can\n"
"reuse what it has already downloaded and compiled for those."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:581
msgid "#### Ensuring Reproducible Builds with the *Cargo.lock* File"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:583
msgid ""
"Cargo has a mechanism that ensures you can rebuild the same artifact every "
"time\n"
"you or anyone else builds your code: Cargo will use only the versions of "
"the\n"
"dependencies you specified until you indicate otherwise. For example, say "
"that\n"
"next week version 0.8.6 of the `rand` crate comes out, and that version\n"
"contains an important bug fix, but it also contains a regression that will\n"
"break your code. To handle this, Rust creates the *Cargo.lock* file the "
"first\n"
"time you run `cargo build`, so we now have this in the *guessing_game*\n"
"directory."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:592
msgid ""
"When you build a project for the first time, Cargo figures out all the "
"versions\n"
"of the dependencies that fit the criteria and then writes them to the\n"
"*Cargo.lock* file. When you build your project in the future, Cargo will "
"see\n"
"that the *Cargo.lock* file exists and will use the versions specified there\n"
"rather than doing all the work of figuring out versions again. This lets "
"you\n"
"have a reproducible build automatically. In other words, your project will\n"
"remain at 0.8.5 until you explicitly upgrade, thanks to the *Cargo.lock* "
"file.\n"
"Because the *Cargo.lock* file is important for reproducible builds, it‚Äôs "
"often\n"
"checked into source control with the rest of the code in your project."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:602
msgid "#### Updating a Crate to Get a New Version"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:604
msgid ""
"When you *do* want to update a crate, Cargo provides the command `update`,\n"
"which will ignore the *Cargo.lock* file and figure out all the latest "
"versions\n"
"that fit your specifications in *Cargo.toml*. Cargo will then write those\n"
"versions to the *Cargo.lock* file. Otherwise, by default, Cargo will only "
"look\n"
"for versions greater than 0.8.5 and less than 0.9.0. If the `rand` crate "
"has\n"
"released the two new versions 0.8.6 and 0.9.0, you would see the following "
"if\n"
"you ran `cargo update`:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:612
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-02/\n"
"cargo update\n"
"assuming there is a new 0.8.x version of rand; otherwise use another update\n"
"as a guide to creating the hypothetical output shown here -->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:618
msgid ""
"```console\n"
"$ cargo update\n"
"    Updating crates.io index\n"
"    Updating rand v0.8.5 -> v0.8.6\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:624
msgid ""
"Cargo ignores the 0.9.0 release. At this point, you would also notice a "
"change\n"
"in your *Cargo.lock* file noting that the version of the `rand` crate you "
"are\n"
"now using is 0.8.6. To use `rand` version 0.9.0 or any version in the 0.9."
"*x*\n"
"series, you‚Äôd have to update the *Cargo.toml* file to look like this instead:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:629
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.9.0\"\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:634
msgid ""
"The next time you run `cargo build`, Cargo will update the registry of "
"crates\n"
"available and reevaluate your `rand` requirements according to the new "
"version\n"
"you have specified."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:638
msgid ""
"There‚Äôs a lot more to say about [Cargo][doccargo]<!-- ignore --> and [its\n"
"ecosystem][doccratesio]<!-- ignore -->, which we‚Äôll discuss in Chapter 14, "
"but\n"
"for now, that‚Äôs all you need to know. Cargo makes it very easy to reuse\n"
"libraries, so Rustaceans are able to write smaller projects that are "
"assembled\n"
"from a number of packages."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:644
msgid "### Generating a Random Number"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:646
msgid ""
"Let‚Äôs start using `rand` to generate a number to guess. The next step is to\n"
"update *src/main.rs*, as shown in Listing 2-3."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:651
msgid ""
"```rust,ignore\n"
"use std::io;\n"
"use rand::Rng;\n"
"\n"
"fn main() {\n"
"    println!(\"Guess the number!\");\n"
"\n"
"    let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"\n"
"    println!(\"The secret number is: {secret_number}\");\n"
"\n"
"    println!(\"Please input your guess.\");\n"
"\n"
"    let mut guess = String::new();\n"
"\n"
"    io::stdin()\n"
"        .read_line(&mut guess)\n"
"        .expect(\"Failed to read line\");\n"
"\n"
"    println!(\"You guessed: {guess}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:674
msgid ""
"<span class=\"caption\">Listing 2-3: Adding code to generate a random\n"
"number</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:677
msgid ""
"First we add the line `use rand::Rng;`. The `Rng` trait defines methods "
"that\n"
"random number generators implement, and this trait must be in scope for us "
"to\n"
"use those methods. Chapter 10 will cover traits in detail."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:681
msgid ""
"Next, we‚Äôre adding two lines in the middle. In the first line, we call the\n"
"`rand::thread_rng` function that gives us the particular random number\n"
"generator we‚Äôre going to use: one that is local to the current thread of\n"
"execution and is seeded by the operating system. Then we call the "
"`gen_range`\n"
"method on the random number generator. This method is defined by the `Rng`\n"
"trait that we brought into scope with the `use rand::Rng;` statement. The\n"
"`gen_range` method takes a range expression as an argument and generates a\n"
"random number in the range. The kind of range expression we‚Äôre using here "
"takes\n"
"the form `start..=end` and is inclusive on the lower and upper bounds, so "
"we\n"
"need to specify `1..=100` to request a number between 1 and 100."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:692
msgid ""
"> Note: You won‚Äôt just know which traits to use and which methods and "
"functions\n"
"> to call from a crate, so each crate has documentation with instructions "
"for\n"
"> using it. Another neat feature of Cargo is that running the `cargo doc\n"
"> --open` command will build documentation provided by all your "
"dependencies\n"
"> locally and open it in your browser. If you‚Äôre interested in other\n"
"> functionality in the `rand` crate, for example, run `cargo doc --open` "
"and\n"
"> click `rand` in the sidebar on the left."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:700
msgid ""
"The second new line prints the secret number. This is useful while we‚Äôre\n"
"developing the program to be able to test it, but we‚Äôll delete it from the\n"
"final version. It‚Äôs not much of a game if the program prints the answer as "
"soon\n"
"as it starts!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:705
msgid "Try running the program a few times:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:707
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-03/\n"
"cargo run\n"
"4\n"
"cargo run\n"
"5\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:715
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 2.53s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 7\n"
"Please input your guess.\n"
"4\n"
"You guessed: 4\n"
"\n"
"$ cargo run\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 83\n"
"Please input your guess.\n"
"5\n"
"You guessed: 5\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:736
msgid ""
"You should get different random numbers, and they should all be numbers "
"between\n"
"1 and 100. Great job!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:739
msgid "## Comparing the Guess to the Secret Number"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:741
msgid ""
"Now that we have user input and a random number, we can compare them. That "
"step\n"
"is shown in Listing 2-4. Note that this code won‚Äôt compile just yet, as we "
"will\n"
"explain."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:747
msgid ""
"```rust,ignore,does_not_compile\n"
"use rand::Rng;\n"
"use std::cmp::Ordering;\n"
"use std::io;\n"
"\n"
"fn main() {\n"
"    // --snip--\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"\n"
"    println!(\"You guessed: {guess}\");\n"
"\n"
"    match guess.cmp(&secret_number) {\n"
"        Ordering::Less => println!(\"Too small!\"),\n"
"        Ordering::Greater => println!(\"Too big!\"),\n"
"        Ordering::Equal => println!(\"You win!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:778
msgid ""
"<span class=\"caption\">Listing 2-4: Handling the possible return values of\n"
"comparing two numbers</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:781
msgid ""
"First we add another `use` statement, bringing a type called\n"
"`std::cmp::Ordering` into scope from the standard library. The `Ordering` "
"type\n"
"is another enum and has the variants `Less`, `Greater`, and `Equal`. These "
"are\n"
"the three outcomes that are possible when you compare two values."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:786
msgid ""
"Then we add five new lines at the bottom that use the `Ordering` type. The\n"
"`cmp` method compares two values and can be called on anything that can be\n"
"compared. It takes a reference to whatever you want to compare with: here "
"it‚Äôs\n"
"comparing `guess` to `secret_number`. Then it returns a variant of the\n"
"`Ordering` enum we brought into scope with the `use` statement. We use a\n"
"[`match`][match]<!-- ignore --> expression to decide what to do next based "
"on\n"
"which variant of `Ordering` was returned from the call to `cmp` with the "
"values\n"
"in `guess` and `secret_number`."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:795
msgid ""
"A `match` expression is made up of *arms*. An arm consists of a *pattern* "
"to\n"
"match against, and the code that should be run if the value given to "
"`match`\n"
"fits that arm‚Äôs pattern. Rust takes the value given to `match` and looks\n"
"through each arm‚Äôs pattern in turn. Patterns and the `match` construct are\n"
"powerful Rust features: they let you express a variety of situations your "
"code\n"
"might encounter and they make sure you handle them all. These features will "
"be\n"
"covered in detail in Chapter 6 and Chapter 18, respectively."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:803
msgid ""
"Let‚Äôs walk through an example with the `match` expression we use here. Say "
"that\n"
"the user has guessed 50 and the randomly generated secret number this time "
"is\n"
"38."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:807
msgid ""
"When the code compares 50 to 38, the `cmp` method will return\n"
"`Ordering::Greater` because 50 is greater than 38. The `match` expression "
"gets\n"
"the `Ordering::Greater` value and starts checking each arm‚Äôs pattern. It "
"looks\n"
"at the first arm‚Äôs pattern, `Ordering::Less`, and sees that the value\n"
"`Ordering::Greater` does not match `Ordering::Less`, so it ignores the code "
"in\n"
"that arm and moves to the next arm. The next arm‚Äôs pattern is\n"
"`Ordering::Greater`, which *does* match `Ordering::Greater`! The associated\n"
"code in that arm will execute and print `Too big!` to the screen. The "
"`match`\n"
"expression ends after the first successful match, so it won‚Äôt look at the "
"last\n"
"arm in this scenario."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:818
msgid "However, the code in Listing 2-4 won‚Äôt compile yet. Let‚Äôs try it:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:820
msgid ""
"<!--\n"
"The error numbers in this output should be that of the code **WITHOUT** the\n"
"anchor or snip comments\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:825
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling libc v0.2.86\n"
"   Compiling getrandom v0.2.2\n"
"   Compiling cfg-if v1.0.0\n"
"   Compiling ppv-lite86 v0.2.10\n"
"   Compiling rand_core v0.6.2\n"
"   Compiling rand_chacha v0.3.0\n"
"   Compiling rand v0.8.5\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"error[E0308]: mismatched types\n"
"  --> src/main.rs:22:21\n"
"   |\n"
"22 |     match guess.cmp(&secret_number) {\n"
"   |                 --- ^^^^^^^^^^^^^^ expected struct `String`, found "
"integer\n"
"   |                 |\n"
"   |                 arguments to this function are incorrect\n"
"   |\n"
"   = note: expected reference `&String`\n"
"              found reference `&{integer}`\n"
"note: associated function defined here\n"
"  --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/cmp."
"rs:783:8\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `guessing_game` due to previous error\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:852
msgid ""
"The core of the error states that there are *mismatched types*. Rust has a\n"
"strong, static type system. However, it also has type inference. When we "
"wrote\n"
"`let mut guess = String::new()`, Rust was able to infer that `guess` should "
"be\n"
"a `String` and didn‚Äôt make us write the type. The `secret_number`, on the "
"other\n"
"hand, is a number type. A few of Rust‚Äôs number types can have a value "
"between 1\n"
"and 100: `i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a\n"
"64-bit number; as well as others. Unless otherwise specified, Rust defaults "
"to\n"
"an `i32`, which is the type of `secret_number` unless you add type "
"information\n"
"elsewhere that would cause Rust to infer a different numerical type. The "
"reason\n"
"for the error is that Rust cannot compare a string and a number type."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:863
msgid ""
"Ultimately, we want to convert the `String` the program reads as input into "
"a\n"
"real number type so we can compare it numerically to the secret number. We "
"do\n"
"so by adding this line to the `main` function body:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:869
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"    // --snip--\n"
"\n"
"    let mut guess = String::new();\n"
"\n"
"    io::stdin()\n"
"        .read_line(&mut guess)\n"
"        .expect(\"Failed to read line\");\n"
"\n"
"    let guess: u32 = guess.trim().parse().expect(\"Please type a number!"
"\");\n"
"\n"
"    println!(\"You guessed: {guess}\");\n"
"\n"
"    match guess.cmp(&secret_number) {\n"
"        Ordering::Less => println!(\"Too small!\"),\n"
"        Ordering::Greater => println!(\"Too big!\"),\n"
"        Ordering::Equal => println!(\"You win!\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:903
msgid "The line is:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:905
msgid ""
"```rust,ignore\n"
"let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:909
msgid ""
"We create a variable named `guess`. But wait, doesn‚Äôt the program already "
"have\n"
"a variable named `guess`? It does, but helpfully Rust allows us to shadow "
"the\n"
"previous value of `guess` with a new one. *Shadowing* lets us reuse the "
"`guess`\n"
"variable name rather than forcing us to create two unique variables, such "
"as\n"
"`guess_str` and `guess`, for example. We‚Äôll cover this in more detail in\n"
"[Chapter 3][shadowing]<!-- ignore -->, but for now, know that this feature "
"is\n"
"often used when you want to convert a value from one type to another type."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:917
msgid ""
"We bind this new variable to the expression `guess.trim().parse()`. The "
"`guess`\n"
"in the expression refers to the original `guess` variable that contained "
"the\n"
"input as a string. The `trim` method on a `String` instance will eliminate "
"any\n"
"whitespace at the beginning and end, which we must do to be able to compare "
"the\n"
"string to the `u32`, which can only contain numerical data. The user must "
"press\n"
"<span class=\"keystroke\">enter</span> to satisfy `read_line` and input "
"their\n"
"guess, which adds a newline character to the string. For example, if the "
"user\n"
"types <span class=\"keystroke\">5</span> and presses <span\n"
"class=\"keystroke\">enter</span>, `guess` looks like this: `5\\n`. The "
"`\\n`\n"
"represents ‚Äúnewline.‚Äù (On Windows, pressing <span\n"
"class=\"keystroke\">enter</span> results in a carriage return and a "
"newline,\n"
"`\\r\\n`.) The `trim` method eliminates `\\n` or `\\r\\n`, resulting in just "
"`5`."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:930
msgid ""
"The [`parse` method on strings][parse]<!-- ignore --> converts a string to\n"
"another type. Here, we use it to convert from a string to a number. We need "
"to\n"
"tell Rust the exact number type we want by using `let guess: u32`. The "
"colon\n"
"(`:`) after `guess` tells Rust we‚Äôll annotate the variable‚Äôs type. Rust has "
"a\n"
"few built-in number types; the `u32` seen here is an unsigned, 32-bit "
"integer.\n"
"It‚Äôs a good default choice for a small positive number. You‚Äôll learn about\n"
"other number types in [Chapter 3][integers]<!-- ignore -->."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:938
msgid ""
"Additionally, the `u32` annotation in this example program and the "
"comparison\n"
"with `secret_number` means Rust will infer that `secret_number` should be a\n"
"`u32` as well. So now the comparison will be between two values of the same\n"
"type!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:943
msgid ""
"The `parse` method will only work on characters that can logically be "
"converted\n"
"into numbers and so can easily cause errors. If, for example, the string\n"
"contained `Aüëç%`, there would be no way to convert that to a number. Because "
"it\n"
"might fail, the `parse` method returns a `Result` type, much as the "
"`read_line`\n"
"method does (discussed earlier in [‚ÄúHandling Potential Failure with\n"
"`Result`‚Äù](#handling-potential-failure-with-result)<!-- ignore-->). We‚Äôll "
"treat\n"
"this `Result` the same way by using the `expect` method again. If `parse`\n"
"returns an `Err` `Result` variant because it couldn‚Äôt create a number from "
"the\n"
"string, the `expect` call will crash the game and print the message we give "
"it.\n"
"If `parse` can successfully convert the string to a number, it will return "
"the\n"
"`Ok` variant of `Result`, and `expect` will return the number that we want "
"from\n"
"the `Ok` value."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:956
msgid "Let‚Äôs run the program now:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:958
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-"
"number/\n"
"cargo run\n"
"  76\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:964
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 58\n"
"Please input your guess.\n"
"  76\n"
"You guessed: 76\n"
"Too big!\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:977
msgid ""
"Nice! Even though spaces were added before the guess, the program still "
"figured\n"
"out that the user guessed 76. Run the program a few times to verify the\n"
"different behavior with different kinds of input: guess the number "
"correctly,\n"
"guess a number that is too high, and guess a number that is too low."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:982
msgid ""
"We have most of the game working now, but the user can make only one guess.\n"
"Let‚Äôs change that by adding a loop!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:985
msgid "## Allowing Multiple Guesses with Looping"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:987
msgid ""
"The `loop` keyword creates an infinite loop. We‚Äôll add a loop to give users\n"
"more chances at guessing the number:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:992
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"    // --snip--\n"
"\n"
"    println!(\"The secret number is: {secret_number}\");\n"
"\n"
"    loop {\n"
"        println!(\"Please input your guess.\");\n"
"\n"
"        // --snip--\n"
"\n"
"# \n"
"#         let mut guess = String::new();\n"
"# \n"
"#         io::stdin()\n"
"#             .read_line(&mut guess)\n"
"#             .expect(\"Failed to read line\");\n"
"# \n"
"#         let guess: u32 = guess.trim().parse().expect(\"Please type a "
"number!\");\n"
"# \n"
"#         println!(\"You guessed: {guess}\");\n"
"# \n"
"        match guess.cmp(&secret_number) {\n"
"            Ordering::Less => println!(\"Too small!\"),\n"
"            Ordering::Greater => println!(\"Too big!\"),\n"
"            Ordering::Equal => println!(\"You win!\"),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1031
msgid ""
"As you can see, we‚Äôve moved everything from the guess input prompt onward "
"into\n"
"a loop. Be sure to indent the lines inside the loop another four spaces "
"each\n"
"and run the program again. The program will now ask for another guess "
"forever,\n"
"which actually introduces a new problem. It doesn‚Äôt seem like the user can "
"quit!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1036
msgid ""
"The user could always interrupt the program by using the keyboard shortcut\n"
"<span class=\"keystroke\">ctrl-c</span>. But there‚Äôs another way to escape "
"this\n"
"insatiable monster, as mentioned in the `parse` discussion in [‚ÄúComparing "
"the\n"
"Guess to the Secret Number‚Äù](#comparing-the-guess-to-the-secret-number)<!--\n"
"ignore -->: if the user enters a non-number answer, the program will crash. "
"We\n"
"can take advantage of that to allow the user to quit, as shown here:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1043
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/\n"
"cargo run\n"
"(too small guess)\n"
"(too big guess)\n"
"(correct guess)\n"
"quit\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1052
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.50s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 59\n"
"Please input your guess.\n"
"45\n"
"You guessed: 45\n"
"Too small!\n"
"Please input your guess.\n"
"60\n"
"You guessed: 60\n"
"Too big!\n"
"Please input your guess.\n"
"59\n"
"You guessed: 59\n"
"You win!\n"
"Please input your guess.\n"
"quit\n"
"thread 'main' panicked at 'Please type a number!: ParseIntError { kind: "
"InvalidDigit }', src/main.rs:28:47\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1077
msgid ""
"Typing `quit` will quit the game, but as you‚Äôll notice, so will entering "
"any\n"
"other non-number input. This is suboptimal, to say the least; we want the "
"game\n"
"to also stop when the correct number is guessed."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1081
msgid "### Quitting After a Correct Guess"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1083
msgid ""
"Let‚Äôs program the game to quit when the user wins by adding a `break` "
"statement:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1087
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     loop {\n"
"#         println!(\"Please input your guess.\");\n"
"# \n"
"#         let mut guess = String::new();\n"
"# \n"
"#         io::stdin()\n"
"#             .read_line(&mut guess)\n"
"#             .expect(\"Failed to read line\");\n"
"# \n"
"#         let guess: u32 = guess.trim().parse().expect(\"Please type a "
"number!\");\n"
"# \n"
"#         println!(\"You guessed: {guess}\");\n"
"# \n"
"        // --snip--\n"
"\n"
"        match guess.cmp(&secret_number) {\n"
"            Ordering::Less => println!(\"Too small!\"),\n"
"            Ordering::Greater => println!(\"Too big!\"),\n"
"            Ordering::Equal => {\n"
"                println!(\"You win!\");\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1126
msgid ""
"Adding the `break` line after `You win!` makes the program exit the loop "
"when\n"
"the user guesses the secret number correctly. Exiting the loop also means\n"
"exiting the program, because the loop is the last part of `main`."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1130
msgid "### Handling Invalid Input"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1132
msgid ""
"To further refine the game‚Äôs behavior, rather than crashing the program "
"when\n"
"the user inputs a non-number, let‚Äôs make the game ignore a non-number so "
"the\n"
"user can continue guessing. We can do that by altering the line where "
"`guess`\n"
"is converted from a `String` to a `u32`, as shown in Listing 2-5."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1139
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     loop {\n"
"#         println!(\"Please input your guess.\");\n"
"# \n"
"#         let mut guess = String::new();\n"
"# \n"
"        // --snip--\n"
"\n"
"        io::stdin()\n"
"            .read_line(&mut guess)\n"
"            .expect(\"Failed to read line\");\n"
"\n"
"        let guess: u32 = match guess.trim().parse() {\n"
"            Ok(num) => num,\n"
"            Err(_) => continue,\n"
"        };\n"
"\n"
"        println!(\"You guessed: {guess}\");\n"
"\n"
"        // --snip--\n"
"# \n"
"#         match guess.cmp(&secret_number) {\n"
"#             Ordering::Less => println!(\"Too small!\"),\n"
"#             Ordering::Greater => println!(\"Too big!\"),\n"
"#             Ordering::Equal => {\n"
"#                 println!(\"You win!\");\n"
"#                 break;\n"
"#             }\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1183
msgid ""
"<span class=\"caption\">Listing 2-5: Ignoring a non-number guess and asking "
"for\n"
"another guess instead of crashing the program</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1186
msgid ""
"We switch from an `expect` call to a `match` expression to move from "
"crashing\n"
"on an error to handling the error. Remember that `parse` returns a `Result`\n"
"type and `Result` is an enum that has the variants `Ok` and `Err`. We‚Äôre "
"using\n"
"a `match` expression here, as we did with the `Ordering` result of the "
"`cmp`\n"
"method."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1192
msgid ""
"If `parse` is able to successfully turn the string into a number, it will\n"
"return an `Ok` value that contains the resultant number. That `Ok` value "
"will\n"
"match the first arm‚Äôs pattern, and the `match` expression will just return "
"the\n"
"`num` value that `parse` produced and put inside the `Ok` value. That "
"number\n"
"will end up right where we want it in the new `guess` variable we‚Äôre "
"creating."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1198
msgid ""
"If `parse` is *not* able to turn the string into a number, it will return "
"an\n"
"`Err` value that contains more information about the error. The `Err` value\n"
"does not match the `Ok(num)` pattern in the first `match` arm, but it does\n"
"match the `Err(_)` pattern in the second arm. The underscore, `_`, is a\n"
"catchall value; in this example, we‚Äôre saying we want to match all `Err`\n"
"values, no matter what information they have inside them. So the program "
"will\n"
"execute the second arm‚Äôs code, `continue`, which tells the program to go to "
"the\n"
"next iteration of the `loop` and ask for another guess. So, effectively, "
"the\n"
"program ignores all errors that `parse` might encounter!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1208
msgid "Now everything in the program should work as expected. Let‚Äôs try it:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1210
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch02-guessing-game-tutorial/listing-02-05/\n"
"cargo run\n"
"(too small guess)\n"
"(too big guess)\n"
"foo\n"
"(correct guess)\n"
"-->"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1219
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 61\n"
"Please input your guess.\n"
"10\n"
"You guessed: 10\n"
"Too small!\n"
"Please input your guess.\n"
"99\n"
"You guessed: 99\n"
"Too big!\n"
"Please input your guess.\n"
"foo\n"
"Please input your guess.\n"
"61\n"
"You guessed: 61\n"
"You win!\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1242
msgid ""
"Awesome! With one tiny final tweak, we will finish the guessing game. "
"Recall\n"
"that the program is still printing the secret number. That worked well for\n"
"testing, but it ruins the game. Let‚Äôs delete the `println!` that outputs "
"the\n"
"secret number. Listing 2-6 shows the final code."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1249
msgid ""
"```rust,ignore\n"
"use rand::Rng;\n"
"use std::cmp::Ordering;\n"
"use std::io;\n"
"\n"
"fn main() {\n"
"    println!(\"Guess the number!\");\n"
"\n"
"    let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"\n"
"    loop {\n"
"        println!(\"Please input your guess.\");\n"
"\n"
"        let mut guess = String::new();\n"
"\n"
"        io::stdin()\n"
"            .read_line(&mut guess)\n"
"            .expect(\"Failed to read line\");\n"
"\n"
"        let guess: u32 = match guess.trim().parse() {\n"
"            Ok(num) => num,\n"
"            Err(_) => continue,\n"
"        };\n"
"\n"
"        println!(\"You guessed: {guess}\");\n"
"\n"
"        match guess.cmp(&secret_number) {\n"
"            Ordering::Less => println!(\"Too small!\"),\n"
"            Ordering::Greater => println!(\"Too big!\"),\n"
"            Ordering::Equal => {\n"
"                println!(\"You win!\");\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1287
msgid "<span class=\"caption\">Listing 2-6: Complete guessing game code</span>"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1289
msgid ""
"At this point, you‚Äôve successfully built the guessing game. Congratulations!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1293
msgid ""
"This project was a hands-on way to introduce you to many new Rust concepts:\n"
"`let`, `match`, functions, the use of external crates, and more. In the "
"next\n"
"few chapters, you‚Äôll learn about these concepts in more detail. Chapter 3\n"
"covers concepts that most programming languages have, such as variables, "
"data\n"
"types, and functions, and shows how to use them in Rust. Chapter 4 explores\n"
"ownership, a feature that makes Rust different from other languages. Chapter "
"5\n"
"discusses structs and method syntax, and Chapter 6 explains how enums work."
msgstr ""

#: src/ch03-00-common-programming-concepts.md:1
msgid "# Common Programming Concepts"
msgstr ""

#: src/ch03-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language\n"
"and how they work in Rust. Many programming languages have much in common "
"at\n"
"their core. None of the concepts presented in this chapter are unique to "
"Rust,\n"
"but we‚Äôll discuss them in the context of Rust and explain the conventions\n"
"around using these concepts."
msgstr ""

#: src/ch03-00-common-programming-concepts.md:9
msgid ""
"Specifically, you‚Äôll learn about variables, basic types, functions, "
"comments,\n"
"and control flow. These foundations will be in every Rust program, and "
"learning\n"
"them early will give you a strong core to start from."
msgstr ""

#: src/ch03-00-common-programming-concepts.md:13
msgid ""
"> #### Keywords\n"
">\n"
"> The Rust language has a set of *keywords* that are reserved for use by "
"the\n"
"> language only, much as in other languages. Keep in mind that you cannot "
"use\n"
"> these words as names of variables or functions. Most of the keywords have\n"
"> special meanings, and you‚Äôll be using them to do various tasks in your "
"Rust\n"
"> programs; a few have no current functionality associated with them but "
"have\n"
"> been reserved for functionality that might be added to Rust in the future. "
"You\n"
"> can find a list of the keywords in [Appendix A][appendix_a]<!-- ignore -->."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:1
msgid "## Variables and Mutability"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:3
msgid ""
"As mentioned in the [‚ÄúStoring Values with\n"
"Variables‚Äù][storing-values-with-variables]<!-- ignore --> section, by "
"default,\n"
"variables are immutable. This is one of many nudges Rust gives you to write\n"
"your code in a way that takes advantage of the safety and easy concurrency "
"that\n"
"Rust offers. However, you still have the option to make your variables "
"mutable.\n"
"Let‚Äôs explore how and why Rust encourages you to favor immutability and why\n"
"sometimes you might want to opt out."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:11
msgid ""
"When a variable is immutable, once a value is bound to a name, you can‚Äôt "
"change\n"
"that value. To illustrate this, generate a new project called *variables* "
"in\n"
"your *projects* directory by using `cargo new variables`."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:15
msgid ""
"Then, in your new *variables* directory, open *src/main.rs* and replace its\n"
"code with the following code, which won‚Äôt compile just yet:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:20
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let x = 5;\n"
"    println!(\"The value of x is: {x}\");\n"
"    x = 6;\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `cargo run`. You should receive an error "
"message\n"
"regarding an immutability error, as shown in this output:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:32
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"error[E0384]: cannot assign twice to immutable variable `x`\n"
" --> src/main.rs:4:5\n"
"  |\n"
"2 |     let x = 5;\n"
"  |         -\n"
"  |         |\n"
"  |         first assignment to `x`\n"
"  |         help: consider making this binding mutable: `mut x`\n"
"3 |     println!(\"The value of x is: {x}\");\n"
"4 |     x = 6;\n"
"  |     ^^^^^ cannot assign twice to immutable variable\n"
"\n"
"For more information about this error, try `rustc --explain E0384`.\n"
"error: could not compile `variables` due to previous error\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:51
msgid ""
"This example shows how the compiler helps you find errors in your programs.\n"
"Compiler errors can be frustrating, but really they only mean your program\n"
"isn‚Äôt safely doing what you want it to do yet; they do *not* mean that "
"you‚Äôre\n"
"not a good programmer! Experienced Rustaceans still get compiler errors."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:56
msgid ""
"You received the error message `` cannot assign twice to immutable variable "
"`x`\n"
"`` because you tried to assign a second value to the immutable `x` variable."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:59
msgid ""
"It‚Äôs important that we get compile-time errors when we attempt to change a\n"
"value that‚Äôs designated as immutable because this very situation can lead "
"to\n"
"bugs. If one part of our code operates on the assumption that a value will\n"
"never change and another part of our code changes that value, it‚Äôs possible\n"
"that the first part of the code won‚Äôt do what it was designed to do. The "
"cause\n"
"of this kind of bug can be difficult to track down after the fact, "
"especially\n"
"when the second piece of code changes the value only *sometimes*. The Rust\n"
"compiler guarantees that when you state that a value won‚Äôt change, it "
"really\n"
"won‚Äôt change, so you don‚Äôt have to keep track of it yourself. Your code is "
"thus\n"
"easier to reason through."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:70
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write.\n"
"Although variables are immutable by default, you can make them mutable by\n"
"adding `mut` in front of the variable name as you did in [Chapter\n"
"2][storing-values-with-variables]<!-- ignore -->. Adding `mut` also conveys\n"
"intent to future readers of the code by indicating that other parts of the "
"code\n"
"will be changing this variable‚Äôs value."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:77
msgid "For example, let‚Äôs change *src/main.rs* to the following:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:81
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    println!(\"The value of x is: {x}\");\n"
"    x = 6;\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:90
msgid "When we run the program now, we get this:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:92
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/variables`\n"
"The value of x is: 5\n"
"The value of x is: 6\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:101
msgid ""
"We‚Äôre allowed to change the value bound to `x` from `5` to `6` when `mut` "
"is\n"
"used. Ultimately, deciding whether to use mutability or not is up to you "
"and\n"
"depends on what you think is clearest in that particular situation."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:105
msgid "### Constants"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:107
msgid ""
"Like immutable variables, *constants* are values that are bound to a name "
"and\n"
"are not allowed to change, but there are a few differences between "
"constants\n"
"and variables."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:111
msgid ""
"First, you aren‚Äôt allowed to use `mut` with constants. Constants aren‚Äôt "
"just\n"
"immutable by default‚Äîthey‚Äôre always immutable. You declare constants using "
"the\n"
"`const` keyword instead of the `let` keyword, and the type of the value "
"*must*\n"
"be annotated. We‚Äôll cover types and type annotations in the next section,\n"
"[‚ÄúData Types‚Äù][data-types]<!-- ignore -->, so don‚Äôt worry about the details\n"
"right now. Just know that you must always annotate the type."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:118
msgid ""
"Constants can be declared in any scope, including the global scope, which "
"makes\n"
"them useful for values that many parts of code need to know about."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:121
msgid ""
"The last difference is that constants may be set only to a constant "
"expression,\n"
"not the result of a value that could only be computed at runtime."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:124
msgid "Here‚Äôs an example of a constant declaration:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:126
msgid ""
"```rust\n"
"const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:130
msgid ""
"The constant‚Äôs name is `THREE_HOURS_IN_SECONDS` and its value is set to the\n"
"result of multiplying 60 (the number of seconds in a minute) by 60 (the "
"number\n"
"of minutes in an hour) by 3 (the number of hours we want to count in this\n"
"program). Rust‚Äôs naming convention for constants is to use all uppercase "
"with\n"
"underscores between words. The compiler is able to evaluate a limited set "
"of\n"
"operations at compile time, which lets us choose to write out this value in "
"a\n"
"way that‚Äôs easier to understand and verify, rather than setting this "
"constant\n"
"to the value 10,800. See the [Rust Reference‚Äôs section on constant\n"
"evaluation][const-eval] for more information on what operations can be used\n"
"when declaring constants."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:141
msgid ""
"Constants are valid for the entire time a program runs, within the scope in\n"
"which they were declared. This property makes constants useful for values "
"in\n"
"your application domain that multiple parts of the program might need to "
"know\n"
"about, such as the maximum number of points any player of a game is allowed "
"to\n"
"earn, or the speed of light."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:147
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in\n"
"conveying the meaning of that value to future maintainers of the code. It "
"also\n"
"helps to have only one place in your code you would need to change if the\n"
"hardcoded value needed to be updated in the future."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:152
msgid "### Shadowing"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:154
msgid ""
"As you saw in the guessing game tutorial in [Chapter\n"
"2][comparing-the-guess-to-the-secret-number]<!-- ignore -->, you can declare "
"a\n"
"new variable with the same name as a previous variable. Rustaceans say that "
"the\n"
"first variable is *shadowed* by the second, which means that the second\n"
"variable is what the compiler will see when you use the name of the "
"variable.\n"
"In effect, the second variable overshadows the first, taking any uses of "
"the\n"
"variable name to itself until either it itself is shadowed or the scope "
"ends.\n"
"We can shadow a variable by using the same variable‚Äôs name and repeating "
"the\n"
"use of the `let` keyword as follows:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:166
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 5;\n"
"\n"
"    let x = x + 1;\n"
"\n"
"    {\n"
"        let x = x * 2;\n"
"        println!(\"The value of x in the inner scope is: {x}\");\n"
"    }\n"
"\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:181
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable\n"
"`x` by repeating `let x =`, taking the original value and adding `1` so the\n"
"value of `x` is then `6`. Then, within an inner scope created with the "
"curly\n"
"brackets, the third `let` statement also shadows `x` and creates a new\n"
"variable, multiplying the previous value by `2` to give `x` a value of "
"`12`.\n"
"When that scope is over, the inner shadowing ends and `x` returns to being "
"`6`.\n"
"When we run this program, it will output the following:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:189
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/variables`\n"
"The value of x in the inner scope is: 12\n"
"The value of x is: 6\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:198
msgid ""
"Shadowing is different from marking a variable as `mut` because we‚Äôll get a\n"
"compile-time error if we accidentally try to reassign to this variable "
"without\n"
"using the `let` keyword. By using `let`, we can perform a few "
"transformations\n"
"on a value but have the variable be immutable after those transformations "
"have\n"
"been completed."
msgstr ""

#: src/ch03-01-variables-and-mutability.md:204
msgid ""
"The other difference between `mut` and shadowing is that because we‚Äôre\n"
"effectively creating a new variable when we use the `let` keyword again, we "
"can\n"
"change the type of the value but reuse the same name. For example, say our\n"
"program asks a user to show how many spaces they want between some text by\n"
"inputting space characters, and then we want to store that input as a number:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:210
msgid ""
"```rust\n"
"# fn main() {\n"
"    let spaces = \"   \";\n"
"    let spaces = spaces.len();\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:217
msgid ""
"The first `spaces` variable is a string type and the second `spaces` "
"variable\n"
"is a number type. Shadowing thus spares us from having to come up with\n"
"different names, such as `spaces_str` and `spaces_num`; instead, we can "
"reuse\n"
"the simpler `spaces` name. However, if we try to use `mut` for this, as "
"shown\n"
"here, we‚Äôll get a compile-time error:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:223
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let mut spaces = \"   \";\n"
"    spaces = spaces.len();\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:230
msgid "The error says we‚Äôre not allowed to mutate a variable‚Äôs type:"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:232
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:3:14\n"
"  |\n"
"2 |     let mut spaces = \"   \";\n"
"  |                      ----- expected due to this value\n"
"3 |     spaces = spaces.len();\n"
"  |              ^^^^^^^^^^^^ expected `&str`, found `usize`\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `variables` due to previous error\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:247
msgid ""
"Now that we‚Äôve explored how variables work, let‚Äôs look at more data types "
"they\n"
"can have."
msgstr ""

#: src/ch03-02-data-types.md:1
msgid "## Data Types"
msgstr ""

#: src/ch03-02-data-types.md:3
msgid ""
"Every value in Rust is of a certain *data type*, which tells Rust what kind "
"of\n"
"data is being specified so it knows how to work with that data. We‚Äôll look "
"at\n"
"two data type subsets: scalar and compound."
msgstr ""

#: src/ch03-02-data-types.md:7
msgid ""
"Keep in mind that Rust is a *statically typed* language, which means that "
"it\n"
"must know the types of all variables at compile time. The compiler can "
"usually\n"
"infer what type we want to use based on the value and how we use it. In "
"cases\n"
"when many types are possible, such as when we converted a `String` to a "
"numeric\n"
"type using `parse` in the [‚ÄúComparing the Guess to the Secret\n"
"Number‚Äù][comparing-the-guess-to-the-secret-number]<!-- ignore --> section "
"in\n"
"Chapter 2, we must add a type annotation, like this:"
msgstr ""

#: src/ch03-02-data-types.md:15
msgid ""
"```rust\n"
"let guess: u32 = \"42\".parse().expect(\"Not a number!\");\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:19
msgid ""
"If we don‚Äôt add the `: u32` type annotation shown in the preceding code, "
"Rust\n"
"will display the following error, which means the compiler needs more\n"
"information from us to know which type we want to use:"
msgstr ""

#: src/ch03-02-data-types.md:23
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling no_type_annotations v0.1.0 (file:///projects/"
"no_type_annotations)\n"
"error[E0282]: type annotations needed\n"
" --> src/main.rs:2:9\n"
"  |\n"
"2 |     let guess = \"42\".parse().expect(\"Not a number!\");\n"
"  |         ^^^^^\n"
"  |\n"
"help: consider giving `guess` an explicit type\n"
"  |\n"
"2 |     let guess: _ = \"42\".parse().expect(\"Not a number!\");\n"
"  |              +++\n"
"\n"
"For more information about this error, try `rustc --explain E0282`.\n"
"error: could not compile `no_type_annotations` due to previous error\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:41
msgid "You‚Äôll see different type annotations for other data types."
msgstr ""

#: src/ch03-02-data-types.md:43
msgid "### Scalar Types"
msgstr ""

#: src/ch03-02-data-types.md:45
msgid ""
"A *scalar* type represents a single value. Rust has four primary scalar "
"types:\n"
"integers, floating-point numbers, Booleans, and characters. You may "
"recognize\n"
"these from other programming languages. Let‚Äôs jump into how they work in "
"Rust."
msgstr ""

#: src/ch03-02-data-types.md:49
msgid "#### Integer Types"
msgstr ""

#: src/ch03-02-data-types.md:51
msgid ""
"An *integer* is a number without a fractional component. We used one "
"integer\n"
"type in Chapter 2, the `u32` type. This type declaration indicates that the\n"
"value it‚Äôs associated with should be an unsigned integer (signed integer "
"types\n"
"start with `i` instead of `u`) that takes up 32 bits of space. Table 3-1 "
"shows\n"
"the built-in integer types in Rust. We can use any of these variants to "
"declare\n"
"the type of an integer value."
msgstr ""

#: src/ch03-02-data-types.md:58
msgid "<span class=\"caption\">Table 3-1: Integer Types in Rust</span>"
msgstr ""

#: src/ch03-02-data-types.md:60
msgid ""
"| Length  | Signed  | Unsigned |\n"
"|---------|---------|----------|\n"
"| 8-bit   | `i8`    | `u8`     |\n"
"| 16-bit  | `i16`   | `u16`    |\n"
"| 32-bit  | `i32`   | `u32`    |\n"
"| 64-bit  | `i64`   | `u64`    |\n"
"| 128-bit | `i128`  | `u128`   |\n"
"| arch    | `isize` | `usize`  |"
msgstr ""

#: src/ch03-02-data-types.md:69
msgid ""
"Each variant can be either signed or unsigned and has an explicit size.\n"
"*Signed* and *unsigned* refer to whether it‚Äôs possible for the number to be\n"
"negative‚Äîin other words, whether the number needs to have a sign with it\n"
"(signed) or whether it will only ever be positive and can therefore be\n"
"represented without a sign (unsigned). It‚Äôs like writing numbers on paper: "
"when\n"
"the sign matters, a number is shown with a plus sign or a minus sign; "
"however,\n"
"when it‚Äôs safe to assume the number is positive, it‚Äôs shown with no sign.\n"
"Signed numbers are stored using [two‚Äôs complement][twos-complement]<!-- "
"ignore\n"
"--> representation."
msgstr ""

#: src/ch03-02-data-types.md:79
msgid ""
"Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n "
"-\n"
"1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So "
"an\n"
"`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which "
"equals\n"
"-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - "
"1,\n"
"so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to "
"255."
msgstr ""

#: src/ch03-02-data-types.md:85
msgid ""
"Additionally, the `isize` and `usize` types depend on the architecture of "
"the\n"
"computer your program is running on, which is denoted in the table as "
"‚Äúarch‚Äù:\n"
"64 bits if you‚Äôre on a 64-bit architecture and 32 bits if you‚Äôre on a 32-"
"bit\n"
"architecture."
msgstr ""

#: src/ch03-02-data-types.md:90
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note\n"
"that number literals that can be multiple numeric types allow a type "
"suffix,\n"
"such as `57u8`, to designate the type. Number literals can also use `_` as "
"a\n"
"visual separator to make the number easier to read, such as `1_000`, which "
"will\n"
"have the same value as if you had specified `1000`."
msgstr ""

#: src/ch03-02-data-types.md:96
msgid "<span class=\"caption\">Table 3-2: Integer Literals in Rust</span>"
msgstr ""

#: src/ch03-02-data-types.md:98
msgid ""
"| Number literals  | Example       |\n"
"|------------------|---------------|\n"
"| Decimal          | `98_222`      |\n"
"| Hex              | `0xff`        |\n"
"| Octal            | `0o77`        |\n"
"| Binary           | `0b1111_0000` |\n"
"| Byte (`u8` only) | `b'A'`        |"
msgstr ""

#: src/ch03-02-data-types.md:106
msgid ""
"So how do you know which type of integer to use? If you‚Äôre unsure, Rust‚Äôs\n"
"defaults are generally good places to start: integer types default to "
"`i32`.\n"
"The primary situation in which you‚Äôd use `isize` or `usize` is when "
"indexing\n"
"some sort of collection."
msgstr ""

#: src/ch03-02-data-types.md:111
msgid ""
"> ##### Integer Overflow\n"
">\n"
"> Let‚Äôs say you have a variable of type `u8` that can hold values between 0 "
"and\n"
"> 255. If you try to change the variable to a value outside that range, such "
"as\n"
"> 256, *integer overflow* will occur, which can result in one of two "
"behaviors.\n"
"> When you‚Äôre compiling in debug mode, Rust includes checks for integer "
"overflow\n"
"> that cause your program to *panic* at runtime if this behavior occurs. "
"Rust\n"
"> uses the term *panicking* when a program exits with an error; we‚Äôll "
"discuss\n"
"> panics in more depth in the [‚ÄúUnrecoverable Errors with\n"
"> `panic!`‚Äù][unrecoverable-errors-with-panic]<!-- ignore --> section in "
"Chapter\n"
"> 9.\n"
">\n"
"> When you‚Äôre compiling in release mode with the `--release` flag, Rust "
"does\n"
"> *not* include checks for integer overflow that cause panics. Instead, if\n"
"> overflow occurs, Rust performs *two‚Äôs complement wrapping*. In short, "
"values\n"
"> greater than the maximum value the type can hold ‚Äúwrap around‚Äù to the "
"minimum\n"
"> of the values the type can hold. In the case of a `u8`, the value 256 "
"becomes\n"
"> 0, the value 257 becomes 1, and so on. The program won‚Äôt panic, but the\n"
"> variable will have a value that probably isn‚Äôt what you were expecting it "
"to\n"
"> have. Relying on integer overflow‚Äôs wrapping behavior is considered an "
"error.\n"
">\n"
"> To explicitly handle the possibility of overflow, you can use these "
"families\n"
"> of methods provided by the standard library for primitive numeric types:\n"
">\n"
"> * Wrap in all modes with the `wrapping_*` methods, such as "
"`wrapping_add`.\n"
"> * Return the `None` value if there is overflow with the `checked_*` "
"methods.\n"
"> * Return the value and a boolean indicating whether there was overflow "
"with\n"
">   the `overflowing_*` methods.\n"
"> * Saturate at the value‚Äôs minimum or maximum values with the "
"`saturating_*`\n"
">   methods."
msgstr ""

#: src/ch03-02-data-types.md:142
msgid "#### Floating-Point Types"
msgstr ""

#: src/ch03-02-data-types.md:144
msgid ""
"Rust also has two primitive types for *floating-point numbers*, which are\n"
"numbers with decimal points. Rust‚Äôs floating-point types are `f32` and "
"`f64`,\n"
"which are 32 bits and 64 bits in size, respectively. The default type is "
"`f64`\n"
"because on modern CPUs, it‚Äôs roughly the same speed as `f32` but is capable "
"of\n"
"more precision. All floating-point types are signed."
msgstr ""

#: src/ch03-02-data-types.md:150
msgid "Here‚Äôs an example that shows floating-point numbers in action:"
msgstr ""

#: src/ch03-02-data-types.md:154
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 2.0; // f64\n"
"\n"
"    let y: f32 = 3.0; // f32\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:162
msgid ""
"Floating-point numbers are represented according to the IEEE-754 standard. "
"The\n"
"`f32` type is a single-precision float, and `f64` has double precision."
msgstr ""

#: src/ch03-02-data-types.md:165
msgid "#### Numeric Operations"
msgstr ""

#: src/ch03-02-data-types.md:167
msgid ""
"Rust supports the basic mathematical operations you‚Äôd expect for all the "
"number\n"
"types: addition, subtraction, multiplication, division, and remainder. "
"Integer\n"
"division truncates toward zero to the nearest integer. The following code "
"shows\n"
"how you‚Äôd use each numeric operation in a `let` statement:"
msgstr ""

#: src/ch03-02-data-types.md:174
msgid ""
"```rust\n"
"fn main() {\n"
"    // addition\n"
"    let sum = 5 + 10;\n"
"\n"
"    // subtraction\n"
"    let difference = 95.5 - 4.3;\n"
"\n"
"    // multiplication\n"
"    let product = 4 * 30;\n"
"\n"
"    // division\n"
"    let quotient = 56.7 / 32.2;\n"
"    let truncated = -5 / 3; // Results in -1\n"
"\n"
"    // remainder\n"
"    let remainder = 43 % 5;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:194
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates\n"
"to a single value, which is then bound to a variable. [Appendix\n"
"B][appendix_b]<!-- ignore --> contains a list of all operators that Rust\n"
"provides."
msgstr ""

#: src/ch03-02-data-types.md:199
msgid "#### The Boolean Type"
msgstr ""

#: src/ch03-02-data-types.md:201
msgid ""
"As in most other programming languages, a Boolean type in Rust has two "
"possible\n"
"values: `true` and `false`. Booleans are one byte in size. The Boolean type "
"in\n"
"Rust is specified using `bool`. For example:"
msgstr ""

#: src/ch03-02-data-types.md:207
msgid ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:215
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if`\n"
"expression. We‚Äôll cover how `if` expressions work in Rust in the [‚ÄúControl\n"
"Flow‚Äù][control-flow]<!-- ignore --> section."
msgstr ""

#: src/ch03-02-data-types.md:219
msgid "#### The Character Type"
msgstr ""

#: src/ch03-02-data-types.md:221
msgid ""
"Rust‚Äôs `char` type is the language‚Äôs most primitive alphabetic type. Here "
"are\n"
"some examples of declaring `char` values:"
msgstr ""

#: src/ch03-02-data-types.md:226
msgid ""
"```rust\n"
"fn main() {\n"
"    let c = 'z';\n"
"    let z: char = '‚Ñ§'; // with explicit type annotation\n"
"    let heart_eyed_cat = 'üòª';\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:234
msgid ""
"Note that we specify `char` literals with single quotes, as opposed to "
"string\n"
"literals, which use double quotes. Rust‚Äôs `char` type is four bytes in size "
"and\n"
"represents a Unicode Scalar Value, which means it can represent a lot more "
"than\n"
"just ASCII. Accented letters; Chinese, Japanese, and Korean characters; "
"emoji;\n"
"and zero-width spaces are all valid `char` values in Rust. Unicode Scalar\n"
"Values range from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF` "
"inclusive.\n"
"However, a ‚Äúcharacter‚Äù isn‚Äôt really a concept in Unicode, so your human\n"
"intuition for what a ‚Äúcharacter‚Äù is may not match up with what a `char` is "
"in\n"
"Rust. We‚Äôll discuss this topic in detail in [‚ÄúStoring UTF-8 Encoded Text "
"with\n"
"Strings‚Äù][strings]<!-- ignore --> in Chapter 8."
msgstr ""

#: src/ch03-02-data-types.md:245
msgid "### Compound Types"
msgstr ""

#: src/ch03-02-data-types.md:247
msgid ""
"*Compound types* can group multiple values into one type. Rust has two\n"
"primitive compound types: tuples and arrays."
msgstr ""

#: src/ch03-02-data-types.md:250
msgid "#### The Tuple Type"
msgstr ""

#: src/ch03-02-data-types.md:252
msgid ""
"A *tuple* is a general way of grouping together a number of values with a\n"
"variety of types into one compound type. Tuples have a fixed length: once\n"
"declared, they cannot grow or shrink in size."
msgstr ""

#: src/ch03-02-data-types.md:256
msgid ""
"We create a tuple by writing a comma-separated list of values inside\n"
"parentheses. Each position in the tuple has a type, and the types of the\n"
"different values in the tuple don‚Äôt have to be the same. We‚Äôve added "
"optional\n"
"type annotations in this example:"
msgstr ""

#: src/ch03-02-data-types.md:263
msgid ""
"```rust\n"
"fn main() {\n"
"    let tup: (i32, f64, u8) = (500, 6.4, 1);\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:269
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered "
"a\n"
"single compound element. To get the individual values out of a tuple, we "
"can\n"
"use pattern matching to destructure a tuple value, like this:"
msgstr ""

#: src/ch03-02-data-types.md:275
msgid ""
"```rust\n"
"fn main() {\n"
"    let tup = (500, 6.4, 1);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    println!(\"The value of y is: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:285
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then\n"
"uses a pattern with `let` to take `tup` and turn it into three separate\n"
"variables, `x`, `y`, and `z`. This is called *destructuring* because it "
"breaks\n"
"the single tuple into three parts. Finally, the program prints the value of\n"
"`y`, which is `6.4`."
msgstr ""

#: src/ch03-02-data-types.md:291
msgid ""
"We can also access a tuple element directly by using a period (`.`) followed "
"by\n"
"the index of the value we want to access. For example:"
msgstr ""

#: src/ch03-02-data-types.md:296
msgid ""
"```rust\n"
"fn main() {\n"
"    let x: (i32, f64, u8) = (500, 6.4, 1);\n"
"\n"
"    let five_hundred = x.0;\n"
"\n"
"    let six_point_four = x.1;\n"
"\n"
"    let one = x.2;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:308
msgid ""
"This program creates the tuple `x` and then accesses each element of the "
"tuple\n"
"using their respective indices. As with most programming languages, the "
"first\n"
"index in a tuple is 0."
msgstr ""

#: src/ch03-02-data-types.md:312
msgid ""
"The tuple without any values has a special name, *unit*. This value and its\n"
"corresponding type are both written `()` and represent an empty value or an\n"
"empty return type. Expressions implicitly return the unit value if they "
"don‚Äôt\n"
"return any other value."
msgstr ""

#: src/ch03-02-data-types.md:317
msgid "#### The Array Type"
msgstr ""

#: src/ch03-02-data-types.md:319
msgid ""
"Another way to have a collection of multiple values is with an *array*. "
"Unlike\n"
"a tuple, every element of an array must have the same type. Unlike arrays "
"in\n"
"some other languages, arrays in Rust have a fixed length."
msgstr ""

#: src/ch03-02-data-types.md:323
msgid ""
"We write the values in an array as a comma-separated list inside square\n"
"brackets:"
msgstr ""

#: src/ch03-02-data-types.md:328
msgid ""
"```rust\n"
"fn main() {\n"
"    let a = [1, 2, 3, 4, 5];\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:334
msgid ""
"Arrays are useful when you want your data allocated on the stack rather "
"than\n"
"the heap (we will discuss the stack and the heap more in [Chapter\n"
"4][stack-and-heap]<!-- ignore -->) or when you want to ensure you always "
"have a\n"
"fixed number of elements. An array isn‚Äôt as flexible as the vector type,\n"
"though. A *vector* is a similar collection type provided by the standard\n"
"library that *is* allowed to grow or shrink in size. If you‚Äôre unsure "
"whether\n"
"to use an array or a vector, chances are you should use a vector. [Chapter\n"
"8][vectors]<!-- ignore --> discusses vectors in more detail."
msgstr ""

#: src/ch03-02-data-types.md:343
msgid ""
"However, arrays are more useful when you know the number of elements will "
"not\n"
"need to change. For example, if you were using the names of the month in a\n"
"program, you would probably use an array rather than a vector because you "
"know\n"
"it will always contain 12 elements:"
msgstr ""

#: src/ch03-02-data-types.md:348
msgid ""
"```rust\n"
"let months = [\"January\", \"February\", \"March\", \"April\", \"May\", "
"\"June\", \"July\",\n"
"              \"August\", \"September\", \"October\", \"November\", "
"\"December\"];\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:353
msgid ""
"You write an array‚Äôs type using square brackets with the type of each "
"element,\n"
"a semicolon, and then the number of elements in the array, like so:"
msgstr ""

#: src/ch03-02-data-types.md:356
msgid ""
"```rust\n"
"let a: [i32; 5] = [1, 2, 3, 4, 5];\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:360
msgid ""
"Here, `i32` is the type of each element. After the semicolon, the number "
"`5`\n"
"indicates the array contains five elements."
msgstr ""

#: src/ch03-02-data-types.md:363
msgid ""
"You can also initialize an array to contain the same value for each element "
"by\n"
"specifying the initial value, followed by a semicolon, and then the length "
"of\n"
"the array in square brackets, as shown here:"
msgstr ""

#: src/ch03-02-data-types.md:367
msgid ""
"```rust\n"
"let a = [3; 5];\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:371
msgid ""
"The array named `a` will contain `5` elements that will all be set to the "
"value\n"
"`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in "
"a\n"
"more concise way."
msgstr ""

#: src/ch03-02-data-types.md:375
msgid "##### Accessing Array Elements"
msgstr ""

#: src/ch03-02-data-types.md:377
msgid ""
"An array is a single chunk of memory of a known, fixed size that can be\n"
"allocated on the stack. You can access elements of an array using indexing,\n"
"like this:"
msgstr ""

#: src/ch03-02-data-types.md:383
msgid ""
"```rust\n"
"fn main() {\n"
"    let a = [1, 2, 3, 4, 5];\n"
"\n"
"    let first = a[0];\n"
"    let second = a[1];\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:392
msgid ""
"In this example, the variable named `first` will get the value `1` because "
"that\n"
"is the value at index `[0]` in the array. The variable named `second` will "
"get\n"
"the value `2` from index `[1]` in the array."
msgstr ""

#: src/ch03-02-data-types.md:396
msgid "##### Invalid Array Element Access"
msgstr ""

#: src/ch03-02-data-types.md:398
msgid ""
"Let‚Äôs see what happens if you try to access an element of an array that is "
"past\n"
"the end of the array. Say you run this code, similar to the guessing game "
"in\n"
"Chapter 2, to get an array index from the user:"
msgstr ""

#: src/ch03-02-data-types.md:404
msgid ""
"```rust,ignore,panics\n"
"use std::io;\n"
"\n"
"fn main() {\n"
"    let a = [1, 2, 3, 4, 5];\n"
"\n"
"    println!(\"Please enter an array index.\");\n"
"\n"
"    let mut index = String::new();\n"
"\n"
"    io::stdin()\n"
"        .read_line(&mut index)\n"
"        .expect(\"Failed to read line\");\n"
"\n"
"    let index: usize = index\n"
"        .trim()\n"
"        .parse()\n"
"        .expect(\"Index entered was not a number\");\n"
"\n"
"    let element = a[index];\n"
"\n"
"    println!(\"The value of the element at index {index} is: {element}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:429
msgid ""
"This code compiles successfully. If you run this code using `cargo run` and\n"
"enter `0`, `1`, `2`, `3`, or `4`, the program will print out the "
"corresponding\n"
"value at that index in the array. If you instead enter a number past the end "
"of\n"
"the array, such as `10`, you‚Äôll see output like this:"
msgstr ""

#: src/ch03-02-data-types.md:434
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-"
"access\n"
"cargo run\n"
"10\n"
"-->"
msgstr ""

#: src/ch03-02-data-types.md:440
msgid ""
"```console\n"
"thread 'main' panicked at 'index out of bounds: the len is 5 but the index "
"is 10', src/main.rs:19:19\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:445
msgid ""
"The program resulted in a *runtime* error at the point of using an invalid\n"
"value in the indexing operation. The program exited with an error message "
"and\n"
"didn‚Äôt execute the final `println!` statement. When you attempt to access "
"an\n"
"element using indexing, Rust will check that the index you‚Äôve specified is "
"less\n"
"than the array length. If the index is greater than or equal to the length,\n"
"Rust will panic. This check has to happen at runtime, especially in this "
"case,\n"
"because the compiler can‚Äôt possibly know what value a user will enter when "
"they\n"
"run the code later."
msgstr ""

#: src/ch03-02-data-types.md:454
msgid ""
"This is an example of Rust‚Äôs memory safety principles in action. In many\n"
"low-level languages, this kind of check is not done, and when you provide "
"an\n"
"incorrect index, invalid memory can be accessed. Rust protects you against "
"this\n"
"kind of error by immediately exiting instead of allowing the memory access "
"and\n"
"continuing. Chapter 9 discusses more of Rust‚Äôs error handling and how you "
"can\n"
"write readable, safe code that neither panics nor allows invalid memory "
"access."
msgstr ""

#: src/ch03-03-how-functions-work.md:1
msgid "## Functions"
msgstr ""

#: src/ch03-03-how-functions-work.md:3
msgid ""
"Functions are prevalent in Rust code. You‚Äôve already seen one of the most\n"
"important functions in the language: the `main` function, which is the "
"entry\n"
"point of many programs. You‚Äôve also seen the `fn` keyword, which allows you "
"to\n"
"declare new functions."
msgstr ""

#: src/ch03-03-how-functions-work.md:8
msgid ""
"Rust code uses *snake case* as the conventional style for function and "
"variable\n"
"names, in which all letters are lowercase and underscores separate words.\n"
"Here‚Äôs a program that contains an example function definition:"
msgstr ""

#: src/ch03-03-how-functions-work.md:14
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello, world!\");\n"
"\n"
"    another_function();\n"
"}\n"
"\n"
"fn another_function() {\n"
"    println!(\"Another function.\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:26
msgid ""
"We define a function in Rust by entering `fn` followed by a function name "
"and a\n"
"set of parentheses. The curly brackets tell the compiler where the function\n"
"body begins and ends."
msgstr ""

#: src/ch03-03-how-functions-work.md:30
msgid ""
"We can call any function we‚Äôve defined by entering its name followed by a "
"set\n"
"of parentheses. Because `another_function` is defined in the program, it can "
"be\n"
"called from inside the `main` function. Note that we defined "
"`another_function`\n"
"*after* the `main` function in the source code; we could have defined it "
"before\n"
"as well. Rust doesn‚Äôt care where you define your functions, only that "
"they‚Äôre\n"
"defined somewhere in a scope that can be seen by the caller."
msgstr ""

#: src/ch03-03-how-functions-work.md:37
msgid ""
"Let‚Äôs start a new binary project named *functions* to explore functions\n"
"further. Place the `another_function` example in *src/main.rs* and run it. "
"You\n"
"should see the following output:"
msgstr ""

#: src/ch03-03-how-functions-work.md:41
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.28s\n"
"     Running `target/debug/functions`\n"
"Hello, world!\n"
"Another function.\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:50
msgid ""
"The lines execute in the order in which they appear in the `main` function.\n"
"First the ‚ÄúHello, world!‚Äù message prints, and then `another_function` is "
"called\n"
"and its message is printed."
msgstr ""

#: src/ch03-03-how-functions-work.md:54
msgid "### Parameters"
msgstr ""

#: src/ch03-03-how-functions-work.md:56
msgid ""
"We can define functions to have *parameters*, which are special variables "
"that\n"
"are part of a function‚Äôs signature. When a function has parameters, you can\n"
"provide it with concrete values for those parameters. Technically, the "
"concrete\n"
"values are called *arguments*, but in casual conversation, people tend to "
"use\n"
"the words *parameter* and *argument* interchangeably for either the "
"variables\n"
"in a function‚Äôs definition or the concrete values passed in when you call a\n"
"function."
msgstr ""

#: src/ch03-03-how-functions-work.md:64
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch03-03-how-functions-work.md:68
msgid ""
"```rust\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: i32) {\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:78
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch03-03-how-functions-work.md:80
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.21s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:88
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of\n"
"`x` is specified as `i32`. When we pass `5` in to `another_function`, the\n"
"`println!` macro puts `5` where the pair of curly brackets containing `x` "
"was\n"
"in the format string."
msgstr ""

#: src/ch03-03-how-functions-work.md:93
msgid ""
"In function signatures, you *must* declare the type of each parameter. This "
"is\n"
"a deliberate decision in Rust‚Äôs design: requiring type annotations in "
"function\n"
"definitions means the compiler almost never needs you to use them elsewhere "
"in\n"
"the code to figure out what type you mean. The compiler is also able to "
"give\n"
"more helpful error messages if it knows what types the function expects."
msgstr ""

#: src/ch03-03-how-functions-work.md:99
msgid ""
"When defining multiple parameters, separate the parameter declarations with\n"
"commas, like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:104
msgid ""
"```rust\n"
"fn main() {\n"
"    print_labeled_measurement(5, 'h');\n"
"}\n"
"\n"
"fn print_labeled_measurement(value: i32, unit_label: char) {\n"
"    println!(\"The measurement is: {value}{unit_label}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:114
msgid ""
"This example creates a function named `print_labeled_measurement` with two\n"
"parameters. The first parameter is named `value` and is an `i32`. The second "
"is\n"
"named `unit_label` and is type `char`. The function then prints text "
"containing\n"
"both the `value` and the `unit_label`."
msgstr ""

#: src/ch03-03-how-functions-work.md:119
msgid ""
"Let‚Äôs try running this code. Replace the program currently in your "
"*functions*\n"
"project‚Äôs *src/main.rs* file with the preceding example and run it using "
"`cargo\n"
"run`:"
msgstr ""

#: src/ch03-03-how-functions-work.md:123
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/functions`\n"
"The measurement is: 5h\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:131
msgid ""
"Because we called the function with `5` as the value for `value` and `'h'` "
"as\n"
"the value for `unit_label`, the program output contains those values."
msgstr ""

#: src/ch03-03-how-functions-work.md:134
msgid "### Statements and Expressions"
msgstr ""

#: src/ch03-03-how-functions-work.md:136
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an\n"
"expression. So far, the functions we‚Äôve covered haven‚Äôt included an ending\n"
"expression, but you have seen an expression as part of a statement. Because\n"
"Rust is an expression-based language, this is an important distinction to\n"
"understand. Other languages don‚Äôt have the same distinctions, so let‚Äôs look "
"at\n"
"what statements and expressions are and how their differences affect the "
"bodies\n"
"of functions."
msgstr ""

#: src/ch03-03-how-functions-work.md:144
msgid ""
"* **Statements** are instructions that perform some action and do not "
"return\n"
"  a value.\n"
"* **Expressions** evaluate to a resultant value. Let‚Äôs look at some examples."
msgstr ""

#: src/ch03-03-how-functions-work.md:148
msgid ""
"We‚Äôve actually already used statements and expressions. Creating a variable "
"and\n"
"assigning a value to it with the `let` keyword is a statement. In Listing "
"3-1,\n"
"`let y = 6;` is a statement."
msgstr ""

#: src/ch03-03-how-functions-work.md:154
msgid ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:160
msgid ""
"<span class=\"caption\">Listing 3-1: A `main` function declaration "
"containing one statement</span>"
msgstr ""

#: src/ch03-03-how-functions-work.md:162
msgid ""
"Function definitions are also statements; the entire preceding example is a\n"
"statement in itself."
msgstr ""

#: src/ch03-03-how-functions-work.md:165
msgid ""
"Statements do not return values. Therefore, you can‚Äôt assign a `let` "
"statement\n"
"to another variable, as the following code tries to do; you‚Äôll get an error:"
msgstr ""

#: src/ch03-03-how-functions-work.md:170
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:176
msgid "When you run this program, the error you‚Äôll get looks like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:178
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error: expected expression, found `let` statement\n"
" --> src/main.rs:2:14\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |              ^^^\n"
"\n"
"error: expected expression, found statement (`let`)\n"
" --> src/main.rs:2:14\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |              ^^^^^^^^^\n"
"  |\n"
"  = note: variable declaration using `let` is a statement\n"
"\n"
"error[E0658]: `let` expressions in this position are unstable\n"
" --> src/main.rs:2:14\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |              ^^^^^^^^^\n"
"  |\n"
"  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> "
"for more information\n"
"\n"
"warning: unnecessary parentheses around assigned value\n"
" --> src/main.rs:2:13\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |             ^         ^\n"
"  |\n"
"  = note: `#[warn(unused_parens)]` on by default\n"
"help: remove these parentheses\n"
"  |\n"
"2 -     let x = (let y = 6);\n"
"2 +     let x = let y = 6;\n"
"  |\n"
"\n"
"For more information about this error, try `rustc --explain E0658`.\n"
"warning: `functions` (bin \"functions\") generated 1 warning\n"
"error: could not compile `functions` due to 3 previous errors; 1 warning "
"emitted\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:221
msgid ""
"The `let y = 6` statement does not return a value, so there isn‚Äôt anything "
"for\n"
"`x` to bind to. This is different from what happens in other languages, such "
"as\n"
"C and Ruby, where the assignment returns the value of the assignment. In "
"those\n"
"languages, you can write `x = y = 6` and have both `x` and `y` have the "
"value\n"
"`6`; that is not the case in Rust."
msgstr ""

#: src/ch03-03-how-functions-work.md:227
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that\n"
"you‚Äôll write in Rust. Consider a math operation, such as `5 + 6`, which is "
"an\n"
"expression that evaluates to the value `11`. Expressions can be part of\n"
"statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an\n"
"expression that evaluates to the value `6`. Calling a function is an\n"
"expression. Calling a macro is an expression. A new scope block created "
"with\n"
"curly brackets is an expression, for example:"
msgstr ""

#: src/ch03-03-how-functions-work.md:237
msgid ""
"```rust\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    println!(\"The value of y is: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:248
msgid "This expression:"
msgstr ""

#: src/ch03-03-how-functions-work.md:250
msgid ""
"```rust,ignore\n"
"{\n"
"    let x = 3;\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:257
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y`\n"
"as part of the `let` statement. Note that the `x + 1` line doesn‚Äôt have a\n"
"semicolon at the end, which is unlike most of the lines you‚Äôve seen so far.\n"
"Expressions do not include ending semicolons. If you add a semicolon to the "
"end\n"
"of an expression, you turn it into a statement, and it will then not return "
"a\n"
"value. Keep this in mind as you explore function return values and "
"expressions\n"
"next."
msgstr ""

#: src/ch03-03-how-functions-work.md:265
msgid "### Functions with Return Values"
msgstr ""

#: src/ch03-03-how-functions-work.md:267
msgid ""
"Functions can return values to the code that calls them. We don‚Äôt name "
"return\n"
"values, but we must declare their type after an arrow (`->`). In Rust, the\n"
"return value of the function is synonymous with the value of the final\n"
"expression in the block of the body of a function. You can return early from "
"a\n"
"function by using the `return` keyword and specifying a value, but most\n"
"functions return the last expression implicitly. Here‚Äôs an example of a\n"
"function that returns a value:"
msgstr ""

#: src/ch03-03-how-functions-work.md:277
msgid ""
"```rust\n"
"fn five() -> i32 {\n"
"    5\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:289
msgid ""
"There are no function calls, macros, or even `let` statements in the `five`\n"
"function‚Äîjust the number `5` by itself. That‚Äôs a perfectly valid function "
"in\n"
"Rust. Note that the function‚Äôs return type is specified too, as `-> i32`. "
"Try\n"
"running this code; the output should look like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:294
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:302
msgid ""
"The `5` in `five` is the function‚Äôs return value, which is why the return "
"type\n"
"is `i32`. Let‚Äôs examine this in more detail. There are two important bits:\n"
"first, the line `let x = five();` shows that we‚Äôre using the return value of "
"a\n"
"function to initialize a variable. Because the function `five` returns a "
"`5`,\n"
"that line is the same as the following:"
msgstr ""

#: src/ch03-03-how-functions-work.md:308
#: src/ch18-01-all-the-places-for-patterns.md:192
msgid ""
"```rust\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:312
msgid ""
"Second, the `five` function has no parameters and defines the type of the\n"
"return value, but the body of the function is a lonely `5` with no "
"semicolon\n"
"because it‚Äôs an expression whose value we want to return."
msgstr ""

#: src/ch03-03-how-functions-work.md:316
msgid "Let‚Äôs look at another example:"
msgstr ""

#: src/ch03-03-how-functions-work.md:320
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"\n"
"fn plus_one(x: i32) -> i32 {\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:332
msgid ""
"Running this code will print `The value of x is: 6`. But if we place a\n"
"semicolon at the end of the line containing `x + 1`, changing it from an\n"
"expression to a statement, we‚Äôll get an error:"
msgstr ""

#: src/ch03-03-how-functions-work.md:338
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    println!(\"The value of x is: {x}\");\n"
"}\n"
"\n"
"fn plus_one(x: i32) -> i32 {\n"
"    x + 1;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:350
msgid "Compiling this code produces an error, as follows:"
msgstr ""

#: src/ch03-03-how-functions-work.md:352
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:7:24\n"
"  |\n"
"7 | fn plus_one(x: i32) -> i32 {\n"
"  |    --------            ^^^ expected `i32`, found `()`\n"
"  |    |\n"
"  |    implicitly returns `()` as its body has no tail or `return` "
"expression\n"
"8 |     x + 1;\n"
"  |          - help: remove this semicolon to return this value\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `functions` due to previous error\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:369
msgid ""
"The main error message, `mismatched types`, reveals the core issue with "
"this\n"
"code. The definition of the function `plus_one` says that it will return an\n"
"`i32`, but statements don‚Äôt evaluate to a value, which is expressed by "
"`()`,\n"
"the unit type. Therefore, nothing is returned, which contradicts the "
"function\n"
"definition and results in an error. In this output, Rust provides a message "
"to\n"
"possibly help rectify this issue: it suggests removing the semicolon, which\n"
"would fix the error."
msgstr ""

#: src/ch03-04-comments.md:1
msgid "## Comments"
msgstr ""

#: src/ch03-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes\n"
"extra explanation is warranted. In these cases, programmers leave *comments* "
"in\n"
"their source code that the compiler will ignore but people reading the "
"source\n"
"code may find useful."
msgstr ""

#: src/ch03-04-comments.md:8
msgid "Here‚Äôs a simple comment:"
msgstr ""

#: src/ch03-04-comments.md:10
msgid ""
"```rust\n"
"// hello, world\n"
"```"
msgstr ""

#: src/ch03-04-comments.md:14
msgid ""
"In Rust, the idiomatic comment style starts a comment with two slashes, and "
"the\n"
"comment continues until the end of the line. For comments that extend beyond "
"a\n"
"single line, you‚Äôll need to include `//` on each line, like this:"
msgstr ""

#: src/ch03-04-comments.md:18
msgid ""
"```rust\n"
"// So we‚Äôre doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what‚Äôs going on.\n"
"```"
msgstr ""

#: src/ch03-04-comments.md:24
msgid "Comments can also be placed at the end of lines containing code:"
msgstr ""

#: src/ch03-04-comments.md:28
msgid ""
"```rust\n"
"fn main() {\n"
"    let lucky_number = 7; // I‚Äôm feeling lucky today\n"
"}\n"
"```"
msgstr ""

#: src/ch03-04-comments.md:34
msgid ""
"But you‚Äôll more often see them used in this format, with the comment on a\n"
"separate line above the code it‚Äôs annotating:"
msgstr ""

#: src/ch03-04-comments.md:39
msgid ""
"```rust\n"
"fn main() {\n"
"    // I‚Äôm feeling lucky today\n"
"    let lucky_number = 7;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-04-comments.md:46
msgid ""
"Rust also has another kind of comment, documentation comments, which we‚Äôll\n"
"discuss in the [‚ÄúPublishing a Crate to Crates.io‚Äù][publishing]<!-- ignore --"
">\n"
"section of Chapter 14."
msgstr ""

#: src/ch03-05-control-flow.md:1
msgid "## Control Flow"
msgstr ""

#: src/ch03-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is `true` and "
"to\n"
"run some code repeatedly while a condition is `true` are basic building "
"blocks\n"
"in most programming languages. The most common constructs that let you "
"control\n"
"the flow of execution of Rust code are `if` expressions and loops."
msgstr ""

#: src/ch03-05-control-flow.md:8
msgid "### `if` Expressions"
msgstr ""

#: src/ch03-05-control-flow.md:10
msgid ""
"An `if` expression allows you to branch your code depending on conditions. "
"You\n"
"provide a condition and then state, ‚ÄúIf this condition is met, run this "
"block\n"
"of code. If the condition is not met, do not run this block of code.‚Äù"
msgstr ""

#: src/ch03-05-control-flow.md:14
msgid ""
"Create a new project called *branches* in your *projects* directory to "
"explore\n"
"the `if` expression. In the *src/main.rs* file, input the following:"
msgstr ""

#: src/ch03-05-control-flow.md:19
msgid ""
"```rust\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number < 5 {\n"
"        println!(\"condition was true\");\n"
"    } else {\n"
"        println!(\"condition was false\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:31
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In\n"
"this case, the condition checks whether or not the variable `number` has a\n"
"value less than 5. We place the block of code to execute if the condition "
"is\n"
"`true` immediately after the condition inside curly brackets. Blocks of "
"code\n"
"associated with the conditions in `if` expressions are sometimes called "
"*arms*,\n"
"just like the arms in `match` expressions that we discussed in the "
"[‚ÄúComparing\n"
"the Guess to the Secret Number‚Äù][comparing-the-guess-to-the-secret-"
"number]<!--\n"
"ignore --> section of Chapter 2."
msgstr ""

#: src/ch03-05-control-flow.md:40
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do\n"
"here, to give the program an alternative block of code to execute should "
"the\n"
"condition evaluate to `false`. If you don‚Äôt provide an `else` expression "
"and\n"
"the condition is `false`, the program will just skip the `if` block and move "
"on\n"
"to the next bit of code."
msgstr ""

#: src/ch03-05-control-flow.md:46
msgid "Try running this code; you should see the following output:"
msgstr ""

#: src/ch03-05-control-flow.md:48
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"condition was true\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:56
msgid ""
"Let‚Äôs try changing the value of `number` to a value that makes the "
"condition\n"
"`false` to see what happens:"
msgstr ""

#: src/ch03-05-control-flow.md:59
msgid ""
"```rust,ignore\n"
"# fn main() {\n"
"    let number = 7;\n"
"# \n"
"#     if number < 5 {\n"
"#         println!(\"condition was true\");\n"
"#     } else {\n"
"#         println!(\"condition was false\");\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:71
msgid "Run the program again, and look at the output:"
msgstr ""

#: src/ch03-05-control-flow.md:73
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"condition was false\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:81
msgid ""
"It‚Äôs also worth noting that the condition in this code *must* be a `bool`. "
"If\n"
"the condition isn‚Äôt a `bool`, we‚Äôll get an error. For example, try running "
"the\n"
"following code:"
msgstr ""

#: src/ch03-05-control-flow.md:87
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number {\n"
"        println!(\"number was three\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:97
msgid ""
"The `if` condition evaluates to a value of `3` this time, and Rust throws "
"an\n"
"error:"
msgstr ""

#: src/ch03-05-control-flow.md:100
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:4:8\n"
"  |\n"
"4 |     if number {\n"
"  |        ^^^^^^ expected `bool`, found integer\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `branches` due to previous error\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:113
msgid ""
"The error indicates that Rust expected a `bool` but got an integer. Unlike\n"
"languages such as Ruby and JavaScript, Rust will not automatically try to\n"
"convert non-Boolean types to a Boolean. You must be explicit and always "
"provide\n"
"`if` with a Boolean as its condition. If we want the `if` code block to run\n"
"only when a number is not equal to `0`, for example, we can change the `if`\n"
"expression to the following:"
msgstr ""

#: src/ch03-05-control-flow.md:122
msgid ""
"```rust\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number != 0 {\n"
"        println!(\"number was something other than zero\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:132
msgid "Running this code will print `number was something other than zero`."
msgstr ""

#: src/ch03-05-control-flow.md:134
msgid "#### Handling Multiple Conditions with `else if`"
msgstr ""

#: src/ch03-05-control-flow.md:136
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else "
"if`\n"
"expression. For example:"
msgstr ""

#: src/ch03-05-control-flow.md:141
msgid ""
"```rust\n"
"fn main() {\n"
"    let number = 6;\n"
"\n"
"    if number % 4 == 0 {\n"
"        println!(\"number is divisible by 4\");\n"
"    } else if number % 3 == 0 {\n"
"        println!(\"number is divisible by 3\");\n"
"    } else if number % 2 == 0 {\n"
"        println!(\"number is divisible by 2\");\n"
"    } else {\n"
"        println!(\"number is not divisible by 4, 3, or 2\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:157
msgid ""
"This program has four possible paths it can take. After running it, you "
"should\n"
"see the following output:"
msgstr ""

#: src/ch03-05-control-flow.md:160
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"number is divisible by 3\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:168
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes\n"
"the first body for which the condition evaluates to `true`. Note that even\n"
"though 6 is divisible by 2, we don‚Äôt see the output `number is divisible by "
"2`,\n"
"nor do we see the `number is not divisible by 4, 3, or 2` text from the "
"`else`\n"
"block. That‚Äôs because Rust only executes the block for the first `true`\n"
"condition, and once it finds one, it doesn‚Äôt even check the rest."
msgstr ""

#: src/ch03-05-control-flow.md:175
msgid ""
"Using too many `else if` expressions can clutter your code, so if you have "
"more\n"
"than one, you might want to refactor your code. Chapter 6 describes a "
"powerful\n"
"Rust branching construct called `match` for these cases."
msgstr ""

#: src/ch03-05-control-flow.md:179
msgid "#### Using `if` in a `let` Statement"
msgstr ""

#: src/ch03-05-control-flow.md:181
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let`\n"
"statement to assign the outcome to a variable, as in Listing 3-2."
msgstr ""

#: src/ch03-05-control-flow.md:186
msgid ""
"```rust\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition { 5 } else { 6 };\n"
"\n"
"    println!(\"The value of number is: {number}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:195
msgid ""
"<span class=\"caption\">Listing 3-2: Assigning the result of an `if` "
"expression\n"
"to a variable</span>"
msgstr ""

#: src/ch03-05-control-flow.md:198
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if`\n"
"expression. Run this code to see what happens:"
msgstr ""

#: src/ch03-05-control-flow.md:201
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/branches`\n"
"The value of number is: 5\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:209
msgid ""
"Remember that blocks of code evaluate to the last expression in them, and\n"
"numbers by themselves are also expressions. In this case, the value of the\n"
"whole `if` expression depends on which block of code executes. This means "
"the\n"
"values that have the potential to be results from each arm of the `if` must "
"be\n"
"the same type; in Listing 3-2, the results of both the `if` arm and the "
"`else`\n"
"arm were `i32` integers. If the types are mismatched, as in the following\n"
"example, we‚Äôll get an error:"
msgstr ""

#: src/ch03-05-control-flow.md:219
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let condition = true;\n"
"\n"
"    let number = if condition { 5 } else { \"six\" };\n"
"\n"
"    println!(\"The value of number is: {number}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:229
msgid ""
"When we try to compile this code, we‚Äôll get an error. The `if` and `else` "
"arms\n"
"have value types that are incompatible, and Rust indicates exactly where to\n"
"find the problem in the program:"
msgstr ""

#: src/ch03-05-control-flow.md:233
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"error[E0308]: `if` and `else` have incompatible types\n"
" --> src/main.rs:4:44\n"
"  |\n"
"4 |     let number = if condition { 5 } else { \"six\" };\n"
"  |                                 -          ^^^^^ expected integer, found "
"`&str`\n"
"  |                                 |\n"
"  |                                 expected because of this\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `branches` due to previous error\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:248
msgid ""
"The expression in the `if` block evaluates to an integer, and the expression "
"in\n"
"the `else` block evaluates to a string. This won‚Äôt work because variables "
"must\n"
"have a single type, and Rust needs to know at compile time what type the\n"
"`number` variable is, definitively. Knowing the type of `number` lets the\n"
"compiler verify the type is valid everywhere we use `number`. Rust wouldn‚Äôt "
"be\n"
"able to do that if the type of `number` was only determined at runtime; the\n"
"compiler would be more complex and would make fewer guarantees about the "
"code\n"
"if it had to keep track of multiple hypothetical types for any variable."
msgstr ""

#: src/ch03-05-control-flow.md:257
msgid "### Repetition with Loops"
msgstr ""

#: src/ch03-05-control-flow.md:259
msgid ""
"It‚Äôs often useful to execute a block of code more than once. For this task,\n"
"Rust provides several *loops*, which will run through the code inside the "
"loop\n"
"body to the end and then start immediately back at the beginning. To "
"experiment\n"
"with loops, let‚Äôs make a new project called *loops*."
msgstr ""

#: src/ch03-05-control-flow.md:264
msgid ""
"Rust has three kinds of loops: `loop`, `while`, and `for`. Let‚Äôs try each "
"one."
msgstr ""

#: src/ch03-05-control-flow.md:266
msgid "#### Repeating Code with `loop`"
msgstr ""

#: src/ch03-05-control-flow.md:268
msgid ""
"The `loop` keyword tells Rust to execute a block of code over and over "
"again\n"
"forever or until you explicitly tell it to stop."
msgstr ""

#: src/ch03-05-control-flow.md:271
msgid ""
"As an example, change the *src/main.rs* file in your *loops* directory to "
"look\n"
"like this:"
msgstr ""

#: src/ch03-05-control-flow.md:276
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    loop {\n"
"        println!(\"again!\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:284
msgid ""
"When we run this program, we‚Äôll see `again!` printed over and over "
"continuously\n"
"until we stop the program manually. Most terminals support the keyboard\n"
"shortcut <span class=\"keystroke\">ctrl-c</span> to interrupt a program that "
"is\n"
"stuck in a continual loop. Give it a try:"
msgstr ""

#: src/ch03-05-control-flow.md:289
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch03-common-programming-concepts/no-listing-32-loop\n"
"cargo run\n"
"CTRL-C\n"
"-->"
msgstr ""

#: src/ch03-05-control-flow.md:295
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.29s\n"
"     Running `target/debug/loops`\n"
"again!\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:307
msgid ""
"The symbol `^C` represents where you pressed <span\n"
"class=\"keystroke\">ctrl-c</span>. You may or may not see the word `again!`\n"
"printed after the `^C`, depending on where the code was in the loop when it\n"
"received the interrupt signal."
msgstr ""

#: src/ch03-05-control-flow.md:312
msgid ""
"Fortunately, Rust also provides a way to break out of a loop using code. "
"You\n"
"can place the `break` keyword within the loop to tell the program when to "
"stop\n"
"executing the loop. Recall that we did this in the guessing game in the\n"
"[‚ÄúQuitting After a Correct Guess‚Äù][quitting-after-a-correct-guess]<!-- "
"ignore\n"
"--> section of Chapter 2 to exit the program when the user won the game by\n"
"guessing the correct number."
msgstr ""

#: src/ch03-05-control-flow.md:319
msgid ""
"We also used `continue` in the guessing game, which in a loop tells the "
"program\n"
"to skip over any remaining code in this iteration of the loop and go to the\n"
"next iteration."
msgstr ""

#: src/ch03-05-control-flow.md:323
msgid "#### Returning Values from Loops"
msgstr ""

#: src/ch03-05-control-flow.md:325
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such\n"
"as checking whether a thread has completed its job. You might also need to "
"pass\n"
"the result of that operation out of the loop to the rest of your code. To "
"do\n"
"this, you can add the value you want returned after the `break` expression "
"you\n"
"use to stop the loop; that value will be returned out of the loop so you "
"can\n"
"use it, as shown here:"
msgstr ""

#: src/ch03-05-control-flow.md:332
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        counter += 1;\n"
"\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"    };\n"
"\n"
"    println!(\"The result is {result}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:348
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to\n"
"`0`. Then we declare a variable named `result` to hold the value returned "
"from\n"
"the loop. On every iteration of the loop, we add `1` to the `counter` "
"variable,\n"
"and then check whether the `counter` is equal to `10`. When it is, we use "
"the\n"
"`break` keyword with the value `counter * 2`. After the loop, we use a\n"
"semicolon to end the statement that assigns the value to `result`. Finally, "
"we\n"
"print the value in `result`, which in this case is `20`."
msgstr ""

#: src/ch03-05-control-flow.md:356
msgid "#### Loop Labels to Disambiguate Between Multiple Loops"
msgstr ""

#: src/ch03-05-control-flow.md:358
msgid ""
"If you have loops within loops, `break` and `continue` apply to the "
"innermost\n"
"loop at that point. You can optionally specify a *loop label* on a loop "
"that\n"
"you can then use with `break` or `continue` to specify that those keywords\n"
"apply to the labeled loop instead of the innermost loop. Loop labels must "
"begin\n"
"with a single quote. Here‚Äôs an example with two nested loops:"
msgstr ""

#: src/ch03-05-control-flow.md:364
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut count = 0;\n"
"    'counting_up: loop {\n"
"        println!(\"count = {count}\");\n"
"        let mut remaining = 10;\n"
"\n"
"        loop {\n"
"            println!(\"remaining = {remaining}\");\n"
"            if remaining == 9 {\n"
"                break;\n"
"            }\n"
"            if count == 2 {\n"
"                break 'counting_up;\n"
"            }\n"
"            remaining -= 1;\n"
"        }\n"
"\n"
"        count += 1;\n"
"    }\n"
"    println!(\"End count = {count}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:388
msgid ""
"The outer loop has the label `'counting_up`, and it will count up from 0 to "
"2.\n"
"The inner loop without a label counts down from 10 to 9. The first `break` "
"that\n"
"doesn‚Äôt specify a label will exit the inner loop only. The `break\n"
"'counting_up;` statement will exit the outer loop. This code prints:"
msgstr ""

#: src/ch03-05-control-flow.md:393
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running `target/debug/loops`\n"
"count = 0\n"
"remaining = 10\n"
"remaining = 9\n"
"count = 1\n"
"remaining = 10\n"
"remaining = 9\n"
"count = 2\n"
"remaining = 10\n"
"End count = 2\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:409
msgid "#### Conditional Loops with `while`"
msgstr ""

#: src/ch03-05-control-flow.md:411
msgid ""
"A program will often need to evaluate a condition within a loop. While the\n"
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the\n"
"program calls `break`, stopping the loop. It‚Äôs possible to implement "
"behavior\n"
"like this using a combination of `loop`, `if`, `else`, and `break`; you "
"could\n"
"try that now in a program, if you‚Äôd like. However, this pattern is so "
"common\n"
"that Rust has a built-in language construct for it, called a `while` loop. "
"In\n"
"Listing 3-3, we use `while` to loop the program three times, counting down "
"each\n"
"time, and then, after the loop, print a message and exit."
msgstr ""

#: src/ch03-05-control-flow.md:422
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut number = 3;\n"
"\n"
"    while number != 0 {\n"
"        println!(\"{number}!\");\n"
"\n"
"        number -= 1;\n"
"    }\n"
"\n"
"    println!(\"LIFTOFF!!!\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:436
msgid ""
"<span class=\"caption\">Listing 3-3: Using a `while` loop to run code while "
"a\n"
"condition holds true</span>"
msgstr ""

#: src/ch03-05-control-flow.md:439
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used\n"
"`loop`, `if`, `else`, and `break`, and it‚Äôs clearer. While a condition\n"
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""

#: src/ch03-05-control-flow.md:443
msgid "#### Looping Through a Collection with `for`"
msgstr ""

#: src/ch03-05-control-flow.md:445
msgid ""
"You can choose to use the `while` construct to loop over the elements of a\n"
"collection, such as an array. For example, the loop in Listing 3-4 prints "
"each\n"
"element in the array `a`."
msgstr ""

#: src/ch03-05-control-flow.md:451
msgid ""
"```rust\n"
"fn main() {\n"
"    let a = [10, 20, 30, 40, 50];\n"
"    let mut index = 0;\n"
"\n"
"    while index < 5 {\n"
"        println!(\"the value is: {}\", a[index]);\n"
"\n"
"        index += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:464
msgid ""
"<span class=\"caption\">Listing 3-4: Looping through each element of a "
"collection\n"
"using a `while` loop</span>"
msgstr ""

#: src/ch03-05-control-flow.md:467
msgid ""
"Here, the code counts up through the elements in the array. It starts at "
"index\n"
"`0`, and then loops until it reaches the final index in the array (that is,\n"
"when `index < 5` is no longer `true`). Running this code will print every\n"
"element in the array:"
msgstr ""

#: src/ch03-05-control-flow.md:472
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.32s\n"
"     Running `target/debug/loops`\n"
"the value is: 10\n"
"the value is: 20\n"
"the value is: 30\n"
"the value is: 40\n"
"the value is: 50\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:484
msgid ""
"All five array values appear in the terminal, as expected. Even though "
"`index`\n"
"will reach a value of `5` at some point, the loop stops executing before "
"trying\n"
"to fetch a sixth value from the array."
msgstr ""

#: src/ch03-05-control-flow.md:488
msgid ""
"However, this approach is error prone; we could cause the program to panic "
"if\n"
"the index value or test condition is incorrect. For example, if you changed "
"the\n"
"definition of the `a` array to have four elements but forgot to update the\n"
"condition to `while index < 4`, the code would panic. It‚Äôs also slow, "
"because\n"
"the compiler adds runtime code to perform the conditional check of whether "
"the\n"
"index is within the bounds of the array on every iteration through the loop."
msgstr ""

#: src/ch03-05-control-flow.md:495
msgid ""
"As a more concise alternative, you can use a `for` loop and execute some "
"code\n"
"for each item in a collection. A `for` loop looks like the code in Listing "
"3-5."
msgstr ""

#: src/ch03-05-control-flow.md:500
msgid ""
"```rust\n"
"fn main() {\n"
"    let a = [10, 20, 30, 40, 50];\n"
"\n"
"    for element in a {\n"
"        println!(\"the value is: {element}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:510
msgid ""
"<span class=\"caption\">Listing 3-5: Looping through each element of a "
"collection\n"
"using a `for` loop</span>"
msgstr ""

#: src/ch03-05-control-flow.md:513
msgid ""
"When we run this code, we‚Äôll see the same output as in Listing 3-4. More\n"
"importantly, we‚Äôve now increased the safety of the code and eliminated the\n"
"chance of bugs that might result from going beyond the end of the array or "
"not\n"
"going far enough and missing some items."
msgstr ""

#: src/ch03-05-control-flow.md:518
msgid ""
"Using the `for` loop, you wouldn‚Äôt need to remember to change any other code "
"if\n"
"you changed the number of values in the array, as you would with the method\n"
"used in Listing 3-4."
msgstr ""

#: src/ch03-05-control-flow.md:522
msgid ""
"The safety and conciseness of `for` loops make them the most commonly used "
"loop\n"
"construct in Rust. Even in situations in which you want to run some code a\n"
"certain number of times, as in the countdown example that used a `while` "
"loop\n"
"in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that\n"
"would be to use a `Range`, provided by the standard library, which "
"generates\n"
"all numbers in sequence starting from one number and ending before another\n"
"number."
msgstr ""

#: src/ch03-05-control-flow.md:530
msgid ""
"Here‚Äôs what the countdown would look like using a `for` loop and another "
"method\n"
"we‚Äôve not yet talked about, `rev`, to reverse the range:"
msgstr ""

#: src/ch03-05-control-flow.md:535
msgid ""
"```rust\n"
"fn main() {\n"
"    for number in (1..4).rev() {\n"
"        println!(\"{number}!\");\n"
"    }\n"
"    println!(\"LIFTOFF!!!\");\n"
"}\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:544
msgid "This code is a bit nicer, isn‚Äôt it?"
msgstr ""

#: src/ch03-05-control-flow.md:548
msgid ""
"You made it! This was a sizable chapter: you learned about variables, "
"scalar\n"
"and compound data types, functions, comments, `if` expressions, and loops! "
"To\n"
"practice with the concepts discussed in this chapter, try building programs "
"to\n"
"do the following:"
msgstr ""

#: src/ch03-05-control-flow.md:553
msgid ""
"* Convert temperatures between Fahrenheit and Celsius.\n"
"* Generate the *n*th Fibonacci number.\n"
"* Print the lyrics to the Christmas carol ‚ÄúThe Twelve Days of Christmas,‚Äù\n"
"  taking advantage of the repetition in the song."
msgstr ""

#: src/ch03-05-control-flow.md:558
msgid ""
"When you‚Äôre ready to move on, we‚Äôll talk about a concept in Rust that "
"*doesn‚Äôt*\n"
"commonly exist in other programming languages: ownership."
msgstr ""

#: src/ch04-00-understanding-ownership.md:1
msgid "# Understanding Ownership"
msgstr ""

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Ownership is Rust‚Äôs most unique feature and has deep implications for the "
"rest\n"
"of the language. It enables Rust to make memory safety guarantees without\n"
"needing a garbage collector, so it‚Äôs important to understand how ownership\n"
"works. In this chapter, we‚Äôll talk about ownership as well as several "
"related\n"
"features: borrowing, slices, and how Rust lays data out in memory."
msgstr ""

#: src/ch04-01-what-is-ownership.md:1
msgid "## What Is Ownership?"
msgstr ""

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"*Ownership* is a set of rules that govern how a Rust program manages "
"memory.\n"
"All programs have to manage the way they use a computer‚Äôs memory while "
"running.\n"
"Some languages have garbage collection that regularly looks for no-longer-"
"used\n"
"memory as the program runs; in other languages, the programmer must "
"explicitly\n"
"allocate and free the memory. Rust uses a third approach: memory is managed\n"
"through a system of ownership with a set of rules that the compiler checks. "
"If\n"
"any of the rules are violated, the program won‚Äôt compile. None of the "
"features\n"
"of ownership will slow down your program while it‚Äôs running."
msgstr ""

#: src/ch04-01-what-is-ownership.md:12
msgid ""
"Because ownership is a new concept for many programmers, it does take some "
"time\n"
"to get used to. The good news is that the more experienced you become with "
"Rust\n"
"and the rules of the ownership system, the easier you‚Äôll find it to "
"naturally\n"
"develop code that is safe and efficient. Keep at it!"
msgstr ""

#: src/ch04-01-what-is-ownership.md:17
msgid ""
"When you understand ownership, you‚Äôll have a solid foundation for "
"understanding\n"
"the features that make Rust unique. In this chapter, you‚Äôll learn ownership "
"by\n"
"working through some examples that focus on a very common data structure:\n"
"strings."
msgstr ""

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"> ### The Stack and the Heap\n"
">\n"
"> Many programming languages don‚Äôt require you to think about the stack and "
"the\n"
"> heap very often. But in a systems programming language like Rust, whether "
"a\n"
"> value is on the stack or the heap affects how the language behaves and "
"why\n"
"> you have to make certain decisions. Parts of ownership will be described "
"in\n"
"> relation to the stack and the heap later in this chapter, so here is a "
"brief\n"
"> explanation in preparation.\n"
">\n"
"> Both the stack and the heap are parts of memory available to your code to "
"use\n"
"> at runtime, but they are structured in different ways. The stack stores\n"
"> values in the order it gets them and removes the values in the opposite\n"
"> order. This is referred to as *last in, first out*. Think of a stack of\n"
"> plates: when you add more plates, you put them on top of the pile, and "
"when\n"
"> you need a plate, you take one off the top. Adding or removing plates "
"from\n"
"> the middle or bottom wouldn‚Äôt work as well! Adding data is called "
"*pushing\n"
"> onto the stack*, and removing data is called *popping off the stack*. All\n"
"> data stored on the stack must have a known, fixed size. Data with an "
"unknown\n"
"> size at compile time or a size that might change must be stored on the "
"heap\n"
"> instead.\n"
">\n"
"> The heap is less organized: when you put data on the heap, you request a\n"
"> certain amount of space. The memory allocator finds an empty spot in the "
"heap\n"
"> that is big enough, marks it as being in use, and returns a *pointer*, "
"which\n"
"> is the address of that location. This process is called *allocating on "
"the\n"
"> heap* and is sometimes abbreviated as just *allocating* (pushing values "
"onto\n"
"> the stack is not considered allocating). Because the pointer to the heap "
"is a\n"
"> known, fixed size, you can store the pointer on the stack, but when you "
"want\n"
"> the actual data, you must follow the pointer. Think of being seated at a\n"
"> restaurant. When you enter, you state the number of people in your group, "
"and\n"
"> the host finds an empty table that fits everyone and leads you there. If\n"
"> someone in your group comes late, they can ask where you‚Äôve been seated "
"to\n"
"> find you.\n"
">\n"
"> Pushing to the stack is faster than allocating on the heap because the\n"
"> allocator never has to search for a place to store new data; that location "
"is\n"
"> always at the top of the stack. Comparatively, allocating space on the "
"heap\n"
"> requires more work because the allocator must first find a big enough "
"space\n"
"> to hold the data and then perform bookkeeping to prepare for the next\n"
"> allocation.\n"
">\n"
"> Accessing data in the heap is slower than accessing data on the stack "
"because\n"
"> you have to follow a pointer to get there. Contemporary processors are "
"faster\n"
"> if they jump around less in memory. Continuing the analogy, consider a "
"server\n"
"> at a restaurant taking orders from many tables. It‚Äôs most efficient to "
"get\n"
"> all the orders at one table before moving on to the next table. Taking an\n"
"> order from table A, then an order from table B, then one from A again, "
"and\n"
"> then one from B again would be a much slower process. By the same token, "
"a\n"
"> processor can do its job better if it works on data that‚Äôs close to other\n"
"> data (as it is on the stack) rather than farther away (as it can be on "
"the\n"
"> heap).\n"
">\n"
"> When your code calls a function, the values passed into the function\n"
"> (including, potentially, pointers to data on the heap) and the function‚Äôs\n"
"> local variables get pushed onto the stack. When the function is over, "
"those\n"
"> values get popped off the stack.\n"
">\n"
"> Keeping track of what parts of code are using what data on the heap,\n"
"> minimizing the amount of duplicate data on the heap, and cleaning up "
"unused\n"
"> data on the heap so you don‚Äôt run out of space are all problems that "
"ownership\n"
"> addresses. Once you understand ownership, you won‚Äôt need to think about "
"the\n"
"> stack and the heap very often, but knowing that the main purpose of "
"ownership\n"
"> is to manage heap data can help explain why it works the way it does."
msgstr ""

#: src/ch04-01-what-is-ownership.md:86
msgid "### Ownership Rules"
msgstr ""

#: src/ch04-01-what-is-ownership.md:88
msgid ""
"First, let‚Äôs take a look at the ownership rules. Keep these rules in mind as "
"we\n"
"work through the examples that illustrate them:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:91
msgid ""
"* Each value in Rust has an *owner*.\n"
"* There can only be one owner at a time.\n"
"* When the owner goes out of scope, the value will be dropped."
msgstr ""

#: src/ch04-01-what-is-ownership.md:95
msgid "### Variable Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:97
msgid ""
"Now that we‚Äôre past basic Rust syntax, we won‚Äôt include all the `fn main() "
"{`\n"
"code in examples, so if you‚Äôre following along, make sure to put the "
"following\n"
"examples inside a `main` function manually. As a result, our examples will "
"be a\n"
"bit more concise, letting us focus on the actual details rather than\n"
"boilerplate code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:103
msgid ""
"As a first example of ownership, we‚Äôll look at the *scope* of some "
"variables. A\n"
"scope is the range within a program for which an item is valid. Take the\n"
"following variable:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:107
msgid ""
"```rust\n"
"let s = \"hello\";\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:111
msgid ""
"The variable `s` refers to a string literal, where the value of the string "
"is\n"
"hardcoded into the text of our program. The variable is valid from the point "
"at\n"
"which it‚Äôs declared until the end of the current *scope*. Listing 4-1 shows "
"a\n"
"program with comments annotating where the variable `s` would be valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:116
msgid ""
"```rust\n"
"# fn main() {\n"
"    {                      // s is not valid here, it‚Äôs not yet declared\n"
"        let s = \"hello\";   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer "
"valid\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:126
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it "
"is\n"
"valid</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:129
msgid "In other words, there are two important points in time here:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:131
msgid ""
"* When `s` comes *into* scope, it is valid.\n"
"* It remains valid until it goes *out of* scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:134
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is\n"
"similar to that in other programming languages. Now we‚Äôll build on top of "
"this\n"
"understanding by introducing the `String` type."
msgstr ""

#: src/ch04-01-what-is-ownership.md:138
msgid "### The `String` Type"
msgstr ""

#: src/ch04-01-what-is-ownership.md:140
msgid ""
"To illustrate the rules of ownership, we need a data type that is more "
"complex\n"
"than those we covered in the [‚ÄúData Types‚Äù][data-types]<!-- ignore --> "
"section\n"
"of Chapter 3. The types covered previously are of a known size, can be "
"stored\n"
"on the stack and popped off the stack when their scope is over, and can be\n"
"quickly and trivially copied to make a new, independent instance if another\n"
"part of code needs to use the same value in a different scope. But we want "
"to\n"
"look at data that is stored on the heap and explore how Rust knows when to\n"
"clean up that data, and the `String` type is a great example."
msgstr ""

#: src/ch04-01-what-is-ownership.md:149
msgid ""
"We‚Äôll concentrate on the parts of `String` that relate to ownership. These\n"
"aspects also apply to other complex data types, whether they are provided "
"by\n"
"the standard library or created by you. We‚Äôll discuss `String` in more depth "
"in\n"
"[Chapter 8][ch8]<!-- ignore -->."
msgstr ""

#: src/ch04-01-what-is-ownership.md:154
msgid ""
"We‚Äôve already seen string literals, where a string value is hardcoded into "
"our\n"
"program. String literals are convenient, but they aren‚Äôt suitable for every\n"
"situation in which we may want to use text. One reason is that they‚Äôre\n"
"immutable. Another is that not every string value can be known when we "
"write\n"
"our code: for example, what if we want to take user input and store it? For\n"
"these situations, Rust has a second string type, `String`. This type "
"manages\n"
"data allocated on the heap and as such is able to store an amount of text "
"that\n"
"is unknown to us at compile time. You can create a `String` from a string\n"
"literal using the `from` function, like so:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:164
msgid ""
"```rust\n"
"let s = String::from(\"hello\");\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"The double colon `::` operator allows us to namespace this particular "
"`from`\n"
"function under the `String` type rather than using some sort of name like\n"
"`string_from`. We‚Äôll discuss this syntax more in the [‚ÄúMethod\n"
"Syntax‚Äù][method-syntax]<!-- ignore --> section of Chapter 5, and when we "
"talk\n"
"about namespacing with modules in [‚ÄúPaths for Referring to an Item in the\n"
"Module Tree‚Äù][paths-module-tree]<!-- ignore --> in Chapter 7."
msgstr ""

#: src/ch04-01-what-is-ownership.md:175
msgid "This kind of string *can* be mutated:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:177
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    s.push_str(\", world!\"); // push_str() appends a literal to a String\n"
"\n"
"    println!(\"{}\", s); // This will print `hello, world!`\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:187
msgid ""
"So, what‚Äôs the difference here? Why can `String` be mutated but literals\n"
"cannot? The difference is in how these two types deal with memory."
msgstr ""

#: src/ch04-01-what-is-ownership.md:190
msgid "### Memory and Allocation"
msgstr ""

#: src/ch04-01-what-is-ownership.md:192
msgid ""
"In the case of a string literal, we know the contents at compile time, so "
"the\n"
"text is hardcoded directly into the final executable. This is why string\n"
"literals are fast and efficient. But these properties only come from the "
"string\n"
"literal‚Äôs immutability. Unfortunately, we can‚Äôt put a blob of memory into "
"the\n"
"binary for each piece of text whose size is unknown at compile time and "
"whose\n"
"size might change while running the program."
msgstr ""

#: src/ch04-01-what-is-ownership.md:199
msgid ""
"With the `String` type, in order to support a mutable, growable piece of "
"text,\n"
"we need to allocate an amount of memory on the heap, unknown at compile "
"time,\n"
"to hold the contents. This means:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:203
msgid ""
"* The memory must be requested from the memory allocator at runtime.\n"
"* We need a way of returning this memory to the allocator when we‚Äôre done "
"with\n"
"  our `String`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:207
msgid ""
"That first part is done by us: when we call `String::from`, its "
"implementation\n"
"requests the memory it needs. This is pretty much universal in programming\n"
"languages."
msgstr ""

#: src/ch04-01-what-is-ownership.md:211
msgid ""
"However, the second part is different. In languages with a *garbage "
"collector\n"
"(GC)*, the GC keeps track of and cleans up memory that isn‚Äôt being used\n"
"anymore, and we don‚Äôt need to think about it. In most languages without a "
"GC,\n"
"it‚Äôs our responsibility to identify when memory is no longer being used and "
"to\n"
"call code to explicitly free it, just as we did to request it. Doing this\n"
"correctly has historically been a difficult programming problem. If we "
"forget,\n"
"we‚Äôll waste memory. If we do it too early, we‚Äôll have an invalid variable. "
"If\n"
"we do it twice, that‚Äôs a bug too. We need to pair exactly one `allocate` "
"with\n"
"exactly one `free`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:221
msgid ""
"Rust takes a different path: the memory is automatically returned once the\n"
"variable that owns it goes out of scope. Here‚Äôs a version of our scope "
"example\n"
"from Listing 4-1 using a `String` instead of a string literal:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:225
msgid ""
"```rust\n"
"# fn main() {\n"
"    {\n"
"        let s = String::from(\"hello\"); // s is valid from this point "
"forward\n"
"\n"
"        // do stuff with s\n"
"    }                                  // this scope is now over, and s is "
"no\n"
"                                       // longer valid\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:236
msgid ""
"There is a natural point at which we can return the memory our `String` "
"needs\n"
"to the allocator: when `s` goes out of scope. When a variable goes out of\n"
"scope, Rust calls a special function for us. This function is called\n"
"[`drop`][drop]<!-- ignore -->, and it‚Äôs where the author of `String` can "
"put\n"
"the code to return the memory. Rust calls `drop` automatically at the "
"closing\n"
"curly bracket."
msgstr ""

#: src/ch04-01-what-is-ownership.md:243
msgid ""
"> Note: In C++, this pattern of deallocating resources at the end of an "
"item‚Äôs\n"
"> lifetime is sometimes called *Resource Acquisition Is Initialization "
"(RAII)*.\n"
"> The `drop` function in Rust will be familiar to you if you‚Äôve used RAII\n"
"> patterns."
msgstr ""

#: src/ch04-01-what-is-ownership.md:248
msgid ""
"This pattern has a profound impact on the way Rust code is written. It may "
"seem\n"
"simple right now, but the behavior of code can be unexpected in more\n"
"complicated situations when we want to have multiple variables use the data\n"
"we‚Äôve allocated on the heap. Let‚Äôs explore some of those situations now."
msgstr ""

#: src/ch04-01-what-is-ownership.md:254
msgid "<a id=\"ways-variables-and-data-interact-move\"></a>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:256
msgid "#### Variables and Data Interacting with Move"
msgstr ""

#: src/ch04-01-what-is-ownership.md:258
msgid ""
"Multiple variables can interact with the same data in different ways in "
"Rust.\n"
"Let‚Äôs look at an example using an integer in Listing 4-2."
msgstr ""

#: src/ch04-01-what-is-ownership.md:261
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 5;\n"
"    let y = x;\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:268
msgid ""
"<span class=\"caption\">Listing 4-2: Assigning the integer value of variable "
"`x`\n"
"to `y`</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:271
msgid ""
"We can probably guess what this is doing: ‚Äúbind the value `5` to `x`; then "
"make\n"
"a copy of the value in `x` and bind it to `y`.‚Äù We now have two variables, "
"`x`\n"
"and `y`, and both equal `5`. This is indeed what is happening, because "
"integers\n"
"are simple values with a known, fixed size, and these two `5` values are "
"pushed\n"
"onto the stack."
msgstr ""

#: src/ch04-01-what-is-ownership.md:277
msgid "Now let‚Äôs look at the `String` version:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:279
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"    let s2 = s1;\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:286
msgid ""
"This looks very similar, so we might assume that the way it works would be "
"the\n"
"same: that is, the second line would make a copy of the value in `s1` and "
"bind\n"
"it to `s2`. But this isn‚Äôt quite what happens."
msgstr ""

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"Take a look at Figure 4-1 to see what is happening to `String` under the\n"
"covers. A `String` is made up of three parts, shown on the left: a pointer "
"to\n"
"the memory that holds the contents of the string, a length, and a capacity.\n"
"This group of data is stored on the stack. On the right is the memory on "
"the\n"
"heap that holds the contents."
msgstr ""

#: src/ch04-01-what-is-ownership.md:296
msgid ""
"<img alt=\"Two tables: the first table contains the representation of s1 on "
"the\n"
"stack, consisting of its length (5), capacity (5), and a pointer to the "
"first\n"
"value in the second table. The second table contains the representation of "
"the\n"
"string data on the heap, byte by byte.\" src=\"img/trpl04-01.svg\" "
"class=\"center\"\n"
"style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:302
msgid ""
"<span class=\"caption\">Figure 4-1: Representation in memory of a `String`\n"
"holding the value `\"hello\"` bound to `s1`</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:305
msgid ""
"The length is how much memory, in bytes, the contents of the `String` are\n"
"currently using. The capacity is the total amount of memory, in bytes, that "
"the\n"
"`String` has received from the allocator. The difference between length and\n"
"capacity matters, but not in this context, so for now, it‚Äôs fine to ignore "
"the\n"
"capacity."
msgstr ""

#: src/ch04-01-what-is-ownership.md:311
msgid ""
"When we assign `s1` to `s2`, the `String` data is copied, meaning we copy "
"the\n"
"pointer, the length, and the capacity that are on the stack. We do not copy "
"the\n"
"data on the heap that the pointer refers to. In other words, the data\n"
"representation in memory looks like Figure 4-2."
msgstr ""

#: src/ch04-01-what-is-ownership.md:316
msgid ""
"<img alt=\"Three tables: tables s1 and s2 representing those strings on the\n"
"stack, respectively, and both pointing to the same string data on the heap."
"\"\n"
"src=\"img/trpl04-02.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:320
msgid ""
"<span class=\"caption\">Figure 4-2: Representation in memory of the variable "
"`s2`\n"
"that has a copy of the pointer, length, and capacity of `s1`</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:323
msgid ""
"The representation does *not* look like Figure 4-3, which is what memory "
"would\n"
"look like if Rust instead copied the heap data as well. If Rust did this, "
"the\n"
"operation `s2 = s1` could be very expensive in terms of runtime performance "
"if\n"
"the data on the heap were large."
msgstr ""

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"<img alt=\"Four tables: two tables representing the stack data for s1 and "
"s2,\n"
"and each points to its own copy of string data on the heap.\"\n"
"src=\"img/trpl04-03.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:332
msgid ""
"<span class=\"caption\">Figure 4-3: Another possibility for what `s2 = s1` "
"might\n"
"do if Rust copied the heap data as well</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:335
msgid ""
"Earlier, we said that when a variable goes out of scope, Rust automatically\n"
"calls the `drop` function and cleans up the heap memory for that variable. "
"But\n"
"Figure 4-2 shows both data pointers pointing to the same location. This is "
"a\n"
"problem: when `s2` and `s1` go out of scope, they will both try to free the\n"
"same memory. This is known as a *double free* error and is one of the "
"memory\n"
"safety bugs we mentioned previously. Freeing memory twice can lead to "
"memory\n"
"corruption, which can potentially lead to security vulnerabilities."
msgstr ""

#: src/ch04-01-what-is-ownership.md:343
msgid ""
"To ensure memory safety, after the line `let s2 = s1;`, Rust considers `s1` "
"as\n"
"no longer valid. Therefore, Rust doesn‚Äôt need to free anything when `s1` "
"goes\n"
"out of scope. Check out what happens when you try to use `s1` after `s2` is\n"
"created; it won‚Äôt work:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:348
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"    let s2 = s1;\n"
"\n"
"    println!(\"{}, world!\", s1);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:357
msgid ""
"You‚Äôll get an error like this because Rust prevents you from using the\n"
"invalidated reference:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:360
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0382]: borrow of moved value: `s1`\n"
" --> src/main.rs:5:28\n"
"  |\n"
"2 |     let s1 = String::from(\"hello\");\n"
"  |         -- move occurs because `s1` has type `String`, which does not "
"implement the `Copy` trait\n"
"3 |     let s2 = s1;\n"
"  |              -- value moved here\n"
"4 |\n"
"5 |     println!(\"{}, world!\", s1);\n"
"  |                            ^^ value borrowed here after move\n"
"  |\n"
"  = note: this error originates in the macro `$crate::format_args_nl` which "
"comes from the expansion of the macro `println` (in Nightly builds, run with "
"-Z macro-backtrace for more info)\n"
"help: consider cloning the value if the performance cost is acceptable\n"
"  |\n"
"3 |     let s2 = s1.clone();\n"
"  |                ++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:384
msgid ""
"If you‚Äôve heard the terms *shallow copy* and *deep copy* while working with\n"
"other languages, the concept of copying the pointer, length, and capacity\n"
"without copying the data probably sounds like making a shallow copy. But\n"
"because Rust also invalidates the first variable, instead of being called a\n"
"shallow copy, it‚Äôs known as a *move*. In this example, we would say that "
"`s1`\n"
"was *moved* into `s2`. So, what actually happens is shown in Figure 4-4."
msgstr ""

#: src/ch04-01-what-is-ownership.md:391
msgid ""
"<img alt=\"Three tables: tables s1 and s2 representing those strings on the\n"
"stack, respectively, and both pointing to the same string data on the heap.\n"
"Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used "
"to\n"
"access the heap data.\" src=\"img/trpl04-04.svg\" class=\"center\" "
"style=\"width:\n"
"50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:397
msgid ""
"<span class=\"caption\">Figure 4-4: Representation in memory after `s1` has "
"been\n"
"invalidated</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:400
msgid ""
"That solves our problem! With only `s2` valid, when it goes out of scope it\n"
"alone will free the memory, and we‚Äôre done."
msgstr ""

#: src/ch04-01-what-is-ownership.md:403
msgid ""
"In addition, there‚Äôs a design choice that‚Äôs implied by this: Rust will "
"never\n"
"automatically create ‚Äúdeep‚Äù copies of your data. Therefore, any *automatic*\n"
"copying can be assumed to be inexpensive in terms of runtime performance."
msgstr ""

#: src/ch04-01-what-is-ownership.md:408
msgid "<a id=\"ways-variables-and-data-interact-clone\"></a>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:410
msgid "#### Variables and Data Interacting with Clone"
msgstr ""

#: src/ch04-01-what-is-ownership.md:412
msgid ""
"If we *do* want to deeply copy the heap data of the `String`, not just the\n"
"stack data, we can use a common method called `clone`. We‚Äôll discuss method\n"
"syntax in Chapter 5, but because methods are a common feature in many\n"
"programming languages, you‚Äôve probably seen them before."
msgstr ""

#: src/ch04-01-what-is-ownership.md:417
msgid "Here‚Äôs an example of the `clone` method in action:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:419
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"    let s2 = s1.clone();\n"
"\n"
"    println!(\"s1 = {}, s2 = {}\", s1, s2);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:428
msgid ""
"This works just fine and explicitly produces the behavior shown in Figure "
"4-3,\n"
"where the heap data *does* get copied."
msgstr ""

#: src/ch04-01-what-is-ownership.md:431
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being\n"
"executed and that code may be expensive. It‚Äôs a visual indicator that "
"something\n"
"different is going on."
msgstr ""

#: src/ch04-01-what-is-ownership.md:435
msgid "#### Stack-Only Data: Copy"
msgstr ""

#: src/ch04-01-what-is-ownership.md:437
msgid ""
"There‚Äôs another wrinkle we haven‚Äôt talked about yet. This code using\n"
"integers‚Äîpart of which was shown in Listing 4-2‚Äîworks and is valid:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:440
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 5;\n"
"    let y = x;\n"
"\n"
"    println!(\"x = {}, y = {}\", x, y);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:449
msgid ""
"But this code seems to contradict what we just learned: we don‚Äôt have a call "
"to\n"
"`clone`, but `x` is still valid and wasn‚Äôt moved into `y`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:452
msgid ""
"The reason is that types such as integers that have a known size at compile\n"
"time are stored entirely on the stack, so copies of the actual values are "
"quick\n"
"to make. That means there‚Äôs no reason we would want to prevent `x` from "
"being\n"
"valid after we create the variable `y`. In other words, there‚Äôs no "
"difference\n"
"between deep and shallow copying here, so calling `clone` wouldn‚Äôt do "
"anything\n"
"different from the usual shallow copying, and we can leave it out."
msgstr ""

#: src/ch04-01-what-is-ownership.md:459
msgid ""
"Rust has a special annotation called the `Copy` trait that we can place on\n"
"types that are stored on the stack, as integers are (we‚Äôll talk more about\n"
"traits in [Chapter 10][traits]<!-- ignore -->). If a type implements the "
"`Copy`\n"
"trait, variables that use it do not move, but rather are trivially copied,\n"
"making them still valid after assignment to another variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:465
msgid ""
"Rust won‚Äôt let us annotate a type with `Copy` if the type, or any of its "
"parts,\n"
"has implemented the `Drop` trait. If the type needs something special to "
"happen\n"
"when the value goes out of scope and we add the `Copy` annotation to that "
"type,\n"
"we‚Äôll get a compile-time error. To learn about how to add the `Copy` "
"annotation\n"
"to your type to implement the trait, see [‚ÄúDerivable\n"
"Traits‚Äù][derivable-traits]<!-- ignore --> in Appendix C."
msgstr ""

#: src/ch04-01-what-is-ownership.md:472
msgid ""
"So, what types implement the `Copy` trait? You can check the documentation "
"for\n"
"the given type to be sure, but as a general rule, any group of simple "
"scalar\n"
"values can implement `Copy`, and nothing that requires allocation or is "
"some\n"
"form of resource can implement `Copy`. Here are some of the types that\n"
"implement `Copy`:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:478
msgid ""
"* All the integer types, such as `u32`.\n"
"* The Boolean type, `bool`, with values `true` and `false`.\n"
"* All the floating-point types, such as `f64`.\n"
"* The character type, `char`.\n"
"* Tuples, if they only contain types that also implement `Copy`. For "
"example,\n"
"  `(i32, i32)` implements `Copy`, but `(i32, String)` does not."
msgstr ""

#: src/ch04-01-what-is-ownership.md:485
msgid "### Ownership and Functions"
msgstr ""

#: src/ch04-01-what-is-ownership.md:487
msgid ""
"The mechanics of passing a value to a function are similar to those when\n"
"assigning a value to a variable. Passing a variable to a function will move "
"or\n"
"copy, just as assignment does. Listing 4-3 has an example with some "
"annotations\n"
"showing where variables go into and out of scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:494
msgid ""
"```rust\n"
"fn main() {\n"
"    let s = String::from(\"hello\");  // s comes into scope\n"
"\n"
"    takes_ownership(s);             // s's value moves into the function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5;                      // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but i32 is Copy, so it's okay to "
"still\n"
"                                    // use x afterward\n"
"\n"
"} // Here, x goes out of scope, then s. But because s's value was moved, "
"nothing\n"
"  // special happens.\n"
"\n"
"fn takes_ownership(some_string: String) { // some_string comes into scope\n"
"    println!(\"{}\", some_string);\n"
"} // Here, some_string goes out of scope and `drop` is called. The backing\n"
"  // memory is freed.\n"
"\n"
"fn makes_copy(some_integer: i32) { // some_integer comes into scope\n"
"    println!(\"{}\", some_integer);\n"
"} // Here, some_integer goes out of scope. Nothing special happens.\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:520
msgid ""
"<span class=\"caption\">Listing 4-3: Functions with ownership and scope\n"
"annotated</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:523
msgid ""
"If we tried to use `s` after the call to `takes_ownership`, Rust would throw "
"a\n"
"compile-time error. These static checks protect us from mistakes. Try "
"adding\n"
"code to `main` that uses `s` and `x` to see where you can use them and "
"where\n"
"the ownership rules prevent you from doing so."
msgstr ""

#: src/ch04-01-what-is-ownership.md:528
msgid "### Return Values and Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:530
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example "
"of a\n"
"function that returns some value, with similar annotations as those in "
"Listing\n"
"4-3."
msgstr ""

#: src/ch04-01-what-is-ownership.md:536
msgid ""
"```rust\n"
"fn main() {\n"
"    let s1 = gives_ownership();         // gives_ownership moves its return\n"
"                                        // value into s1\n"
"\n"
"    let s2 = String::from(\"hello\");     // s2 comes into scope\n"
"\n"
"    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n"
"                                        // takes_and_gives_back, which also\n"
"                                        // moves its return value into s3\n"
"} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n"
"  // happens. s1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> String {             // gives_ownership will move "
"its\n"
"                                             // return value into the "
"function\n"
"                                             // that calls it\n"
"\n"
"    let some_string = String::from(\"yours\"); // some_string comes into "
"scope\n"
"\n"
"    some_string                              // some_string is returned and\n"
"                                             // moves out to the calling\n"
"                                             // function\n"
"}\n"
"\n"
"// This function takes a String and returns one\n"
"fn takes_and_gives_back(a_string: String) -> String { // a_string comes "
"into\n"
"                                                      // scope\n"
"\n"
"    a_string  // a_string is returned and moves out to the calling function\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:568
msgid ""
"<span class=\"caption\">Listing 4-4: Transferring ownership of return\n"
"values</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:571
msgid ""
"The ownership of a variable follows the same pattern every time: assigning "
"a\n"
"value to another variable moves it. When a variable that includes data on "
"the\n"
"heap goes out of scope, the value will be cleaned up by `drop` unless "
"ownership\n"
"of the data has been moved to another variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:576
msgid ""
"While this works, taking ownership and then returning ownership with every\n"
"function is a bit tedious. What if we want to let a function use a value "
"but\n"
"not take ownership? It‚Äôs quite annoying that anything we pass in also needs "
"to\n"
"be passed back if we want to use it again, in addition to any data "
"resulting\n"
"from the body of the function that we might want to return as well."
msgstr ""

#: src/ch04-01-what-is-ownership.md:582
msgid ""
"Rust does let us return multiple values using a tuple, as shown in Listing "
"4-5."
msgstr ""

#: src/ch04-01-what-is-ownership.md:586
msgid ""
"```rust\n"
"fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"\n"
"    let (s2, len) = calculate_length(s1);\n"
"\n"
"    println!(\"The length of '{}' is {}.\", s2, len);\n"
"}\n"
"\n"
"fn calculate_length(s: String) -> (String, usize) {\n"
"    let length = s.len(); // len() returns the length of a String\n"
"\n"
"    (s, length)\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:602
msgid ""
"<span class=\"caption\">Listing 4-5: Returning ownership of parameters</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:604
msgid ""
"But this is too much ceremony and a lot of work for a concept that should "
"be\n"
"common. Luckily for us, Rust has a feature for using a value without\n"
"transferring ownership, called *references*."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:1
msgid "## References and Borrowing"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:3
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the\n"
"`String` to the calling function so we can still use the `String` after the\n"
"call to `calculate_length`, because the `String` was moved into\n"
"`calculate_length`. Instead, we can provide a reference to the `String` "
"value.\n"
"A *reference* is like a pointer in that it‚Äôs an address we can follow to "
"access\n"
"the data stored at that address; that data is owned by some other variable.\n"
"Unlike a pointer, a reference is guaranteed to point to a valid value of a\n"
"particular type for the life of that reference."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:12
msgid ""
"Here is how you would define and use a `calculate_length` function that has "
"a\n"
"reference to an object as a parameter instead of taking ownership of the "
"value:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:17
msgid ""
"```rust\n"
"fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"\n"
"    let len = calculate_length(&s1);\n"
"\n"
"    println!(\"The length of '{}' is {}.\", s1, len);\n"
"}\n"
"\n"
"fn calculate_length(s: &String) -> usize {\n"
"    s.len()\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:31
msgid ""
"First, notice that all the tuple code in the variable declaration and the\n"
"function return value is gone. Second, note that we pass `&s1` into\n"
"`calculate_length` and, in its definition, we take `&String` rather than\n"
"`String`. These ampersands represent *references*, and they allow you to "
"refer\n"
"to some value without taking ownership of it. Figure 4-5 depicts this "
"concept."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:37
msgid ""
"<img alt=\"Three tables: the table for s contains only a pointer to the "
"table\n"
"for s1. The table for s1 contains the stack data for s1 and points to the\n"
"string data on the heap.\" src=\"img/trpl04-05.svg\" class=\"center\" />"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:41
msgid ""
"<span class=\"caption\">Figure 4-5: A diagram of `&String s` pointing at "
"`String\n"
"s1`</span>"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:44
msgid ""
"> Note: The opposite of referencing by using `&` is *dereferencing*, which "
"is\n"
"> accomplished with the dereference operator, `*`. We‚Äôll see some uses of "
"the\n"
"> dereference operator in Chapter 8 and discuss details of dereferencing in\n"
"> Chapter 15."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:49
msgid "Let‚Äôs take a closer look at the function call here:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:51
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"\n"
"    let len = calculate_length(&s1);\n"
"# \n"
"#     println!(\"The length of '{}' is {}.\", s1, len);\n"
"# }\n"
"# \n"
"# fn calculate_length(s: &String) -> usize {\n"
"#     s.len()\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:65
msgid ""
"The `&s1` syntax lets us create a reference that *refers* to the value of "
"`s1`\n"
"but does not own it. Because it does not own it, the value it points to "
"will\n"
"not be dropped when the reference stops being used."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:69
msgid ""
"Likewise, the signature of the function uses `&` to indicate that the type "
"of\n"
"the parameter `s` is a reference. Let‚Äôs add some explanatory annotations:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:72
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let s1 = String::from(\"hello\");\n"
"# \n"
"#     let len = calculate_length(&s1);\n"
"# \n"
"#     println!(\"The length of '{}' is {}.\", s1, len);\n"
"# }\n"
"# \n"
"fn calculate_length(s: &String) -> usize { // s is a reference to a String\n"
"    s.len()\n"
"} // Here, s goes out of scope. But because it does not have ownership of "
"what\n"
"  // it refers to, it is not dropped.\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:87
msgid ""
"The scope in which the variable `s` is valid is the same as any function\n"
"parameter‚Äôs scope, but the value pointed to by the reference is not dropped\n"
"when `s` stops being used, because `s` doesn‚Äôt have ownership. When "
"functions\n"
"have references as parameters instead of the actual values, we won‚Äôt need "
"to\n"
"return the values in order to give back ownership, because we never had\n"
"ownership."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:94
msgid ""
"We call the action of creating a reference *borrowing*. As in real life, if "
"a\n"
"person owns something, you can borrow it from them. When you‚Äôre done, you "
"have\n"
"to give it back. You don‚Äôt own it."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:98
msgid ""
"So, what happens if we try to modify something we‚Äôre borrowing? Try the code "
"in\n"
"Listing 4-6. Spoiler alert: it doesn‚Äôt work!"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:103
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"\n"
"    change(&s);\n"
"}\n"
"\n"
"fn change(some_string: &String) {\n"
"    some_string.push_str(\", world\");\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:115
msgid ""
"<span class=\"caption\">Listing 4-6: Attempting to modify a borrowed value</"
"span>"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:117
#: src/ch04-02-references-and-borrowing.md:178
#: src/ch04-02-references-and-borrowing.md:249
#: src/ch04-02-references-and-borrowing.md:335
msgid "Here‚Äôs the error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:119
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` "
"reference\n"
" --> src/main.rs:8:5\n"
"  |\n"
"7 | fn change(some_string: &String) {\n"
"  |                        ------- help: consider changing this to be a "
"mutable reference: `&mut String`\n"
"8 |     some_string.push_str(\", world\");\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so "
"the data it refers to cannot be borrowed as mutable\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:134
msgid ""
"Just as variables are immutable by default, so are references. We‚Äôre not\n"
"allowed to modify something we have a reference to."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:137
msgid "### Mutable References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:139
msgid ""
"We can fix the code from Listing 4-6 to allow us to modify a borrowed value\n"
"with just a few small tweaks that use, instead, a *mutable reference*:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:144
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    change(&mut s);\n"
"}\n"
"\n"
"fn change(some_string: &mut String) {\n"
"    some_string.push_str(\", world\");\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:156
msgid ""
"First we change `s` to be `mut`. Then we create a mutable reference with "
"`&mut\n"
"s` where we call the `change` function, and update the function signature "
"to\n"
"accept a mutable reference with `some_string: &mut String`. This makes it "
"very\n"
"clear that the `change` function will mutate the value it borrows."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:161
msgid ""
"Mutable references have one big restriction: if you have a mutable reference "
"to\n"
"a value, you can have no other references to that value. This code that\n"
"attempts to create two mutable references to `s` will fail:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:167
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    let r1 = &mut s;\n"
"    let r2 = &mut s;\n"
"\n"
"    println!(\"{}, {}\", r1, r2);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:180
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0499]: cannot borrow `s` as mutable more than once at a time\n"
" --> src/main.rs:5:14\n"
"  |\n"
"4 |     let r1 = &mut s;\n"
"  |              ------ first mutable borrow occurs here\n"
"5 |     let r2 = &mut s;\n"
"  |              ^^^^^^ second mutable borrow occurs here\n"
"6 |\n"
"7 |     println!(\"{}, {}\", r1, r2);\n"
"  |                        -- first borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0499`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:198
msgid ""
"This error says that this code is invalid because we cannot borrow `s` as\n"
"mutable more than once at a time. The first mutable borrow is in `r1` and "
"must\n"
"last until it‚Äôs used in the `println!`, but between the creation of that\n"
"mutable reference and its usage, we tried to create another mutable "
"reference\n"
"in `r2` that borrows the same data as `r1`."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:204
msgid ""
"The restriction preventing multiple mutable references to the same data at "
"the\n"
"same time allows for mutation but in a very controlled fashion. It‚Äôs "
"something\n"
"that new Rustaceans struggle with because most languages let you mutate\n"
"whenever you‚Äôd like. The benefit of having this restriction is that Rust "
"can\n"
"prevent data races at compile time. A *data race* is similar to a race\n"
"condition and happens when these three behaviors occur:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:211
msgid ""
"* Two or more pointers access the same data at the same time.\n"
"* At least one of the pointers is being used to write to the data.\n"
"* There‚Äôs no mechanism being used to synchronize access to the data."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:215
msgid ""
"Data races cause undefined behavior and can be difficult to diagnose and "
"fix\n"
"when you‚Äôre trying to track them down at runtime; Rust prevents this problem "
"by\n"
"refusing to compile code with data races!"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:219
msgid ""
"As always, we can use curly brackets to create a new scope, allowing for\n"
"multiple mutable references, just not *simultaneous* ones:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:222
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    {\n"
"        let r1 = &mut s;\n"
"    } // r1 goes out of scope here, so we can make a new reference with no "
"problems.\n"
"\n"
"    let r2 = &mut s;\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:234
msgid ""
"Rust enforces a similar rule for combining mutable and immutable "
"references.\n"
"This code results in an error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:237
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    let r1 = &s; // no problem\n"
"    let r2 = &s; // no problem\n"
"    let r3 = &mut s; // BIG PROBLEM\n"
"\n"
"    println!(\"{}, {}, and {}\", r1, r2, r3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:251
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0502]: cannot borrow `s` as mutable because it is also borrowed as "
"immutable\n"
" --> src/main.rs:6:14\n"
"  |\n"
"4 |     let r1 = &s; // no problem\n"
"  |              -- immutable borrow occurs here\n"
"5 |     let r2 = &s; // no problem\n"
"6 |     let r3 = &mut s; // BIG PROBLEM\n"
"  |              ^^^^^^ mutable borrow occurs here\n"
"7 |\n"
"8 |     println!(\"{}, {}, and {}\", r1, r2, r3);\n"
"  |                                -- immutable borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:270
msgid ""
"Whew! We *also* cannot have a mutable reference while we have an immutable "
"one\n"
"to the same value."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:273
msgid ""
"Users of an immutable reference don‚Äôt expect the value to suddenly change "
"out\n"
"from under them! However, multiple immutable references are allowed because "
"no\n"
"one who is just reading the data has the ability to affect anyone else‚Äôs\n"
"reading of the data."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:278
msgid ""
"Note that a reference‚Äôs scope starts from where it is introduced and "
"continues\n"
"through the last time that reference is used. For instance, this code will\n"
"compile because the last usage of the immutable references, the `println!`,\n"
"occurs before the mutable reference is introduced:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:283
msgid ""
"```rust,edition2021\n"
"# fn main() {\n"
"    let mut s = String::from(\"hello\");\n"
"\n"
"    let r1 = &s; // no problem\n"
"    let r2 = &s; // no problem\n"
"    println!(\"{} and {}\", r1, r2);\n"
"    // variables r1 and r2 will not be used after this point\n"
"\n"
"    let r3 = &mut s; // no problem\n"
"    println!(\"{}\", r3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:297
msgid ""
"The scopes of the immutable references `r1` and `r2` end after the `println!"
"`\n"
"where they are last used, which is before the mutable reference `r3` is\n"
"created. These scopes don‚Äôt overlap, so this code is allowed: the compiler "
"can\n"
"tell that the reference is no longer being used at a point before the end "
"of\n"
"the scope."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:303
msgid ""
"Even though borrowing errors may be frustrating at times, remember that "
"it‚Äôs\n"
"the Rust compiler pointing out a potential bug early (at compile time "
"rather\n"
"than at runtime) and showing you exactly where the problem is. Then you "
"don‚Äôt\n"
"have to track down why your data isn‚Äôt what you thought it was."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:308
msgid "### Dangling References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:310
msgid ""
"In languages with pointers, it‚Äôs easy to erroneously create a *dangling\n"
"pointer*‚Äîa pointer that references a location in memory that may have been\n"
"given to someone else‚Äîby freeing some memory while preserving a pointer to "
"that\n"
"memory. In Rust, by contrast, the compiler guarantees that references will\n"
"never be dangling references: if you have a reference to some data, the\n"
"compiler will ensure that the data will not go out of scope before the\n"
"reference to the data does."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:318
msgid ""
"Let‚Äôs try to create a dangling reference to see how Rust prevents them with "
"a\n"
"compile-time error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:323
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let reference_to_nothing = dangle();\n"
"}\n"
"\n"
"fn dangle() -> &String {\n"
"    let s = String::from(\"hello\");\n"
"\n"
"    &s\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:337
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:5:16\n"
"  |\n"
"5 | fn dangle() -> &String {\n"
"  |                ^ expected named lifetime parameter\n"
"  |\n"
"  = help: this function's return type contains a borrowed value, but there "
"is no value for it to be borrowed from\n"
"help: consider using the `'static` lifetime\n"
"  |\n"
"5 | fn dangle() -> &'static String {\n"
"  |                 +++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:356
msgid ""
"This error message refers to a feature we haven‚Äôt covered yet: lifetimes. "
"We‚Äôll\n"
"discuss lifetimes in detail in Chapter 10. But, if you disregard the parts\n"
"about lifetimes, the message does contain the key to why this code is a "
"problem:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:360
msgid ""
"```text\n"
"this function's return type contains a borrowed value, but there is no "
"value\n"
"for it to be borrowed from\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:365
msgid ""
"Let‚Äôs take a closer look at exactly what‚Äôs happening at each stage of our\n"
"`dangle` code:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:370
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"#     let reference_to_nothing = dangle();\n"
"# }\n"
"# \n"
"fn dangle() -> &String { // dangle returns a reference to a String\n"
"\n"
"    let s = String::from(\"hello\"); // s is a new String\n"
"\n"
"    &s // we return a reference to the String, s\n"
"} // Here, s goes out of scope, and is dropped. Its memory goes away.\n"
"  // Danger!\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:384
msgid ""
"Because `s` is created inside `dangle`, when the code of `dangle` is "
"finished,\n"
"`s` will be deallocated. But we tried to return a reference to it. That "
"means\n"
"this reference would be pointing to an invalid `String`. That‚Äôs no good! "
"Rust\n"
"won‚Äôt let us do this."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:389
msgid "The solution here is to return the `String` directly:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:391
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let string = no_dangle();\n"
"# }\n"
"# \n"
"fn no_dangle() -> String {\n"
"    let s = String::from(\"hello\");\n"
"\n"
"    s\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:403
msgid ""
"This works without any problems. Ownership is moved out, and nothing is\n"
"deallocated."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:406
msgid "### The Rules of References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:408
msgid "Let‚Äôs recap what we‚Äôve discussed about references:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:410
msgid ""
"* At any given time, you can have *either* one mutable reference *or* any\n"
"  number of immutable references.\n"
"* References must always be valid."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:414
msgid "Next, we‚Äôll look at a different kind of reference: slices."
msgstr ""

#: src/ch04-03-slices.md:1
msgid "## The Slice Type"
msgstr ""

#: src/ch04-03-slices.md:3
msgid ""
"*Slices* let you reference a contiguous sequence of elements in a "
"collection\n"
"rather than the whole collection. A slice is a kind of reference, so it "
"does\n"
"not have ownership."
msgstr ""

#: src/ch04-03-slices.md:7
msgid ""
"Here‚Äôs a small programming problem: write a function that takes a string of\n"
"words separated by spaces and returns the first word it finds in that "
"string.\n"
"If the function doesn‚Äôt find a space in the string, the whole string must "
"be\n"
"one word, so the entire string should be returned."
msgstr ""

#: src/ch04-03-slices.md:12
msgid ""
"Let‚Äôs work through how we‚Äôd write the signature of this function without "
"using\n"
"slices, to understand the problem that slices will solve:"
msgstr ""

#: src/ch04-03-slices.md:15
msgid ""
"```rust,ignore\n"
"fn first_word(s: &String) -> ?\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:19
msgid ""
"The `first_word` function has a `&String` as a parameter. We don‚Äôt want\n"
"ownership, so this is fine. But what should we return? We don‚Äôt really have "
"a\n"
"way to talk about *part* of a string. However, we could return the index of "
"the\n"
"end of the word, indicated by a space. Let‚Äôs try that, as shown in Listing "
"4-7."
msgstr ""

#: src/ch04-03-slices.md:26
msgid ""
"```rust\n"
"fn first_word(s: &String) -> usize {\n"
"    let bytes = s.as_bytes();\n"
"\n"
"    for (i, &item) in bytes.iter().enumerate() {\n"
"        if item == b' ' {\n"
"            return i;\n"
"        }\n"
"    }\n"
"\n"
"    s.len()\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:42
msgid ""
"<span class=\"caption\">Listing 4-7: The `first_word` function that returns "
"a\n"
"byte index value into the `String` parameter</span>"
msgstr ""

#: src/ch04-03-slices.md:45
msgid ""
"Because we need to go through the `String` element by element and check "
"whether\n"
"a value is a space, we‚Äôll convert our `String` to an array of bytes using "
"the\n"
"`as_bytes` method."
msgstr ""

#: src/ch04-03-slices.md:49
msgid ""
"```rust,ignore\n"
"# fn first_word(s: &String) -> usize {\n"
"    let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return i;\n"
"#         }\n"
"#     }\n"
"# \n"
"#     s.len()\n"
"# }\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:65
msgid ""
"Next, we create an iterator over the array of bytes using the `iter` method:"
msgstr ""

#: src/ch04-03-slices.md:67
msgid ""
"```rust,ignore\n"
"# fn first_word(s: &String) -> usize {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"    for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return i;\n"
"#         }\n"
"#     }\n"
"# \n"
"#     s.len()\n"
"# }\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:83
msgid ""
"We‚Äôll discuss iterators in more detail in [Chapter 13][ch13]<!-- ignore --"
">.\n"
"For now, know that `iter` is a method that returns each element in a "
"collection\n"
"and that `enumerate` wraps the result of `iter` and returns each element as\n"
"part of a tuple instead. The first element of the tuple returned from\n"
"`enumerate` is the index, and the second element is a reference to the "
"element.\n"
"This is a bit more convenient than calculating the index ourselves."
msgstr ""

#: src/ch04-03-slices.md:90
msgid ""
"Because the `enumerate` method returns a tuple, we can use patterns to\n"
"destructure that tuple. We‚Äôll be discussing patterns more in [Chapter\n"
"6][ch6]<!-- ignore -->. In the `for` loop, we specify a pattern that has "
"`i`\n"
"for the index in the tuple and `&item` for the single byte in the tuple.\n"
"Because we get a reference to the element from `.iter().enumerate()`, we "
"use\n"
"`&` in the pattern."
msgstr ""

#: src/ch04-03-slices.md:97
msgid ""
"Inside the `for` loop, we search for the byte that represents the space by\n"
"using the byte literal syntax. If we find a space, we return the position.\n"
"Otherwise, we return the length of the string by using `s.len()`."
msgstr ""

#: src/ch04-03-slices.md:101
msgid ""
"```rust,ignore\n"
"# fn first_word(s: &String) -> usize {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"        if item == b' ' {\n"
"            return i;\n"
"        }\n"
"    }\n"
"\n"
"    s.len()\n"
"# }\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:117
msgid ""
"We now have a way to find out the index of the end of the first word in the\n"
"string, but there‚Äôs a problem. We‚Äôre returning a `usize` on its own, but "
"it‚Äôs\n"
"only a meaningful number in the context of the `&String`. In other words,\n"
"because it‚Äôs a separate value from the `String`, there‚Äôs no guarantee that "
"it\n"
"will still be valid in the future. Consider the program in Listing 4-8 that\n"
"uses the `first_word` function from Listing 4-7."
msgstr ""

#: src/ch04-03-slices.md:126
msgid ""
"```rust\n"
"# fn first_word(s: &String) -> usize {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return i;\n"
"#         }\n"
"#     }\n"
"# \n"
"#     s.len()\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut s = String::from(\"hello world\");\n"
"\n"
"    let word = first_word(&s); // word will get the value 5\n"
"\n"
"    s.clear(); // this empties the String, making it equal to \"\"\n"
"\n"
"    // word still has the value 5 here, but there's no more string that\n"
"    // we could meaningfully use the value 5 with. word is now totally "
"invalid!\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:151
msgid ""
"<span class=\"caption\">Listing 4-8: Storing the result from calling the\n"
"`first_word` function and then changing the `String` contents</span>"
msgstr ""

#: src/ch04-03-slices.md:154
msgid ""
"This program compiles without any errors and would also do so if we used "
"`word`\n"
"after calling `s.clear()`. Because `word` isn‚Äôt connected to the state of "
"`s`\n"
"at all, `word` still contains the value `5`. We could use that value `5` "
"with\n"
"the variable `s` to try to extract the first word out, but this would be a "
"bug\n"
"because the contents of `s` have changed since we saved `5` in `word`."
msgstr ""

#: src/ch04-03-slices.md:160
msgid ""
"Having to worry about the index in `word` getting out of sync with the data "
"in\n"
"`s` is tedious and error prone! Managing these indices is even more brittle "
"if\n"
"we write a `second_word` function. Its signature would have to look like "
"this:"
msgstr ""

#: src/ch04-03-slices.md:164
msgid ""
"```rust,ignore\n"
"fn second_word(s: &String) -> (usize, usize) {\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:168
msgid ""
"Now we‚Äôre tracking a starting *and* an ending index, and we have even more\n"
"values that were calculated from data in a particular state but aren‚Äôt tied "
"to\n"
"that state at all. We have three unrelated variables floating around that "
"need\n"
"to be kept in sync."
msgstr ""

#: src/ch04-03-slices.md:173
msgid "Luckily, Rust has a solution to this problem: string slices."
msgstr ""

#: src/ch04-03-slices.md:175
msgid "### String Slices"
msgstr ""

#: src/ch04-03-slices.md:177
msgid ""
"A *string slice* is a reference to part of a `String`, and it looks like "
"this:"
msgstr ""

#: src/ch04-03-slices.md:179
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s = String::from(\"hello world\");\n"
"\n"
"    let hello = &s[0..5];\n"
"    let world = &s[6..11];\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:188
msgid ""
"Rather than a reference to the entire `String`, `hello` is a reference to a\n"
"portion of the `String`, specified in the extra `[0..5]` bit. We create "
"slices\n"
"using a range within brackets by specifying `[starting_index.."
"ending_index]`,\n"
"where `starting_index` is the first position in the slice and `ending_index` "
"is\n"
"one more than the last position in the slice. Internally, the slice data\n"
"structure stores the starting position and the length of the slice, which\n"
"corresponds to `ending_index` minus `starting_index`. So, in the case of "
"`let\n"
"world = &s[6..11];`, `world` would be a slice that contains a pointer to "
"the\n"
"byte at index 6 of `s` with a length value of `5`."
msgstr ""

#: src/ch04-03-slices.md:198
msgid "Figure 4-6 shows this in a diagram."
msgstr ""

#: src/ch04-03-slices.md:200
msgid ""
"<img alt=\"Three tables: a table representing the stack data of s, which "
"points\n"
"to the byte at index 0 in a table of the string data &quot;hello world&quot; "
"on\n"
"the heap. The third table rep-resents the stack data of the slice world, "
"which\n"
"has a length value of 5 and points to byte 6 of the heap data table.\"\n"
"src=\"img/trpl04-06.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-03-slices.md:206
msgid ""
"<span class=\"caption\">Figure 4-6: String slice referring to part of a\n"
"`String`</span>"
msgstr ""

#: src/ch04-03-slices.md:209
msgid ""
"With Rust‚Äôs `..` range syntax, if you want to start at index 0, you can "
"drop\n"
"the value before the two periods. In other words, these are equal:"
msgstr ""

#: src/ch04-03-slices.md:212
msgid ""
"```rust\n"
"let s = String::from(\"hello\");\n"
"\n"
"let slice = &s[0..2];\n"
"let slice = &s[..2];\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:219
msgid ""
"By the same token, if your slice includes the last byte of the `String`, "
"you\n"
"can drop the trailing number. That means these are equal:"
msgstr ""

#: src/ch04-03-slices.md:222
msgid ""
"```rust\n"
"let s = String::from(\"hello\");\n"
"\n"
"let len = s.len();\n"
"\n"
"let slice = &s[3..len];\n"
"let slice = &s[3..];\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:231
msgid ""
"You can also drop both values to take a slice of the entire string. So "
"these\n"
"are equal:"
msgstr ""

#: src/ch04-03-slices.md:234
msgid ""
"```rust\n"
"let s = String::from(\"hello\");\n"
"\n"
"let len = s.len();\n"
"\n"
"let slice = &s[0..len];\n"
"let slice = &s[..];\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:243
msgid ""
"> Note: String slice range indices must occur at valid UTF-8 character\n"
"> boundaries. If you attempt to create a string slice in the middle of a\n"
"> multibyte character, your program will exit with an error. For the "
"purposes\n"
"> of introducing string slices, we are assuming ASCII only in this section; "
"a\n"
"> more thorough discussion of UTF-8 handling is in the [‚ÄúStoring UTF-8 "
"Encoded\n"
"> Text with Strings‚Äù][strings]<!-- ignore --> section of Chapter 8."
msgstr ""

#: src/ch04-03-slices.md:250
msgid ""
"With all this information in mind, let‚Äôs rewrite `first_word` to return a\n"
"slice. The type that signifies ‚Äústring slice‚Äù is written as `&str`:"
msgstr ""

#: src/ch04-03-slices.md:255
msgid ""
"```rust\n"
"fn first_word(s: &String) -> &str {\n"
"    let bytes = s.as_bytes();\n"
"\n"
"    for (i, &item) in bytes.iter().enumerate() {\n"
"        if item == b' ' {\n"
"            return &s[0..i];\n"
"        }\n"
"    }\n"
"\n"
"    &s[..]\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:271
msgid ""
"We get the index for the end of the word the same way we did in Listing 4-7, "
"by\n"
"looking for the first occurrence of a space. When we find a space, we return "
"a\n"
"string slice using the start of the string and the index of the space as "
"the\n"
"starting and ending indices."
msgstr ""

#: src/ch04-03-slices.md:276
msgid ""
"Now when we call `first_word`, we get back a single value that is tied to "
"the\n"
"underlying data. The value is made up of a reference to the starting point "
"of\n"
"the slice and the number of elements in the slice."
msgstr ""

#: src/ch04-03-slices.md:280
msgid "Returning a slice would also work for a `second_word` function:"
msgstr ""

#: src/ch04-03-slices.md:282
msgid ""
"```rust,ignore\n"
"fn second_word(s: &String) -> &str {\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:286
msgid ""
"We now have a straightforward API that‚Äôs much harder to mess up because the\n"
"compiler will ensure the references into the `String` remain valid. "
"Remember\n"
"the bug in the program in Listing 4-8, when we got the index to the end of "
"the\n"
"first word but then cleared the string so our index was invalid? That code "
"was\n"
"logically incorrect but didn‚Äôt show any immediate errors. The problems "
"would\n"
"show up later if we kept trying to use the first word index with an emptied\n"
"string. Slices make this bug impossible and let us know we have a problem "
"with\n"
"our code much sooner. Using the slice version of `first_word` will throw a\n"
"compile-time error:"
msgstr ""

#: src/ch04-03-slices.md:298
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn first_word(s: &String) -> &str {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return &s[0..i];\n"
"#         }\n"
"#     }\n"
"# \n"
"#     &s[..]\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut s = String::from(\"hello world\");\n"
"\n"
"    let word = first_word(&s);\n"
"\n"
"    s.clear(); // error!\n"
"\n"
"    println!(\"the first word is: {}\", word);\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:322
msgid "Here‚Äôs the compiler error:"
msgstr ""

#: src/ch04-03-slices.md:324
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0502]: cannot borrow `s` as mutable because it is also borrowed as "
"immutable\n"
"  --> src/main.rs:18:5\n"
"   |\n"
"16 |     let word = first_word(&s);\n"
"   |                           -- immutable borrow occurs here\n"
"17 |\n"
"18 |     s.clear(); // error!\n"
"   |     ^^^^^^^^^ mutable borrow occurs here\n"
"19 |\n"
"20 |     println!(\"the first word is: {}\", word);\n"
"   |                                       ---- immutable borrow later used "
"here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `ownership` due to previous error\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:343
msgid ""
"Recall from the borrowing rules that if we have an immutable reference to\n"
"something, we cannot also take a mutable reference. Because `clear` needs "
"to\n"
"truncate the `String`, it needs to get a mutable reference. The `println!`\n"
"after the call to `clear` uses the reference in `word`, so the immutable\n"
"reference must still be active at that point. Rust disallows the mutable\n"
"reference in `clear` and the immutable reference in `word` from existing at "
"the\n"
"same time, and compilation fails. Not only has Rust made our API easier to "
"use,\n"
"but it has also eliminated an entire class of errors at compile time!"
msgstr ""

#: src/ch04-03-slices.md:353
msgid "<a id=\"string-literals-are-slices\"></a>"
msgstr ""

#: src/ch04-03-slices.md:355
msgid "#### String Literals as Slices"
msgstr ""

#: src/ch04-03-slices.md:357
msgid ""
"Recall that we talked about string literals being stored inside the binary. "
"Now\n"
"that we know about slices, we can properly understand string literals:"
msgstr ""

#: src/ch04-03-slices.md:360
msgid ""
"```rust\n"
"let s = \"Hello, world!\";\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:364
msgid ""
"The type of `s` here is `&str`: it‚Äôs a slice pointing to that specific point "
"of\n"
"the binary. This is also why string literals are immutable; `&str` is an\n"
"immutable reference."
msgstr ""

#: src/ch04-03-slices.md:368
msgid "#### String Slices as Parameters"
msgstr ""

#: src/ch04-03-slices.md:370
msgid ""
"Knowing that you can take slices of literals and `String` values leads us "
"to\n"
"one more improvement on `first_word`, and that‚Äôs its signature:"
msgstr ""

#: src/ch04-03-slices.md:373
msgid ""
"```rust,ignore\n"
"fn first_word(s: &String) -> &str {\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:377
msgid ""
"A more experienced Rustacean would write the signature shown in Listing 4-9\n"
"instead because it allows us to use the same function on both `&String` "
"values\n"
"and `&str` values."
msgstr ""

#: src/ch04-03-slices.md:381
msgid ""
"```rust,ignore\n"
"fn first_word(s: &str) -> &str {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return &s[0..i];\n"
"#         }\n"
"#     }\n"
"# \n"
"#     &s[..]\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let my_string = String::from(\"hello world\");\n"
"# \n"
"#     // `first_word` works on slices of `String`s, whether partial or "
"whole\n"
"#     let word = first_word(&my_string[0..6]);\n"
"#     let word = first_word(&my_string[..]);\n"
"#     // `first_word` also works on references to `String`s, which are "
"equivalent\n"
"#     // to whole slices of `String`s\n"
"#     let word = first_word(&my_string);\n"
"# \n"
"#     let my_string_literal = \"hello world\";\n"
"# \n"
"#     // `first_word` works on slices of string literals, whether partial or "
"whole\n"
"#     let word = first_word(&my_string_literal[0..6]);\n"
"#     let word = first_word(&my_string_literal[..]);\n"
"# \n"
"#     // Because string literals *are* string slices already,\n"
"#     // this works too, without the slice syntax!\n"
"#     let word = first_word(my_string_literal);\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:416
msgid ""
"<span class=\"caption\">Listing 4-9: Improving the `first_word` function by "
"using\n"
"a string slice for the type of the `s` parameter</span>"
msgstr ""

#: src/ch04-03-slices.md:419
msgid ""
"If we have a string slice, we can pass that directly. If we have a `String`, "
"we\n"
"can pass a slice of the `String` or a reference to the `String`. This\n"
"flexibility takes advantage of *deref coercions*, a feature we will cover "
"in\n"
"[‚ÄúImplicit Deref Coercions with Functions and\n"
"Methods‚Äù][deref-coercions]<!--ignore--> section of Chapter 15."
msgstr ""

#: src/ch04-03-slices.md:425
msgid ""
"Defining a function to take a string slice instead of a reference to a "
"`String`\n"
"makes our API more general and useful without losing any functionality:"
msgstr ""

#: src/ch04-03-slices.md:430
msgid ""
"```rust\n"
"# fn first_word(s: &str) -> &str {\n"
"#     let bytes = s.as_bytes();\n"
"# \n"
"#     for (i, &item) in bytes.iter().enumerate() {\n"
"#         if item == b' ' {\n"
"#             return &s[0..i];\n"
"#         }\n"
"#     }\n"
"# \n"
"#     &s[..]\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let my_string = String::from(\"hello world\");\n"
"\n"
"    // `first_word` works on slices of `String`s, whether partial or whole\n"
"    let word = first_word(&my_string[0..6]);\n"
"    let word = first_word(&my_string[..]);\n"
"    // `first_word` also works on references to `String`s, which are "
"equivalent\n"
"    // to whole slices of `String`s\n"
"    let word = first_word(&my_string);\n"
"\n"
"    let my_string_literal = \"hello world\";\n"
"\n"
"    // `first_word` works on slices of string literals, whether partial or "
"whole\n"
"    let word = first_word(&my_string_literal[0..6]);\n"
"    let word = first_word(&my_string_literal[..]);\n"
"\n"
"    // Because string literals *are* string slices already,\n"
"    // this works too, without the slice syntax!\n"
"    let word = first_word(my_string_literal);\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:465
msgid "### Other Slices"
msgstr ""

#: src/ch04-03-slices.md:467
msgid ""
"String slices, as you might imagine, are specific to strings. But there‚Äôs a\n"
"more general slice type too. Consider this array:"
msgstr ""

#: src/ch04-03-slices.md:470
msgid ""
"```rust\n"
"let a = [1, 2, 3, 4, 5];\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:474
msgid ""
"Just as we might want to refer to part of a string, we might want to refer "
"to\n"
"part of an array. We‚Äôd do so like this:"
msgstr ""

#: src/ch04-03-slices.md:477
msgid ""
"```rust\n"
"let a = [1, 2, 3, 4, 5];\n"
"\n"
"let slice = &a[1..3];\n"
"\n"
"assert_eq!(slice, &[2, 3]);\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:485
msgid ""
"This slice has the type `&[i32]`. It works the same way as string slices do, "
"by\n"
"storing a reference to the first element and a length. You‚Äôll use this kind "
"of\n"
"slice for all sorts of other collections. We‚Äôll discuss these collections "
"in\n"
"detail when we talk about vectors in Chapter 8."
msgstr ""

#: src/ch04-03-slices.md:492
msgid ""
"The concepts of ownership, borrowing, and slices ensure memory safety in "
"Rust\n"
"programs at compile time. The Rust language gives you control over your "
"memory\n"
"usage in the same way as other systems programming languages, but having "
"the\n"
"owner of data automatically clean up that data when the owner goes out of "
"scope\n"
"means you don‚Äôt have to write and debug extra code to get this control."
msgstr ""

#: src/ch04-03-slices.md:498
msgid ""
"Ownership affects how lots of other parts of Rust work, so we‚Äôll talk about\n"
"these concepts further throughout the rest of the book. Let‚Äôs move on to\n"
"Chapter 5 and look at grouping pieces of data together in a `struct`."
msgstr ""

#: src/ch05-00-structs.md:1
msgid "# Using Structs to Structure Related Data"
msgstr ""

#: src/ch05-00-structs.md:3
msgid ""
"A *struct*, or *structure*, is a custom data type that lets you package\n"
"together and name multiple related values that make up a meaningful group. "
"If\n"
"you‚Äôre familiar with an object-oriented language, a *struct* is like an\n"
"object‚Äôs data attributes. In this chapter, we‚Äôll compare and contrast "
"tuples\n"
"with structs to build on what you already know and demonstrate when structs "
"are\n"
"a better way to group data."
msgstr ""

#: src/ch05-00-structs.md:10
msgid ""
"We‚Äôll demonstrate how to define and instantiate structs. We‚Äôll discuss how "
"to\n"
"define associated functions, especially the kind of associated functions "
"called\n"
"*methods*, to specify behavior associated with a struct type. Structs and "
"enums\n"
"(discussed in Chapter 6) are the building blocks for creating new types in "
"your\n"
"program‚Äôs domain to take full advantage of Rust‚Äôs compile-time type checking."
msgstr ""

#: src/ch05-01-defining-structs.md:1
msgid "## Defining and Instantiating Structs"
msgstr ""

#: src/ch05-01-defining-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in [‚ÄúThe Tuple Type‚Äù][tuples]<!--\n"
"ignore --> section, in that both hold multiple related values. Like tuples, "
"the\n"
"pieces of a struct can be different types. Unlike with tuples, in a struct\n"
"you‚Äôll name each piece of data so it‚Äôs clear what the values mean. Adding "
"these\n"
"names means that structs are more flexible than tuples: you don‚Äôt have to "
"rely\n"
"on the order of the data to specify or access the values of an instance."
msgstr ""

#: src/ch05-01-defining-structs.md:10
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A\n"
"struct‚Äôs name should describe the significance of the pieces of data being\n"
"grouped together. Then, inside curly brackets, we define the names and types "
"of\n"
"the pieces of data, which we call *fields*. For example, Listing 5-1 shows "
"a\n"
"struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-structs.md:18
msgid ""
"```rust\n"
"struct User {\n"
"    active: bool,\n"
"    username: String,\n"
"    email: String,\n"
"    sign_in_count: u64,\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:29
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:31
msgid ""
"To use a struct after we‚Äôve defined it, we create an *instance* of that "
"struct\n"
"by specifying concrete values for each of the fields. We create an instance "
"by\n"
"stating the name of the struct and then add curly brackets containing *key:\n"
"value* pairs, where the keys are the names of the fields and the values are "
"the\n"
"data we want to store in those fields. We don‚Äôt have to specify the fields "
"in\n"
"the same order in which we declared them in the struct. In other words, the\n"
"struct definition is like a general template for the type, and instances "
"fill\n"
"in that template with particular data to create values of the type. For\n"
"example, we can declare a particular user as shown in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:43
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true,\n"
"        username: String::from(\"someusername123\"),\n"
"        email: String::from(\"someone@example.com\"),\n"
"        sign_in_count: 1,\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:61
msgid ""
"<span class=\"caption\">Listing 5-2: Creating an instance of the `User`\n"
"struct</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:64
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to\n"
"access this user‚Äôs email address, we use `user1.email`. If the instance is\n"
"mutable, we can change a value by using the dot notation and assigning into "
"a\n"
"particular field. Listing 5-3 shows how to change the value in the `email`\n"
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-structs.md:72
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true,\n"
"        username: String::from(\"someusername123\"),\n"
"        email: String::from(\"someone@example.com\"),\n"
"        sign_in_count: 1,\n"
"    };\n"
"\n"
"    user1.email = String::from(\"anotheremail@example.com\");\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:92
msgid ""
"<span class=\"caption\">Listing 5-3: Changing the value in the `email` field "
"of a\n"
"`User` instance</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:95
msgid ""
"Note that the entire instance must be mutable; Rust doesn‚Äôt allow us to "
"mark\n"
"only certain fields as mutable. As with any expression, we can construct a "
"new\n"
"instance of the struct as the last expression in the function body to\n"
"implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-structs.md:100
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with\n"
"the given email and username. The `active` field gets the value of `true`, "
"and\n"
"the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-structs.md:106
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn build_user(email: String, username: String) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username: username,\n"
"        email: email,\n"
"        sign_in_count: 1,\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let user1 = build_user(\n"
"#         String::from(\"someone@example.com\"),\n"
"#         String::from(\"someusername123\"),\n"
"#     );\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:131
msgid ""
"<span class=\"caption\">Listing 5-4: A `build_user` function that takes an "
"email\n"
"and username and returns a `User` instance</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:134
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct\n"
"fields, but having to repeat the `email` and `username` field names and\n"
"variables is a bit tedious. If the struct had more fields, repeating each "
"name\n"
"would get even more annoying. Luckily, there‚Äôs a convenient shorthand!"
msgstr ""

#: src/ch05-01-defining-structs.md:140
msgid ""
"<a id=\"using-the-field-init-shorthand-when-variables-and-fields-have-the-"
"same-name\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:142
msgid "### Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-structs.md:144
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in\n"
"Listing 5-4, we can use the *field init shorthand* syntax to rewrite\n"
"`build_user` so it behaves exactly the same but doesn‚Äôt have the repetition "
"of\n"
"`username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-structs.md:151
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn build_user(email: String, username: String) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username,\n"
"        email,\n"
"        sign_in_count: 1,\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let user1 = build_user(\n"
"#         String::from(\"someone@example.com\"),\n"
"#         String::from(\"someusername123\"),\n"
"#     );\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:176
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field "
"init\n"
"shorthand because the `username` and `email` parameters have the same name "
"as\n"
"struct fields</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:180
msgid ""
"Here, we‚Äôre creating a new instance of the `User` struct, which has a field\n"
"named `email`. We want to set the `email` field‚Äôs value to the value in the\n"
"`email` parameter of the `build_user` function. Because the `email` field "
"and\n"
"the `email` parameter have the same name, we only need to write `email` "
"rather\n"
"than `email: email`."
msgstr ""

#: src/ch05-01-defining-structs.md:186
msgid "### Creating Instances from Other Instances with Struct Update Syntax"
msgstr ""

#: src/ch05-01-defining-structs.md:188
msgid ""
"It‚Äôs often useful to create a new instance of a struct that includes most "
"of\n"
"the values from another instance, but changes some. You can do this using\n"
"*struct update syntax*."
msgstr ""

#: src/ch05-01-defining-structs.md:192
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in "
"`user2`\n"
"regularly, without the update syntax. We set a new value for `email` but\n"
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:198
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    // --snip--\n"
"# \n"
"#     let user1 = User {\n"
"#         email: String::from(\"someone@example.com\"),\n"
"#         username: String::from(\"someusername123\"),\n"
"#         active: true,\n"
"#         sign_in_count: 1,\n"
"#     };\n"
"\n"
"    let user2 = User {\n"
"        active: user1.active,\n"
"        username: user1.username,\n"
"        email: String::from(\"another@example.com\"),\n"
"        sign_in_count: user1.sign_in_count,\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:225
msgid ""
"<span class=\"caption\">Listing 5-6: Creating a new `User` instance using "
"one of\n"
"the values from `user1`</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:228
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as\n"
"shown in Listing 5-7. The syntax `..` specifies that the remaining fields "
"not\n"
"explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""

#: src/ch05-01-defining-structs.md:234
msgid ""
"```rust\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: String,\n"
"#     email: String,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    // --snip--\n"
"# \n"
"#     let user1 = User {\n"
"#         email: String::from(\"someone@example.com\"),\n"
"#         username: String::from(\"someusername123\"),\n"
"#         active: true,\n"
"#         sign_in_count: 1,\n"
"#     };\n"
"\n"
"    let user2 = User {\n"
"        email: String::from(\"another@example.com\"),\n"
"        ..user1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:259
msgid ""
"<span class=\"caption\">Listing 5-7: Using struct update syntax to set a "
"new\n"
"`email` value for a `User` instance but to use the rest of the values from\n"
"`user1`</span>"
msgstr ""

#: src/ch05-01-defining-structs.md:263
msgid ""
"The code in Listing 5-7 also creates an instance in `user2` that has a\n"
"different value for `email` but has the same values for the `username`,\n"
"`active`, and `sign_in_count` fields from `user1`. The `..user1` must come "
"last\n"
"to specify that any remaining fields should get their values from the\n"
"corresponding fields in `user1`, but we can choose to specify values for as\n"
"many fields as we want in any order, regardless of the order of the fields "
"in\n"
"the struct‚Äôs definition."
msgstr ""

#: src/ch05-01-defining-structs.md:271
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because\n"
"it moves the data, just as we saw in the [‚ÄúVariables and Data Interacting "
"with\n"
"Move‚Äù][move]<!-- ignore --> section. In this example, we can no longer use\n"
"`user1` as a whole after creating `user2` because the `String` in the\n"
"`username` field of `user1` was moved into `user2`. If we had given `user2` "
"new\n"
"`String` values for both `email` and `username`, and thus only used the\n"
"`active` and `sign_in_count` values from `user1`, then `user1` would still "
"be\n"
"valid after creating `user2`. Both `active` and `sign_in_count` are types "
"that\n"
"implement the `Copy` trait, so the behavior we discussed in the [‚ÄúStack-"
"Only\n"
"Data: Copy‚Äù][copy]<!-- ignore --> section would apply."
msgstr ""

#: src/ch05-01-defining-structs.md:282
msgid "### Using Tuple Structs Without Named Fields to Create Different Types"
msgstr ""

#: src/ch05-01-defining-structs.md:284
msgid ""
"Rust also supports structs that look similar to tuples, called *tuple "
"structs*.\n"
"Tuple structs have the added meaning the struct name provides but don‚Äôt "
"have\n"
"names associated with their fields; rather, they just have the types of the\n"
"fields. Tuple structs are useful when you want to give the whole tuple a "
"name\n"
"and make the tuple a different type from other tuples, and when naming each\n"
"field as in a regular struct would be verbose or redundant."
msgstr ""

#: src/ch05-01-defining-structs.md:291
msgid ""
"To define a tuple struct, start with the `struct` keyword and the struct "
"name\n"
"followed by the types in the tuple. For example, here we define and use two\n"
"tuple structs named `Color` and `Point`:"
msgstr ""

#: src/ch05-01-defining-structs.md:297
msgid ""
"```rust\n"
"struct Color(i32, i32, i32);\n"
"struct Point(i32, i32, i32);\n"
"\n"
"fn main() {\n"
"    let black = Color(0, 0, 0);\n"
"    let origin = Point(0, 0, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:307
msgid ""
"Note that the `black` and `origin` values are different types because "
"they‚Äôre\n"
"instances of different tuple structs. Each struct you define is its own "
"type,\n"
"even though the fields within the struct might have the same types. For\n"
"example, a function that takes a parameter of type `Color` cannot take a\n"
"`Point` as an argument, even though both types are made up of three `i32`\n"
"values. Otherwise, tuple struct instances are similar to tuples in that you "
"can\n"
"destructure them into their individual pieces, and you can use a `.` "
"followed\n"
"by the index to access an individual value."
msgstr ""

#: src/ch05-01-defining-structs.md:316
msgid "### Unit-Like Structs Without Any Fields"
msgstr ""

#: src/ch05-01-defining-structs.md:318
msgid ""
"You can also define structs that don‚Äôt have any fields! These are called\n"
"*unit-like structs* because they behave similarly to `()`, the unit type "
"that\n"
"we mentioned in [‚ÄúThe Tuple Type‚Äù][tuples]<!-- ignore --> section. Unit-"
"like\n"
"structs can be useful when you need to implement a trait on some type but "
"don‚Äôt\n"
"have any data that you want to store in the type itself. We‚Äôll discuss "
"traits\n"
"in Chapter 10. Here‚Äôs an example of declaring and instantiating a unit "
"struct\n"
"named `AlwaysEqual`:"
msgstr ""

#: src/ch05-01-defining-structs.md:328
msgid ""
"```rust\n"
"struct AlwaysEqual;\n"
"\n"
"fn main() {\n"
"    let subject = AlwaysEqual;\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:336
msgid ""
"To define `AlwaysEqual`, we use the `struct` keyword, the name we want, and\n"
"then a semicolon. No need for curly brackets or parentheses! Then we can get "
"an\n"
"instance of `AlwaysEqual` in the `subject` variable in a similar way: using "
"the\n"
"name we defined, without any curly brackets or parentheses. Imagine that "
"later\n"
"we‚Äôll implement behavior for this type such that every instance of\n"
"`AlwaysEqual` is always equal to every instance of any other type, perhaps "
"to\n"
"have a known result for testing purposes. We wouldn‚Äôt need any data to\n"
"implement that behavior! You‚Äôll see in Chapter 10 how to define traits and\n"
"implement them on any type, including unit-like structs."
msgstr ""

#: src/ch05-01-defining-structs.md:346
msgid ""
"> ### Ownership of Struct Data\n"
">\n"
"> In the `User` struct definition in Listing 5-1, we used the owned "
"`String`\n"
"> type rather than the `&str` string slice type. This is a deliberate "
"choice\n"
"> because we want each instance of this struct to own all of its data and "
"for\n"
"> that data to be valid for as long as the entire struct is valid.\n"
">\n"
"> It‚Äôs also possible for structs to store references to data owned by "
"something\n"
"> else, but to do so requires the use of *lifetimes*, a Rust feature that "
"we‚Äôll\n"
"> discuss in Chapter 10. Lifetimes ensure that the data referenced by a "
"struct\n"
"> is valid for as long as the struct is. Let‚Äôs say you try to store a "
"reference\n"
"> in a struct without specifying lifetimes, like the following; this won‚Äôt "
"work:\n"
">\n"
"> <span class=\"filename\">Filename: src/main.rs</span>\n"
">\n"
"> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 --"
">\n"
">\n"
"> ```rust,ignore,does_not_compile\n"
"> struct User {\n"
">     active: bool,\n"
">     username: &str,\n"
">     email: &str,\n"
">     sign_in_count: u64,\n"
"> }\n"
">\n"
"> fn main() {\n"
">     let user1 = User {\n"
">         active: true,\n"
">         username: \"someusername123\",\n"
">         email: \"someone@example.com\",\n"
">         sign_in_count: 1,\n"
">     };\n"
"> }\n"
"> ```\n"
">\n"
"> The compiler will complain that it needs lifetime specifiers:\n"
">\n"
"> ```console\n"
"> $ cargo run\n"
">    Compiling structs v0.1.0 (file:///projects/structs)\n"
"> error[E0106]: missing lifetime specifier\n"
">  --> src/main.rs:3:15\n"
">   |\n"
"> 3 |     username: &str,\n"
">   |               ^ expected named lifetime parameter\n"
">   |\n"
"> help: consider introducing a named lifetime parameter\n"
">   |\n"
"> 1 ~ struct User<'a> {\n"
"> 2 |     active: bool,\n"
"> 3 ~     username: &'a str,\n"
">   |\n"
">\n"
"> error[E0106]: missing lifetime specifier\n"
">  --> src/main.rs:4:12\n"
">   |\n"
"> 4 |     email: &str,\n"
">   |            ^ expected named lifetime parameter\n"
">   |\n"
"> help: consider introducing a named lifetime parameter\n"
">   |\n"
"> 1 ~ struct User<'a> {\n"
"> 2 |     active: bool,\n"
"> 3 |     username: &str,\n"
"> 4 ~     email: &'a str,\n"
">   |\n"
">\n"
"> For more information about this error, try `rustc --explain E0106`.\n"
"> error: could not compile `structs` due to 2 previous errors\n"
"> ```\n"
">\n"
"> In Chapter 10, we‚Äôll discuss how to fix these errors so you can store\n"
"> references in structs, but for now, we‚Äôll fix errors like these using "
"owned\n"
"> types like `String` instead of references like `&str`."
msgstr ""

#: src/ch05-01-defining-structs.md:421
msgid ""
"<!-- manual-regeneration\n"
"for the error above\n"
"after running update-rustc.sh:\n"
"pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-"
"reference-in-struct/output.txt\n"
"paste above\n"
"add `> ` before every line -->"
msgstr ""

#: src/ch05-02-example-structs.md:1
msgid "## An Example Program Using Structs"
msgstr ""

#: src/ch05-02-example-structs.md:3
msgid ""
"To understand when we might want to use structs, let‚Äôs write a program that\n"
"calculates the area of a rectangle. We‚Äôll start by using single variables, "
"and\n"
"then refactor the program until we‚Äôre using structs instead."
msgstr ""

#: src/ch05-02-example-structs.md:7
msgid ""
"Let‚Äôs make a new binary project with Cargo called *rectangles* that will "
"take\n"
"the width and height of a rectangle specified in pixels and calculate the "
"area\n"
"of the rectangle. Listing 5-8 shows a short program with one way of doing\n"
"exactly that in our project‚Äôs *src/main.rs*."
msgstr ""

#: src/ch05-02-example-structs.md:14
msgid ""
"```rust\n"
"fn main() {\n"
"    let width1 = 30;\n"
"    let height1 = 50;\n"
"\n"
"    println!(\n"
"        \"The area of the rectangle is {} square pixels.\",\n"
"        area(width1, height1)\n"
"    );\n"
"}\n"
"\n"
"fn area(width: u32, height: u32) -> u32 {\n"
"    width * height\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:30
msgid ""
"<span class=\"caption\">Listing 5-8: Calculating the area of a rectangle\n"
"specified by separate width and height variables</span>"
msgstr ""

#: src/ch05-02-example-structs.md:33
msgid "Now, run this program using `cargo run`:"
msgstr ""

#: src/ch05-02-example-structs.md:35
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n"
"     Running `target/debug/rectangles`\n"
"The area of the rectangle is 1500 square pixels.\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:43
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the\n"
"`area` function with each dimension, but we can do more to make this code "
"clear\n"
"and readable."
msgstr ""

#: src/ch05-02-example-structs.md:47
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch05-02-example-structs.md:49
msgid ""
"```rust,ignore\n"
"# fn main() {\n"
"#     let width1 = 30;\n"
"#     let height1 = 50;\n"
"# \n"
"#     println!(\n"
"#         \"The area of the rectangle is {} square pixels.\",\n"
"#         area(width1, height1)\n"
"#     );\n"
"# }\n"
"# \n"
"fn area(width: u32, height: u32) -> u32 {\n"
"#     width * height\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:65
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the\n"
"function we wrote has two parameters, and it‚Äôs not clear anywhere in our\n"
"program that the parameters are related. It would be more readable and more\n"
"manageable to group width and height together. We‚Äôve already discussed one "
"way\n"
"we might do that in [‚ÄúThe Tuple Type‚Äù][the-tuple-type]<!-- ignore --> "
"section\n"
"of Chapter 3: by using tuples."
msgstr ""

#: src/ch05-02-example-structs.md:72
msgid "### Refactoring with Tuples"
msgstr ""

#: src/ch05-02-example-structs.md:74
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr ""

#: src/ch05-02-example-structs.md:78
msgid ""
"```rust\n"
"fn main() {\n"
"    let rect1 = (30, 50);\n"
"\n"
"    println!(\n"
"        \"The area of the rectangle is {} square pixels.\",\n"
"        area(rect1)\n"
"    );\n"
"}\n"
"\n"
"fn area(dimensions: (u32, u32)) -> u32 {\n"
"    dimensions.0 * dimensions.1\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:93
msgid ""
"<span class=\"caption\">Listing 5-9: Specifying the width and height of the\n"
"rectangle with a tuple</span>"
msgstr ""

#: src/ch05-02-example-structs.md:96
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and\n"
"we‚Äôre now passing just one argument. But in another way, this version is "
"less\n"
"clear: tuples don‚Äôt name their elements, so we have to index into the parts "
"of\n"
"the tuple, making our calculation less obvious."
msgstr ""

#: src/ch05-02-example-structs.md:101
msgid ""
"Mixing up the width and height wouldn‚Äôt matter for the area calculation, but "
"if\n"
"we want to draw the rectangle on the screen, it would matter! We would have "
"to\n"
"keep in mind that `width` is the tuple index `0` and `height` is the tuple\n"
"index `1`. This would be even harder for someone else to figure out and keep "
"in\n"
"mind if they were to use our code. Because we haven‚Äôt conveyed the meaning "
"of\n"
"our data in our code, it‚Äôs now easier to introduce errors."
msgstr ""

#: src/ch05-02-example-structs.md:108
msgid "### Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch05-02-example-structs.md:110
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple\n"
"we‚Äôre using into a struct with a name for the whole as well as names for "
"the\n"
"parts, as shown in Listing 5-10."
msgstr ""

#: src/ch05-02-example-structs.md:116
msgid ""
"```rust\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"\n"
"    println!(\n"
"        \"The area of the rectangle is {} square pixels.\",\n"
"        area(&rect1)\n"
"    );\n"
"}\n"
"\n"
"fn area(rectangle: &Rectangle) -> u32 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:139
msgid ""
"<span class=\"caption\">Listing 5-10: Defining a `Rectangle` struct</span>"
msgstr ""

#: src/ch05-02-example-structs.md:141
msgid ""
"Here we‚Äôve defined a struct and named it `Rectangle`. Inside the curly\n"
"brackets, we defined the fields as `width` and `height`, both of which have\n"
"type `u32`. Then, in `main`, we created a particular instance of "
"`Rectangle`\n"
"that has a width of `30` and a height of `50`."
msgstr ""

#: src/ch05-02-example-structs.md:146
msgid ""
"Our `area` function is now defined with one parameter, which we‚Äôve named\n"
"`rectangle`, whose type is an immutable borrow of a struct `Rectangle`\n"
"instance. As mentioned in Chapter 4, we want to borrow the struct rather "
"than\n"
"take ownership of it. This way, `main` retains its ownership and can "
"continue\n"
"using `rect1`, which is the reason we use the `&` in the function signature "
"and\n"
"where we call the function."
msgstr ""

#: src/ch05-02-example-structs.md:153
msgid ""
"The `area` function accesses the `width` and `height` fields of the "
"`Rectangle`\n"
"instance (note that accessing fields of a borrowed struct instance does not\n"
"move the field values, which is why you often see borrows of structs). Our\n"
"function signature for `area` now says exactly what we mean: calculate the "
"area\n"
"of `Rectangle`, using its `width` and `height` fields. This conveys that "
"the\n"
"width and height are related to each other, and it gives descriptive names "
"to\n"
"the values rather than using the tuple index values of `0` and `1`. This is "
"a\n"
"win for clarity."
msgstr ""

#: src/ch05-02-example-structs.md:162
msgid "### Adding Useful Functionality with Derived Traits"
msgstr ""

#: src/ch05-02-example-structs.md:164
msgid ""
"It‚Äôd be useful to be able to print an instance of `Rectangle` while we‚Äôre\n"
"debugging our program and see the values for all its fields. Listing 5-11 "
"tries\n"
"using the [`println!` macro][println]<!-- ignore --> as we have used in\n"
"previous chapters. This won‚Äôt work, however."
msgstr ""

#: src/ch05-02-example-structs.md:171
msgid ""
"```rust,ignore,does_not_compile\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"\n"
"    println!(\"rect1 is {}\", rect1);\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:187
msgid ""
"<span class=\"caption\">Listing 5-11: Attempting to print a `Rectangle`\n"
"instance</span>"
msgstr ""

#: src/ch05-02-example-structs.md:190
msgid "When we compile this code, we get an error with this core message:"
msgstr ""

#: src/ch05-02-example-structs.md:192
msgid ""
"```text\n"
"error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:196
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly\n"
"brackets tell `println!` to use formatting known as `Display`: output "
"intended\n"
"for direct end user consumption. The primitive types we‚Äôve seen so far\n"
"implement `Display` by default because there‚Äôs only one way you‚Äôd want to "
"show\n"
"a `1` or any other primitive type to a user. But with structs, the way\n"
"`println!` should format the output is less clear because there are more\n"
"display possibilities: Do you want commas or not? Do you want to print the\n"
"curly brackets? Should all the fields be shown? Due to this ambiguity, Rust\n"
"doesn‚Äôt try to guess what we want, and structs don‚Äôt have a provided\n"
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""

#: src/ch05-02-example-structs.md:207
msgid "If we continue reading the errors, we‚Äôll find this helpful note:"
msgstr ""

#: src/ch05-02-example-structs.md:209
msgid ""
"```text\n"
"   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`\n"
"   = note: in format strings you may be able to use `{:?}` (or {:#?} for "
"pretty-print) instead\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:214
msgid ""
"Let‚Äôs try it! The `println!` macro call will now look like `println!(\"rect1 "
"is\n"
"{:?}\", rect1);`. Putting the specifier `:?` inside the curly brackets "
"tells\n"
"`println!` we want to use an output format called `Debug`. The `Debug` "
"trait\n"
"enables us to print our struct in a way that is useful for developers so we "
"can\n"
"see its value while we‚Äôre debugging our code."
msgstr ""

#: src/ch05-02-example-structs.md:220
msgid "Compile the code with this change. Drat! We still get an error:"
msgstr ""

#: src/ch05-02-example-structs.md:222
msgid ""
"```text\n"
"error[E0277]: `Rectangle` doesn't implement `Debug`\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:226
msgid "But again, the compiler gives us a helpful note:"
msgstr ""

#: src/ch05-02-example-structs.md:228
msgid ""
"```text\n"
"   = help: the trait `Debug` is not implemented for `Rectangle`\n"
"   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for "
"Rectangle`\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:233
msgid ""
"Rust *does* include functionality to print out debugging information, but "
"we\n"
"have to explicitly opt in to make that functionality available for our "
"struct.\n"
"To do that, we add the outer attribute `#[derive(Debug)]` just before the\n"
"struct definition, as shown in Listing 5-12."
msgstr ""

#: src/ch05-02-example-structs.md:240
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"\n"
"    println!(\"rect1 is {:?}\", rect1);\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:257
msgid ""
"<span class=\"caption\">Listing 5-12: Adding the attribute to derive the "
"`Debug`\n"
"trait and printing the `Rectangle` instance using debug formatting</span>"
msgstr ""

#: src/ch05-02-example-structs.md:260
msgid ""
"Now when we run the program, we won‚Äôt get any errors, and we‚Äôll see the\n"
"following output:"
msgstr ""

#: src/ch05-02-example-structs.md:263
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/rectangles`\n"
"rect1 is Rectangle { width: 30, height: 50 }\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:271
msgid ""
"Nice! It‚Äôs not the prettiest output, but it shows the values of all the "
"fields\n"
"for this instance, which would definitely help during debugging. When we "
"have\n"
"larger structs, it‚Äôs useful to have output that‚Äôs a bit easier to read; in\n"
"those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string. "
"In\n"
"this example, using the `{:#?}` style will output the following:"
msgstr ""

#: src/ch05-02-example-structs.md:277
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/rectangles`\n"
"rect1 is Rectangle {\n"
"    width: 30,\n"
"    height: 50,\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:288
msgid ""
"Another way to print out a value using the `Debug` format is to use the "
"[`dbg!`\n"
"macro][dbg]<!-- ignore -->, which takes ownership of an expression (as "
"opposed\n"
"to `println!`, which takes a reference), prints the file and line number of\n"
"where that `dbg!` macro call occurs in your code along with the resultant "
"value\n"
"of that expression, and returns ownership of the value."
msgstr ""

#: src/ch05-02-example-structs.md:294
msgid ""
"> Note: Calling the `dbg!` macro prints to the standard error console "
"stream\n"
"> (`stderr`), as opposed to `println!`, which prints to the standard output\n"
"> console stream (`stdout`). We‚Äôll talk more about `stderr` and `stdout` in "
"the\n"
"> [‚ÄúWriting Error Messages to Standard Error Instead of Standard Output‚Äù\n"
"> section in Chapter 12][err]<!-- ignore -->."
msgstr ""

#: src/ch05-02-example-structs.md:300
msgid ""
"Here‚Äôs an example where we‚Äôre interested in the value that gets assigned to "
"the\n"
"`width` field, as well as the value of the whole struct in `rect1`:"
msgstr ""

#: src/ch05-02-example-structs.md:303
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let scale = 2;\n"
"    let rect1 = Rectangle {\n"
"        width: dbg!(30 * scale),\n"
"        height: 50,\n"
"    };\n"
"\n"
"    dbg!(&rect1);\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:321
msgid ""
"We can put `dbg!` around the expression `30 * scale` and, because `dbg!`\n"
"returns ownership of the expression‚Äôs value, the `width` field will get the\n"
"same value as if we didn‚Äôt have the `dbg!` call there. We don‚Äôt want `dbg!` "
"to\n"
"take ownership of `rect1`, so we use a reference to `rect1` in the next "
"call.\n"
"Here‚Äôs what the output of this example looks like:"
msgstr ""

#: src/ch05-02-example-structs.md:327
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running `target/debug/rectangles`\n"
"[src/main.rs:10] 30 * scale = 60\n"
"[src/main.rs:14] &rect1 = Rectangle {\n"
"    width: 60,\n"
"    height: 50,\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:339
msgid ""
"We can see the first bit of output came from *src/main.rs* line 10 where "
"we‚Äôre\n"
"debugging the expression `30 * scale`, and its resultant value is `60` (the\n"
"`Debug` formatting implemented for integers is to print only their value). "
"The\n"
"`dbg!` call on line 14 of *src/main.rs* outputs the value of `&rect1`, which "
"is\n"
"the `Rectangle` struct. This output uses the pretty `Debug` formatting of "
"the\n"
"`Rectangle` type. The `dbg!` macro can be really helpful when you‚Äôre trying "
"to\n"
"figure out what your code is doing!"
msgstr ""

#: src/ch05-02-example-structs.md:347
msgid ""
"In addition to the `Debug` trait, Rust has provided a number of traits for "
"us\n"
"to use with the `derive` attribute that can add useful behavior to our "
"custom\n"
"types. Those traits and their behaviors are listed in [Appendix C][app-"
"c]<!--\n"
"ignore -->. We‚Äôll cover how to implement these traits with custom behavior "
"as\n"
"well as how to create your own traits in Chapter 10. There are also many\n"
"attributes other than `derive`; for more information, see [the ‚ÄúAttributes‚Äù\n"
"section of the Rust Reference][attributes]."
msgstr ""

#: src/ch05-02-example-structs.md:355
msgid ""
"Our `area` function is very specific: it only computes the area of "
"rectangles.\n"
"It would be helpful to tie this behavior more closely to our `Rectangle` "
"struct\n"
"because it won‚Äôt work with any other type. Let‚Äôs look at how we can continue "
"to\n"
"refactor this code by turning the `area` function into an `area` *method*\n"
"defined on our `Rectangle` type."
msgstr ""

#: src/ch05-03-method-syntax.md:1
msgid "## Method Syntax"
msgstr ""

#: src/ch05-03-method-syntax.md:3
msgid ""
"*Methods* are similar to functions: we declare them with the `fn` keyword "
"and a\n"
"name, they can have parameters and a return value, and they contain some "
"code\n"
"that‚Äôs run when the method is called from somewhere else. Unlike functions,\n"
"methods are defined within the context of a struct (or an enum or a trait\n"
"object, which we cover in [Chapter 6][enums]<!-- ignore --> and [Chapter\n"
"17][trait-objects]<!-- ignore -->, respectively), and their first parameter "
"is\n"
"always `self`, which represents the instance of the struct the method is "
"being\n"
"called on."
msgstr ""

#: src/ch05-03-method-syntax.md:12
msgid "### Defining Methods"
msgstr ""

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let‚Äôs change the `area` function that has a `Rectangle` instance as a "
"parameter\n"
"and instead make an `area` method defined on the `Rectangle` struct, as "
"shown\n"
"in Listing 5-13."
msgstr ""

#: src/ch05-03-method-syntax.md:20
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"\n"
"    println!(\n"
"        \"The area of the rectangle is {} square pixels.\",\n"
"        rect1.area()\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:46
msgid ""
"<span class=\"caption\">Listing 5-13: Defining an `area` method on the\n"
"`Rectangle` struct</span>"
msgstr ""

#: src/ch05-03-method-syntax.md:49
msgid ""
"To define the function within the context of `Rectangle`, we start an "
"`impl`\n"
"(implementation) block for `Rectangle`. Everything within this `impl` block\n"
"will be associated with the `Rectangle` type. Then we move the `area` "
"function\n"
"within the `impl` curly brackets and change the first (and in this case, "
"only)\n"
"parameter to be `self` in the signature and everywhere within the body. In\n"
"`main`, where we called the `area` function and passed `rect1` as an "
"argument,\n"
"we can instead use *method syntax* to call the `area` method on our "
"`Rectangle`\n"
"instance. The method syntax goes after an instance: we add a dot followed "
"by\n"
"the method name, parentheses, and any arguments."
msgstr ""

#: src/ch05-03-method-syntax.md:59
msgid ""
"In the signature for `area`, we use `&self` instead of `rectangle: "
"&Rectangle`.\n"
"The `&self` is actually short for `self: &Self`. Within an `impl` block, "
"the\n"
"type `Self` is an alias for the type that the `impl` block is for. Methods "
"must\n"
"have a parameter named `self` of type `Self` for their first parameter, so "
"Rust\n"
"lets you abbreviate this with only the name `self` in the first parameter "
"spot.\n"
"Note that we still need to use the `&` in front of the `self` shorthand to\n"
"indicate that this method borrows the `Self` instance, just as we did in\n"
"`rectangle: &Rectangle`. Methods can take ownership of `self`, borrow "
"`self`\n"
"immutably, as we‚Äôve done here, or borrow `self` mutably, just as they can "
"any\n"
"other parameter."
msgstr ""

#: src/ch05-03-method-syntax.md:70
msgid ""
"We chose `&self` here for the same reason we used `&Rectangle` in the "
"function\n"
"version: we don‚Äôt want to take ownership, and we just want to read the data "
"in\n"
"the struct, not write to it. If we wanted to change the instance that we‚Äôve\n"
"called the method on as part of what the method does, we‚Äôd use `&mut self` "
"as\n"
"the first parameter. Having a method that takes ownership of the instance "
"by\n"
"using just `self` as the first parameter is rare; this technique is usually\n"
"used when the method transforms `self` into something else and you want to\n"
"prevent the caller from using the original instance after the transformation."
msgstr ""

#: src/ch05-03-method-syntax.md:79
msgid ""
"The main reason for using methods instead of functions, in addition to\n"
"providing method syntax and not having to repeat the type of `self` in "
"every\n"
"method‚Äôs signature, is for organization. We‚Äôve put all the things we can do\n"
"with an instance of a type in one `impl` block rather than making future "
"users\n"
"of our code search for capabilities of `Rectangle` in various places in the\n"
"library we provide."
msgstr ""

#: src/ch05-03-method-syntax.md:86
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct‚Äôs\n"
"fields. For example, we can define a method on `Rectangle` that is also "
"named\n"
"`width`:"
msgstr ""

#: src/ch05-03-method-syntax.md:92
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"impl Rectangle {\n"
"    fn width(&self) -> bool {\n"
"        self.width > 0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"\n"
"    if rect1.width() {\n"
"        println!(\"The rectangle has a nonzero width; it is {}\", rect1."
"width);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:117
msgid ""
"Here, we‚Äôre choosing to make the `width` method return `true` if the value "
"in\n"
"the instance‚Äôs `width` field is greater than `0` and `false` if the value "
"is\n"
"`0`: we can use a field within a method of the same name for any purpose. "
"In\n"
"`main`, when we follow `rect1.width` with parentheses, Rust knows we mean "
"the\n"
"method `width`. When we don‚Äôt use parentheses, Rust knows we mean the field\n"
"`width`."
msgstr ""

#: src/ch05-03-method-syntax.md:124
msgid ""
"Often, but not always, when we give a method the same name as a field we "
"want\n"
"it to only return the value in the field and do nothing else. Methods like "
"this\n"
"are called *getters*, and Rust does not implement them automatically for "
"struct\n"
"fields as some other languages do. Getters are useful because you can make "
"the\n"
"field private but the method public, and thus enable read-only access to "
"that\n"
"field as part of the type‚Äôs public API. We will discuss what public and "
"private\n"
"are and how to designate a field or method as public or private in [Chapter\n"
"7][public]<!-- ignore -->."
msgstr ""

#: src/ch05-03-method-syntax.md:133
msgid ""
"> ### Where‚Äôs the `->` Operator?\n"
">\n"
"> In C and C++, two different operators are used for calling methods: you "
"use\n"
"> `.` if you‚Äôre calling a method on the object directly and `->` if you‚Äôre\n"
"> calling the method on a pointer to the object and need to dereference the\n"
"> pointer first. In other words, if `object` is a pointer,\n"
"> `object->something()` is similar to `(*object).something()`.\n"
">\n"
"> Rust doesn‚Äôt have an equivalent to the `->` operator; instead, Rust has a\n"
"> feature called *automatic referencing and dereferencing*. Calling methods "
"is\n"
"> one of the few places in Rust that has this behavior.\n"
">\n"
"> Here‚Äôs how it works: when you call a method with `object.something()`, "
"Rust\n"
"> automatically adds in `&`, `&mut`, or `*` so `object` matches the "
"signature of\n"
"> the method. In other words, the following are the same:\n"
">\n"
"> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 "
"-->\n"
"> ```rust\n"
"> # #[derive(Debug,Copy,Clone)]\n"
"> # struct Point {\n"
"> #     x: f64,\n"
"> #     y: f64,\n"
"> # }\n"
"> #\n"
"> # impl Point {\n"
"> #    fn distance(&self, other: &Point) -> f64 {\n"
"> #        let x_squared = f64::powi(other.x - self.x, 2);\n"
"> #        let y_squared = f64::powi(other.y - self.y, 2);\n"
"> #\n"
"> #        f64::sqrt(x_squared + y_squared)\n"
"> #    }\n"
"> # }\n"
"> # let p1 = Point { x: 0.0, y: 0.0 };\n"
"> # let p2 = Point { x: 5.0, y: 6.5 };\n"
"> p1.distance(&p2);\n"
"> (&p1).distance(&p2);\n"
"> ```\n"
">\n"
"> The first one looks much cleaner. This automatic referencing behavior "
"works\n"
"> because methods have a clear receiver‚Äîthe type of `self`. Given the "
"receiver\n"
"> and name of a method, Rust can figure out definitively whether the method "
"is\n"
"> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The "
"fact\n"
"> that Rust makes borrowing implicit for method receivers is a big part of\n"
"> making ownership ergonomic in practice."
msgstr ""

#: src/ch05-03-method-syntax.md:178
msgid "### Methods with More Parameters"
msgstr ""

#: src/ch05-03-method-syntax.md:180
msgid ""
"Let‚Äôs practice using methods by implementing a second method on the "
"`Rectangle`\n"
"struct. This time we want an instance of `Rectangle` to take another "
"instance\n"
"of `Rectangle` and return `true` if the second `Rectangle` can fit "
"completely\n"
"within `self` (the first `Rectangle`); otherwise, it should return `false`.\n"
"That is, once we‚Äôve defined the `can_hold` method, we want to be able to "
"write\n"
"the program shown in Listing 5-14."
msgstr ""

#: src/ch05-03-method-syntax.md:189
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    let rect1 = Rectangle {\n"
"        width: 30,\n"
"        height: 50,\n"
"    };\n"
"    let rect2 = Rectangle {\n"
"        width: 10,\n"
"        height: 40,\n"
"    };\n"
"    let rect3 = Rectangle {\n"
"        width: 60,\n"
"        height: 45,\n"
"    };\n"
"\n"
"    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n"
"    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n"
"}\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:209
msgid ""
"<span class=\"caption\">Listing 5-14: Using the as-yet-unwritten `can_hold`\n"
"method</span>"
msgstr ""

#: src/ch05-03-method-syntax.md:212
msgid ""
"The expected output would look like the following because both dimensions "
"of\n"
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than\n"
"`rect1`:"
msgstr ""

#: src/ch05-03-method-syntax.md:216
msgid ""
"```text\n"
"Can rect1 hold rect2? true\n"
"Can rect1 hold rect3? false\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:221
msgid ""
"We know we want to define a method, so it will be within the `impl "
"Rectangle`\n"
"block. The method name will be `can_hold`, and it will take an immutable "
"borrow\n"
"of another `Rectangle` as a parameter. We can tell what the type of the\n"
"parameter will be by looking at the code that calls the method:\n"
"`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow "
"to\n"
"`rect2`, an instance of `Rectangle`. This makes sense because we only need "
"to\n"
"read `rect2` (rather than write, which would mean we‚Äôd need a mutable "
"borrow),\n"
"and we want `main` to retain ownership of `rect2` so we can use it again "
"after\n"
"calling the `can_hold` method. The return value of `can_hold` will be a\n"
"Boolean, and the implementation will check whether the width and height of\n"
"`self` are greater than the width and height of the other `Rectangle`,\n"
"respectively. Let‚Äôs add the new `can_hold` method to the `impl` block from\n"
"Listing 5-13, shown in Listing 5-15."
msgstr ""

#: src/ch05-03-method-syntax.md:237
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn can_hold(&self, other: &Rectangle) -> bool {\n"
"        self.width > other.width && self.height > other.height\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let rect1 = Rectangle {\n"
"#         width: 30,\n"
"#         height: 50,\n"
"#     };\n"
"#     let rect2 = Rectangle {\n"
"#         width: 10,\n"
"#         height: 40,\n"
"#     };\n"
"#     let rect3 = Rectangle {\n"
"#         width: 60,\n"
"#         height: 45,\n"
"#     };\n"
"# \n"
"#     println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n"
"#     println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:273
msgid ""
"<span class=\"caption\">Listing 5-15: Implementing the `can_hold` method on\n"
"`Rectangle` that takes another `Rectangle` instance as a parameter</span>"
msgstr ""

#: src/ch05-03-method-syntax.md:276
msgid ""
"When we run this code with the `main` function in Listing 5-14, we‚Äôll get "
"our\n"
"desired output. Methods can take multiple parameters that we add to the\n"
"signature after the `self` parameter, and those parameters work just like\n"
"parameters in functions."
msgstr ""

#: src/ch05-03-method-syntax.md:281
msgid "### Associated Functions"
msgstr ""

#: src/ch05-03-method-syntax.md:283
msgid ""
"All functions defined within an `impl` block are called *associated "
"functions*\n"
"because they‚Äôre associated with the type named after the `impl`. We can "
"define\n"
"associated functions that don‚Äôt have `self` as their first parameter (and "
"thus\n"
"are not methods) because they don‚Äôt need an instance of the type to work "
"with.\n"
"We‚Äôve already used one function like this: the `String::from` function "
"that‚Äôs\n"
"defined on the `String` type."
msgstr ""

#: src/ch05-03-method-syntax.md:290
msgid ""
"Associated functions that aren‚Äôt methods are often used for constructors "
"that\n"
"will return a new instance of the struct. These are often called `new`, but\n"
"`new` isn‚Äôt a special name and isn‚Äôt built into the language. For example, "
"we\n"
"could choose to provide an associated function named `square` that would "
"have\n"
"one dimension parameter and use that as both width and height, thus making "
"it\n"
"easier to create a square `Rectangle` rather than having to specify the "
"same\n"
"value twice:"
msgstr ""

#: src/ch05-03-method-syntax.md:300
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"impl Rectangle {\n"
"    fn square(size: u32) -> Self {\n"
"        Self {\n"
"            width: size,\n"
"            height: size,\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let sq = Rectangle::square(3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:321
msgid ""
"The `Self` keywords in the return type and in the body of the function are\n"
"aliases for the type that appears after the `impl` keyword, which in this "
"case\n"
"is `Rectangle`."
msgstr ""

#: src/ch05-03-method-syntax.md:325
msgid ""
"To call this associated function, we use the `::` syntax with the struct "
"name;\n"
"`let sq = Rectangle::square(3);` is an example. This function is namespaced "
"by\n"
"the struct: the `::` syntax is used for both associated functions and\n"
"namespaces created by modules. We‚Äôll discuss modules in [Chapter\n"
"7][modules]<!-- ignore -->."
msgstr ""

#: src/ch05-03-method-syntax.md:331
msgid "### Multiple `impl` Blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:333
msgid ""
"Each struct is allowed to have multiple `impl` blocks. For example, Listing\n"
"5-15 is equivalent to the code shown in Listing 5-16, which has each method "
"in\n"
"its own `impl` block."
msgstr ""

#: src/ch05-03-method-syntax.md:337
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn can_hold(&self, other: &Rectangle) -> bool {\n"
"        self.width > other.width && self.height > other.height\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let rect1 = Rectangle {\n"
"#         width: 30,\n"
"#         height: 50,\n"
"#     };\n"
"#     let rect2 = Rectangle {\n"
"#         width: 10,\n"
"#         height: 40,\n"
"#     };\n"
"#     let rect3 = Rectangle {\n"
"#         width: 60,\n"
"#         height: 45,\n"
"#     };\n"
"# \n"
"#     println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n"
"#     println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n"
"# }\n"
"```"
msgstr ""

#: src/ch05-03-method-syntax.md:375
msgid ""
"<span class=\"caption\">Listing 5-16: Rewriting Listing 5-15 using multiple "
"`impl`\n"
"blocks</span>"
msgstr ""

#: src/ch05-03-method-syntax.md:378
msgid ""
"There‚Äôs no reason to separate these methods into multiple `impl` blocks "
"here,\n"
"but this is valid syntax. We‚Äôll see a case in which multiple `impl` blocks "
"are\n"
"useful in Chapter 10, where we discuss generic types and traits."
msgstr ""

#: src/ch05-03-method-syntax.md:384
msgid ""
"Structs let you create custom types that are meaningful for your domain. By\n"
"using structs, you can keep associated pieces of data connected to each "
"other\n"
"and name each piece to make your code clear. In `impl` blocks, you can "
"define\n"
"functions that are associated with your type, and methods are a kind of\n"
"associated function that let you specify the behavior that instances of "
"your\n"
"structs have."
msgstr ""

#: src/ch05-03-method-syntax.md:391
msgid ""
"But structs aren‚Äôt the only way you can create custom types: let‚Äôs turn to\n"
"Rust‚Äôs enum feature to add another tool to your toolbox."
msgstr ""

#: src/ch06-00-enums.md:1
msgid "# Enums and Pattern Matching"
msgstr ""

#: src/ch06-00-enums.md:3
msgid ""
"In this chapter, we‚Äôll look at *enumerations*, also referred to as *enums*.\n"
"Enums allow you to define a type by enumerating its possible *variants*. "
"First\n"
"we‚Äôll define and use an enum to show how an enum can encode meaning along "
"with\n"
"data. Next, we‚Äôll explore a particularly useful enum, called `Option`, "
"which\n"
"expresses that a value can be either something or nothing. Then we‚Äôll look "
"at\n"
"how pattern matching in the `match` expression makes it easy to run "
"different\n"
"code for different values of an enum. Finally, we‚Äôll cover how the `if let`\n"
"construct is another convenient and concise idiom available to handle enums "
"in\n"
"your code."
msgstr ""

#: src/ch06-01-defining-an-enum.md:1
msgid "## Defining an Enum"
msgstr ""

#: src/ch06-01-defining-an-enum.md:3
msgid ""
"Where structs give you a way of grouping together related fields and data, "
"like\n"
"a `Rectangle` with its `width` and `height`, enums give you a way of saying "
"a\n"
"value is one of a possible set of values. For example, we may want to say "
"that\n"
"`Rectangle` is one of a set of possible shapes that also includes `Circle` "
"and\n"
"`Triangle`. To do this, Rust allows us to encode these possibilities as an "
"enum."
msgstr ""

#: src/ch06-01-defining-an-enum.md:9
msgid ""
"Let‚Äôs look at a situation we might want to express in code and see why "
"enums\n"
"are useful and more appropriate than structs in this case. Say we need to "
"work\n"
"with IP addresses. Currently, two major standards are used for IP "
"addresses:\n"
"version four and version six. Because these are the only possibilities for "
"an\n"
"IP address that our program will come across, we can *enumerate* all "
"possible\n"
"variants, which is where enumeration gets its name."
msgstr ""

#: src/ch06-01-defining-an-enum.md:16
msgid ""
"Any IP address can be either a version four or a version six address, but "
"not\n"
"both at the same time. That property of IP addresses makes the enum data\n"
"structure appropriate because an enum value can only be one of its "
"variants.\n"
"Both version four and version six addresses are still fundamentally IP\n"
"addresses, so they should be treated as the same type when the code is "
"handling\n"
"situations that apply to any kind of IP address."
msgstr ""

#: src/ch06-01-defining-an-enum.md:23
msgid ""
"We can express this concept in code by defining an `IpAddrKind` enumeration "
"and\n"
"listing the possible kinds an IP address can be, `V4` and `V6`. These are "
"the\n"
"variants of the enum:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:27
msgid ""
"```rust\n"
"enum IpAddrKind {\n"
"    V4,\n"
"    V6,\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let four = IpAddrKind::V4;\n"
"#     let six = IpAddrKind::V6;\n"
"# \n"
"#     route(IpAddrKind::V4);\n"
"#     route(IpAddrKind::V6);\n"
"# }\n"
"# \n"
"# fn route(ip_kind: IpAddrKind) {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:44
msgid ""
"`IpAddrKind` is now a custom data type that we can use elsewhere in our code."
msgstr ""

#: src/ch06-01-defining-an-enum.md:46
msgid "### Enum Values"
msgstr ""

#: src/ch06-01-defining-an-enum.md:48
msgid ""
"We can create instances of each of the two variants of `IpAddrKind` like "
"this:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:50
msgid ""
"```rust\n"
"# enum IpAddrKind {\n"
"#     V4,\n"
"#     V6,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"    let four = IpAddrKind::V4;\n"
"    let six = IpAddrKind::V6;\n"
"# \n"
"#     route(IpAddrKind::V4);\n"
"#     route(IpAddrKind::V6);\n"
"# }\n"
"# \n"
"# fn route(ip_kind: IpAddrKind) {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:67
msgid ""
"Note that the variants of the enum are namespaced under its identifier, and "
"we\n"
"use a double colon to separate the two. This is useful because now both "
"values\n"
"`IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: `IpAddrKind`. "
"We\n"
"can then, for instance, define a function that takes any `IpAddrKind`:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:72
msgid ""
"```rust\n"
"# enum IpAddrKind {\n"
"#     V4,\n"
"#     V6,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let four = IpAddrKind::V4;\n"
"#     let six = IpAddrKind::V6;\n"
"# \n"
"#     route(IpAddrKind::V4);\n"
"#     route(IpAddrKind::V6);\n"
"# }\n"
"# \n"
"fn route(ip_kind: IpAddrKind) {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:89
msgid "And we can call this function with either variant:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:91
msgid ""
"```rust\n"
"# enum IpAddrKind {\n"
"#     V4,\n"
"#     V6,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let four = IpAddrKind::V4;\n"
"#     let six = IpAddrKind::V6;\n"
"# \n"
"    route(IpAddrKind::V4);\n"
"    route(IpAddrKind::V6);\n"
"# }\n"
"# \n"
"# fn route(ip_kind: IpAddrKind) {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:108
msgid ""
"Using enums has even more advantages. Thinking more about our IP address "
"type,\n"
"at the moment we don‚Äôt have a way to store the actual IP address *data*; we\n"
"only know what *kind* it is. Given that you just learned about structs in\n"
"Chapter 5, you might be tempted to tackle this problem with structs as shown "
"in\n"
"Listing 6-1."
msgstr ""

#: src/ch06-01-defining-an-enum.md:114
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum IpAddrKind {\n"
"        V4,\n"
"        V6,\n"
"    }\n"
"\n"
"    struct IpAddr {\n"
"        kind: IpAddrKind,\n"
"        address: String,\n"
"    }\n"
"\n"
"    let home = IpAddr {\n"
"        kind: IpAddrKind::V4,\n"
"        address: String::from(\"127.0.0.1\"),\n"
"    };\n"
"\n"
"    let loopback = IpAddr {\n"
"        kind: IpAddrKind::V6,\n"
"        address: String::from(\"::1\"),\n"
"    };\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:138
msgid ""
"<span class=\"caption\">Listing 6-1: Storing the data and `IpAddrKind` "
"variant of\n"
"an IP address using a `struct`</span>"
msgstr ""

#: src/ch06-01-defining-an-enum.md:141
msgid ""
"Here, we‚Äôve defined a struct `IpAddr` that has two fields: a `kind` field "
"that\n"
"is of type `IpAddrKind` (the enum we defined previously) and an `address` "
"field\n"
"of type `String`. We have two instances of this struct. The first is "
"`home`,\n"
"and it has the value `IpAddrKind::V4` as its `kind` with associated address\n"
"data of `127.0.0.1`. The second instance is `loopback`. It has the other\n"
"variant of `IpAddrKind` as its `kind` value, `V6`, and has address `::1`\n"
"associated with it. We‚Äôve used a struct to bundle the `kind` and `address`\n"
"values together, so now the variant is associated with the value."
msgstr ""

#: src/ch06-01-defining-an-enum.md:150
msgid ""
"However, representing the same concept using just an enum is more concise:\n"
"rather than an enum inside a struct, we can put data directly into each "
"enum\n"
"variant. This new definition of the `IpAddr` enum says that both `V4` and "
"`V6`\n"
"variants will have associated `String` values:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:155
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum IpAddr {\n"
"        V4(String),\n"
"        V6(String),\n"
"    }\n"
"\n"
"    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n"
"\n"
"    let loopback = IpAddr::V6(String::from(\"::1\"));\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:168
msgid ""
"We attach data to each variant of the enum directly, so there is no need for "
"an\n"
"extra struct. Here, it‚Äôs also easier to see another detail of how enums "
"work:\n"
"the name of each enum variant that we define also becomes a function that\n"
"constructs an instance of the enum. That is, `IpAddr::V4()` is a function "
"call\n"
"that takes a `String` argument and returns an instance of the `IpAddr` type. "
"We\n"
"automatically get this constructor function defined as a result of defining "
"the\n"
"enum."
msgstr ""

#: src/ch06-01-defining-an-enum.md:176
msgid ""
"There‚Äôs another advantage to using an enum rather than a struct: each "
"variant\n"
"can have different types and amounts of associated data. Version four IP\n"
"addresses will always have four numeric components that will have values\n"
"between 0 and 255. If we wanted to store `V4` addresses as four `u8` values "
"but\n"
"still express `V6` addresses as one `String` value, we wouldn‚Äôt be able to "
"with\n"
"a struct. Enums handle this case with ease:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:183
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum IpAddr {\n"
"        V4(u8, u8, u8, u8),\n"
"        V6(String),\n"
"    }\n"
"\n"
"    let home = IpAddr::V4(127, 0, 0, 1);\n"
"\n"
"    let loopback = IpAddr::V6(String::from(\"::1\"));\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:196
msgid ""
"We‚Äôve shown several different ways to define data structures to store "
"version\n"
"four and version six IP addresses. However, as it turns out, wanting to "
"store\n"
"IP addresses and encode which kind they are is so common that [the standard\n"
"library has a definition we can use!][IpAddr]<!-- ignore --> Let‚Äôs look at "
"how\n"
"the standard library defines `IpAddr`: it has the exact enum and variants "
"that\n"
"we‚Äôve defined and used, but it embeds the address data inside the variants "
"in\n"
"the form of two different structs, which are defined differently for each\n"
"variant:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:205
msgid ""
"```rust\n"
"struct Ipv4Addr {\n"
"    // --snip--\n"
"}\n"
"\n"
"struct Ipv6Addr {\n"
"    // --snip--\n"
"}\n"
"\n"
"enum IpAddr {\n"
"    V4(Ipv4Addr),\n"
"    V6(Ipv6Addr),\n"
"}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:220
msgid ""
"This code illustrates that you can put any kind of data inside an enum "
"variant:\n"
"strings, numeric types, or structs, for example. You can even include "
"another\n"
"enum! Also, standard library types are often not much more complicated than\n"
"what you might come up with."
msgstr ""

#: src/ch06-01-defining-an-enum.md:225
msgid ""
"Note that even though the standard library contains a definition for "
"`IpAddr`,\n"
"we can still create and use our own definition without conflict because we\n"
"haven‚Äôt brought the standard library‚Äôs definition into our scope. We‚Äôll "
"talk\n"
"more about bringing types into scope in Chapter 7."
msgstr ""

#: src/ch06-01-defining-an-enum.md:230
msgid ""
"Let‚Äôs look at another example of an enum in Listing 6-2: this one has a "
"wide\n"
"variety of types embedded in its variants."
msgstr ""

#: src/ch06-01-defining-an-enum.md:233 src/ch15-01-box.md:194
msgid ""
"```rust\n"
"enum Message {\n"
"    Quit,\n"
"    Move { x: i32, y: i32 },\n"
"    Write(String),\n"
"    ChangeColor(i32, i32, i32),\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:244
msgid ""
"<span class=\"caption\">Listing 6-2: A `Message` enum whose variants each "
"store\n"
"different amounts and types of values</span>"
msgstr ""

#: src/ch06-01-defining-an-enum.md:247
msgid "This enum has four variants with different types:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:249
msgid ""
"* `Quit` has no data associated with it at all.\n"
"* `Move` has named fields, like a struct does.\n"
"* `Write` includes a single `String`.\n"
"* `ChangeColor` includes three `i32` values."
msgstr ""

#: src/ch06-01-defining-an-enum.md:254
msgid ""
"Defining an enum with variants such as the ones in Listing 6-2 is similar "
"to\n"
"defining different kinds of struct definitions, except the enum doesn‚Äôt use "
"the\n"
"`struct` keyword and all the variants are grouped together under the "
"`Message`\n"
"type. The following structs could hold the same data that the preceding "
"enum\n"
"variants hold:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:260
msgid ""
"```rust\n"
"struct QuitMessage; // unit struct\n"
"struct MoveMessage {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"struct WriteMessage(String); // tuple struct\n"
"struct ChangeColorMessage(i32, i32, i32); // tuple struct\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:272
msgid ""
"But if we used the different structs, each of which has its own type, we\n"
"couldn‚Äôt as easily define a function to take any of these kinds of messages "
"as\n"
"we could with the `Message` enum defined in Listing 6-2, which is a single "
"type."
msgstr ""

#: src/ch06-01-defining-an-enum.md:276
msgid ""
"There is one more similarity between enums and structs: just as we‚Äôre able "
"to\n"
"define methods on structs using `impl`, we‚Äôre also able to define methods "
"on\n"
"enums. Here‚Äôs a method named `call` that we could define on our `Message` "
"enum:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:280
msgid ""
"```rust\n"
"# fn main() {\n"
"#     enum Message {\n"
"#         Quit,\n"
"#         Move { x: i32, y: i32 },\n"
"#         Write(String),\n"
"#         ChangeColor(i32, i32, i32),\n"
"#     }\n"
"# \n"
"    impl Message {\n"
"        fn call(&self) {\n"
"            // method body would be defined here\n"
"        }\n"
"    }\n"
"\n"
"    let m = Message::Write(String::from(\"hello\"));\n"
"    m.call();\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:300
msgid ""
"The body of the method would use `self` to get the value that we called the\n"
"method on. In this example, we‚Äôve created a variable `m` that has the value\n"
"`Message::Write(String::from(\"hello\"))`, and that is what `self` will be "
"in the\n"
"body of the `call` method when `m.call()` runs."
msgstr ""

#: src/ch06-01-defining-an-enum.md:305
msgid ""
"Let‚Äôs look at another enum in the standard library that is very common and\n"
"useful: `Option`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:308
msgid "### The `Option` Enum and Its Advantages Over Null Values"
msgstr ""

#: src/ch06-01-defining-an-enum.md:310
msgid ""
"This section explores a case study of `Option`, which is another enum "
"defined\n"
"by the standard library. The `Option` type encodes the very common scenario "
"in\n"
"which a value could be something or it could be nothing."
msgstr ""

#: src/ch06-01-defining-an-enum.md:314
msgid ""
"For example, if you request the first item in a non-empty list, you would "
"get\n"
"a value. If you request the first item in an empty list, you would get "
"nothing.\n"
"Expressing this concept in terms of the type system means the compiler can\n"
"check whether you‚Äôve handled all the cases you should be handling; this\n"
"functionality can prevent bugs that are extremely common in other "
"programming\n"
"languages."
msgstr ""

#: src/ch06-01-defining-an-enum.md:321
msgid ""
"Programming language design is often thought of in terms of which features "
"you\n"
"include, but the features you exclude are important too. Rust doesn‚Äôt have "
"the\n"
"null feature that many other languages have. *Null* is a value that means "
"there\n"
"is no value there. In languages with null, variables can always be in one "
"of\n"
"two states: null or not-null."
msgstr ""

#: src/ch06-01-defining-an-enum.md:327
msgid ""
"In his 2009 presentation ‚ÄúNull References: The Billion Dollar Mistake,‚Äù "
"Tony\n"
"Hoare, the inventor of null, has this to say:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:330
msgid ""
"> I call it my billion-dollar mistake. At that time, I was designing the "
"first\n"
"> comprehensive type system for references in an object-oriented language. "
"My\n"
"> goal was to ensure that all use of references should be absolutely safe, "
"with\n"
"> checking performed automatically by the compiler. But I couldn‚Äôt resist "
"the\n"
"> temptation to put in a null reference, simply because it was so easy to\n"
"> implement. This has led to innumerable errors, vulnerabilities, and "
"system\n"
"> crashes, which have probably caused a billion dollars of pain and damage "
"in\n"
"> the last forty years."
msgstr ""

#: src/ch06-01-defining-an-enum.md:339
msgid ""
"The problem with null values is that if you try to use a null value as a\n"
"not-null value, you‚Äôll get an error of some kind. Because this null or not-"
"null\n"
"property is pervasive, it‚Äôs extremely easy to make this kind of error."
msgstr ""

#: src/ch06-01-defining-an-enum.md:343
msgid ""
"However, the concept that null is trying to express is still a useful one: "
"a\n"
"null is a value that is currently invalid or absent for some reason."
msgstr ""

#: src/ch06-01-defining-an-enum.md:346
msgid ""
"The problem isn‚Äôt really with the concept but with the particular\n"
"implementation. As such, Rust does not have nulls, but it does have an enum\n"
"that can encode the concept of a value being present or absent. This enum "
"is\n"
"`Option<T>`, and it is [defined by the standard library][option]<!-- ignore "
"-->\n"
"as follows:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:352
msgid ""
"```rust\n"
"enum Option<T> {\n"
"    None,\n"
"    Some(T),\n"
"}\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:359
msgid ""
"The `Option<T>` enum is so useful that it‚Äôs even included in the prelude; "
"you\n"
"don‚Äôt need to bring it into scope explicitly. Its variants are also included "
"in\n"
"the prelude: you can use `Some` and `None` directly without the `Option::`\n"
"prefix. The `Option<T>` enum is still just a regular enum, and `Some(T)` "
"and\n"
"`None` are still variants of type `Option<T>`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:365
msgid ""
"The `<T>` syntax is a feature of Rust we haven‚Äôt talked about yet. It‚Äôs a\n"
"generic type parameter, and we‚Äôll cover generics in more detail in Chapter "
"10.\n"
"For now, all you need to know is that `<T>` means that the `Some` variant "
"of\n"
"the `Option` enum can hold one piece of data of any type, and that each\n"
"concrete type that gets used in place of `T` makes the overall `Option<T>` "
"type\n"
"a different type. Here are some examples of using `Option` values to hold\n"
"number types and string types:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:373
msgid ""
"```rust\n"
"# fn main() {\n"
"    let some_number = Some(5);\n"
"    let some_char = Some('e');\n"
"\n"
"    let absent_number: Option<i32> = None;\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:382
msgid ""
"The type of `some_number` is `Option<i32>`. The type of `some_char` is\n"
"`Option<char>`, which is a different type. Rust can infer these types "
"because\n"
"we‚Äôve specified a value inside the `Some` variant. For `absent_number`, "
"Rust\n"
"requires us to annotate the overall `Option` type: the compiler can‚Äôt infer "
"the\n"
"type that the corresponding `Some` variant will hold by looking only at a\n"
"`None` value. Here, we tell Rust that we mean for `absent_number` to be of "
"type\n"
"`Option<i32>`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:390
msgid ""
"When we have a `Some` value, we know that a value is present and the value "
"is\n"
"held within the `Some`. When we have a `None` value, in some sense it means "
"the\n"
"same thing as null: we don‚Äôt have a valid value. So why is having "
"`Option<T>`\n"
"any better than having null?"
msgstr ""

#: src/ch06-01-defining-an-enum.md:395
msgid ""
"In short, because `Option<T>` and `T` (where `T` can be any type) are "
"different\n"
"types, the compiler won‚Äôt let us use an `Option<T>` value as if it were\n"
"definitely a valid value. For example, this code won‚Äôt compile, because "
"it‚Äôs\n"
"trying to add an `i8` to an `Option<i8>`:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:400
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let x: i8 = 5;\n"
"    let y: Option<i8> = Some(5);\n"
"\n"
"    let sum = x + y;\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:409
msgid "If we run this code, we get an error message like this one:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:411
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling enums v0.1.0 (file:///projects/enums)\n"
"error[E0277]: cannot add `Option<i8>` to `i8`\n"
" --> src/main.rs:5:17\n"
"  |\n"
"5 |     let sum = x + y;\n"
"  |                 ^ no implementation for `i8 + Option<i8>`\n"
"  |\n"
"  = help: the trait `Add<Option<i8>>` is not implemented for `i8`\n"
"  = help: the following other types implement trait `Add<Rhs>`:\n"
"            <&'a i8 as Add<i8>>\n"
"            <&i8 as Add<&i8>>\n"
"            <i8 as Add<&i8>>\n"
"            <i8 as Add>\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `enums` due to previous error\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:431
msgid ""
"Intense! In effect, this error message means that Rust doesn‚Äôt understand "
"how\n"
"to add an `i8` and an `Option<i8>`, because they‚Äôre different types. When "
"we\n"
"have a value of a type like `i8` in Rust, the compiler will ensure that we\n"
"always have a valid value. We can proceed confidently without having to "
"check\n"
"for null before using that value. Only when we have an `Option<i8>` (or\n"
"whatever type of value we‚Äôre working with) do we have to worry about "
"possibly\n"
"not having a value, and the compiler will make sure we handle that case "
"before\n"
"using the value."
msgstr ""

#: src/ch06-01-defining-an-enum.md:440
msgid ""
"In other words, you have to convert an `Option<T>` to a `T` before you can\n"
"perform `T` operations with it. Generally, this helps catch one of the most\n"
"common issues with null: assuming that something isn‚Äôt null when it actually "
"is."
msgstr ""

#: src/ch06-01-defining-an-enum.md:444
msgid ""
"Eliminating the risk of incorrectly assuming a not-null value helps you to "
"be\n"
"more confident in your code. In order to have a value that can possibly be\n"
"null, you must explicitly opt in by making the type of that value "
"`Option<T>`.\n"
"Then, when you use that value, you are required to explicitly handle the "
"case\n"
"when the value is null. Everywhere that a value has a type that isn‚Äôt an\n"
"`Option<T>`, you *can* safely assume that the value isn‚Äôt null. This was a\n"
"deliberate design decision for Rust to limit null‚Äôs pervasiveness and "
"increase\n"
"the safety of Rust code."
msgstr ""

#: src/ch06-01-defining-an-enum.md:453
msgid ""
"So how do you get the `T` value out of a `Some` variant when you have a "
"value\n"
"of type `Option<T>` so that you can use that value? The `Option<T>` enum has "
"a\n"
"large number of methods that are useful in a variety of situations; you can\n"
"check them out in [its documentation][docs]<!-- ignore -->. Becoming "
"familiar\n"
"with the methods on `Option<T>` will be extremely useful in your journey "
"with\n"
"Rust."
msgstr ""

#: src/ch06-01-defining-an-enum.md:460
msgid ""
"In general, in order to use an `Option<T>` value, you want to have code "
"that\n"
"will handle each variant. You want some code that will run only when you "
"have a\n"
"`Some(T)` value, and this code is allowed to use the inner `T`. You want "
"some\n"
"other code to run only if you have a `None` value, and that code doesn‚Äôt "
"have a\n"
"`T` value available. The `match` expression is a control flow construct "
"that\n"
"does just this when used with enums: it will run different code depending "
"on\n"
"which variant of the enum it has, and that code can use the data inside the\n"
"matching value."
msgstr ""

#: src/ch06-02-match.md:2
msgid "<a id=\"the-match-control-flow-operator\"></a>"
msgstr ""

#: src/ch06-02-match.md:3
msgid "## The `match` Control Flow Construct"
msgstr ""

#: src/ch06-02-match.md:5
msgid ""
"Rust has an extremely powerful control flow construct called `match` that\n"
"allows you to compare a value against a series of patterns and then execute\n"
"code based on which pattern matches. Patterns can be made up of literal "
"values,\n"
"variable names, wildcards, and many other things; [Chapter\n"
"18][ch18-00-patterns]<!-- ignore --> covers all the different kinds of "
"patterns\n"
"and what they do. The power of `match` comes from the expressiveness of the\n"
"patterns and the fact that the compiler confirms that all possible cases "
"are\n"
"handled."
msgstr ""

#: src/ch06-02-match.md:14
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide\n"
"down a track with variously sized holes along it, and each coin falls "
"through\n"
"the first hole it encounters that it fits into. In the same way, values go\n"
"through each pattern in a `match`, and at the first pattern the value "
"‚Äúfits,‚Äù\n"
"the value falls into the associated code block to be used during execution."
msgstr ""

#: src/ch06-02-match.md:20
msgid ""
"Speaking of coins, let‚Äôs use them as an example using `match`! We can write "
"a\n"
"function that takes an unknown US coin and, in a similar way as the "
"counting\n"
"machine, determines which coin it is and returns its value in cents, as "
"shown\n"
"in Listing 6-3."
msgstr ""

#: src/ch06-02-match.md:25
msgid ""
"```rust\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> u8 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch06-02-match.md:45
msgid ""
"<span class=\"caption\">Listing 6-3: An enum and a `match` expression that "
"has\n"
"the variants of the enum as its patterns</span>"
msgstr ""

#: src/ch06-02-match.md:48
msgid ""
"Let‚Äôs break down the `match` in the `value_in_cents` function. First we "
"list\n"
"the `match` keyword followed by an expression, which in this case is the "
"value\n"
"`coin`. This seems very similar to a conditional expression used with `if`, "
"but\n"
"there‚Äôs a big difference: with `if`, the condition needs to evaluate to a\n"
"Boolean value, but here it can be any type. The type of `coin` in this "
"example\n"
"is the `Coin` enum that we defined on the first line."
msgstr ""

#: src/ch06-02-match.md:55
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The\n"
"first arm here has a pattern that is the value `Coin::Penny` and then the "
"`=>`\n"
"operator that separates the pattern and the code to run. The code in this "
"case\n"
"is just the value `1`. Each arm is separated from the next with a comma."
msgstr ""

#: src/ch06-02-match.md:60
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against\n"
"the pattern of each arm, in order. If a pattern matches the value, the code\n"
"associated with that pattern is executed. If that pattern doesn‚Äôt match the\n"
"value, execution continues to the next arm, much as in a coin-sorting "
"machine.\n"
"We can have as many arms as we need: in Listing 6-3, our `match` has four "
"arms."
msgstr ""

#: src/ch06-02-match.md:66
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of\n"
"the expression in the matching arm is the value that gets returned for the\n"
"entire `match` expression."
msgstr ""

#: src/ch06-02-match.md:70
msgid ""
"We don‚Äôt typically use curly brackets if the match arm code is short, as it "
"is\n"
"in Listing 6-3 where each arm just returns a value. If you want to run "
"multiple\n"
"lines of code in a match arm, you must use curly brackets, and the comma\n"
"following the arm is then optional. For example, the following code prints\n"
"‚ÄúLucky penny!‚Äù every time the method is called with a `Coin::Penny`, but "
"still\n"
"returns the last value of the block, `1`:"
msgstr ""

#: src/ch06-02-match.md:77
msgid ""
"```rust\n"
"# enum Coin {\n"
"#     Penny,\n"
"#     Nickel,\n"
"#     Dime,\n"
"#     Quarter,\n"
"# }\n"
"# \n"
"fn value_in_cents(coin: Coin) -> u8 {\n"
"    match coin {\n"
"        Coin::Penny => {\n"
"            println!(\"Lucky penny!\");\n"
"            1\n"
"        }\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch06-02-match.md:100
msgid "### Patterns That Bind to Values"
msgstr ""

#: src/ch06-02-match.md:102
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the\n"
"values that match the pattern. This is how we can extract values out of "
"enum\n"
"variants."
msgstr ""

#: src/ch06-02-match.md:106
msgid ""
"As an example, let‚Äôs change one of our enum variants to hold data inside "
"it.\n"
"From 1999 through 2008, the United States minted quarters with different\n"
"designs for each of the 50 states on one side. No other coins got state\n"
"designs, so only quarters have this extra value. We can add this information "
"to\n"
"our `enum` by changing the `Quarter` variant to include a `UsState` value\n"
"stored inside it, which we‚Äôve done in Listing 6-4."
msgstr ""

#: src/ch06-02-match.md:113
msgid ""
"```rust\n"
"#[derive(Debug)] // so we can inspect the state in a minute\n"
"enum UsState {\n"
"    Alabama,\n"
"    Alaska,\n"
"    // --snip--\n"
"}\n"
"\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter(UsState),\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch06-02-match.md:131
msgid ""
"<span class=\"caption\">Listing 6-4: A `Coin` enum in which the `Quarter` "
"variant\n"
"also holds a `UsState` value</span>"
msgstr ""

#: src/ch06-02-match.md:134
msgid ""
"Let‚Äôs imagine that a friend is trying to collect all 50 state quarters. "
"While\n"
"we sort our loose change by coin type, we‚Äôll also call out the name of the\n"
"state associated with each quarter so that if it‚Äôs one our friend doesn‚Äôt "
"have,\n"
"they can add it to their collection."
msgstr ""

#: src/ch06-02-match.md:139
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the\n"
"pattern that matches values of the variant `Coin::Quarter`. When a\n"
"`Coin::Quarter` matches, the `state` variable will bind to the value of "
"that\n"
"quarter‚Äôs state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch06-02-match.md:144
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# enum UsState {\n"
"#     Alabama,\n"
"#     Alaska,\n"
"#     // --snip--\n"
"# }\n"
"# \n"
"# enum Coin {\n"
"#     Penny,\n"
"#     Nickel,\n"
"#     Dime,\n"
"#     Quarter(UsState),\n"
"# }\n"
"# \n"
"fn value_in_cents(coin: Coin) -> u8 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter(state) => {\n"
"            println!(\"State quarter from {:?}!\", state);\n"
"            25\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     value_in_cents(Coin::Quarter(UsState::Alaska));\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:176
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`\n"
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each\n"
"of the match arms, none of them match until we reach `Coin::Quarter(state)`. "
"At\n"
"that point, the binding for `state` will be the value `UsState::Alaska`. We "
"can\n"
"then use that binding in the `println!` expression, thus getting the inner\n"
"state value out of the `Coin` enum variant for `Quarter`."
msgstr ""

#: src/ch06-02-match.md:183
msgid "### Matching with `Option<T>`"
msgstr ""

#: src/ch06-02-match.md:185
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some`\n"
"case when using `Option<T>`; we can also handle `Option<T>` using `match`, "
"as\n"
"we did with the `Coin` enum! Instead of comparing coins, we‚Äôll compare the\n"
"variants of `Option<T>`, but the way the `match` expression works remains "
"the\n"
"same."
msgstr ""

#: src/ch06-02-match.md:191
msgid ""
"Let‚Äôs say we want to write a function that takes an `Option<i32>` and, if\n"
"there‚Äôs a value inside, adds 1 to that value. If there isn‚Äôt a value "
"inside,\n"
"the function should return the `None` value and not attempt to perform any\n"
"operations."
msgstr ""

#: src/ch06-02-match.md:196
msgid ""
"This function is very easy to write, thanks to `match`, and will look like\n"
"Listing 6-5."
msgstr ""

#: src/ch06-02-match.md:199
msgid ""
"```rust\n"
"# fn main() {\n"
"    fn plus_one(x: Option<i32>) -> Option<i32> {\n"
"        match x {\n"
"            None => None,\n"
"            Some(i) => Some(i + 1),\n"
"        }\n"
"    }\n"
"\n"
"    let five = Some(5);\n"
"    let six = plus_one(five);\n"
"    let none = plus_one(None);\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:214
msgid ""
"<span class=\"caption\">Listing 6-5: A function that uses a `match` "
"expression on\n"
"an `Option<i32>`</span>"
msgstr ""

#: src/ch06-02-match.md:217
msgid ""
"Let‚Äôs examine the first execution of `plus_one` in more detail. When we "
"call\n"
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the\n"
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""

#: src/ch06-02-match.md:221 src/ch06-02-match.md:262
msgid ""
"```rust,ignore\n"
"# fn main() {\n"
"#     fn plus_one(x: Option<i32>) -> Option<i32> {\n"
"#         match x {\n"
"            None => None,\n"
"#             Some(i) => Some(i + 1),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     let five = Some(5);\n"
"#     let six = plus_one(five);\n"
"#     let none = plus_one(None);\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:236
msgid ""
"The `Some(5)` value doesn‚Äôt match the pattern `None`, so we continue to the\n"
"next arm:"
msgstr ""

#: src/ch06-02-match.md:239
msgid ""
"```rust,ignore\n"
"# fn main() {\n"
"#     fn plus_one(x: Option<i32>) -> Option<i32> {\n"
"#         match x {\n"
"#             None => None,\n"
"            Some(i) => Some(i + 1),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     let five = Some(5);\n"
"#     let six = plus_one(five);\n"
"#     let none = plus_one(None);\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:254
msgid ""
"Does `Some(5)` match `Some(i)`? It does! We have the same variant. The `i`\n"
"binds to the value contained in `Some`, so `i` takes the value `5`. The code "
"in\n"
"the match arm is then executed, so we add 1 to the value of `i` and create "
"a\n"
"new `Some` value with our total `6` inside."
msgstr ""

#: src/ch06-02-match.md:259
msgid ""
"Now let‚Äôs consider the second call of `plus_one` in Listing 6-5, where `x` "
"is\n"
"`None`. We enter the `match` and compare to the first arm:"
msgstr ""

#: src/ch06-02-match.md:277
msgid ""
"It matches! There‚Äôs no value to add to, so the program stops and returns "
"the\n"
"`None` value on the right side of `=>`. Because the first arm matched, no "
"other\n"
"arms are compared."
msgstr ""

#: src/ch06-02-match.md:281
msgid ""
"Combining `match` and enums is useful in many situations. You‚Äôll see this\n"
"pattern a lot in Rust code: `match` against an enum, bind a variable to the\n"
"data inside, and then execute code based on it. It‚Äôs a bit tricky at first, "
"but\n"
"once you get used to it, you‚Äôll wish you had it in all languages. It‚Äôs\n"
"consistently a user favorite."
msgstr ""

#: src/ch06-02-match.md:287
msgid "### Matches Are Exhaustive"
msgstr ""

#: src/ch06-02-match.md:289
msgid ""
"There‚Äôs one other aspect of `match` we need to discuss: the arms‚Äô patterns "
"must\n"
"cover all possibilities. Consider this version of our `plus_one` function,\n"
"which has a bug and won‚Äôt compile:"
msgstr ""

#: src/ch06-02-match.md:293
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    fn plus_one(x: Option<i32>) -> Option<i32> {\n"
"        match x {\n"
"            Some(i) => Some(i + 1),\n"
"        }\n"
"    }\n"
"# \n"
"#     let five = Some(5);\n"
"#     let six = plus_one(five);\n"
"#     let none = plus_one(None);\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:307
msgid ""
"We didn‚Äôt handle the `None` case, so this code will cause a bug. Luckily, "
"it‚Äôs\n"
"a bug Rust knows how to catch. If we try to compile this code, we‚Äôll get "
"this\n"
"error:"
msgstr ""

#: src/ch06-02-match.md:311
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling enums v0.1.0 (file:///projects/enums)\n"
"error[E0004]: non-exhaustive patterns: `None` not covered\n"
" --> src/main.rs:3:15\n"
"  |\n"
"3 |         match x {\n"
"  |               ^ pattern `None` not covered\n"
"  |\n"
"note: `Option<i32>` defined here\n"
" --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option."
"rs:518:1\n"
"  |\n"
"  = note: \n"
"/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option."
"rs:522:5: not covered\n"
"  = note: the matched value is of type `Option<i32>`\n"
"help: ensure that all possible cases are being handled by adding a match arm "
"with a wildcard pattern or an explicit pattern as shown\n"
"  |\n"
"4 ~             Some(i) => Some(i + 1),\n"
"5 ~             None => todo!(),\n"
"  |\n"
"\n"
"For more information about this error, try `rustc --explain E0004`.\n"
"error: could not compile `enums` due to previous error\n"
"```"
msgstr ""

#: src/ch06-02-match.md:336
msgid ""
"Rust knows that we didn‚Äôt cover every possible case, and even knows which\n"
"pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every "
"last\n"
"possibility in order for the code to be valid. Especially in the case of\n"
"`Option<T>`, when Rust prevents us from forgetting to explicitly handle the\n"
"`None` case, it protects us from assuming that we have a value when we "
"might\n"
"have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""

#: src/ch06-02-match.md:343
msgid "### Catch-all Patterns and the `_` Placeholder"
msgstr ""

#: src/ch06-02-match.md:345
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but\n"
"for all other values take one default action. Imagine we‚Äôre implementing a "
"game\n"
"where, if you roll a 3 on a dice roll, your player doesn‚Äôt move, but "
"instead\n"
"gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For "
"all\n"
"other values, your player moves that number of spaces on the game board. "
"Here‚Äôs\n"
"a `match` that implements that logic, with the result of the dice roll\n"
"hardcoded rather than a random value, and all other logic represented by\n"
"functions without bodies because actually implementing them is out of scope "
"for\n"
"this example:"
msgstr ""

#: src/ch06-02-match.md:355
msgid ""
"```rust\n"
"# fn main() {\n"
"    let dice_roll = 9;\n"
"    match dice_roll {\n"
"        3 => add_fancy_hat(),\n"
"        7 => remove_fancy_hat(),\n"
"        other => move_player(other),\n"
"    }\n"
"\n"
"    fn add_fancy_hat() {}\n"
"    fn remove_fancy_hat() {}\n"
"    fn move_player(num_spaces: u8) {}\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:370
msgid ""
"For the first two arms, the patterns are the literal values `3` and `7`. "
"For\n"
"the last arm that covers every other possible value, the pattern is the\n"
"variable we‚Äôve chosen to name `other`. The code that runs for the `other` "
"arm\n"
"uses the variable by passing it to the `move_player` function."
msgstr ""

#: src/ch06-02-match.md:375
msgid ""
"This code compiles, even though we haven‚Äôt listed all the possible values a\n"
"`u8` can have, because the last pattern will match all values not "
"specifically\n"
"listed. This catch-all pattern meets the requirement that `match` must be\n"
"exhaustive. Note that we have to put the catch-all arm last because the\n"
"patterns are evaluated in order. If we put the catch-all arm earlier, the "
"other\n"
"arms would never run, so Rust will warn us if we add arms after a catch-all!"
msgstr ""

#: src/ch06-02-match.md:382
msgid ""
"Rust also has a pattern we can use when we want a catch-all but don‚Äôt want "
"to\n"
"*use* the value in the catch-all pattern: `_` is a special pattern that "
"matches\n"
"any value and does not bind to that value. This tells Rust we aren‚Äôt going "
"to\n"
"use the value, so Rust won‚Äôt warn us about an unused variable."
msgstr ""

#: src/ch06-02-match.md:387
msgid ""
"Let‚Äôs change the rules of the game: now, if you roll anything other than a 3 "
"or\n"
"a 7, you must roll again. We no longer need to use the catch-all value, so "
"we\n"
"can change our code to use `_` instead of the variable named `other`:"
msgstr ""

#: src/ch06-02-match.md:391
msgid ""
"```rust\n"
"# fn main() {\n"
"    let dice_roll = 9;\n"
"    match dice_roll {\n"
"        3 => add_fancy_hat(),\n"
"        7 => remove_fancy_hat(),\n"
"        _ => reroll(),\n"
"    }\n"
"\n"
"    fn add_fancy_hat() {}\n"
"    fn remove_fancy_hat() {}\n"
"    fn reroll() {}\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:406
msgid ""
"This example also meets the exhaustiveness requirement because we‚Äôre "
"explicitly\n"
"ignoring all other values in the last arm; we haven‚Äôt forgotten anything."
msgstr ""

#: src/ch06-02-match.md:409
msgid ""
"Finally, we‚Äôll change the rules of the game one more time so that nothing "
"else\n"
"happens on your turn if you roll anything other than a 3 or a 7. We can "
"express\n"
"that by using the unit value (the empty tuple type we mentioned in [‚ÄúThe "
"Tuple\n"
"Type‚Äù][tuples]<!-- ignore --> section) as the code that goes with the `_` "
"arm:"
msgstr ""

#: src/ch06-02-match.md:414
msgid ""
"```rust\n"
"# fn main() {\n"
"    let dice_roll = 9;\n"
"    match dice_roll {\n"
"        3 => add_fancy_hat(),\n"
"        7 => remove_fancy_hat(),\n"
"        _ => (),\n"
"    }\n"
"\n"
"    fn add_fancy_hat() {}\n"
"    fn remove_fancy_hat() {}\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-02-match.md:428
msgid ""
"Here, we‚Äôre telling Rust explicitly that we aren‚Äôt going to use any other "
"value\n"
"that doesn‚Äôt match a pattern in an earlier arm, and we don‚Äôt want to run "
"any\n"
"code in this case."
msgstr ""

#: src/ch06-02-match.md:432
msgid ""
"There‚Äôs more about patterns and matching that we‚Äôll cover in [Chapter\n"
"18][ch18-00-patterns]<!-- ignore -->. For now, we‚Äôre going to move on to "
"the\n"
"`if let` syntax, which can be useful in situations where the `match` "
"expression\n"
"is a bit wordy."
msgstr ""

#: src/ch06-03-if-let.md:1
msgid "## Concise Control Flow with `if let`"
msgstr ""

#: src/ch06-03-if-let.md:3
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to\n"
"handle values that match one pattern while ignoring the rest. Consider the\n"
"program in Listing 6-6 that matches on an `Option<u8>` value in the\n"
"`config_max` variable but only wants to execute code if the value is the "
"`Some`\n"
"variant."
msgstr ""

#: src/ch06-03-if-let.md:9
msgid ""
"```rust\n"
"# fn main() {\n"
"    let config_max = Some(3u8);\n"
"    match config_max {\n"
"        Some(max) => println!(\"The maximum is configured to be {}\", max),\n"
"        _ => (),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-03-if-let.md:19
msgid ""
"<span class=\"caption\">Listing 6-6: A `match` that only cares about "
"executing\n"
"code when the value is `Some`</span>"
msgstr ""

#: src/ch06-03-if-let.md:22
msgid ""
"If the value is `Some`, we print out the value in the `Some` variant by "
"binding\n"
"the value to the variable `max` in the pattern. We don‚Äôt want to do "
"anything\n"
"with the `None` value. To satisfy the `match` expression, we have to add `_ "
"=>\n"
"()` after processing just one variant, which is annoying boilerplate code "
"to\n"
"add."
msgstr ""

#: src/ch06-03-if-let.md:28
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following\n"
"code behaves the same as the `match` in Listing 6-6:"
msgstr ""

#: src/ch06-03-if-let.md:31
msgid ""
"```rust\n"
"# fn main() {\n"
"    let config_max = Some(3u8);\n"
"    if let Some(max) = config_max {\n"
"        println!(\"The maximum is configured to be {}\", max);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-03-if-let.md:40
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal\n"
"sign. It works the same way as a `match`, where the expression is given to "
"the\n"
"`match` and the pattern is its first arm. In this case, the pattern is\n"
"`Some(max)`, and the `max` binds to the value inside the `Some`. We can "
"then\n"
"use `max` in the body of the `if let` block in the same way we used `max` "
"in\n"
"the corresponding `match` arm. The code in the `if let` block isn‚Äôt run if "
"the\n"
"value doesn‚Äôt match the pattern."
msgstr ""

#: src/ch06-03-if-let.md:48
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code.\n"
"However, you lose the exhaustive checking that `match` enforces. Choosing\n"
"between `match` and `if let` depends on what you‚Äôre doing in your "
"particular\n"
"situation and whether gaining conciseness is an appropriate trade-off for\n"
"losing exhaustive checking."
msgstr ""

#: src/ch06-03-if-let.md:54
msgid ""
"In other words, you can think of `if let` as syntax sugar for a `match` "
"that\n"
"runs code when the value matches one pattern and then ignores all other "
"values."
msgstr ""

#: src/ch06-03-if-let.md:57
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"the\n"
"`else` is the same as the block of code that would go with the `_` case in "
"the\n"
"`match` expression that is equivalent to the `if let` and `else`. Recall "
"the\n"
"`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held "
"a\n"
"`UsState` value. If we wanted to count all non-quarter coins we see while "
"also\n"
"announcing the state of the quarters, we could do that with a `match`\n"
"expression, like this:"
msgstr ""

#: src/ch06-03-if-let.md:65
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# enum UsState {\n"
"#     Alabama,\n"
"#     Alaska,\n"
"#     // --snip--\n"
"# }\n"
"# \n"
"# enum Coin {\n"
"#     Penny,\n"
"#     Nickel,\n"
"#     Dime,\n"
"#     Quarter(UsState),\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let coin = Coin::Penny;\n"
"    let mut count = 0;\n"
"    match coin {\n"
"        Coin::Quarter(state) => println!(\"State quarter from {:?}!\", "
"state),\n"
"        _ => count += 1,\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-03-if-let.md:90
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr ""

#: src/ch06-03-if-let.md:92
msgid ""
"```rust\n"
"# #[derive(Debug)]\n"
"# enum UsState {\n"
"#     Alabama,\n"
"#     Alaska,\n"
"#     // --snip--\n"
"# }\n"
"# \n"
"# enum Coin {\n"
"#     Penny,\n"
"#     Nickel,\n"
"#     Dime,\n"
"#     Quarter(UsState),\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let coin = Coin::Penny;\n"
"    let mut count = 0;\n"
"    if let Coin::Quarter(state) = coin {\n"
"        println!(\"State quarter from {:?}!\", state);\n"
"    } else {\n"
"        count += 1;\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch06-03-if-let.md:118
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to\n"
"express using a `match`, remember that `if let` is in your Rust toolbox as "
"well."
msgstr ""

#: src/ch06-03-if-let.md:123
msgid ""
"We‚Äôve now covered how to use enums to create custom types that can be one of "
"a\n"
"set of enumerated values. We‚Äôve shown how the standard library‚Äôs "
"`Option<T>`\n"
"type helps you use the type system to prevent errors. When enum values have\n"
"data inside them, you can use `match` or `if let` to extract and use those\n"
"values, depending on how many cases you need to handle."
msgstr ""

#: src/ch06-03-if-let.md:129
msgid ""
"Your Rust programs can now express concepts in your domain using structs "
"and\n"
"enums. Creating custom types to use in your API ensures type safety: the\n"
"compiler will make certain your functions only get values of the type each\n"
"function expects."
msgstr ""

#: src/ch06-03-if-let.md:134
msgid ""
"In order to provide a well-organized API to your users that is "
"straightforward\n"
"to use and only exposes exactly what your users will need, let‚Äôs now turn "
"to\n"
"Rust‚Äôs modules."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:1
msgid "# Managing Growing Projects with Packages, Crates, and Modules"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly\n"
"important. By grouping related functionality and separating code with "
"distinct\n"
"features, you‚Äôll clarify where to find code that implements a particular\n"
"feature and where to go to change how a feature works."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we‚Äôve written so far have been in one module in one file. As a\n"
"project grows, you should organize code by splitting it into multiple "
"modules\n"
"and then multiple files. A package can contain multiple binary crates and\n"
"optionally one library crate. As a package grows, you can extract parts "
"into\n"
"separate crates that become external dependencies. This chapter covers all\n"
"these techniques. For very large projects comprising a set of interrelated\n"
"packages that evolve together, Cargo provides *workspaces*, which we‚Äôll "
"cover\n"
"in the [‚ÄúCargo Workspaces‚Äù][workspaces]<!-- ignore --> section in Chapter 14."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:17
msgid ""
"We‚Äôll also discuss encapsulating implementation details, which lets you "
"reuse\n"
"code at a higher level: once you‚Äôve implemented an operation, other code "
"can\n"
"call your code via its public interface without having to know how the\n"
"implementation works. The way you write code defines which parts are public "
"for\n"
"other code to use and which parts are private implementation details that "
"you\n"
"reserve the right to change. This is another way to limit the amount of "
"detail\n"
"you have to keep in your head."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:25
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a\n"
"set of names that are defined as ‚Äúin scope.‚Äù When reading, writing, and\n"
"compiling code, programmers and compilers need to know whether a particular\n"
"name at a particular spot refers to a variable, function, struct, enum, "
"module,\n"
"constant, or other item and what that item means. You can create scopes and\n"
"change which names are in or out of scope. You can‚Äôt have two items with "
"the\n"
"same name in the same scope; tools are available to resolve name conflicts."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:33
msgid ""
"Rust has a number of features that allow you to manage your code‚Äôs\n"
"organization, including which details are exposed, which details are "
"private,\n"
"and what names are in each scope in your programs. These features, "
"sometimes\n"
"collectively referred to as the *module system*, include:"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:38
msgid ""
"* **Packages:** A Cargo feature that lets you build, test, and share crates\n"
"* **Crates:** A tree of modules that produces a library or executable\n"
"* **Modules** and **use:** Let you control the organization, scope, and\n"
"  privacy of paths\n"
"* **Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:44
msgid ""
"In this chapter, we‚Äôll cover all these features, discuss how they interact, "
"and\n"
"explain how to use them to manage scope. By the end, you should have a "
"solid\n"
"understanding of the module system and be able to work with scopes like a "
"pro!"
msgstr ""

#: src/ch07-01-packages-and-crates.md:1
msgid "## Packages and Crates"
msgstr ""

#: src/ch07-01-packages-and-crates.md:3
msgid ""
"The first parts of the module system we‚Äôll cover are packages and crates."
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A *crate* is the smallest amount of code that the Rust compiler considers at "
"a\n"
"time. Even if you run `rustc` rather than `cargo` and pass a single source "
"code\n"
"file (as we did all the way back in the ‚ÄúWriting and Running a Rust "
"Program‚Äù\n"
"section of Chapter 1), the compiler considers that file to be a crate. "
"Crates\n"
"can contain modules, and the modules may be defined in other files that get\n"
"compiled with the crate, as we‚Äôll see in the coming sections."
msgstr ""

#: src/ch07-01-packages-and-crates.md:12
msgid ""
"A crate can come in one of two forms: a binary crate or a library crate.\n"
"*Binary crates* are programs you can compile to an executable that you can "
"run,\n"
"such as a command-line program or a server. Each must have a function "
"called\n"
"`main` that defines what happens when the executable runs. All the crates "
"we‚Äôve\n"
"created so far have been binary crates."
msgstr ""

#: src/ch07-01-packages-and-crates.md:18
msgid ""
"*Library crates* don‚Äôt have a `main` function, and they don‚Äôt compile to an\n"
"executable. Instead, they define functionality intended to be shared with\n"
"multiple projects. For example, the `rand` crate we used in [Chapter\n"
"2][rand]<!-- ignore --> provides functionality that generates random "
"numbers.\n"
"Most of the time when Rustaceans say ‚Äúcrate‚Äù, they mean library crate, and "
"they\n"
"use ‚Äúcrate‚Äù interchangeably with the general programming concept of a "
"‚Äúlibrary\"."
msgstr ""

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"The *crate root* is a source file that the Rust compiler starts from and "
"makes\n"
"up the root module of your crate (we‚Äôll explain modules in depth in the\n"
"[‚ÄúDefining Modules to Control Scope and Privacy‚Äù][modules]<!-- ignore -->\n"
"section)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:30
msgid ""
"A *package* is a bundle of one or more crates that provides a set of\n"
"functionality. A package contains a *Cargo.toml* file that describes how to\n"
"build those crates. Cargo is actually a package that contains the binary "
"crate\n"
"for the command-line tool you‚Äôve been using to build your code. The Cargo\n"
"package also contains a library crate that the binary crate depends on. "
"Other\n"
"projects can depend on the Cargo library crate to use the same logic the "
"Cargo\n"
"command-line tool uses."
msgstr ""

#: src/ch07-01-packages-and-crates.md:38
msgid ""
"A package can contain as many binary crates as you like, but at most only "
"one\n"
"library crate. A package must contain at least one crate, whether that‚Äôs a\n"
"library or binary crate."
msgstr ""

#: src/ch07-01-packages-and-crates.md:42
msgid ""
"Let‚Äôs walk through what happens when we create a package. First, we enter "
"the\n"
"command `cargo new`:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"```console\n"
"$ cargo new my-project\n"
"     Created binary (application) `my-project` package\n"
"$ ls my-project\n"
"Cargo.toml\n"
"src\n"
"$ ls my-project/src\n"
"main.rs\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:55
msgid ""
"After we run `cargo new`, we use `ls` to see what Cargo creates. In the "
"project\n"
"directory, there‚Äôs a *Cargo.toml* file, giving us a package. There‚Äôs also a\n"
"*src* directory that contains *main.rs*. Open *Cargo.toml* in your text "
"editor,\n"
"and note there‚Äôs no mention of *src/main.rs*. Cargo follows a convention "
"that\n"
"*src/main.rs* is the crate root of a binary crate with the same name as the\n"
"package. Likewise, Cargo knows that if the package directory contains\n"
"*src/lib.rs*, the package contains a library crate with the same name as "
"the\n"
"package, and *src/lib.rs* is its crate root. Cargo passes the crate root "
"files\n"
"to `rustc` to build the library or binary."
msgstr ""

#: src/ch07-01-packages-and-crates.md:65
msgid ""
"Here, we have a package that only contains *src/main.rs*, meaning it only\n"
"contains a binary crate named `my-project`. If a package contains *src/main."
"rs*\n"
"and *src/lib.rs*, it has two crates: a binary and a library, both with the "
"same\n"
"name as the package. A package can have multiple binary crates by placing "
"files\n"
"in the *src/bin* directory: each file will be a separate binary crate."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:1
msgid "## Defining Modules to Control Scope and Privacy"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:3
msgid ""
"In this section, we‚Äôll talk about modules and other parts of the module "
"system,\n"
"namely *paths* that allow you to name items; the `use` keyword that brings "
"a\n"
"path into scope; and the `pub` keyword to make items public. We‚Äôll also "
"discuss\n"
"the `as` keyword, external packages, and the glob operator."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:8
msgid ""
"First, we‚Äôre going to start with a list of rules for easy reference when "
"you‚Äôre\n"
"organizing your code in the future. Then we‚Äôll explain each of the rules in\n"
"detail."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:12
msgid "### Modules Cheat Sheet"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:14
msgid ""
"Here we provide a quick reference on how modules, paths, the `use` keyword, "
"and\n"
"the `pub` keyword work in the compiler, and how most developers organize "
"their\n"
"code. We‚Äôll be going through examples of each of these rules throughout "
"this\n"
"chapter, but this is a great place to refer to as a reminder of how modules\n"
"work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:20
msgid ""
"- **Start from the crate root**: When compiling a crate, the compiler first\n"
"  looks in the crate root file (usually *src/lib.rs* for a library crate or\n"
"  *src/main.rs* for a binary crate) for code to compile.\n"
"- **Declaring modules**: In the crate root file, you can declare new "
"modules;\n"
"say, you declare a ‚Äúgarden‚Äù module with `mod garden;`. The compiler will "
"look\n"
"for the module‚Äôs code in these places:\n"
"  - Inline, within curly brackets that replace the semicolon following `mod\n"
"    garden`\n"
"  - In the file *src/garden.rs*\n"
"  - In the file *src/garden/mod.rs*\n"
"- **Declaring submodules**: In any file other than the crate root, you can\n"
"  declare submodules. For example, you might declare `mod vegetables;` in\n"
"  *src/garden.rs*. The compiler will look for the submodule‚Äôs code within "
"the\n"
"  directory named for the parent module in these places:\n"
"  - Inline, directly following `mod vegetables`, within curly brackets "
"instead\n"
"    of the semicolon\n"
"  - In the file *src/garden/vegetables.rs*\n"
"  - In the file *src/garden/vegetables/mod.rs*\n"
"- **Paths to code in modules**: Once a module is part of your crate, you "
"can\n"
"  refer to code in that module from anywhere else in that same crate, as "
"long\n"
"  as the privacy rules allow, using the path to the code. For example, an\n"
"  `Asparagus` type in the garden vegetables module would be found at\n"
"  `crate::garden::vegetables::Asparagus`.\n"
"- **Private vs public**: Code within a module is private from its parent\n"
"  modules by default. To make a module public, declare it with `pub mod`\n"
"  instead of `mod`. To make items within a public module public as well, "
"use\n"
"  `pub` before their declarations.\n"
"- **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to\n"
"  items to reduce repetition of long paths. In any scope that can refer to\n"
"  `crate::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use\n"
"  crate::garden::vegetables::Asparagus;` and from then on you only need to\n"
"  write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:53
msgid ""
"Here we create a binary crate named `backyard` that illustrates these rules. "
"The\n"
"crate‚Äôs directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:56
msgid ""
"```text\n"
"backyard\n"
"‚îú‚îÄ‚îÄ Cargo.lock\n"
"‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îî‚îÄ‚îÄ src\n"
"    ‚îú‚îÄ‚îÄ garden\n"
"    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vegetables.rs\n"
"    ‚îú‚îÄ‚îÄ garden.rs\n"
"    ‚îî‚îÄ‚îÄ main.rs\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:67
msgid "The crate root file in this case is *src/main.rs*, and it contains:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:71
msgid ""
"```rust,noplayground,ignore\n"
"use crate::garden::vegetables::Asparagus;\n"
"\n"
"pub mod garden;\n"
"\n"
"fn main() {\n"
"    let plant = Asparagus {};\n"
"    println!(\"I'm growing {:?}!\", plant);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:82
msgid ""
"The `pub mod garden;` line tells the compiler to include the code it finds "
"in\n"
"*src/garden.rs*, which is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:85
msgid "<span class=\"filename\">Filename: src/garden.rs</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:87
msgid ""
"```rust,noplayground,ignore\n"
"pub mod vegetables;\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:91
msgid ""
"Here, `pub mod vegetables;` means the code in *src/garden/vegetables.rs* is\n"
"included too. That code is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:94
msgid ""
"```rust,noplayground,ignore\n"
"#[derive(Debug)]\n"
"pub struct Asparagus {}\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:99
msgid ""
"Now let‚Äôs get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:101
msgid "### Grouping Related Code in Modules"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:103
msgid ""
"*Modules* let us organize code within a crate for readability and easy "
"reuse.\n"
"Modules also allow us to control the *privacy* of items, because code within "
"a\n"
"module is private by default. Private items are internal implementation "
"details\n"
"not available for outside use. We can choose to make modules and the items\n"
"within them public, which exposes them to allow external code to use and "
"depend\n"
"on them."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:110
msgid ""
"As an example, let‚Äôs write a library crate that provides the functionality "
"of a\n"
"restaurant. We‚Äôll define the signatures of functions but leave their bodies\n"
"empty to concentrate on the organization of the code, rather than the\n"
"implementation of a restaurant."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:115
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as\n"
"*front of house* and others as *back of house*. Front of house is where\n"
"customers are; this encompasses where the hosts seat customers, servers "
"take\n"
"orders and payment, and bartenders make drinks. Back of house is where the\n"
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do\n"
"administrative work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:122
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested\n"
"modules. Create a new library named `restaurant` by running `cargo new\n"
"restaurant --lib`; then enter the code in Listing 7-1 into *src/lib.rs* to\n"
"define some modules and function signatures. Here‚Äôs the front of house "
"section:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:127
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:32
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:220
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:308
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:348
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:399
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:15
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:45
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:103
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:157
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:226
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:425
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:439
#: src/ch07-05-separating-modules-into-different-files.md:19
#: src/ch10-02-traits.md:30 src/ch10-02-traits.md:67 src/ch10-02-traits.md:170
#: src/ch10-02-traits.md:605 src/ch10-03-lifetime-syntax.md:573
#: src/ch11-01-writing-tests.md:46 src/ch11-01-writing-tests.md:138
#: src/ch11-01-writing-tests.md:179 src/ch11-01-writing-tests.md:260
#: src/ch11-01-writing-tests.md:285 src/ch11-01-writing-tests.md:359
#: src/ch11-01-writing-tests.md:533 src/ch11-01-writing-tests.md:678
#: src/ch11-01-writing-tests.md:822 src/ch11-01-writing-tests.md:945
#: src/ch11-02-running-tests.md:61 src/ch11-02-running-tests.md:182
#: src/ch11-02-running-tests.md:294 src/ch11-03-test-organization.md:38
#: src/ch11-03-test-organization.md:68
#: src/ch12-03-improving-error-handling-and-modularity.md:833
#: src/ch12-04-testing-the-librarys-functionality.md:38
#: src/ch12-04-testing-the-librarys-functionality.md:102
#: src/ch12-04-testing-the-librarys-functionality.md:254
#: src/ch12-04-testing-the-librarys-functionality.md:322
#: src/ch12-04-testing-the-librarys-functionality.md:391
#: src/ch12-04-testing-the-librarys-functionality.md:497
#: src/ch12-05-working-with-environment-variables.md:19
#: src/ch12-05-working-with-environment-variables.md:124
#: src/ch12-05-working-with-environment-variables.md:277
#: src/ch12-05-working-with-environment-variables.md:384
#: src/ch12-05-working-with-environment-variables.md:496
#: src/ch13-02-iterators.md:91 src/ch13-02-iterators.md:143
#: src/ch13-02-iterators.md:264 src/ch13-03-improving-our-io-project.md:16
#: src/ch13-03-improving-our-io-project.md:215
#: src/ch13-03-improving-our-io-project.md:351
#: src/ch13-03-improving-our-io-project.md:483
#: src/ch13-03-improving-our-io-project.md:552
#: src/ch14-02-publishing-to-crates-io.md:29
#: src/ch14-02-publishing-to-crates-io.md:130
#: src/ch14-02-publishing-to-crates-io.md:205
#: src/ch14-02-publishing-to-crates-io.md:289
#: src/ch15-05-interior-mutability.md:146
#: src/ch15-05-interior-mutability.md:210
#: src/ch15-05-interior-mutability.md:337
#: src/ch15-05-interior-mutability.md:458 src/ch17-01-what-is-oo.md:47
#: src/ch17-01-what-is-oo.md:66 src/ch17-02-trait-objects.md:69
#: src/ch17-02-trait-objects.md:85 src/ch17-02-trait-objects.md:104
#: src/ch17-02-trait-objects.md:134 src/ch17-02-trait-objects.md:178
#: src/ch17-03-oo-design-patterns.md:100 src/ch17-03-oo-design-patterns.md:151
#: src/ch17-03-oo-design-patterns.md:202 src/ch17-03-oo-design-patterns.md:246
#: src/ch17-03-oo-design-patterns.md:353 src/ch17-03-oo-design-patterns.md:454
#: src/ch17-03-oo-design-patterns.md:564 src/ch17-03-oo-design-patterns.md:779
#: src/ch17-03-oo-design-patterns.md:839 src/ch19-03-advanced-traits.md:50
#: src/ch19-03-advanced-traits.md:199 src/ch19-06-macros.md:78
#: src/ch19-06-macros.md:178 src/ch19-06-macros.md:242
#: src/ch20-02-multithreaded.md:307 src/ch20-02-multithreaded.md:386
#: src/ch20-02-multithreaded.md:457 src/ch20-02-multithreaded.md:513
#: src/ch20-02-multithreaded.md:587 src/ch20-02-multithreaded.md:685
#: src/ch20-02-multithreaded.md:792 src/ch20-02-multithreaded.md:860
#: src/ch20-02-multithreaded.md:962 src/ch20-02-multithreaded.md:1049
#: src/ch20-02-multithreaded.md:1137 src/ch20-02-multithreaded.md:1290
#: src/ch20-03-graceful-shutdown-and-cleanup.md:25
#: src/ch20-03-graceful-shutdown-and-cleanup.md:147
#: src/ch20-03-graceful-shutdown-and-cleanup.md:267
#: src/ch20-03-graceful-shutdown-and-cleanup.md:355
#: src/ch20-03-graceful-shutdown-and-cleanup.md:464
#: src/ch20-03-graceful-shutdown-and-cleanup.md:565
#: src/ch20-03-graceful-shutdown-and-cleanup.md:845
msgid "<span class=\"filename\">Filename: src/lib.rs</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:129
msgid ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:147
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing "
"other\n"
"modules that then contain functions</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:150
msgid ""
"We define a module with the `mod` keyword followed by the name of the "
"module\n"
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly\n"
"brackets. Inside modules, we can place other modules, as in this case with "
"the\n"
"modules `hosting` and `serving`. Modules can also hold definitions for "
"other\n"
"items, such as structs, enums, constants, traits, and‚Äîas in Listing\n"
"7-1‚Äîfunctions."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:157
msgid ""
"By using modules, we can group related definitions together and name why\n"
"they‚Äôre related. Programmers using this code can navigate the code based on "
"the\n"
"groups rather than having to read through all the definitions, making it "
"easier\n"
"to find the definitions relevant to them. Programmers adding new "
"functionality\n"
"to this code would know where to place the code to keep the program "
"organized."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:163
msgid ""
"Earlier, we mentioned that *src/main.rs* and *src/lib.rs* are called crate\n"
"roots. The reason for their name is that the contents of either of these "
"two\n"
"files form a module named `crate` at the root of the crate‚Äôs module "
"structure,\n"
"known as the *module tree*."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:168
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:170
msgid ""
"```text\n"
"crate\n"
" ‚îî‚îÄ‚îÄ front_of_house\n"
"     ‚îú‚îÄ‚îÄ hosting\n"
"     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist\n"
"     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table\n"
"     ‚îî‚îÄ‚îÄ serving\n"
"         ‚îú‚îÄ‚îÄ take_order\n"
"         ‚îú‚îÄ‚îÄ serve_order\n"
"         ‚îî‚îÄ‚îÄ take_payment\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:182
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in "
"Listing\n"
"7-1</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:185
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example,\n"
"`hosting` nests inside `front_of_house`. The tree also shows that some "
"modules\n"
"are *siblings* to each other, meaning they‚Äôre defined in the same module;\n"
"`hosting` and `serving` are siblings defined within `front_of_house`. If "
"module\n"
"A is contained inside module B, we say that module A is the *child* of "
"module B\n"
"and that module B is the *parent* of module A. Notice that the entire "
"module\n"
"tree is rooted under the implicit module named `crate`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:193
msgid ""
"The module tree might remind you of the filesystem‚Äôs directory tree on your\n"
"computer; this is a very apt comparison! Just like directories in a "
"filesystem,\n"
"you use modules to organize your code. And just like files in a directory, "
"we\n"
"need a way to find our modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "## Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Rust where to find an item in a module tree, we use a path in the "
"same\n"
"way we use a path when navigating a filesystem. To call a function, we need "
"to\n"
"know its path."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid "A path can take two forms:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:9
msgid ""
"* An *absolute path* is the full path starting from a crate root; for code\n"
"  from an external crate, the absolute path begins with the crate name, and "
"for\n"
"  code from the current crate, it starts with the literal `crate`.\n"
"* A *relative path* starts from the current module and uses `self`, `super`, "
"or\n"
"  an identifier in the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
msgid ""
"Both absolute and relative paths are followed by one or more identifiers\n"
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:18
msgid ""
"Returning to Listing 7-1, say we want to call the `add_to_waitlist` "
"function.\n"
"This is the same as asking: what‚Äôs the path of the `add_to_waitlist` "
"function?\n"
"Listing 7-3 contains Listing 7-1 with some of the modules and functions\n"
"removed."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:23
msgid ""
"We‚Äôll show two ways to call the `add_to_waitlist` function from a new "
"function\n"
"`eat_at_restaurant` defined in the crate root. These paths are correct, but\n"
"there‚Äôs another problem remaining that will prevent this example from "
"compiling\n"
"as-is. We‚Äôll explain why in a bit."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:28
msgid ""
"The `eat_at_restaurant` function is part of our library crate‚Äôs public API, "
"so\n"
"we mark it with the `pub` keyword. In the [‚ÄúExposing Paths with the `pub`\n"
"Keyword‚Äù][pub]<!-- ignore --> section, we‚Äôll go into more detail about `pub`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:34
msgid ""
"```rust,ignore,does_not_compile\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    crate::front_of_house::hosting::add_to_waitlist();\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function "
"using\n"
"absolute and relative paths</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:53
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`,\n"
"we use an absolute path. The `add_to_waitlist` function is defined in the "
"same\n"
"crate as `eat_at_restaurant`, which means we can use the `crate` keyword to\n"
"start an absolute path. We then include each of the successive modules until "
"we\n"
"make our way to `add_to_waitlist`. You can imagine a filesystem with the "
"same\n"
"structure: we‚Äôd specify the path `/front_of_house/hosting/add_to_waitlist` "
"to\n"
"run the `add_to_waitlist` program; using the `crate` name to start from the\n"
"crate root is like using `/` to start from the filesystem root in your shell."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
msgid ""
"The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a\n"
"relative path. The path starts with `front_of_house`, the name of the "
"module\n"
"defined at the same level of the module tree as `eat_at_restaurant`. Here "
"the\n"
"filesystem equivalent would be using the path\n"
"`front_of_house/hosting/add_to_waitlist`. Starting with a module name means\n"
"that the path is relative."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:69
msgid ""
"Choosing whether to use a relative or absolute path is a decision you‚Äôll "
"make\n"
"based on your project, and depends on whether you‚Äôre more likely to move "
"item\n"
"definition code separately from or together with the code that uses the "
"item.\n"
"For example, if we move the `front_of_house` module and the "
"`eat_at_restaurant`\n"
"function into a module named `customer_experience`, we‚Äôd need to update the\n"
"absolute path to `add_to_waitlist`, but the relative path would still be "
"valid.\n"
"However, if we moved the `eat_at_restaurant` function separately into a "
"module\n"
"named `dining`, the absolute path to the `add_to_waitlist` call would stay "
"the\n"
"same, but the relative path would need to be updated. Our preference in "
"general\n"
"is to specify absolute paths because it‚Äôs more likely we‚Äôll want to move "
"code\n"
"definitions and item calls independently of each other."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:81
msgid ""
"Let‚Äôs try to compile Listing 7-3 and find out why it won‚Äôt compile yet! The\n"
"error we get is shown in Listing 7-4."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:84
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0603]: module `hosting` is private\n"
" --> src/lib.rs:9:28\n"
"  |\n"
"9 |     crate::front_of_house::hosting::add_to_waitlist();\n"
"  |                            ^^^^^^^ private module\n"
"  |\n"
"note: the module `hosting` is defined here\n"
" --> src/lib.rs:2:5\n"
"  |\n"
"2 |     mod hosting {\n"
"  |     ^^^^^^^^^^^\n"
"\n"
"error[E0603]: module `hosting` is private\n"
"  --> src/lib.rs:12:21\n"
"   |\n"
"12 |     front_of_house::hosting::add_to_waitlist();\n"
"   |                     ^^^^^^^ private module\n"
"   |\n"
"note: the module `hosting` is defined here\n"
"  --> src/lib.rs:2:5\n"
"   |\n"
"2  |     mod hosting {\n"
"   |     ^^^^^^^^^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0603`.\n"
"error: could not compile `restaurant` due to 2 previous errors\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:115
msgid ""
"<span class=\"caption\">Listing 7-4: Compiler errors from building the code "
"in\n"
"Listing 7-3</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:118
msgid ""
"The error messages say that module `hosting` is private. In other words, we\n"
"have the correct paths for the `hosting` module and the `add_to_waitlist`\n"
"function, but Rust won‚Äôt let us use them because it doesn‚Äôt have access to "
"the\n"
"private sections. In Rust, all items (functions, methods, structs, enums,\n"
"modules, and constants) are private to parent modules by default. If you "
"want\n"
"to make an item like a function or struct private, you put it in a module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:125
msgid ""
"Items in a parent module can‚Äôt use the private items inside child modules, "
"but\n"
"items in child modules can use the items in their ancestor modules. This is\n"
"because child modules wrap and hide their implementation details, but the "
"child\n"
"modules can see the context in which they‚Äôre defined. To continue with our\n"
"metaphor, think of the privacy rules as being like the back office of a\n"
"restaurant: what goes on in there is private to restaurant customers, but\n"
"office managers can see and do everything in the restaurant they operate."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:133
msgid ""
"Rust chose to have the module system function this way so that hiding inner\n"
"implementation details is the default. That way, you know which parts of "
"the\n"
"inner code you can change without breaking outer code. However, Rust does "
"give\n"
"you the option to expose inner parts of child modules‚Äô code to outer "
"ancestor\n"
"modules by using the `pub` keyword to make an item public."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:139
msgid "### Exposing Paths with the `pub` Keyword"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:141
msgid ""
"Let‚Äôs return to the error in Listing 7-4 that told us the `hosting` module "
"is\n"
"private. We want the `eat_at_restaurant` function in the parent module to "
"have\n"
"access to the `add_to_waitlist` function in the child module, so we mark "
"the\n"
"`hosting` module with the `pub` keyword, as shown in Listing 7-5."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:148
msgid ""
"```rust,ignore,does_not_compile\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    crate::front_of_house::hosting::add_to_waitlist();\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:164
msgid ""
"<span class=\"caption\">Listing 7-5: Declaring the `hosting` module as `pub` "
"to\n"
"use it from `eat_at_restaurant`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:167
msgid ""
"Unfortunately, the code in Listing 7-5 still results in an error, as shown "
"in\n"
"Listing 7-6."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:170
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0603]: function `add_to_waitlist` is private\n"
" --> src/lib.rs:9:37\n"
"  |\n"
"9 |     crate::front_of_house::hosting::add_to_waitlist();\n"
"  |                                     ^^^^^^^^^^^^^^^ private function\n"
"  |\n"
"note: the function `add_to_waitlist` is defined here\n"
" --> src/lib.rs:3:9\n"
"  |\n"
"3 |         fn add_to_waitlist() {}\n"
"  |         ^^^^^^^^^^^^^^^^^^^^\n"
"\n"
"error[E0603]: function `add_to_waitlist` is private\n"
"  --> src/lib.rs:12:30\n"
"   |\n"
"12 |     front_of_house::hosting::add_to_waitlist();\n"
"   |                              ^^^^^^^^^^^^^^^ private function\n"
"   |\n"
"note: the function `add_to_waitlist` is defined here\n"
"  --> src/lib.rs:3:9\n"
"   |\n"
"3  |         fn add_to_waitlist() {}\n"
"   |         ^^^^^^^^^^^^^^^^^^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0603`.\n"
"error: could not compile `restaurant` due to 2 previous errors\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:201
msgid ""
"<span class=\"caption\">Listing 7-6: Compiler errors from building the code "
"in\n"
"Listing 7-5</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:204
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting` makes the\n"
"module public. With this change, if we can access `front_of_house`, we can\n"
"access `hosting`. But the *contents* of `hosting` are still private; making "
"the\n"
"module public doesn‚Äôt make its contents public. The `pub` keyword on a "
"module\n"
"only lets code in its ancestor modules refer to it, not access its inner "
"code.\n"
"Because modules are containers, there‚Äôs not much we can do by only making "
"the\n"
"module public; we need to go further and choose to make one or more of the\n"
"items within the module public as well."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:213
msgid ""
"The errors in Listing 7-6 say that the `add_to_waitlist` function is "
"private.\n"
"The privacy rules apply to structs, enums, functions, and methods as well "
"as\n"
"modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:217
msgid ""
"Let‚Äôs also make the `add_to_waitlist` function public by adding the `pub`\n"
"keyword before its definition, as in Listing 7-7."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:222
msgid ""
"```rust,noplayground,test_harness\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    crate::front_of_house::hosting::add_to_waitlist();\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:238
msgid ""
"<span class=\"caption\">Listing 7-7: Adding the `pub` keyword to `mod "
"hosting`\n"
"and `fn add_to_waitlist` lets us call the function from\n"
"`eat_at_restaurant`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:242
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use\n"
"these paths in `add_to_waitlist` with respect to the privacy rules, let‚Äôs "
"look\n"
"at the absolute and the relative paths."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:246
msgid ""
"In the absolute path, we start with `crate`, the root of our crate‚Äôs module\n"
"tree. The `front_of_house` module is defined in the crate root. While\n"
"`front_of_house` isn‚Äôt public, because the `eat_at_restaurant` function is\n"
"defined in the same module as `front_of_house` (that is, "
"`eat_at_restaurant`\n"
"and `front_of_house` are siblings), we can refer to `front_of_house` from\n"
"`eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can\n"
"access the parent module of `hosting`, so we can access `hosting`. Finally, "
"the\n"
"`add_to_waitlist` function is marked with `pub` and we can access its "
"parent\n"
"module, so this function call works!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:256
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the\n"
"first step: rather than starting from the crate root, the path starts from\n"
"`front_of_house`. The `front_of_house` module is defined within the same "
"module\n"
"as `eat_at_restaurant`, so the relative path starting from the module in "
"which\n"
"`eat_at_restaurant` is defined works. Then, because `hosting` and\n"
"`add_to_waitlist` are marked with `pub`, the rest of the path works, and "
"this\n"
"function call is valid!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:264
msgid ""
"If you plan on sharing your library crate so other projects can use your "
"code,\n"
"your public API is your contract with users of your crate that determines "
"how\n"
"they can interact with your code. There are many considerations around "
"managing\n"
"changes to your public API to make it easier for people to depend on your\n"
"crate. These considerations are out of the scope of this book; if you‚Äôre\n"
"interested in this topic, see [The Rust API Guidelines][api-guidelines]."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:271
msgid ""
"> #### Best Practices for Packages with a Binary and a Library\n"
">\n"
"> We mentioned a package can contain both a *src/main.rs* binary crate root "
"as\n"
"> well as a *src/lib.rs* library crate root, and both crates will have the\n"
"> package name by default. Typically, packages with this pattern of "
"containing\n"
"> both a library and a binary crate will have just enough code in the "
"binary\n"
"> crate to start an executable that calls code with the library crate. This\n"
"> lets other projects benefit from the most functionality that the package\n"
"> provides, because the library crate‚Äôs code can be shared.\n"
">\n"
"> The module tree should be defined in *src/lib.rs*. Then, any public items "
"can\n"
"> be used in the binary crate by starting paths with the name of the "
"package.\n"
"> The binary crate becomes a user of the library crate just like a "
"completely\n"
"> external crate would use the library crate: it can only use the public "
"API.\n"
"> This helps you design a good API; not only are you the author, you‚Äôre also "
"a\n"
"> client!\n"
">\n"
"> In [Chapter 12][ch12]<!-- ignore -->, we‚Äôll demonstrate this "
"organizational\n"
"> practice with a command-line program that will contain both a binary "
"crate\n"
"> and a library crate."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:292
msgid "### Starting Relative Paths with `super`"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:294
msgid ""
"We can construct relative paths that begin in the parent module, rather "
"than\n"
"the current module or the crate root, by using `super` at the start of the\n"
"path. This is like starting a filesystem path with the `..` syntax. Using\n"
"`super` allows us to reference an item that we know is in the parent "
"module,\n"
"which can make rearranging the module tree easier when the module is "
"closely\n"
"related to the parent, but the parent might be moved elsewhere in the "
"module\n"
"tree someday."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:302
msgid ""
"Consider the code in Listing 7-8 that models the situation in which a chef\n"
"fixes an incorrect order and personally brings it out to the customer. The\n"
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the\n"
"function `deliver_order` defined in the parent module by specifying the path "
"to\n"
"`deliver_order` starting with `super`:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:310
msgid ""
"```rust,noplayground,test_harness\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:323
msgid ""
"<span class=\"caption\">Listing 7-8: Calling a function using a relative "
"path\n"
"starting with `super`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:326
msgid ""
"The `fix_incorrect_order` function is in the `back_of_house` module, so we "
"can\n"
"use `super` to go to the parent module of `back_of_house`, which in this "
"case\n"
"is `crate`, the root. From there, we look for `deliver_order` and find it.\n"
"Success! We think the `back_of_house` module and the `deliver_order` "
"function\n"
"are likely to stay in the same relationship to each other and get moved\n"
"together should we decide to reorganize the crate‚Äôs module tree. Therefore, "
"we\n"
"used `super` so we‚Äôll have fewer places to update code in the future if "
"this\n"
"code gets moved to a different module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:335
msgid "### Making Structs and Enums Public"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:337
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a\n"
"few details extra to the usage of `pub` with structs and enums. If we use "
"`pub`\n"
"before a struct definition, we make the struct public, but the struct‚Äôs "
"fields\n"
"will still be private. We can make each field public or not on a case-by-"
"case\n"
"basis. In Listing 7-9, we‚Äôve defined a public `back_of_house::Breakfast` "
"struct\n"
"with a public `toast` field but a private `seasonal_fruit` field. This "
"models\n"
"the case in a restaurant where the customer can pick the type of bread that\n"
"comes with a meal, but the chef decides which fruit accompanies the meal "
"based\n"
"on what‚Äôs in season and in stock. The available fruit changes quickly, so\n"
"customers can‚Äôt choose the fruit or even see which fruit they‚Äôll get."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:350
msgid ""
"```rust,noplayground\n"
"mod back_of_house {\n"
"    pub struct Breakfast {\n"
"        pub toast: String,\n"
"        seasonal_fruit: String,\n"
"    }\n"
"\n"
"    impl Breakfast {\n"
"        pub fn summer(toast: &str) -> Breakfast {\n"
"            Breakfast {\n"
"                toast: String::from(toast),\n"
"                seasonal_fruit: String::from(\"peaches\"),\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Order a breakfast in the summer with Rye toast\n"
"    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n"
"    // Change our mind about what bread we'd like\n"
"    meal.toast = String::from(\"Wheat\");\n"
"    println!(\"I'd like {} toast please\", meal.toast);\n"
"\n"
"    // The next line won't compile if we uncomment it; we're not allowed\n"
"    // to see or modify the seasonal fruit that comes with the meal\n"
"    // meal.seasonal_fruit = String::from(\"blueberries\");\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:380
msgid ""
"<span class=\"caption\">Listing 7-9: A struct with some public fields and "
"some\n"
"private fields</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:383
msgid ""
"Because the `toast` field in the `back_of_house::Breakfast` struct is "
"public,\n"
"in `eat_at_restaurant` we can write and read to the `toast` field using dot\n"
"notation. Notice that we can‚Äôt use the `seasonal_fruit` field in\n"
"`eat_at_restaurant` because `seasonal_fruit` is private. Try uncommenting "
"the\n"
"line modifying the `seasonal_fruit` field value to see what error you get!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:389
msgid ""
"Also, note that because `back_of_house::Breakfast` has a private field, the\n"
"struct needs to provide a public associated function that constructs an\n"
"instance of `Breakfast` (we‚Äôve named it `summer` here). If `Breakfast` "
"didn‚Äôt\n"
"have such a function, we couldn‚Äôt create an instance of `Breakfast` in\n"
"`eat_at_restaurant` because we couldn‚Äôt set the value of the private\n"
"`seasonal_fruit` field in `eat_at_restaurant`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:396
msgid ""
"In contrast, if we make an enum public, all of its variants are then public. "
"We\n"
"only need the `pub` before the `enum` keyword, as shown in Listing 7-10."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:401
msgid ""
"```rust,noplayground\n"
"mod back_of_house {\n"
"    pub enum Appetizer {\n"
"        Soup,\n"
"        Salad,\n"
"    }\n"
"}\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    let order1 = back_of_house::Appetizer::Soup;\n"
"    let order2 = back_of_house::Appetizer::Salad;\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:415
msgid ""
"<span class=\"caption\">Listing 7-10: Designating an enum as public makes "
"all its\n"
"variants public</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:418
msgid ""
"Because we made the `Appetizer` enum public, we can use the `Soup` and "
"`Salad`\n"
"variants in `eat_at_restaurant`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:421
msgid ""
"Enums aren‚Äôt very useful unless their variants are public; it would be "
"annoying\n"
"to have to annotate all enum variants with `pub` in every case, so the "
"default\n"
"for enum variants is to be public. Structs are often useful without their\n"
"fields being public, so struct fields follow the general rule of everything\n"
"being private by default unless annotated with `pub`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:427
msgid ""
"There‚Äôs one more situation involving `pub` that we haven‚Äôt covered, and that "
"is\n"
"our last module system feature: the `use` keyword. We‚Äôll cover `use` by "
"itself\n"
"first, and then we‚Äôll show how to combine `pub` and `use`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "## Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and\n"
"repetitive. In Listing 7-7, whether we chose the absolute or relative path "
"to\n"
"the `add_to_waitlist` function, every time we wanted to call "
"`add_to_waitlist`\n"
"we had to specify `front_of_house` and `hosting` too. Fortunately, there‚Äôs "
"a\n"
"way to simplify this process: we can create a shortcut to a path with the "
"`use`\n"
"keyword once, and then use the shorter name everywhere else in the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
msgid ""
"In Listing 7-11, we bring the `crate::front_of_house::hosting` module into "
"the\n"
"scope of the `eat_at_restaurant` function so we only have to specify\n"
"`hosting::add_to_waitlist` to call the `add_to_waitlist` function in\n"
"`eat_at_restaurant`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:17
msgid ""
"```rust,noplayground,test_harness\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use crate::front_of_house::hosting;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"<span class=\"caption\">Listing 7-11: Bringing a module into scope with\n"
"`use`</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link "
"in\n"
"the filesystem. By adding `use crate::front_of_house::hosting` in the crate\n"
"root, `hosting` is now a valid name in that scope, just as though the "
"`hosting`\n"
"module had been defined in the crate root. Paths brought into scope with "
"`use`\n"
"also check privacy, like any other paths."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:40
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the\n"
"`use` occurs. Listing 7-12 moves the `eat_at_restaurant` function into a "
"new\n"
"child module named `customer`, which is then a different scope than the "
"`use`\n"
"statement, so the function body won‚Äôt compile:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:47
msgid ""
"```rust,noplayground,test_harness,does_not_compile,ignore\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use crate::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    pub fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:63
msgid ""
"<span class=\"caption\">Listing 7-12: A `use` statement only applies in the "
"scope\n"
"it‚Äôs in</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:66
msgid ""
"The compiler error shows that the shortcut no longer applies within the\n"
"`customer` module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:69
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"warning: unused import: `crate::front_of_house::hosting`\n"
" --> src/lib.rs:7:5\n"
"  |\n"
"7 | use crate::front_of_house::hosting;\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: `#[warn(unused_imports)]` on by default\n"
"\n"
"error[E0433]: failed to resolve: use of undeclared crate or module "
"`hosting`\n"
"  --> src/lib.rs:11:9\n"
"   |\n"
"11 |         hosting::add_to_waitlist();\n"
"   |         ^^^^^^^ use of undeclared crate or module `hosting`\n"
"\n"
"For more information about this error, try `rustc --explain E0433`.\n"
"warning: `restaurant` (lib) generated 1 warning\n"
"error: could not compile `restaurant` due to previous error; 1 warning "
"emitted\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:91
msgid ""
"Notice there‚Äôs also a warning that the `use` is no longer used in its scope! "
"To\n"
"fix this problem, move the `use` within the `customer` module too, or "
"reference\n"
"the shortcut in the parent module with `super::hosting` within the child\n"
"`customer` module."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid "### Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:98
msgid ""
"In Listing 7-11, you might have wondered why we specified `use\n"
"crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` "
"in\n"
"`eat_at_restaurant` rather than specifying the `use` path all the way out "
"to\n"
"the `add_to_waitlist` function to achieve the same result, as in Listing "
"7-13."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:105
msgid ""
"```rust,noplayground,test_harness\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use crate::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:119
msgid ""
"<span class=\"caption\">Listing 7-13: Bringing the `add_to_waitlist` "
"function\n"
"into scope with `use`, which is unidiomatic</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 "
"is\n"
"the idiomatic way to bring a function into scope with `use`. Bringing the\n"
"function‚Äôs parent module into scope with `use` means we have to specify the\n"
"parent module when calling the function. Specifying the parent module when\n"
"calling the function makes it clear that the function isn‚Äôt locally defined\n"
"while still minimizing repetition of the full path. The code in Listing 7-13 "
"is\n"
"unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:130
msgid ""
"On the other hand, when bringing in structs, enums, and other items with "
"`use`,\n"
"it‚Äôs idiomatic to specify the full path. Listing 7-14 shows the idiomatic "
"way\n"
"to bring the standard library‚Äôs `HashMap` struct into the scope of a binary\n"
"crate."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut map = HashMap::new();\n"
"    map.insert(1, 2);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"<span class=\"caption\">Listing 7-14: Bringing `HashMap` into scope in an\n"
"idiomatic way</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"There‚Äôs no strong reason behind this idiom: it‚Äôs just the convention that "
"has\n"
"emerged, and folks have gotten used to reading and writing Rust code this "
"way."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:152
msgid ""
"The exception to this idiom is if we‚Äôre bringing two items with the same "
"name\n"
"into scope with `use` statements, because Rust doesn‚Äôt allow that. Listing "
"7-15\n"
"shows how to bring two `Result` types into scope that have the same name "
"but\n"
"different parent modules and how to refer to them."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:159
msgid ""
"```rust,noplayground\n"
"use std::fmt;\n"
"use std::io;\n"
"\n"
"fn function1() -> fmt::Result {\n"
"    // --snip--\n"
"#     Ok(())\n"
"}\n"
"\n"
"fn function2() -> io::Result<()> {\n"
"    // --snip--\n"
"#     Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:174
msgid ""
"<span class=\"caption\">Listing 7-15: Bringing two types with the same name "
"into\n"
"the same scope requires using their parent modules.</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:177
msgid ""
"As you can see, using the parent modules distinguishes the two `Result` "
"types.\n"
"If instead we specified `use std::fmt::Result` and `use std::io::Result`, "
"we‚Äôd\n"
"have two `Result` types in the same scope and Rust wouldn‚Äôt know which one "
"we\n"
"meant when we used `Result`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid "### Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"There‚Äôs another solution to the problem of bringing two types of the same "
"name\n"
"into the same scope with `use`: after the path, we can specify `as` and a "
"new\n"
"local name, or *alias*, for the type. Listing 7-16 shows another way to "
"write\n"
"the code in Listing 7-15 by renaming one of the two `Result` types using "
"`as`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:191
msgid ""
"```rust,noplayground\n"
"use std::fmt::Result;\n"
"use std::io::Result as IoResult;\n"
"\n"
"fn function1() -> Result {\n"
"    // --snip--\n"
"#     Ok(())\n"
"}\n"
"\n"
"fn function2() -> IoResult<()> {\n"
"    // --snip--\n"
"#     Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:206
msgid ""
"<span class=\"caption\">Listing 7-16: Renaming a type when it‚Äôs brought "
"into\n"
"scope with the `as` keyword</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:209
msgid ""
"In the second `use` statement, we chose the new name `IoResult` for the\n"
"`std::io::Result` type, which won‚Äôt conflict with the `Result` from `std::"
"fmt`\n"
"that we‚Äôve also brought into scope. Listing 7-15 and Listing 7-16 are\n"
"considered idiomatic, so the choice is up to you!"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:214
msgid "### Re-exporting Names with `pub use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:216
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in\n"
"the new scope is private. To enable the code that calls our code to refer "
"to\n"
"that name as if it had been defined in that code‚Äôs scope, we can combine "
"`pub`\n"
"and `use`. This technique is called *re-exporting* because we‚Äôre bringing\n"
"an item into scope but also making that item available for others to bring "
"into\n"
"their scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:223
msgid ""
"Listing 7-17 shows the code in Listing 7-11 with `use` in the root module\n"
"changed to `pub use`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:228
msgid ""
"```rust,noplayground,test_harness\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"pub use crate::front_of_house::hosting;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:242
msgid ""
"<span class=\"caption\">Listing 7-17: Making a name available for any code "
"to use\n"
"from a new scope with `pub use`</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:245
msgid ""
"Before this change, external code would have to call the `add_to_waitlist`\n"
"function by using the path\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this "
"`pub\n"
"use` has re-exported the `hosting` module from the root module, external "
"code\n"
"can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid ""
"Re-exporting is useful when the internal structure of your code is "
"different\n"
"from how programmers calling your code would think about the domain. For\n"
"example, in this restaurant metaphor, the people running the restaurant "
"think\n"
"about ‚Äúfront of house‚Äù and ‚Äúback of house.‚Äù But customers visiting a "
"restaurant\n"
"probably won‚Äôt think about the parts of the restaurant in those terms. With\n"
"`pub use`, we can write our code with one structure but expose a different\n"
"structure. Doing so makes our library well organized for programmers working "
"on\n"
"the library and programmers calling the library. We‚Äôll look at another "
"example\n"
"of `pub use` and how it affects your crate‚Äôs documentation in the "
"[‚ÄúExporting a\n"
"Convenient Public API with `pub use`‚Äù][ch14-pub-use]<!-- ignore --> section "
"of\n"
"Chapter 14."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:263
msgid "### Using External Packages"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:265
msgid ""
"In Chapter 2, we programmed a guessing game project that used an external\n"
"package called `rand` to get random numbers. To use `rand` in our project, "
"we\n"
"added this line to *Cargo.toml*:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:269
msgid ""
"<!-- When updating the version of `rand` used, also update the version of\n"
"`rand` used in these files so they all match:\n"
"* ch02-00-guessing-game-tutorial.md\n"
"* ch14-03-cargo-workspaces.md\n"
"-->"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:277
msgid ""
"```toml\n"
"rand = \"0.8.5\"\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:281
msgid ""
"Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the\n"
"`rand` package and any dependencies from [crates.io](https://crates.io/) "
"and\n"
"make `rand` available to our project."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:285
msgid ""
"Then, to bring `rand` definitions into the scope of our package, we added a\n"
"`use` line starting with the name of the crate, `rand`, and listed the "
"items\n"
"we wanted to bring into scope. Recall that in the [‚ÄúGenerating a Random\n"
"Number‚Äù][rand]<!-- ignore --> section in Chapter 2, we brought the `Rng` "
"trait\n"
"into scope and called the `rand::thread_rng` function:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:291
msgid ""
"```rust,ignore\n"
"# use std::io;\n"
"use rand::Rng;\n"
"\n"
"fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"    let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:314
msgid ""
"Members of the Rust community have made many packages available at\n"
"[crates.io](https://crates.io/), and pulling any of them into your package\n"
"involves these same steps: listing them in your package‚Äôs *Cargo.toml* file "
"and\n"
"using `use` to bring items from their crates into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:319
msgid ""
"Note that the standard `std` library is also a crate that‚Äôs external to our\n"
"package. Because the standard library is shipped with the Rust language, we\n"
"don‚Äôt need to change *Cargo.toml* to include `std`. But we do need to refer "
"to\n"
"it with `use` to bring items from there into our package‚Äôs scope. For "
"example,\n"
"with `HashMap` we would use this line:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:325
msgid ""
"```rust\n"
"use std::collections::HashMap;\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:329
msgid ""
"This is an absolute path starting with `std`, the name of the standard "
"library\n"
"crate."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:332
msgid "### Using Nested Paths to Clean Up Large `use` Lists"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:334
msgid ""
"If we‚Äôre using multiple items defined in the same crate or same module,\n"
"listing each item on its own line can take up a lot of vertical space in "
"our\n"
"files. For example, these two `use` statements we had in the Guessing Game "
"in\n"
"Listing 2-4 bring items from `std` into scope:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:341
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"// --snip--\n"
"use std::cmp::Ordering;\n"
"use std::io;\n"
"// --snip--\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# \n"
"#     match guess.cmp(&secret_number) {\n"
"#         Ordering::Less => println!(\"Too small!\"),\n"
"#         Ordering::Greater => println!(\"Too big!\"),\n"
"#         Ordering::Equal => println!(\"You win!\"),\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:373
msgid ""
"Instead, we can use nested paths to bring the same items into scope in one\n"
"line. We do this by specifying the common part of the path, followed by two\n"
"colons, and then curly brackets around a list of the parts of the paths "
"that\n"
"differ, as shown in Listing 7-18."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:380
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"// --snip--\n"
"use std::{cmp::Ordering, io};\n"
"// --snip--\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     println!(\"Please input your guess.\");\n"
"# \n"
"#     let mut guess = String::new();\n"
"# \n"
"#     io::stdin()\n"
"#         .read_line(&mut guess)\n"
"#         .expect(\"Failed to read line\");\n"
"# \n"
"#     let guess: u32 = guess.trim().parse().expect(\"Please type a number!"
"\");\n"
"# \n"
"#     println!(\"You guessed: {guess}\");\n"
"# \n"
"#     match guess.cmp(&secret_number) {\n"
"#         Ordering::Less => println!(\"Too small!\"),\n"
"#         Ordering::Greater => println!(\"Too big!\"),\n"
"#         Ordering::Equal => println!(\"You win!\"),\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:413
msgid ""
"<span class=\"caption\">Listing 7-18: Specifying a nested path to bring "
"multiple\n"
"items with the same prefix into scope</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:416
msgid ""
"In bigger programs, bringing many items into scope from the same crate or\n"
"module using nested paths can reduce the number of separate `use` "
"statements\n"
"needed by a lot!"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:420
msgid ""
"We can use a nested path at any level in a path, which is useful when "
"combining\n"
"two `use` statements that share a subpath. For example, Listing 7-19 shows "
"two\n"
"`use` statements: one that brings `std::io` into scope and one that brings\n"
"`std::io::Write` into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:427
msgid ""
"```rust,noplayground\n"
"use std::io;\n"
"use std::io::Write;\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:432
msgid ""
"<span class=\"caption\">Listing 7-19: Two `use` statements where one is a "
"subpath\n"
"of the other</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:435
msgid ""
"The common part of these two paths is `std::io`, and that‚Äôs the complete "
"first\n"
"path. To merge these two paths into one `use` statement, we can use `self` "
"in\n"
"the nested path, as shown in Listing 7-20."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:441
msgid ""
"```rust,noplayground\n"
"use std::io::{self, Write};\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:445
msgid ""
"<span class=\"caption\">Listing 7-20: Combining the paths in Listing 7-19 "
"into\n"
"one `use` statement</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:448
msgid "This line brings `std::io` and `std::io::Write` into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:450
msgid "### The Glob Operator"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:452
msgid ""
"If we want to bring *all* public items defined in a path into scope, we can\n"
"specify that path followed by the `*` glob operator:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:455
msgid ""
"```rust\n"
"use std::collections::*;\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:459
msgid ""
"This `use` statement brings all public items defined in `std::collections` "
"into\n"
"the current scope. Be careful when using the glob operator! Glob can make "
"it\n"
"harder to tell what names are in scope and where a name used in your "
"program\n"
"was defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:464
msgid ""
"The glob operator is often used when testing to bring everything under test\n"
"into the `tests` module; we‚Äôll talk about that in the [‚ÄúHow to Write\n"
"Tests‚Äù][writing-tests]<!-- ignore --> section in Chapter 11. The glob "
"operator\n"
"is also sometimes used as part of the prelude pattern: see [the standard\n"
"library documentation](../std/prelude/index.html#other-preludes)<!-- ignore "
"-->\n"
"for more information on that pattern."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:1
msgid "## Separating Modules into Different Files"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file.\n"
"When modules get large, you might want to move their definitions to a "
"separate\n"
"file to make the code easier to navigate."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let‚Äôs start from the code in Listing 7-17 that had multiple\n"
"restaurant modules. We‚Äôll extract modules into files instead of having all "
"the\n"
"modules defined in the crate root file. In this case, the crate root file "
"is\n"
"*src/lib.rs*, but this procedure also works with binary crates whose crate "
"root\n"
"file is *src/main.rs*."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:13
msgid ""
"First, we‚Äôll extract the `front_of_house` module to its own file. Remove "
"the\n"
"code inside the curly brackets for the `front_of_house` module, leaving "
"only\n"
"the `mod front_of_house;` declaration, so that *src/lib.rs* contains the "
"code\n"
"shown in Listing 7-21. Note that this won‚Äôt compile until we create the\n"
"*src/front_of_house.rs* file in Listing 7-22."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:21
msgid ""
"```rust,ignore,does_not_compile\n"
"mod front_of_house;\n"
"\n"
"pub use crate::front_of_house::hosting;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:31
msgid ""
"<span class=\"caption\">Listing 7-21: Declaring the `front_of_house` module "
"whose\n"
"body will be in *src/front_of_house.rs*</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:34
msgid ""
"Next, place the code that was in the curly brackets into a new file named\n"
"*src/front_of_house.rs*, as shown in Listing 7-22. The compiler knows to "
"look\n"
"in this file because it came across the module declaration in the crate "
"root\n"
"with the name `front_of_house`."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:39
#: src/ch07-05-separating-modules-into-different-files.md:67
msgid "<span class=\"filename\">Filename: src/front_of_house.rs</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:41
msgid ""
"```rust,ignore\n"
"pub mod hosting {\n"
"    pub fn add_to_waitlist() {}\n"
"}\n"
"```"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:47
msgid ""
"<span class=\"caption\">Listing 7-22: Definitions inside the "
"`front_of_house`\n"
"module in *src/front_of_house.rs*</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:50
msgid ""
"Note that you only need to load a file using a `mod` declaration *once* in "
"your\n"
"module tree. Once the compiler knows the file is part of the project (and "
"knows\n"
"where in the module tree the code resides because of where you‚Äôve put the "
"`mod`\n"
"statement), other files in your project should refer to the loaded file‚Äôs "
"code\n"
"using a path to where it was declared, as covered in the [‚ÄúPaths for "
"Referring\n"
"to an Item in the Module Tree‚Äù][paths]<!-- ignore --> section. In other "
"words,\n"
"`mod` is *not* an ‚Äúinclude‚Äù operation that you may have seen in other\n"
"programming languages."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:59
msgid ""
"Next, we‚Äôll extract the `hosting` module to its own file. The process is a "
"bit\n"
"different because `hosting` is a child module of `front_of_house`, not of "
"the\n"
"root module. We‚Äôll place the file for `hosting` in a new directory that will "
"be\n"
"named for its ancestors in the module tree, in this case *src/front_of_house/"
"*."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:64
msgid ""
"To start moving `hosting`, we change *src/front_of_house.rs* to contain only "
"the\n"
"declaration of the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:69
msgid ""
"```rust,ignore\n"
"pub mod hosting;\n"
"```"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:73
msgid ""
"Then we create a *src/front_of_house* directory and a file *hosting.rs* to\n"
"contain the definitions made in the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:76
msgid "<span class=\"filename\">Filename: src/front_of_house/hosting.rs</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:78
msgid ""
"```rust,ignore\n"
"pub fn add_to_waitlist() {}\n"
"```"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:82
msgid ""
"If we instead put *hosting.rs* in the *src* directory, the compiler would\n"
"expect the *hosting.rs* code to be in a `hosting` module declared in the "
"crate\n"
"root, and not declared as a child of the `front_of_house` module. The\n"
"compiler‚Äôs rules for which files to check for which modules‚Äô code means the\n"
"directories and files more closely match the module tree."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:88
msgid ""
"> ### Alternate File Paths\n"
">\n"
"> So far we‚Äôve covered the most idiomatic file paths the Rust compiler "
"uses,\n"
"> but Rust also supports an older style of file path. For a module named\n"
"> `front_of_house` declared in the crate root, the compiler will look for "
"the\n"
"> module‚Äôs code in:\n"
">\n"
"> * *src/front_of_house.rs* (what we covered)\n"
"> * *src/front_of_house/mod.rs* (older style, still supported path)\n"
">\n"
"> For a module named `hosting` that is a submodule of `front_of_house`, the\n"
"> compiler will look for the module‚Äôs code in:\n"
">\n"
"> * *src/front_of_house/hosting.rs* (what we covered)\n"
"> * *src/front_of_house/hosting/mod.rs* (older style, still supported path)\n"
">\n"
"> If you use both styles for the same module, you‚Äôll get a compiler error. "
"Using\n"
"> a mix of both styles for different modules in the same project is allowed, "
"but\n"
"> might be confusing for people navigating your project.\n"
">\n"
"> The main downside to the style that uses files named *mod.rs* is that "
"your\n"
"> project can end up with many files named *mod.rs*, which can get "
"confusing\n"
"> when you have them open in your editor at the same time."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:112
msgid ""
"We‚Äôve moved each module‚Äôs code to a separate file, and the module tree "
"remains\n"
"the same. The function calls in `eat_at_restaurant` will work without any\n"
"modification, even though the definitions live in different files. This\n"
"technique lets you move modules to new files as they grow in size."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:117
msgid ""
"Note that the `pub use crate::front_of_house::hosting` statement in\n"
"*src/lib.rs* also hasn‚Äôt changed, nor does `use` have any impact on what "
"files\n"
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Rust\n"
"looks in a file with the same name as the module for the code that goes "
"into\n"
"that module."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:125
msgid ""
"Rust lets you split a package into multiple crates and a crate into modules\n"
"so you can refer to items defined in one module from another module. You can "
"do\n"
"this by specifying absolute or relative paths. These paths can be brought "
"into\n"
"scope with a `use` statement so you can use a shorter path for multiple uses "
"of\n"
"the item in that scope. Module code is private by default, but you can make\n"
"definitions public by adding the `pub` keyword."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:132
msgid ""
"In the next chapter, we‚Äôll look at some collection data structures in the\n"
"standard library that you can use in your neatly organized code."
msgstr ""

#: src/ch08-00-common-collections.md:1
msgid "# Common Collections"
msgstr ""

#: src/ch08-00-common-collections.md:3
msgid ""
"Rust‚Äôs standard library includes a number of very useful data structures "
"called\n"
"*collections*. Most other data types represent one specific value, but\n"
"collections can contain multiple values. Unlike the built-in array and "
"tuple\n"
"types, the data these collections point to is stored on the heap, which "
"means\n"
"the amount of data does not need to be known at compile time and can grow "
"or\n"
"shrink as the program runs. Each kind of collection has different "
"capabilities\n"
"and costs, and choosing an appropriate one for your current situation is a\n"
"skill you‚Äôll develop over time. In this chapter, we‚Äôll discuss three\n"
"collections that are used very often in Rust programs:"
msgstr ""

#: src/ch08-00-common-collections.md:13
msgid ""
"* A *vector* allows you to store a variable number of values next to each "
"other.\n"
"* A *string* is a collection of characters. We‚Äôve mentioned the `String` "
"type\n"
"  previously, but in this chapter we‚Äôll talk about it in depth.\n"
"* A *hash map* allows you to associate a value with a particular key. It‚Äôs "
"a\n"
"  particular implementation of the more general data structure called a "
"*map*."
msgstr ""

#: src/ch08-00-common-collections.md:19
msgid ""
"To learn about the other kinds of collections provided by the standard "
"library,\n"
"see [the documentation][collections]."
msgstr ""

#: src/ch08-00-common-collections.md:22
msgid ""
"We‚Äôll discuss how to create and update vectors, strings, and hash maps, as "
"well\n"
"as what makes each special."
msgstr ""

#: src/ch08-01-vectors.md:1
msgid "## Storing Lists of Values with Vectors"
msgstr ""

#: src/ch08-01-vectors.md:3
msgid ""
"The first collection type we‚Äôll look at is `Vec<T>`, also known as a "
"*vector*.\n"
"Vectors allow you to store more than one value in a single data structure "
"that\n"
"puts all the values next to each other in memory. Vectors can only store "
"values\n"
"of the same type. They are useful when you have a list of items, such as "
"the\n"
"lines of text in a file or the prices of items in a shopping cart."
msgstr ""

#: src/ch08-01-vectors.md:9
msgid "### Creating a New Vector"
msgstr ""

#: src/ch08-01-vectors.md:11
msgid ""
"To create a new empty vector, we call the `Vec::new` function, as shown in\n"
"Listing 8-1."
msgstr ""

#: src/ch08-01-vectors.md:14
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v: Vec<i32> = Vec::new();\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:20
msgid ""
"<span class=\"caption\">Listing 8-1: Creating a new, empty vector to hold "
"values\n"
"of type `i32`</span>"
msgstr ""

#: src/ch08-01-vectors.md:23
msgid ""
"Note that we added a type annotation here. Because we aren‚Äôt inserting any\n"
"values into this vector, Rust doesn‚Äôt know what kind of elements we intend "
"to\n"
"store. This is an important point. Vectors are implemented using generics;\n"
"we‚Äôll cover how to use generics with your own types in Chapter 10. For now,\n"
"know that the `Vec<T>` type provided by the standard library can hold any "
"type.\n"
"When we create a vector to hold a specific type, we can specify the type "
"within\n"
"angle brackets. In Listing 8-1, we‚Äôve told Rust that the `Vec<T>` in `v` "
"will\n"
"hold elements of the `i32` type."
msgstr ""

#: src/ch08-01-vectors.md:32
msgid ""
"More often, you‚Äôll create a `Vec<T>` with initial values and Rust will "
"infer\n"
"the type of value you want to store, so you rarely need to do this type\n"
"annotation. Rust conveniently provides the `vec!` macro, which will create "
"a\n"
"new vector that holds the values you give it. Listing 8-2 creates a new\n"
"`Vec<i32>` that holds the values `1`, `2`, and `3`. The integer type is "
"`i32`\n"
"because that‚Äôs the default integer type, as we discussed in the [‚ÄúData\n"
"Types‚Äù][data-types]<!-- ignore --> section of Chapter 3."
msgstr ""

#: src/ch08-01-vectors.md:40
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v = vec![1, 2, 3];\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:46
msgid ""
"<span class=\"caption\">Listing 8-2: Creating a new vector containing\n"
"values</span>"
msgstr ""

#: src/ch08-01-vectors.md:49
msgid ""
"Because we‚Äôve given initial `i32` values, Rust can infer that the type of "
"`v`\n"
"is `Vec<i32>`, and the type annotation isn‚Äôt necessary. Next, we‚Äôll look at "
"how\n"
"to modify a vector."
msgstr ""

#: src/ch08-01-vectors.md:53
msgid "### Updating a Vector"
msgstr ""

#: src/ch08-01-vectors.md:55
msgid ""
"To create a vector and then add elements to it, we can use the `push` "
"method,\n"
"as shown in Listing 8-3."
msgstr ""

#: src/ch08-01-vectors.md:58
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut v = Vec::new();\n"
"\n"
"    v.push(5);\n"
"    v.push(6);\n"
"    v.push(7);\n"
"    v.push(8);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:69
msgid ""
"<span class=\"caption\">Listing 8-3: Using the `push` method to add values "
"to a\n"
"vector</span>"
msgstr ""

#: src/ch08-01-vectors.md:72
msgid ""
"As with any variable, if we want to be able to change its value, we need to\n"
"make it mutable using the `mut` keyword, as discussed in Chapter 3. The "
"numbers\n"
"we place inside are all of type `i32`, and Rust infers this from the data, "
"so\n"
"we don‚Äôt need the `Vec<i32>` annotation."
msgstr ""

#: src/ch08-01-vectors.md:77
msgid "### Reading Elements of Vectors"
msgstr ""

#: src/ch08-01-vectors.md:79
msgid ""
"There are two ways to reference a value stored in a vector: via indexing or\n"
"using the `get` method. In the following examples, we‚Äôve annotated the types "
"of\n"
"the values that are returned from these functions for extra clarity."
msgstr ""

#: src/ch08-01-vectors.md:83
msgid ""
"Listing 8-4 shows both methods of accessing a value in a vector, with "
"indexing\n"
"syntax and the `get` method."
msgstr ""

#: src/ch08-01-vectors.md:86
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v = vec![1, 2, 3, 4, 5];\n"
"\n"
"    let third: &i32 = &v[2];\n"
"    println!(\"The third element is {third}\");\n"
"\n"
"    let third: Option<&i32> = v.get(2);\n"
"    match third {\n"
"        Some(third) => println!(\"The third element is {third}\"),\n"
"        None => println!(\"There is no third element.\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:101
msgid ""
"<span class=\"caption\">Listing 8-4: Using indexing syntax or the `get` "
"method to\n"
"access an item in a vector</span>"
msgstr ""

#: src/ch08-01-vectors.md:104
msgid ""
"Note a few details here. We use the index value of `2` to get the third "
"element\n"
"because vectors are indexed by number, starting at zero. Using `&` and `[]`\n"
"gives us a reference to the element at the index value. When we use the "
"`get`\n"
"method with the index passed as an argument, we get an `Option<&T>` that we "
"can\n"
"use with `match`."
msgstr ""

#: src/ch08-01-vectors.md:110
msgid ""
"The reason Rust provides these two ways to reference an element is so you "
"can\n"
"choose how the program behaves when you try to use an index value outside "
"the\n"
"range of existing elements. As an example, let‚Äôs see what happens when we "
"have\n"
"a vector of five elements and then we try to access an element at index 100\n"
"with each technique, as shown in Listing 8-5."
msgstr ""

#: src/ch08-01-vectors.md:116
msgid ""
"```rust,should_panic,panics\n"
"# fn main() {\n"
"    let v = vec![1, 2, 3, 4, 5];\n"
"\n"
"    let does_not_exist = &v[100];\n"
"    let does_not_exist = v.get(100);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:125
msgid ""
"<span class=\"caption\">Listing 8-5: Attempting to access the element at "
"index\n"
"100 in a vector containing five elements</span>"
msgstr ""

#: src/ch08-01-vectors.md:128
msgid ""
"When we run this code, the first `[]` method will cause the program to "
"panic\n"
"because it references a nonexistent element. This method is best used when "
"you\n"
"want your program to crash if there‚Äôs an attempt to access an element past "
"the\n"
"end of the vector."
msgstr ""

#: src/ch08-01-vectors.md:133
msgid ""
"When the `get` method is passed an index that is outside the vector, it "
"returns\n"
"`None` without panicking. You would use this method if accessing an element\n"
"beyond the range of the vector may happen occasionally under normal\n"
"circumstances. Your code will then have logic to handle having either\n"
"`Some(&element)` or `None`, as discussed in Chapter 6. For example, the "
"index\n"
"could be coming from a person entering a number. If they accidentally enter "
"a\n"
"number that‚Äôs too large and the program gets a `None` value, you could tell "
"the\n"
"user how many items are in the current vector and give them another chance "
"to\n"
"enter a valid value. That would be more user-friendly than crashing the "
"program\n"
"due to a typo!"
msgstr ""

#: src/ch08-01-vectors.md:144
msgid ""
"When the program has a valid reference, the borrow checker enforces the\n"
"ownership and borrowing rules (covered in Chapter 4) to ensure this "
"reference\n"
"and any other references to the contents of the vector remain valid. Recall "
"the\n"
"rule that states you can‚Äôt have mutable and immutable references in the "
"same\n"
"scope. That rule applies in Listing 8-6, where we hold an immutable "
"reference\n"
"to the first element in a vector and try to add an element to the end. This\n"
"program won‚Äôt work if we also try to refer to that element later in the\n"
"function:"
msgstr ""

#: src/ch08-01-vectors.md:154
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let mut v = vec![1, 2, 3, 4, 5];\n"
"\n"
"    let first = &v[0];\n"
"\n"
"    v.push(6);\n"
"\n"
"    println!(\"The first element is: {first}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:166
msgid ""
"<span class=\"caption\">Listing 8-6: Attempting to add an element to a "
"vector\n"
"while holding a reference to an item</span>"
msgstr ""

#: src/ch08-01-vectors.md:169
msgid "Compiling this code will result in this error:"
msgstr ""

#: src/ch08-01-vectors.md:172
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"error[E0502]: cannot borrow `v` as mutable because it is also borrowed as "
"immutable\n"
" --> src/main.rs:6:5\n"
"  |\n"
"4 |     let first = &v[0];\n"
"  |                  - immutable borrow occurs here\n"
"5 |\n"
"6 |     v.push(6);\n"
"  |     ^^^^^^^^^ mutable borrow occurs here\n"
"7 |\n"
"8 |     println!(\"The first element is: {first}\");\n"
"  |                                      ----- immutable borrow later used "
"here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `collections` due to previous error\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:191
msgid ""
"The code in Listing 8-6 might look like it should work: why should a "
"reference\n"
"to the first element care about changes at the end of the vector? This error "
"is\n"
"due to the way vectors work: because vectors put the values next to each "
"other\n"
"in memory, adding a new element onto the end of the vector might require\n"
"allocating new memory and copying the old elements to the new space, if "
"there\n"
"isn‚Äôt enough room to put all the elements next to each other where the "
"vector\n"
"is currently stored. In that case, the reference to the first element would "
"be\n"
"pointing to deallocated memory. The borrowing rules prevent programs from\n"
"ending up in that situation."
msgstr ""

#: src/ch08-01-vectors.md:201
msgid ""
"> Note: For more on the implementation details of the `Vec<T>` type, see "
"[‚ÄúThe\n"
"> Rustonomicon‚Äù][nomicon]."
msgstr ""

#: src/ch08-01-vectors.md:204
msgid "### Iterating over the Values in a Vector"
msgstr ""

#: src/ch08-01-vectors.md:206
msgid ""
"To access each element in a vector in turn, we would iterate through all of "
"the\n"
"elements rather than use indices to access one at a time. Listing 8-7 shows "
"how\n"
"to use a `for` loop to get immutable references to each element in a vector "
"of\n"
"`i32` values and print them."
msgstr ""

#: src/ch08-01-vectors.md:211
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v = vec![100, 32, 57];\n"
"    for i in &v {\n"
"        println!(\"{i}\");\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:220
msgid ""
"<span class=\"caption\">Listing 8-7: Printing each element in a vector by\n"
"iterating over the elements using a `for` loop</span>"
msgstr ""

#: src/ch08-01-vectors.md:223
msgid ""
"We can also iterate over mutable references to each element in a mutable "
"vector\n"
"in order to make changes to all the elements. The `for` loop in Listing 8-8\n"
"will add `50` to each element."
msgstr ""

#: src/ch08-01-vectors.md:227
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut v = vec![100, 32, 57];\n"
"    for i in &mut v {\n"
"        *i += 50;\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:236
msgid ""
"<span class=\"caption\">Listing 8-8: Iterating over mutable references to\n"
"elements in a vector</span>"
msgstr ""

#: src/ch08-01-vectors.md:239
msgid ""
"To change the value that the mutable reference refers to, we have to use "
"the\n"
"`*` dereference operator to get to the value in `i` before we can use the "
"`+=`\n"
"operator. We‚Äôll talk more about the dereference operator in the [‚ÄúFollowing "
"the\n"
"Pointer to the Value with the Dereference Operator‚Äù][deref]<!-- ignore -->\n"
"section of Chapter 15."
msgstr ""

#: src/ch08-01-vectors.md:245
msgid ""
"Iterating over a vector, whether immutably or mutably, is safe because of "
"the\n"
"borrow checker's rules. If we attempted to insert or remove items in the "
"`for`\n"
"loop bodies in Listing 8-7 and Listing 8-8, we would get a compiler error\n"
"similar to the one we got with the code in Listing 8-6. The reference to "
"the\n"
"vector that the `for` loop holds prevents simultaneous modification of the\n"
"whole vector."
msgstr ""

#: src/ch08-01-vectors.md:252
msgid "### Using an Enum to Store Multiple Types"
msgstr ""

#: src/ch08-01-vectors.md:254
msgid ""
"Vectors can only store values that are the same type. This can be "
"inconvenient;\n"
"there are definitely use cases for needing to store a list of items of\n"
"different types. Fortunately, the variants of an enum are defined under the\n"
"same enum type, so when we need one type to represent elements of different\n"
"types, we can define and use an enum!"
msgstr ""

#: src/ch08-01-vectors.md:260
msgid ""
"For example, say we want to get values from a row in a spreadsheet in which\n"
"some of the columns in the row contain integers, some floating-point "
"numbers,\n"
"and some strings. We can define an enum whose variants will hold the "
"different\n"
"value types, and all the enum variants will be considered the same type: "
"that\n"
"of the enum. Then we can create a vector to hold that enum and so, "
"ultimately,\n"
"holds different types. We‚Äôve demonstrated this in Listing 8-9."
msgstr ""

#: src/ch08-01-vectors.md:267
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum SpreadsheetCell {\n"
"        Int(i32),\n"
"        Float(f64),\n"
"        Text(String),\n"
"    }\n"
"\n"
"    let row = vec![\n"
"        SpreadsheetCell::Int(3),\n"
"        SpreadsheetCell::Text(String::from(\"blue\")),\n"
"        SpreadsheetCell::Float(10.12),\n"
"    ];\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:283
msgid ""
"<span class=\"caption\">Listing 8-9: Defining an `enum` to store values of\n"
"different types in one vector</span>"
msgstr ""

#: src/ch08-01-vectors.md:286
msgid ""
"Rust needs to know what types will be in the vector at compile time so it "
"knows\n"
"exactly how much memory on the heap will be needed to store each element. "
"We\n"
"must also be explicit about what types are allowed in this vector. If Rust\n"
"allowed a vector to hold any type, there would be a chance that one or more "
"of\n"
"the types would cause errors with the operations performed on the elements "
"of\n"
"the vector. Using an enum plus a `match` expression means that Rust will "
"ensure\n"
"at compile time that every possible case is handled, as discussed in Chapter "
"6."
msgstr ""

#: src/ch08-01-vectors.md:294
msgid ""
"If you don‚Äôt know the exhaustive set of types a program will get at runtime "
"to\n"
"store in a vector, the enum technique won‚Äôt work. Instead, you can use a "
"trait\n"
"object, which we‚Äôll cover in Chapter 17."
msgstr ""

#: src/ch08-01-vectors.md:298
msgid ""
"Now that we‚Äôve discussed some of the most common ways to use vectors, be "
"sure\n"
"to review [the API documentation][vec-api]<!-- ignore --> for all the many\n"
"useful methods defined on `Vec<T>` by the standard library. For example, in\n"
"addition to `push`, a `pop` method removes and returns the last element."
msgstr ""

#: src/ch08-01-vectors.md:303
msgid "### Dropping a Vector Drops Its Elements"
msgstr ""

#: src/ch08-01-vectors.md:305
msgid ""
"Like any other `struct`, a vector is freed when it goes out of scope, as\n"
"annotated in Listing 8-10."
msgstr ""

#: src/ch08-01-vectors.md:308
msgid ""
"```rust\n"
"# fn main() {\n"
"    {\n"
"        let v = vec![1, 2, 3, 4];\n"
"\n"
"        // do stuff with v\n"
"    } // <- v goes out of scope and is freed here\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:318
msgid ""
"<span class=\"caption\">Listing 8-10: Showing where the vector and its "
"elements\n"
"are dropped</span>"
msgstr ""

#: src/ch08-01-vectors.md:321
msgid ""
"When the vector gets dropped, all of its contents are also dropped, meaning "
"the\n"
"integers it holds will be cleaned up. The borrow checker ensures that any\n"
"references to contents of a vector are only used while the vector itself is\n"
"valid."
msgstr ""

#: src/ch08-01-vectors.md:326
msgid "Let‚Äôs move on to the next collection type: `String`!"
msgstr ""

#: src/ch08-02-strings.md:1
msgid "## Storing UTF-8 Encoded Text with Strings"
msgstr ""

#: src/ch08-02-strings.md:3
msgid ""
"We talked about strings in Chapter 4, but we‚Äôll look at them in more depth "
"now.\n"
"New Rustaceans commonly get stuck on strings for a combination of three\n"
"reasons: Rust‚Äôs propensity for exposing possible errors, strings being a "
"more\n"
"complicated data structure than many programmers give them credit for, and\n"
"UTF-8. These factors combine in a way that can seem difficult when you‚Äôre\n"
"coming from other programming languages."
msgstr ""

#: src/ch08-02-strings.md:10
msgid ""
"We discuss strings in the context of collections because strings are\n"
"implemented as a collection of bytes, plus some methods to provide useful\n"
"functionality when those bytes are interpreted as text. In this section, "
"we‚Äôll\n"
"talk about the operations on `String` that every collection type has, such "
"as\n"
"creating, updating, and reading. We‚Äôll also discuss the ways in which "
"`String`\n"
"is different from the other collections, namely how indexing into a `String` "
"is\n"
"complicated by the differences between how people and computers interpret\n"
"`String` data."
msgstr ""

#: src/ch08-02-strings.md:19
msgid "### What Is a String?"
msgstr ""

#: src/ch08-02-strings.md:21
msgid ""
"We‚Äôll first define what we mean by the term *string*. Rust has only one "
"string\n"
"type in the core language, which is the string slice `str` that is usually "
"seen\n"
"in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,\n"
"which are references to some UTF-8 encoded string data stored elsewhere. "
"String\n"
"literals, for example, are stored in the program‚Äôs binary and are therefore\n"
"string slices."
msgstr ""

#: src/ch08-02-strings.md:28
msgid ""
"The `String` type, which is provided by Rust‚Äôs standard library rather than\n"
"coded into the core language, is a growable, mutable, owned, UTF-8 encoded\n"
"string type. When Rustaceans refer to ‚Äústrings‚Äù in Rust, they might be\n"
"referring to either the `String` or the string slice `&str` types, not just "
"one\n"
"of those types. Although this section is largely about `String`, both types "
"are\n"
"used heavily in Rust‚Äôs standard library, and both `String` and string "
"slices\n"
"are UTF-8 encoded."
msgstr ""

#: src/ch08-02-strings.md:36
msgid "### Creating a New String"
msgstr ""

#: src/ch08-02-strings.md:38
msgid ""
"Many of the same operations available with `Vec<T>` are available with "
"`String`\n"
"as well, because `String` is actually implemented as a wrapper around a "
"vector\n"
"of bytes with some extra guarantees, restrictions, and capabilities. An "
"example\n"
"of a function that works the same way with `Vec<T>` and `String` is the "
"`new`\n"
"function to create an instance, shown in Listing 8-11."
msgstr ""

#: src/ch08-02-strings.md:44
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s = String::new();\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:50
msgid ""
"<span class=\"caption\">Listing 8-11: Creating a new, empty `String`</span>"
msgstr ""

#: src/ch08-02-strings.md:52
msgid ""
"This line creates a new empty string called `s`, which we can then load "
"data\n"
"into. Often, we‚Äôll have some initial data that we want to start the string\n"
"with. For that, we use the `to_string` method, which is available on any "
"type\n"
"that implements the `Display` trait, as string literals do. Listing 8-12 "
"shows\n"
"two examples."
msgstr ""

#: src/ch08-02-strings.md:58
msgid ""
"```rust\n"
"# fn main() {\n"
"    let data = \"initial contents\";\n"
"\n"
"    let s = data.to_string();\n"
"\n"
"    // the method also works on a literal directly:\n"
"    let s = \"initial contents\".to_string();\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:69
msgid ""
"<span class=\"caption\">Listing 8-12: Using the `to_string` method to create "
"a\n"
"`String` from a string literal</span>"
msgstr ""

#: src/ch08-02-strings.md:72
msgid "This code creates a string containing `initial contents`."
msgstr ""

#: src/ch08-02-strings.md:74
msgid ""
"We can also use the function `String::from` to create a `String` from a "
"string\n"
"literal. The code in Listing 8-13 is equivalent to the code from Listing "
"8-12\n"
"that uses `to_string`."
msgstr ""

#: src/ch08-02-strings.md:78
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s = String::from(\"initial contents\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:84
msgid ""
"<span class=\"caption\">Listing 8-13: Using the `String::from` function to "
"create\n"
"a `String` from a string literal</span>"
msgstr ""

#: src/ch08-02-strings.md:87
msgid ""
"Because strings are used for so many things, we can use many different "
"generic\n"
"APIs for strings, providing us with a lot of options. Some of them can seem\n"
"redundant, but they all have their place! In this case, `String::from` and\n"
"`to_string` do the same thing, so which you choose is a matter of style and\n"
"readability."
msgstr ""

#: src/ch08-02-strings.md:93
msgid ""
"Remember that strings are UTF-8 encoded, so we can include any properly "
"encoded\n"
"data in them, as shown in Listing 8-14."
msgstr ""

#: src/ch08-02-strings.md:96
msgid ""
"```rust\n"
"# fn main() {\n"
"    let hello = String::from(\"ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ\");\n"
"    let hello = String::from(\"Dobr√Ω den\");\n"
"    let hello = String::from(\"Hello\");\n"
"    let hello = String::from(\"◊©÷∏◊Å◊ú◊ï÷π◊ù\");\n"
"    let hello = String::from(\"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\");\n"
"    let hello = String::from(\"„Åì„Çì„Å´„Å°„ÅØ\");\n"
"    let hello = String::from(\"ÏïàÎÖïÌïòÏÑ∏Ïöî\");\n"
"    let hello = String::from(\"‰Ω†Â•Ω\");\n"
"    let hello = String::from(\"Ol√°\");\n"
"    let hello = String::from(\"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\");\n"
"    let hello = String::from(\"Hola\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:112
msgid ""
"<span class=\"caption\">Listing 8-14: Storing greetings in different "
"languages in\n"
"strings</span>"
msgstr ""

#: src/ch08-02-strings.md:115
msgid "All of these are valid `String` values."
msgstr ""

#: src/ch08-02-strings.md:117
msgid "### Updating a String"
msgstr ""

#: src/ch08-02-strings.md:119
msgid ""
"A `String` can grow in size and its contents can change, just like the "
"contents\n"
"of a `Vec<T>`, if you push more data into it. In addition, you can "
"conveniently\n"
"use the `+` operator or the `format!` macro to concatenate `String` values."
msgstr ""

#: src/ch08-02-strings.md:123
msgid "#### Appending to a String with `push_str` and `push`"
msgstr ""

#: src/ch08-02-strings.md:125
msgid ""
"We can grow a `String` by using the `push_str` method to append a string "
"slice,\n"
"as shown in Listing 8-15."
msgstr ""

#: src/ch08-02-strings.md:128
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s = String::from(\"foo\");\n"
"    s.push_str(\"bar\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:135
msgid ""
"<span class=\"caption\">Listing 8-15: Appending a string slice to a "
"`String`\n"
"using the `push_str` method</span>"
msgstr ""

#: src/ch08-02-strings.md:138
msgid ""
"After these two lines, `s` will contain `foobar`. The `push_str` method "
"takes a\n"
"string slice because we don‚Äôt necessarily want to take ownership of the\n"
"parameter. For example, in the code in Listing 8-16, we want to be able to "
"use\n"
"`s2` after appending its contents to `s1`."
msgstr ""

#: src/ch08-02-strings.md:143
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s1 = String::from(\"foo\");\n"
"    let s2 = \"bar\";\n"
"    s1.push_str(s2);\n"
"    println!(\"s2 is {s2}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:152
msgid ""
"<span class=\"caption\">Listing 8-16: Using a string slice after appending "
"its\n"
"contents to a `String`</span>"
msgstr ""

#: src/ch08-02-strings.md:155
msgid ""
"If the `push_str` method took ownership of `s2`, we wouldn‚Äôt be able to "
"print\n"
"its value on the last line. However, this code works as we‚Äôd expect!"
msgstr ""

#: src/ch08-02-strings.md:158
msgid ""
"The `push` method takes a single character as a parameter and adds it to "
"the\n"
"`String`. Listing 8-17 adds the letter ‚Äúl‚Äù to a `String` using the `push`\n"
"method."
msgstr ""

#: src/ch08-02-strings.md:162
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut s = String::from(\"lo\");\n"
"    s.push('l');\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:169
msgid ""
"<span class=\"caption\">Listing 8-17: Adding one character to a `String` "
"value\n"
"using `push`</span>"
msgstr ""

#: src/ch08-02-strings.md:172
msgid "As a result, `s` will contain `lol`."
msgstr ""

#: src/ch08-02-strings.md:174
msgid "#### Concatenation with the `+` Operator or the `format!` Macro"
msgstr ""

#: src/ch08-02-strings.md:176
msgid ""
"Often, you‚Äôll want to combine two existing strings. One way to do so is to "
"use\n"
"the `+` operator, as shown in Listing 8-18."
msgstr ""

#: src/ch08-02-strings.md:179
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"Hello, \");\n"
"    let s2 = String::from(\"world!\");\n"
"    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be "
"used\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:187
msgid ""
"<span class=\"caption\">Listing 8-18: Using the `+` operator to combine two\n"
"`String` values into a new `String` value</span>"
msgstr ""

#: src/ch08-02-strings.md:190
msgid ""
"The string `s3` will contain `Hello, world!`. The reason `s1` is no longer\n"
"valid after the addition, and the reason we used a reference to `s2`, has to "
"do\n"
"with the signature of the method that‚Äôs called when we use the `+` "
"operator.\n"
"The `+` operator uses the `add` method, whose signature looks something "
"like\n"
"this:"
msgstr ""

#: src/ch08-02-strings.md:196
msgid ""
"```rust,ignore\n"
"fn add(self, s: &str) -> String {\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:200
msgid ""
"In the standard library, you'll see `add` defined using generics and "
"associated\n"
"types. Here, we‚Äôve substituted in concrete types, which is what happens when "
"we\n"
"call this method with `String` values. We‚Äôll discuss generics in Chapter "
"10.\n"
"This signature gives us the clues we need to understand the tricky bits of "
"the\n"
"`+` operator."
msgstr ""

#: src/ch08-02-strings.md:206
msgid ""
"First, `s2` has an `&`, meaning that we‚Äôre adding a *reference* of the "
"second\n"
"string to the first string. This is because of the `s` parameter in the "
"`add`\n"
"function: we can only add a `&str` to a `String`; we can‚Äôt add two `String`\n"
"values together. But wait‚Äîthe type of `&s2` is `&String`, not `&str`, as\n"
"specified in the second parameter to `add`. So why does Listing 8-18 compile?"
msgstr ""

#: src/ch08-02-strings.md:212
msgid ""
"The reason we‚Äôre able to use `&s2` in the call to `add` is that the "
"compiler\n"
"can *coerce* the `&String` argument into a `&str`. When we call the `add`\n"
"method, Rust uses a *deref coercion*, which here turns `&s2` into "
"`&s2[..]`.\n"
"We‚Äôll discuss deref coercion in more depth in Chapter 15. Because `add` "
"does\n"
"not take ownership of the `s` parameter, `s2` will still be a valid "
"`String`\n"
"after this operation."
msgstr ""

#: src/ch08-02-strings.md:219
msgid ""
"Second, we can see in the signature that `add` takes ownership of `self`,\n"
"because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will "
"be\n"
"moved into the `add` call and will no longer be valid after that. So "
"although\n"
"`let s3 = s1 + &s2;` looks like it will copy both strings and create a new "
"one,\n"
"this statement actually takes ownership of `s1`, appends a copy of the "
"contents\n"
"of `s2`, and then returns ownership of the result. In other words, it looks\n"
"like it‚Äôs making a lot of copies but isn‚Äôt; the implementation is more\n"
"efficient than copying."
msgstr ""

#: src/ch08-02-strings.md:228
msgid ""
"If we need to concatenate multiple strings, the behavior of the `+` "
"operator\n"
"gets unwieldy:"
msgstr ""

#: src/ch08-02-strings.md:231
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"tic\");\n"
"    let s2 = String::from(\"tac\");\n"
"    let s3 = String::from(\"toe\");\n"
"\n"
"    let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:241
msgid ""
"At this point, `s` will be `tic-tac-toe`. With all of the `+` and `\"`\n"
"characters, it‚Äôs difficult to see what‚Äôs going on. For more complicated "
"string\n"
"combining, we can instead use the `format!` macro:"
msgstr ""

#: src/ch08-02-strings.md:245
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s1 = String::from(\"tic\");\n"
"    let s2 = String::from(\"tac\");\n"
"    let s3 = String::from(\"toe\");\n"
"\n"
"    let s = format!(\"{s1}-{s2}-{s3}\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:255
msgid ""
"This code also sets `s` to `tic-tac-toe`. The `format!` macro works like\n"
"`println!`, but instead of printing the output to the screen, it returns a\n"
"`String` with the contents. The version of the code using `format!` is much\n"
"easier to read, and the code generated by the `format!` macro uses "
"references\n"
"so that this call doesn‚Äôt take ownership of any of its parameters."
msgstr ""

#: src/ch08-02-strings.md:261
msgid "### Indexing into Strings"
msgstr ""

#: src/ch08-02-strings.md:263
msgid ""
"In many other programming languages, accessing individual characters in a\n"
"string by referencing them by index is a valid and common operation. "
"However,\n"
"if you try to access parts of a `String` using indexing syntax in Rust, "
"you‚Äôll\n"
"get an error. Consider the invalid code in Listing 8-19."
msgstr ""

#: src/ch08-02-strings.md:268
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let s1 = String::from(\"hello\");\n"
"    let h = s1[0];\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:275
msgid ""
"<span class=\"caption\">Listing 8-19: Attempting to use indexing syntax with "
"a\n"
"String</span>"
msgstr ""

#: src/ch08-02-strings.md:278
msgid "This code will result in the following error:"
msgstr ""

#: src/ch08-02-strings.md:280
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"error[E0277]: the type `String` cannot be indexed by `{integer}`\n"
" --> src/main.rs:3:13\n"
"  |\n"
"3 |     let h = s1[0];\n"
"  |             ^^^^^ `String` cannot be indexed by `{integer}`\n"
"  |\n"
"  = help: the trait `Index<{integer}>` is not implemented for `String`\n"
"  = help: the following other types implement trait `Index<Idx>`:\n"
"            <String as Index<RangeFrom<usize>>>\n"
"            <String as Index<RangeFull>>\n"
"            <String as Index<RangeInclusive<usize>>>\n"
"            <String as Index<RangeTo<usize>>>\n"
"            <String as Index<RangeToInclusive<usize>>>\n"
"            <String as Index<std::ops::Range<usize>>>\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `collections` due to previous error\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:302
msgid ""
"The error and the note tell the story: Rust strings don‚Äôt support indexing. "
"But\n"
"why not? To answer that question, we need to discuss how Rust stores strings "
"in\n"
"memory."
msgstr ""

#: src/ch08-02-strings.md:306
msgid "#### Internal Representation"
msgstr ""

#: src/ch08-02-strings.md:308
msgid ""
"A `String` is a wrapper over a `Vec<u8>`. Let‚Äôs look at some of our "
"properly\n"
"encoded UTF-8 example strings from Listing 8-14. First, this one:"
msgstr ""

#: src/ch08-02-strings.md:311
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let hello = String::from(\"ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ\");\n"
"#     let hello = String::from(\"Dobr√Ω den\");\n"
"#     let hello = String::from(\"Hello\");\n"
"#     let hello = String::from(\"◊©÷∏◊Å◊ú◊ï÷π◊ù\");\n"
"#     let hello = String::from(\"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\");\n"
"#     let hello = String::from(\"„Åì„Çì„Å´„Å°„ÅØ\");\n"
"#     let hello = String::from(\"ÏïàÎÖïÌïòÏÑ∏Ïöî\");\n"
"#     let hello = String::from(\"‰Ω†Â•Ω\");\n"
"#     let hello = String::from(\"Ol√°\");\n"
"#     let hello = String::from(\"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\");\n"
"    let hello = String::from(\"Hola\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:327
msgid ""
"In this case, `len` will be 4, which means the vector storing the string "
"‚ÄúHola‚Äù\n"
"is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. "
"The\n"
"following line, however, may surprise you. (Note that this string begins "
"with\n"
"the capital Cyrillic letter Ze, not the number 3.)"
msgstr ""

#: src/ch08-02-strings.md:332
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let hello = String::from(\"ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ\");\n"
"#     let hello = String::from(\"Dobr√Ω den\");\n"
"#     let hello = String::from(\"Hello\");\n"
"#     let hello = String::from(\"◊©÷∏◊Å◊ú◊ï÷π◊ù\");\n"
"#     let hello = String::from(\"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\");\n"
"#     let hello = String::from(\"„Åì„Çì„Å´„Å°„ÅØ\");\n"
"#     let hello = String::from(\"ÏïàÎÖïÌïòÏÑ∏Ïöî\");\n"
"#     let hello = String::from(\"‰Ω†Â•Ω\");\n"
"#     let hello = String::from(\"Ol√°\");\n"
"    let hello = String::from(\"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\");\n"
"#     let hello = String::from(\"Hola\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:348
msgid ""
"Asked how long the string is, you might say 12. In fact, Rust‚Äôs answer is "
"24:\n"
"that‚Äôs the number of bytes it takes to encode ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù in UTF-8, "
"because\n"
"each Unicode scalar value in that string takes 2 bytes of storage. "
"Therefore,\n"
"an index into the string‚Äôs bytes will not always correlate to a valid "
"Unicode\n"
"scalar value. To demonstrate, consider this invalid Rust code:"
msgstr ""

#: src/ch08-02-strings.md:354
msgid ""
"```rust,ignore,does_not_compile\n"
"let hello = \"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\";\n"
"let answer = &hello[0];\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:359
msgid ""
"You already know that `answer` will not be `–ó`, the first letter. When "
"encoded\n"
"in UTF-8, the first byte of `–ó` is `208` and the second is `151`, so it "
"would\n"
"seem that `answer` should in fact be `208`, but `208` is not a valid "
"character\n"
"on its own. Returning `208` is likely not what a user would want if they "
"asked\n"
"for the first letter of this string; however, that‚Äôs the only data that "
"Rust\n"
"has at byte index 0. Users generally don‚Äôt want the byte value returned, "
"even\n"
"if the string contains only Latin letters: if `&\"hello\"[0]` were valid "
"code\n"
"that returned the byte value, it would return `104`, not `h`."
msgstr ""

#: src/ch08-02-strings.md:368
msgid ""
"The answer, then, is that to avoid returning an unexpected value and "
"causing\n"
"bugs that might not be discovered immediately, Rust doesn‚Äôt compile this "
"code\n"
"at all and prevents misunderstandings early in the development process."
msgstr ""

#: src/ch08-02-strings.md:372
msgid "#### Bytes and Scalar Values and Grapheme Clusters! Oh My!"
msgstr ""

#: src/ch08-02-strings.md:374
msgid ""
"Another point about UTF-8 is that there are actually three relevant ways to\n"
"look at strings from Rust‚Äôs perspective: as bytes, scalar values, and "
"grapheme\n"
"clusters (the closest thing to what we would call *letters*)."
msgstr ""

#: src/ch08-02-strings.md:378
msgid ""
"If we look at the Hindi word ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù written in the Devanagari script, it is\n"
"stored as a vector of `u8` values that looks like this:"
msgstr ""

#: src/ch08-02-strings.md:381
msgid ""
"```text\n"
"[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n"
"224, 165, 135]\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:386
msgid ""
"That‚Äôs 18 bytes and is how computers ultimately store this data. If we look "
"at\n"
"them as Unicode scalar values, which are what Rust‚Äôs `char` type is, those\n"
"bytes look like this:"
msgstr ""

#: src/ch08-02-strings.md:390
msgid ""
"```text\n"
"['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:394
msgid ""
"There are six `char` values here, but the fourth and sixth are not letters:\n"
"they‚Äôre diacritics that don‚Äôt make sense on their own. Finally, if we look "
"at\n"
"them as grapheme clusters, we‚Äôd get what a person would call the four "
"letters\n"
"that make up the Hindi word:"
msgstr ""

#: src/ch08-02-strings.md:399
msgid ""
"```text\n"
"[\"‡§®\", \"‡§Æ\", \"‡§∏‡•ç\", \"‡§§‡•á\"]\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:403
msgid ""
"Rust provides different ways of interpreting the raw string data that "
"computers\n"
"store so that each program can choose the interpretation it needs, no "
"matter\n"
"what human language the data is in."
msgstr ""

#: src/ch08-02-strings.md:407
msgid ""
"A final reason Rust doesn‚Äôt allow us to index into a `String` to get a\n"
"character is that indexing operations are expected to always take constant "
"time\n"
"(O(1)). But it isn‚Äôt possible to guarantee that performance with a "
"`String`,\n"
"because Rust would have to walk through the contents from the beginning to "
"the\n"
"index to determine how many valid characters there were."
msgstr ""

#: src/ch08-02-strings.md:413
msgid "### Slicing Strings"
msgstr ""

#: src/ch08-02-strings.md:415
msgid ""
"Indexing into a string is often a bad idea because it‚Äôs not clear what the\n"
"return type of the string-indexing operation should be: a byte value, a\n"
"character, a grapheme cluster, or a string slice. If you really need to use\n"
"indices to create string slices, therefore, Rust asks you to be more "
"specific."
msgstr ""

#: src/ch08-02-strings.md:420
msgid ""
"Rather than indexing using `[]` with a single number, you can use `[]` with "
"a\n"
"range to create a string slice containing particular bytes:"
msgstr ""

#: src/ch08-02-strings.md:423
msgid ""
"```rust\n"
"let hello = \"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\";\n"
"\n"
"let s = &hello[0..4];\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:429
msgid ""
"Here, `s` will be a `&str` that contains the first 4 bytes of the string.\n"
"Earlier, we mentioned that each of these characters was 2 bytes, which "
"means\n"
"`s` will be `–ó–¥`."
msgstr ""

#: src/ch08-02-strings.md:433
msgid ""
"If we were to try to slice only part of a character‚Äôs bytes with something "
"like\n"
"`&hello[0..1]`, Rust would panic at runtime in the same way as if an "
"invalid\n"
"index were accessed in a vector:"
msgstr ""

#: src/ch08-02-strings.md:437
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/collections`\n"
"thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside "
"'–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:446
msgid ""
"You should use ranges to create string slices with caution, because doing "
"so\n"
"can crash your program."
msgstr ""

#: src/ch08-02-strings.md:449
msgid "### Methods for Iterating Over Strings"
msgstr ""

#: src/ch08-02-strings.md:451
msgid ""
"The best way to operate on pieces of strings is to be explicit about "
"whether\n"
"you want characters or bytes. For individual Unicode scalar values, use the\n"
"`chars` method. Calling `chars` on ‚Äú–ó–¥‚Äù separates out and returns two "
"values\n"
"of type `char`, and you can iterate over the result to access each element:"
msgstr ""

#: src/ch08-02-strings.md:456
msgid ""
"```rust\n"
"for c in \"–ó–¥\".chars() {\n"
"    println!(\"{c}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:462 src/ch16-03-shared-state.md:323
msgid "This code will print the following:"
msgstr ""

#: src/ch08-02-strings.md:464
msgid ""
"```text\n"
"–ó\n"
"–¥\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:469
msgid ""
"Alternatively, the `bytes` method returns each raw byte, which might be\n"
"appropriate for your domain:"
msgstr ""

#: src/ch08-02-strings.md:472
msgid ""
"```rust\n"
"for b in \"–ó–¥\".bytes() {\n"
"    println!(\"{b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:478
msgid "This code will print the four bytes that make up this string:"
msgstr ""

#: src/ch08-02-strings.md:480
msgid ""
"```text\n"
"208\n"
"151\n"
"208\n"
"180\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:487
msgid ""
"But be sure to remember that valid Unicode scalar values may be made up of "
"more\n"
"than 1 byte."
msgstr ""

#: src/ch08-02-strings.md:490
msgid ""
"Getting grapheme clusters from strings as with the Devanagari script is\n"
"complex, so this functionality is not provided by the standard library. "
"Crates\n"
"are available on [crates.io](https://crates.io/)<!-- ignore --> if this is "
"the\n"
"functionality you need."
msgstr ""

#: src/ch08-02-strings.md:495
msgid "### Strings Are Not So Simple"
msgstr ""

#: src/ch08-02-strings.md:497
msgid ""
"To summarize, strings are complicated. Different programming languages make\n"
"different choices about how to present this complexity to the programmer. "
"Rust\n"
"has chosen to make the correct handling of `String` data the default "
"behavior\n"
"for all Rust programs, which means programmers have to put more thought "
"into\n"
"handling UTF-8 data upfront. This trade-off exposes more of the complexity "
"of\n"
"strings than is apparent in other programming languages, but it prevents "
"you\n"
"from having to handle errors involving non-ASCII characters later in your\n"
"development life cycle."
msgstr ""

#: src/ch08-02-strings.md:506
msgid ""
"The good news is that the standard library offers a lot of functionality "
"built\n"
"off the `String` and `&str` types to help handle these complex situations\n"
"correctly. Be sure to check out the documentation for useful methods like\n"
"`contains` for searching in a string and `replace` for substituting parts of "
"a\n"
"string with another string."
msgstr ""

#: src/ch08-02-strings.md:512
msgid "Let‚Äôs switch to something a bit less complex: hash maps!"
msgstr ""

#: src/ch08-03-hash-maps.md:1
msgid "## Storing Keys with Associated Values in Hash Maps"
msgstr ""

#: src/ch08-03-hash-maps.md:3
msgid ""
"The last of our common collections is the *hash map*. The type `HashMap<K, "
"V>`\n"
"stores a mapping of keys of type `K` to values of type `V` using a\n"
"*hashing function*, which determines how it places these keys and values "
"into\n"
"memory. Many programming languages support this kind of data structure, but\n"
"they often use a different name, such as hash, map, object, hash table,\n"
"dictionary, or associative array, just to name a few."
msgstr ""

#: src/ch08-03-hash-maps.md:10
msgid ""
"Hash maps are useful when you want to look up data not by using an index, "
"as\n"
"you can with vectors, but by using a key that can be of any type. For "
"example,\n"
"in a game, you could keep track of each team‚Äôs score in a hash map in which\n"
"each key is a team‚Äôs name and the values are each team‚Äôs score. Given a "
"team\n"
"name, you can retrieve its score."
msgstr ""

#: src/ch08-03-hash-maps.md:16
msgid ""
"We‚Äôll go over the basic API of hash maps in this section, but many more "
"goodies\n"
"are hiding in the functions defined on `HashMap<K, V>` by the standard "
"library.\n"
"As always, check the standard library documentation for more information."
msgstr ""

#: src/ch08-03-hash-maps.md:20
msgid "### Creating a New Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:22
msgid ""
"One way to create an empty hash map is using `new` and adding elements with\n"
"`insert`. In Listing 8-20, we‚Äôre keeping track of the scores of two teams "
"whose\n"
"names are *Blue* and *Yellow*. The Blue team starts with 10 points, and the\n"
"Yellow team starts with 50."
msgstr ""

#: src/ch08-03-hash-maps.md:27
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let mut scores = HashMap::new();\n"
"\n"
"    scores.insert(String::from(\"Blue\"), 10);\n"
"    scores.insert(String::from(\"Yellow\"), 50);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:38
msgid ""
"<span class=\"caption\">Listing 8-20: Creating a new hash map and inserting "
"some\n"
"keys and values</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:41
msgid ""
"Note that we need to first `use` the `HashMap` from the collections portion "
"of\n"
"the standard library. Of our three common collections, this one is the "
"least\n"
"often used, so it‚Äôs not included in the features brought into scope\n"
"automatically in the prelude. Hash maps also have less support from the\n"
"standard library; there‚Äôs no built-in macro to construct them, for example."
msgstr ""

#: src/ch08-03-hash-maps.md:47
msgid ""
"Just like vectors, hash maps store their data on the heap. This `HashMap` "
"has\n"
"keys of type `String` and values of type `i32`. Like vectors, hash maps are\n"
"homogeneous: all of the keys must have the same type as each other, and all "
"of\n"
"the values must have the same type."
msgstr ""

#: src/ch08-03-hash-maps.md:52
msgid "### Accessing Values in a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:54
msgid ""
"We can get a value out of the hash map by providing its key to the `get`\n"
"method, as shown in Listing 8-21."
msgstr ""

#: src/ch08-03-hash-maps.md:57
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let mut scores = HashMap::new();\n"
"\n"
"    scores.insert(String::from(\"Blue\"), 10);\n"
"    scores.insert(String::from(\"Yellow\"), 50);\n"
"\n"
"    let team_name = String::from(\"Blue\");\n"
"    let score = scores.get(&team_name).copied().unwrap_or(0);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:71
msgid ""
"<span class=\"caption\">Listing 8-21: Accessing the score for the Blue team\n"
"stored in the hash map</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:74
msgid ""
"Here, `score` will have the value that‚Äôs associated with the Blue team, and "
"the\n"
"result will be `10`. The `get` method returns an `Option<&V>`; if there‚Äôs "
"no\n"
"value for that key in the hash map, `get` will return `None`. This program\n"
"handles the `Option` by calling `copied` to get an `Option<i32>` rather than "
"an\n"
"`Option<&i32>`, then `unwrap_or` to set `score` to zero if `scores` doesn't\n"
"have an entry for the key."
msgstr ""

#: src/ch08-03-hash-maps.md:81
msgid ""
"We can iterate over each key/value pair in a hash map in a similar manner as "
"we\n"
"do with vectors, using a `for` loop:"
msgstr ""

#: src/ch08-03-hash-maps.md:84
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let mut scores = HashMap::new();\n"
"\n"
"    scores.insert(String::from(\"Blue\"), 10);\n"
"    scores.insert(String::from(\"Yellow\"), 50);\n"
"\n"
"    for (key, value) in &scores {\n"
"        println!(\"{key}: {value}\");\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:99
msgid "This code will print each pair in an arbitrary order:"
msgstr ""

#: src/ch08-03-hash-maps.md:101
msgid ""
"```text\n"
"Yellow: 50\n"
"Blue: 10\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:106
msgid "### Hash Maps and Ownership"
msgstr ""

#: src/ch08-03-hash-maps.md:108
msgid ""
"For types that implement the `Copy` trait, like `i32`, the values are "
"copied\n"
"into the hash map. For owned values like `String`, the values will be moved "
"and\n"
"the hash map will be the owner of those values, as demonstrated in Listing "
"8-22."
msgstr ""

#: src/ch08-03-hash-maps.md:112
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let field_name = String::from(\"Favorite color\");\n"
"    let field_value = String::from(\"Blue\");\n"
"\n"
"    let mut map = HashMap::new();\n"
"    map.insert(field_name, field_value);\n"
"    // field_name and field_value are invalid at this point, try using them "
"and\n"
"    // see what compiler error you get!\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:126
msgid ""
"<span class=\"caption\">Listing 8-22: Showing that keys and values are owned "
"by\n"
"the hash map once they‚Äôre inserted</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:129
msgid ""
"We aren‚Äôt able to use the variables `field_name` and `field_value` after\n"
"they‚Äôve been moved into the hash map with the call to `insert`."
msgstr ""

#: src/ch08-03-hash-maps.md:132
msgid ""
"If we insert references to values into the hash map, the values won‚Äôt be "
"moved\n"
"into the hash map. The values that the references point to must be valid for "
"at\n"
"least as long as the hash map is valid. We‚Äôll talk more about these issues "
"in\n"
"the [‚ÄúValidating References with\n"
"Lifetimes‚Äù][validating-references-with-lifetimes]<!-- ignore --> section in\n"
"Chapter 10."
msgstr ""

#: src/ch08-03-hash-maps.md:139
msgid "### Updating a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:141
msgid ""
"Although the number of key and value pairs is growable, each unique key can\n"
"only have one value associated with it at a time (but not vice versa: for\n"
"example, both the Blue team and the Yellow team could have value 10 stored "
"in\n"
"the `scores` hash map)."
msgstr ""

#: src/ch08-03-hash-maps.md:146
msgid ""
"When you want to change the data in a hash map, you have to decide how to\n"
"handle the case when a key already has a value assigned. You could replace "
"the\n"
"old value with the new value, completely disregarding the old value. You "
"could\n"
"keep the old value and ignore the new value, only adding the new value if "
"the\n"
"key *doesn‚Äôt* already have a value. Or you could combine the old value and "
"the\n"
"new value. Let‚Äôs look at how to do each of these!"
msgstr ""

#: src/ch08-03-hash-maps.md:153
msgid "#### Overwriting a Value"
msgstr ""

#: src/ch08-03-hash-maps.md:155
msgid ""
"If we insert a key and a value into a hash map and then insert that same "
"key\n"
"with a different value, the value associated with that key will be "
"replaced.\n"
"Even though the code in Listing 8-23 calls `insert` twice, the hash map "
"will\n"
"only contain one key/value pair because we‚Äôre inserting the value for the "
"Blue\n"
"team‚Äôs key both times."
msgstr ""

#: src/ch08-03-hash-maps.md:161
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let mut scores = HashMap::new();\n"
"\n"
"    scores.insert(String::from(\"Blue\"), 10);\n"
"    scores.insert(String::from(\"Blue\"), 25);\n"
"\n"
"    println!(\"{:?}\", scores);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:174
msgid ""
"<span class=\"caption\">Listing 8-23: Replacing a value stored with a "
"particular\n"
"key</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:177
msgid ""
"This code will print `{\"Blue\": 25}`. The original value of `10` has been\n"
"overwritten."
msgstr ""

#: src/ch08-03-hash-maps.md:180 src/ch10-02-traits.md:376
#: src/ch12-03-improving-error-handling-and-modularity.md:380
#: src/ch12-03-improving-error-handling-and-modularity.md:454
#: src/ch13-01-closures.md:13 src/ch13-01-closures.md:412
#: src/ch17-03-oo-design-patterns.md:344 src/ch20-02-multithreaded.md:139
#: src/ch20-02-multithreaded.md:208 src/ch20-02-multithreaded.md:274
msgid "<!-- Old headings. Do not remove or links may break. -->"
msgstr ""

#: src/ch08-03-hash-maps.md:181
msgid "<a id=\"only-inserting-a-value-if-the-key-has-no-value\"></a>"
msgstr ""

#: src/ch08-03-hash-maps.md:183
msgid "#### Adding a Key and Value Only If a Key Isn‚Äôt Present"
msgstr ""

#: src/ch08-03-hash-maps.md:185
msgid ""
"It‚Äôs common to check whether a particular key already exists in the hash "
"map\n"
"with a value then take the following actions: if the key does exist in the "
"hash\n"
"map, the existing value should remain the way it is. If the key doesn‚Äôt "
"exist,\n"
"insert it and a value for it."
msgstr ""

#: src/ch08-03-hash-maps.md:190
msgid ""
"Hash maps have a special API for this called `entry` that takes the key you\n"
"want to check as a parameter. The return value of the `entry` method is an "
"enum\n"
"called `Entry` that represents a value that might or might not exist. Let‚Äôs "
"say\n"
"we want to check whether the key for the Yellow team has a value associated\n"
"with it. If it doesn‚Äôt, we want to insert the value 50, and the same for "
"the\n"
"Blue team. Using the `entry` API, the code looks like Listing 8-24."
msgstr ""

#: src/ch08-03-hash-maps.md:197
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let mut scores = HashMap::new();\n"
"    scores.insert(String::from(\"Blue\"), 10);\n"
"\n"
"    scores.entry(String::from(\"Yellow\")).or_insert(50);\n"
"    scores.entry(String::from(\"Blue\")).or_insert(50);\n"
"\n"
"    println!(\"{:?}\", scores);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:211
msgid ""
"<span class=\"caption\">Listing 8-24: Using the `entry` method to only "
"insert if\n"
"the key does not already have a value</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:214
msgid ""
"The `or_insert` method on `Entry` is defined to return a mutable reference "
"to\n"
"the value for the corresponding `Entry` key if that key exists, and if not,\n"
"inserts the parameter as the new value for this key and returns a mutable\n"
"reference to the new value. This technique is much cleaner than writing the\n"
"logic ourselves and, in addition, plays more nicely with the borrow checker."
msgstr ""

#: src/ch08-03-hash-maps.md:220
msgid ""
"Running the code in Listing 8-24 will print `{\"Yellow\": 50, \"Blue\": 10}"
"`. The\n"
"first call to `entry` will insert the key for the Yellow team with the "
"value\n"
"50 because the Yellow team doesn‚Äôt have a value already. The second call to\n"
"`entry` will not change the hash map because the Blue team already has the\n"
"value 10."
msgstr ""

#: src/ch08-03-hash-maps.md:226
msgid "#### Updating a Value Based on the Old Value"
msgstr ""

#: src/ch08-03-hash-maps.md:228
msgid ""
"Another common use case for hash maps is to look up a key‚Äôs value and then\n"
"update it based on the old value. For instance, Listing 8-25 shows code "
"that\n"
"counts how many times each word appears in some text. We use a hash map "
"with\n"
"the words as keys and increment the value to keep track of how many times "
"we‚Äôve\n"
"seen that word. If it‚Äôs the first time we‚Äôve seen a word, we‚Äôll first "
"insert\n"
"the value 0."
msgstr ""

#: src/ch08-03-hash-maps.md:235
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::collections::HashMap;\n"
"\n"
"    let text = \"hello world wonderful world\";\n"
"\n"
"    let mut map = HashMap::new();\n"
"\n"
"    for word in text.split_whitespace() {\n"
"        let count = map.entry(word).or_insert(0);\n"
"        *count += 1;\n"
"    }\n"
"\n"
"    println!(\"{:?}\", map);\n"
"# }\n"
"```"
msgstr ""

#: src/ch08-03-hash-maps.md:252
msgid ""
"<span class=\"caption\">Listing 8-25: Counting occurrences of words using a "
"hash\n"
"map that stores words and counts</span>"
msgstr ""

#: src/ch08-03-hash-maps.md:255
msgid ""
"This code will print `{\"world\": 2, \"hello\": 1, \"wonderful\": 1}`. You "
"might see\n"
"the same key/value pairs printed in a different order: recall from the\n"
"[‚ÄúAccessing Values in a Hash Map‚Äù][access]<!-- ignore --> section that\n"
"iterating over a hash map happens in an arbitrary order."
msgstr ""

#: src/ch08-03-hash-maps.md:260
msgid ""
"The `split_whitespace` method returns an iterator over sub-slices, separated "
"by\n"
"whitespace, of the value in `text`. The `or_insert` method returns a "
"mutable\n"
"reference (`&mut V`) to the value for the specified key. Here we store that\n"
"mutable reference in the `count` variable, so in order to assign to that "
"value,\n"
"we must first dereference `count` using the asterisk (`*`). The mutable\n"
"reference goes out of scope at the end of the `for` loop, so all of these\n"
"changes are safe and allowed by the borrowing rules."
msgstr ""

#: src/ch08-03-hash-maps.md:268
msgid "### Hashing Functions"
msgstr ""

#: src/ch08-03-hash-maps.md:270
msgid ""
"By default, `HashMap` uses a hashing function called *SipHash* that can "
"provide\n"
"resistance to Denial of Service (DoS) attacks involving hash\n"
"tables[^siphash]<!-- ignore -->. This is not the fastest hashing algorithm\n"
"available, but the trade-off for better security that comes with the drop "
"in\n"
"performance is worth it. If you profile your code and find that the default\n"
"hash function is too slow for your purposes, you can switch to another "
"function\n"
"by specifying a different hasher. A *hasher* is a type that implements the\n"
"`BuildHasher` trait. We‚Äôll talk about traits and how to implement them in\n"
"Chapter 10. You don‚Äôt necessarily have to implement your own hasher from\n"
"scratch; [crates.io](https://crates.io/)<!-- ignore --> has libraries shared "
"by\n"
"other Rust users that provide hashers implementing many common hashing\n"
"algorithms."
msgstr ""

#: src/ch08-03-hash-maps.md:283
msgid ""
"[https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/"
"SipHash)"
msgstr ""

#: src/ch08-03-hash-maps.md:287
msgid ""
"Vectors, strings, and hash maps will provide a large amount of "
"functionality\n"
"necessary in programs when you need to store, access, and modify data. Here "
"are\n"
"some exercises you should now be equipped to solve:"
msgstr ""

#: src/ch08-03-hash-maps.md:291
msgid ""
"* Given a list of integers, use a vector and return the median (when "
"sorted,\n"
"  the value in the middle position) and mode (the value that occurs most "
"often;\n"
"  a hash map will be helpful here) of the list.\n"
"* Convert strings to pig latin. The first consonant of each word is moved "
"to\n"
"  the end of the word and ‚Äúay‚Äù is added, so ‚Äúfirst‚Äù becomes ‚Äúirst-fay.‚Äù "
"Words\n"
"  that start with a vowel have ‚Äúhay‚Äù added to the end instead (‚Äúapple‚Äù "
"becomes\n"
"  ‚Äúapple-hay‚Äù). Keep in mind the details about UTF-8 encoding!\n"
"* Using a hash map and vectors, create a text interface to allow a user to "
"add\n"
"  employee names to a department in a company. For example, ‚ÄúAdd Sally to\n"
"  Engineering‚Äù or ‚ÄúAdd Amir to Sales.‚Äù Then let the user retrieve a list of "
"all\n"
"  people in a department or all people in the company by department, sorted\n"
"  alphabetically."
msgstr ""

#: src/ch08-03-hash-maps.md:304
msgid ""
"The standard library API documentation describes methods that vectors, "
"strings,\n"
"and hash maps have that will be helpful for these exercises!"
msgstr ""

#: src/ch08-03-hash-maps.md:307
msgid ""
"We‚Äôre getting into more complex programs in which operations can fail, so, "
"it‚Äôs\n"
"a perfect time to discuss error handling. We‚Äôll do that next!"
msgstr ""

#: src/ch09-00-error-handling.md:1
msgid "# Error Handling"
msgstr ""

#: src/ch09-00-error-handling.md:3
msgid ""
"Errors are a fact of life in software, so Rust has a number of features for\n"
"handling situations in which something goes wrong. In many cases, Rust "
"requires\n"
"you to acknowledge the possibility of an error and take some action before "
"your\n"
"code will compile. This requirement makes your program more robust by "
"ensuring\n"
"that you‚Äôll discover errors and handle them appropriately before you‚Äôve\n"
"deployed your code to production!"
msgstr ""

#: src/ch09-00-error-handling.md:10
msgid ""
"Rust groups errors into two major categories: *recoverable* and "
"*unrecoverable*\n"
"errors. For a recoverable error, such as a *file not found* error, we most\n"
"likely just want to report the problem to the user and retry the operation.\n"
"Unrecoverable errors are always symptoms of bugs, like trying to access a\n"
"location beyond the end of an array, and so we want to immediately stop the\n"
"program."
msgstr ""

#: src/ch09-00-error-handling.md:17
msgid ""
"Most languages don‚Äôt distinguish between these two kinds of errors and "
"handle\n"
"both in the same way, using mechanisms such as exceptions. Rust doesn‚Äôt "
"have\n"
"exceptions. Instead, it has the type `Result<T, E>` for recoverable errors "
"and\n"
"the `panic!` macro that stops execution when the program encounters an\n"
"unrecoverable error. This chapter covers calling `panic!` first and then "
"talks\n"
"about returning `Result<T, E>` values. Additionally, we‚Äôll explore\n"
"considerations when deciding whether to try to recover from an error or to "
"stop\n"
"execution."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "## Unrecoverable Errors with `panic!`"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"Sometimes, bad things happen in your code, and there‚Äôs nothing you can do "
"about\n"
"it. In these cases, Rust has the `panic!` macro. There are two ways to cause "
"a\n"
"panic in practice: by taking an action that causes our code to panic (such "
"as\n"
"accessing an array past the end) or by explicitly calling the `panic!` "
"macro.\n"
"In both cases, we cause a panic in our program. By default, these panics "
"will\n"
"print a failure message, unwind, clean up the stack, and quit. Via an\n"
"environment variable, you can also have Rust display the call stack when a\n"
"panic occurs to make it easier to track down the source of the panic."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:12
msgid ""
"> ### Unwinding the Stack or Aborting in Response to a Panic\n"
">\n"
"> By default, when a panic occurs, the program starts *unwinding*, which\n"
"> means Rust walks back up the stack and cleans up the data from each "
"function\n"
"> it encounters. However, this walking back and cleanup is a lot of work. "
"Rust,\n"
"> therefore, allows you to choose the alternative of immediately "
"*aborting*,\n"
"> which ends the program without cleaning up.\n"
">\n"
"> Memory that the program was using will then need to be cleaned\n"
"> up by the operating system. If in your project you need to make the "
"resulting\n"
"> binary as small as possible, you can switch from unwinding to aborting "
"upon a\n"
"> panic by adding `panic = 'abort'` to the appropriate `[profile]` sections "
"in\n"
"> your *Cargo.toml* file. For example, if you want to abort on panic in "
"release\n"
"> mode, add this:\n"
">\n"
"> ```toml\n"
"> [profile.release]\n"
"> panic = 'abort'\n"
"> ```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:32
msgid "Let‚Äôs try calling `panic!` in a simple program:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:36
msgid ""
"```rust,should_panic,panics\n"
"fn main() {\n"
"    panic!(\"crash and burn\");\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:42
msgid "When you run the program, you‚Äôll see something like this:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:44
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling panic v0.1.0 (file:///projects/panic)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n"
"     Running `target/debug/panic`\n"
"thread 'main' panicked at 'crash and burn', src/main.rs:2:5\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:53
msgid ""
"The call to `panic!` causes the error message contained in the last two "
"lines.\n"
"The first line shows our panic message and the place in our source code "
"where\n"
"the panic occurred: *src/main.rs:2:5* indicates that it‚Äôs the second line,\n"
"fifth character of our *src/main.rs* file."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid ""
"In this case, the line indicated is part of our code, and if we go to that\n"
"line, we see the `panic!` macro call. In other cases, the `panic!` call "
"might\n"
"be in code that our code calls, and the filename and line number reported "
"by\n"
"the error message will be someone else‚Äôs code where the `panic!` macro is\n"
"called, not the line of our code that eventually led to the `panic!` call. "
"We\n"
"can use the backtrace of the functions the `panic!` call came from to "
"figure\n"
"out the part of our code that is causing the problem. We‚Äôll discuss "
"backtraces\n"
"in more detail next."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:67
msgid "### Using a `panic!` Backtrace"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:69
msgid ""
"Let‚Äôs look at another example to see what it‚Äôs like when a `panic!` call "
"comes\n"
"from a library because of a bug in our code instead of from our code "
"calling\n"
"the macro directly. Listing 9-1 has some code that attempts to access an\n"
"index in a vector beyond the range of valid indexes."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:76
msgid ""
"```rust,should_panic,panics\n"
"fn main() {\n"
"    let v = vec![1, 2, 3];\n"
"\n"
"    v[99];\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:84
msgid ""
"<span class=\"caption\">Listing 9-1: Attempting to access an element beyond "
"the\n"
"end of a vector, which will cause a call to `panic!`</span>"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:87
msgid ""
"Here, we‚Äôre attempting to access the 100th element of our vector (which is "
"at\n"
"index 99 because indexing starts at zero), but the vector has only 3 "
"elements.\n"
"In this situation, Rust will panic. Using `[]` is supposed to return an\n"
"element, but if you pass an invalid index, there‚Äôs no element that Rust "
"could\n"
"return here that would be correct."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:93
msgid ""
"In C, attempting to read beyond the end of a data structure is undefined\n"
"behavior. You might get whatever is at the location in memory that would\n"
"correspond to that element in the data structure, even though the memory\n"
"doesn‚Äôt belong to that structure. This is called a *buffer overread* and "
"can\n"
"lead to security vulnerabilities if an attacker is able to manipulate the "
"index\n"
"in such a way as to read data they shouldn‚Äôt be allowed to that is stored "
"after\n"
"the data structure."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:101
msgid ""
"To protect your program from this sort of vulnerability, if you try to read "
"an\n"
"element at an index that doesn‚Äôt exist, Rust will stop execution and refuse "
"to\n"
"continue. Let‚Äôs try it and see:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:105
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling panic v0.1.0 (file:///projects/panic)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n"
"     Running `target/debug/panic`\n"
"thread 'main' panicked at 'index out of bounds: the len is 3 but the index "
"is 99', src/main.rs:4:5\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:114
msgid ""
"This error points at line 4 of our `main.rs` where we attempt to access "
"index\n"
"99. The next note line tells us that we can set the `RUST_BACKTRACE`\n"
"environment variable to get a backtrace of exactly what happened to cause "
"the\n"
"error. A *backtrace* is a list of all the functions that have been called "
"to\n"
"get to this point. Backtraces in Rust work as they do in other languages: "
"the\n"
"key to reading the backtrace is to start from the top and read until you "
"see\n"
"files you wrote. That‚Äôs the spot where the problem originated. The lines "
"above\n"
"that spot are code that your code has called; the lines below are code that\n"
"called your code. These before-and-after lines might include core Rust "
"code,\n"
"standard library code, or crates that you‚Äôre using. Let‚Äôs try getting a\n"
"backtrace by setting the `RUST_BACKTRACE` environment variable to any value\n"
"except 0. Listing 9-2 shows output similar to what you‚Äôll see."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:127
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch09-error-handling/listing-09-01\n"
"RUST_BACKTRACE=1 cargo run\n"
"copy the backtrace output below\n"
"check the backtrace number mentioned in the text below the listing\n"
"-->"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:134
msgid ""
"```console\n"
"$ RUST_BACKTRACE=1 cargo run\n"
"thread 'main' panicked at 'index out of bounds: the len is 3 but the index "
"is 99', src/main.rs:4:5\n"
"stack backtrace:\n"
"   0: rust_begin_unwind\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/"
"src/panicking.rs:584:5\n"
"   1: core::panicking::panic_fmt\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/"
"src/panicking.rs:142:14\n"
"   2: core::panicking::panic_bounds_check\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/"
"src/panicking.rs:84:5\n"
"   3: <usize as core::slice::index::SliceIndex<[T]>>::index\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/"
"src/slice/index.rs:242:10\n"
"   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/"
"src/slice/index.rs:18:9\n"
"   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/"
"alloc/src/vec/mod.rs:2591:9\n"
"   6: panic::main\n"
"             at ./src/main.rs:4:5\n"
"   7: core::ops::function::FnOnce::call_once\n"
"             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/"
"src/ops/function.rs:248:5\n"
"note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose "
"backtrace.\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:157
msgid ""
"<span class=\"caption\">Listing 9-2: The backtrace generated by a call to\n"
"`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</"
"span>"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:160
msgid ""
"That‚Äôs a lot of output! The exact output you see might be different "
"depending\n"
"on your operating system and Rust version. In order to get backtraces with "
"this\n"
"information, debug symbols must be enabled. Debug symbols are enabled by\n"
"default when using `cargo build` or `cargo run` without the `--release` "
"flag,\n"
"as we have here."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:166
msgid ""
"In the output in Listing 9-2, line 6 of the backtrace points to the line in "
"our\n"
"project that‚Äôs causing the problem: line 4 of *src/main.rs*. If we don‚Äôt "
"want\n"
"our program to panic, we should start our investigation at the location "
"pointed\n"
"to by the first line mentioning a file we wrote. In Listing 9-1, where we\n"
"deliberately wrote code that would panic, the way to fix the panic is to "
"not\n"
"request an element beyond the range of the vector indexes. When your code\n"
"panics in the future, you‚Äôll need to figure out what action the code is "
"taking\n"
"with what values to cause the panic and what the code should do instead."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:175
msgid ""
"We‚Äôll come back to `panic!` and when we should and should not use `panic!` "
"to\n"
"handle error conditions in the [‚ÄúTo `panic!` or Not to\n"
"`panic!`‚Äù][to-panic-or-not-to-panic]<!-- ignore --> section later in this\n"
"chapter. Next, we‚Äôll look at how to recover from an error using `Result`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:1
msgid "## Recoverable Errors with `Result`"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:3
msgid ""
"Most errors aren‚Äôt serious enough to require the program to stop entirely.\n"
"Sometimes, when a function fails, it‚Äôs for a reason that you can easily\n"
"interpret and respond to. For example, if you try to open a file and that\n"
"operation fails because the file doesn‚Äôt exist, you might want to create "
"the\n"
"file instead of terminating the process."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:9
msgid ""
"Recall from [‚ÄúHandling Potential Failure with `Result`‚Äù]"
"[handle_failure]<!--\n"
"ignore --> in Chapter 2 that the `Result` enum is defined as having two\n"
"variants, `Ok` and `Err`, as follows:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:13 src/ch10-01-syntax.md:281
msgid ""
"```rust\n"
"enum Result<T, E> {\n"
"    Ok(T),\n"
"    Err(E),\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:20
msgid ""
"The `T` and `E` are generic type parameters: we‚Äôll discuss generics in more\n"
"detail in Chapter 10. What you need to know right now is that `T` "
"represents\n"
"the type of the value that will be returned in a success case within the "
"`Ok`\n"
"variant, and `E` represents the type of the error that will be returned in "
"a\n"
"failure case within the `Err` variant. Because `Result` has these generic "
"type\n"
"parameters, we can use the `Result` type and the functions defined on it in\n"
"many different situations where the successful value and error value we want "
"to\n"
"return may differ."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:29
msgid ""
"Let‚Äôs call a function that returns a `Result` value because the function "
"could\n"
"fail. In Listing 9-3 we try to open a file."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:34
msgid ""
"```rust\n"
"use std::fs::File;\n"
"\n"
"fn main() {\n"
"    let greeting_file_result = File::open(\"hello.txt\");\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:42
msgid "<span class=\"caption\">Listing 9-3: Opening a file</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:44
msgid ""
"The return type of `File::open` is a `Result<T, E>`. The generic parameter "
"`T`\n"
"has been filled in by the implementation of `File::open` with the type of "
"the\n"
"success value, `std::fs::File`, which is a file handle. The type of `E` used "
"in\n"
"the error value is `std::io::Error`. This return type means the call to\n"
"`File::open` might succeed and return a file handle that we can read from "
"or\n"
"write to. The function call also might fail: for example, the file might "
"not\n"
"exist, or we might not have permission to access the file. The `File::open`\n"
"function needs to have a way to tell us whether it succeeded or failed and "
"at\n"
"the same time give us either the file handle or error information. This\n"
"information is exactly what the `Result` enum conveys."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:55
msgid ""
"In the case where `File::open` succeeds, the value in the variable\n"
"`greeting_file_result` will be an instance of `Ok` that contains a file "
"handle.\n"
"In the case where it fails, the value in `greeting_file_result` will be an\n"
"instance of `Err` that contains more information about the kind of error "
"that\n"
"happened."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:61
msgid ""
"We need to add to the code in Listing 9-3 to take different actions "
"depending\n"
"on the value `File::open` returns. Listing 9-4 shows one way to handle the\n"
"`Result` using a basic tool, the `match` expression that we discussed in\n"
"Chapter 6."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:68
msgid ""
"```rust,should_panic\n"
"use std::fs::File;\n"
"\n"
"fn main() {\n"
"    let greeting_file_result = File::open(\"hello.txt\");\n"
"\n"
"    let greeting_file = match greeting_file_result {\n"
"        Ok(file) => file,\n"
"        Err(error) => panic!(\"Problem opening the file: {:?}\", error),\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:81
msgid ""
"<span class=\"caption\">Listing 9-4: Using a `match` expression to handle "
"the\n"
"`Result` variants that might be returned</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:84
msgid ""
"Note that, like the `Option` enum, the `Result` enum and its variants have "
"been\n"
"brought into scope by the prelude, so we don‚Äôt need to specify `Result::`\n"
"before the `Ok` and `Err` variants in the `match` arms."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:88
msgid ""
"When the result is `Ok`, this code will return the inner `file` value out "
"of\n"
"the `Ok` variant, and we then assign that file handle value to the variable\n"
"`greeting_file`. After the `match`, we can use the file handle for reading "
"or\n"
"writing."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:93
msgid ""
"The other arm of the `match` handles the case where we get an `Err` value "
"from\n"
"`File::open`. In this example, we‚Äôve chosen to call the `panic!` macro. If\n"
"there‚Äôs no file named *hello.txt* in our current directory and we run this\n"
"code, we‚Äôll see the following output from the `panic!` macro:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:98
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n"
"     Running `target/debug/error-handling`\n"
"thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: "
"NotFound, message: \"No such file or directory\" }', src/main.rs:8:23\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:107
msgid "As usual, this output tells us exactly what has gone wrong."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:109
msgid "### Matching on Different Errors"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:111
msgid ""
"The code in Listing 9-4 will `panic!` no matter why `File::open` failed.\n"
"However, we want to take different actions for different failure reasons: "
"if\n"
"`File::open` failed because the file doesn‚Äôt exist, we want to create the "
"file\n"
"and return the handle to the new file. If `File::open` failed for any other\n"
"reason‚Äîfor example, because we didn‚Äôt have permission to open the file‚Äîwe "
"still\n"
"want the code to `panic!` in the same way as it did in Listing 9-4. For this "
"we\n"
"add an inner `match` expression, shown in Listing 9-5."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:121
msgid ""
"<!-- ignore this test because otherwise it creates hello.txt which causes "
"other\n"
"tests to fail lol -->"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:124
msgid ""
"```rust,ignore\n"
"use std::fs::File;\n"
"use std::io::ErrorKind;\n"
"\n"
"fn main() {\n"
"    let greeting_file_result = File::open(\"hello.txt\");\n"
"\n"
"    let greeting_file = match greeting_file_result {\n"
"        Ok(file) => file,\n"
"        Err(error) => match error.kind() {\n"
"            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n"
"                Ok(fc) => fc,\n"
"                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n"
"            },\n"
"            other_error => {\n"
"                panic!(\"Problem opening the file: {:?}\", other_error);\n"
"            }\n"
"        },\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:146
msgid ""
"<span class=\"caption\">Listing 9-5: Handling different kinds of errors in\n"
"different ways</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:149
msgid ""
"The type of the value that `File::open` returns inside the `Err` variant is\n"
"`io::Error`, which is a struct provided by the standard library. This "
"struct\n"
"has a method `kind` that we can call to get an `io::ErrorKind` value. The "
"enum\n"
"`io::ErrorKind` is provided by the standard library and has variants\n"
"representing the different kinds of errors that might result from an `io`\n"
"operation. The variant we want to use is `ErrorKind::NotFound`, which "
"indicates\n"
"the file we‚Äôre trying to open doesn‚Äôt exist yet. So we match on\n"
"`greeting_file_result`, but we also have an inner match on `error.kind()`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:158
msgid ""
"The condition we want to check in the inner match is whether the value "
"returned\n"
"by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it "
"is,\n"
"we try to create the file with `File::create`. However, because `File::"
"create`\n"
"could also fail, we need a second arm in the inner `match` expression. When "
"the\n"
"file can‚Äôt be created, a different error message is printed. The second arm "
"of\n"
"the outer `match` stays the same, so the program panics on any error "
"besides\n"
"the missing file error."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:166
msgid ""
"> ### Alternatives to Using `match` with `Result<T, E>`\n"
">\n"
"> That‚Äôs a lot of `match`! The `match` expression is very useful but also "
"very\n"
"> much a primitive. In Chapter 13, you‚Äôll learn about closures, which are "
"used\n"
"> with many of the methods defined on `Result<T, E>`. These methods can be "
"more\n"
"> concise than using `match` when handling `Result<T, E>` values in your "
"code.\n"
">\n"
"> For example, here‚Äôs another way to write the same logic as shown in "
"Listing\n"
"> 9-5, this time using closures and the `unwrap_or_else` method:\n"
">\n"
"> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 --"
">\n"
">\n"
"> ```rust,ignore\n"
"> use std::fs::File;\n"
"> use std::io::ErrorKind;\n"
">\n"
"> fn main() {\n"
">     let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| "
"{\n"
">         if error.kind() == ErrorKind::NotFound {\n"
">             File::create(\"hello.txt\").unwrap_or_else(|error| {\n"
">                 panic!(\"Problem creating the file: {:?}\", error);\n"
">             })\n"
">         } else {\n"
">             panic!(\"Problem opening the file: {:?}\", error);\n"
">         }\n"
">     });\n"
"> }\n"
"> ```\n"
">\n"
"> Although this code has the same behavior as Listing 9-5, it doesn‚Äôt "
"contain\n"
"> any `match` expressions and is cleaner to read. Come back to this example\n"
"> after you‚Äôve read Chapter 13, and look up the `unwrap_or_else` method in "
"the\n"
"> standard library documentation. Many more of these methods can clean up "
"huge\n"
"> nested `match` expressions when you‚Äôre dealing with errors."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:201
msgid "### Shortcuts for Panic on Error: `unwrap` and `expect`"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:203
msgid ""
"Using `match` works well enough, but it can be a bit verbose and doesn‚Äôt "
"always\n"
"communicate intent well. The `Result<T, E>` type has many helper methods\n"
"defined on it to do various, more specific tasks. The `unwrap` method is a\n"
"shortcut method implemented just like the `match` expression we wrote in\n"
"Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will "
"return\n"
"the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` "
"will\n"
"call the `panic!` macro for us. Here is an example of `unwrap` in action:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:213
msgid ""
"```rust,should_panic\n"
"use std::fs::File;\n"
"\n"
"fn main() {\n"
"    let greeting_file = File::open(\"hello.txt\").unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:221
msgid ""
"If we run this code without a *hello.txt* file, we‚Äôll see an error message "
"from\n"
"the `panic!` call that the `unwrap` method makes:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:224
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch09-error-handling/no-listing-04-unwrap\n"
"cargo run\n"
"copy and paste relevant text\n"
"-->"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:230
msgid ""
"```text\n"
"thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os "
"{\n"
"code: 2, kind: NotFound, message: \"No such file or directory\" }',\n"
"src/main.rs:4:49\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:236
msgid ""
"Similarly, the `expect` method lets us also choose the `panic!` error "
"message.\n"
"Using `expect` instead of `unwrap` and providing good error messages can "
"convey\n"
"your intent and make tracking down the source of a panic easier. The syntax "
"of\n"
"`expect` looks like this:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:243
msgid ""
"```rust,should_panic\n"
"use std::fs::File;\n"
"\n"
"fn main() {\n"
"    let greeting_file = File::open(\"hello.txt\")\n"
"        .expect(\"hello.txt should be included in this project\");\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:252
msgid ""
"We use `expect` in the same way as `unwrap`: to return the file handle or "
"call\n"
"the `panic!` macro. The error message used by `expect` in its call to `panic!"
"`\n"
"will be the parameter that we pass to `expect`, rather than the default\n"
"`panic!` message that `unwrap` uses. Here‚Äôs what it looks like:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:257
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch09-error-handling/no-listing-05-expect\n"
"cargo run\n"
"copy and paste relevant text\n"
"-->"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:263
msgid ""
"```text\n"
"thread 'main' panicked at 'hello.txt should be included in this project: Os "
"{\n"
"code: 2, kind: NotFound, message: \"No such file or directory\" }',\n"
"src/main.rs:5:10\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:269
msgid ""
"In production-quality code, most Rustaceans choose `expect` rather than\n"
"`unwrap` and give more context about why the operation is expected to "
"always\n"
"succeed. That way, if your assumptions are ever proven wrong, you have more\n"
"information to use in debugging."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:274
msgid "### Propagating Errors"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:276
msgid ""
"When a function‚Äôs implementation calls something that might fail, instead "
"of\n"
"handling the error within the function itself, you can return the error to "
"the\n"
"calling code so that it can decide what to do. This is known as "
"*propagating*\n"
"the error and gives more control to the calling code, where there might be "
"more\n"
"information or logic that dictates how the error should be handled than "
"what\n"
"you have available in the context of your code."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:283
msgid ""
"For example, Listing 9-6 shows a function that reads a username from a file. "
"If\n"
"the file doesn‚Äôt exist or can‚Äôt be read, this function will return those "
"errors\n"
"to the code that called the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:289
#: src/ch09-02-recoverable-errors-with-result.md:376
#: src/ch09-02-recoverable-errors-with-result.md:432
#: src/ch09-02-recoverable-errors-with-result.md:465
msgid ""
"<!-- Deliberately not using rustdoc_include here; the `main` function in "
"the\n"
"file panics. We do want to include it for reader experimentation purposes, "
"but\n"
"don't want to include it for rustdoc testing purposes. -->"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:293
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::{self, Read};\n"
"\n"
"fn read_username_from_file() -> Result<String, io::Error> {\n"
"    let username_file_result = File::open(\"hello.txt\");\n"
"\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:314
msgid ""
"<span class=\"caption\">Listing 9-6: A function that returns errors to the\n"
"calling code using `match`</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:317
msgid ""
"This function can be written in a much shorter way, but we‚Äôre going to start "
"by\n"
"doing a lot of it manually in order to explore error handling; at the end,\n"
"we‚Äôll show the shorter way. Let‚Äôs look at the return type of the function\n"
"first: `Result<String, io::Error>`. This means the function is returning a\n"
"value of the type `Result<T, E>` where the generic parameter `T` has been\n"
"filled in with the concrete type `String`, and the generic type `E` has "
"been\n"
"filled in with the concrete type `io::Error`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:325
msgid ""
"If this function succeeds without any problems, the code that calls this\n"
"function will receive an `Ok` value that holds a `String`‚Äîthe username that\n"
"this function read from the file. If this function encounters any problems, "
"the\n"
"calling code will receive an `Err` value that holds an instance of `io::"
"Error`\n"
"that contains more information about what the problems were. We chose\n"
"`io::Error` as the return type of this function because that happens to be "
"the\n"
"type of the error value returned from both of the operations we‚Äôre calling "
"in\n"
"this function‚Äôs body that might fail: the `File::open` function and the\n"
"`read_to_string` method."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:335
msgid ""
"The body of the function starts by calling the `File::open` function. Then "
"we\n"
"handle the `Result` value with a `match` similar to the `match` in Listing "
"9-4.\n"
"If `File::open` succeeds, the file handle in the pattern variable `file`\n"
"becomes the value in the mutable variable `username_file` and the function\n"
"continues. In the `Err` case, instead of calling `panic!`, we use the "
"`return`\n"
"keyword to return early out of the function entirely and pass the error "
"value\n"
"from `File::open`, now in the pattern variable `e`, back to the calling code "
"as\n"
"this function‚Äôs error value."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:344
msgid ""
"So if we have a file handle in `username_file`, the function then creates a "
"new\n"
"`String` in variable `username` and calls the `read_to_string` method on\n"
"the file handle in `username_file` to read the contents of the file into\n"
"`username`. The `read_to_string` method also returns a `Result` because it\n"
"might fail, even though `File::open` succeeded. So we need another `match` "
"to\n"
"handle that `Result`: if `read_to_string` succeeds, then our function has\n"
"succeeded, and we return the username from the file that‚Äôs now in "
"`username`\n"
"wrapped in an `Ok`. If `read_to_string` fails, we return the error value in "
"the\n"
"same way that we returned the error value in the `match` that handled the\n"
"return value of `File::open`. However, we don‚Äôt need to explicitly say\n"
"`return`, because this is the last expression in the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:356
msgid ""
"The code that calls this code will then handle getting either an `Ok` value\n"
"that contains a username or an `Err` value that contains an `io::Error`. "
"It‚Äôs\n"
"up to the calling code to decide what to do with those values. If the "
"calling\n"
"code gets an `Err` value, it could call `panic!` and crash the program, use "
"a\n"
"default username, or look up the username from somewhere other than a file, "
"for\n"
"example. We don‚Äôt have enough information on what the calling code is "
"actually\n"
"trying to do, so we propagate all the success or error information upward "
"for\n"
"it to handle appropriately."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:365
msgid ""
"This pattern of propagating errors is so common in Rust that Rust provides "
"the\n"
"question mark operator `?` to make this easier."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:368
msgid "#### A Shortcut for Propagating Errors: the `?` Operator"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:370
msgid ""
"Listing 9-7 shows an implementation of `read_username_from_file` that has "
"the\n"
"same functionality as in Listing 9-6, but this implementation uses the\n"
"`?` operator."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:380
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::{self, Read};\n"
"\n"
"fn read_username_from_file() -> Result<String, io::Error> {\n"
"    let mut username_file = File::open(\"hello.txt\")?;\n"
"    let mut username = String::new();\n"
"    username_file.read_to_string(&mut username)?;\n"
"    Ok(username)\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:392
msgid ""
"<span class=\"caption\">Listing 9-7: A function that returns errors to the\n"
"calling code using the `?` operator</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:395
msgid ""
"The `?` placed after a `Result` value is defined to work in almost the same "
"way\n"
"as the `match` expressions we defined to handle the `Result` values in "
"Listing\n"
"9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` "
"will\n"
"get returned from this expression, and the program will continue. If the "
"value\n"
"is an `Err`, the `Err` will be returned from the whole function as if we "
"had\n"
"used the `return` keyword so the error value gets propagated to the calling\n"
"code."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:403
msgid ""
"There is a difference between what the `match` expression from Listing 9-6 "
"does\n"
"and what the `?` operator does: error values that have the `?` operator "
"called\n"
"on them go through the `from` function, defined in the `From` trait in the\n"
"standard library, which is used to convert values from one type into "
"another.\n"
"When the `?` operator calls the `from` function, the error type received is\n"
"converted into the error type defined in the return type of the current\n"
"function. This is useful when a function returns one error type to "
"represent\n"
"all the ways a function might fail, even if parts might fail for many "
"different\n"
"reasons."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:413
msgid ""
"For example, we could change the `read_username_from_file` function in "
"Listing\n"
"9-7 to return a custom error type named `OurError` that we define. If we "
"also\n"
"define `impl From<io::Error> for OurError` to construct an instance of\n"
"`OurError` from an `io::Error`, then the `?` operator calls in the body of\n"
"`read_username_from_file` will call `from` and convert the error types "
"without\n"
"needing to add any more code to the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:420
msgid ""
"In the context of Listing 9-7, the `?` at the end of the `File::open` call "
"will\n"
"return the value inside an `Ok` to the variable `username_file`. If an "
"error\n"
"occurs, the `?` operator will return early out of the whole function and "
"give\n"
"any `Err` value to the calling code. The same thing applies to the `?` at "
"the\n"
"end of the `read_to_string` call."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:426
msgid ""
"The `?` operator eliminates a lot of boilerplate and makes this function‚Äôs\n"
"implementation simpler. We could even shorten this code further by chaining\n"
"method calls immediately after the `?`, as shown in Listing 9-8."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:436
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::{self, Read};\n"
"\n"
"fn read_username_from_file() -> Result<String, io::Error> {\n"
"    let mut username = String::new();\n"
"\n"
"    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n"
"\n"
"    Ok(username)\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:449
msgid ""
"<span class=\"caption\">Listing 9-8: Chaining method calls after the `?`\n"
"operator</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:452
msgid ""
"We‚Äôve moved the creation of the new `String` in `username` to the beginning "
"of\n"
"the function; that part hasn‚Äôt changed. Instead of creating a variable\n"
"`username_file`, we‚Äôve chained the call to `read_to_string` directly onto "
"the\n"
"result of `File::open(\"hello.txt\")?`. We still have a `?` at the end of "
"the\n"
"`read_to_string` call, and we still return an `Ok` value containing "
"`username`\n"
"when both `File::open` and `read_to_string` succeed rather than returning\n"
"errors. The functionality is again the same as in Listing 9-6 and Listing "
"9-7;\n"
"this is just a different, more ergonomic way to write it."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:461
msgid ""
"Listing 9-9 shows a way to make this even shorter using `fs::read_to_string`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:469
msgid ""
"```rust\n"
"use std::fs;\n"
"use std::io;\n"
"\n"
"fn read_username_from_file() -> Result<String, io::Error> {\n"
"    fs::read_to_string(\"hello.txt\")\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:478
msgid ""
"<span class=\"caption\">Listing 9-9: Using `fs::read_to_string` instead of\n"
"opening and then reading the file</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:481
msgid ""
"Reading a file into a string is a fairly common operation, so the standard\n"
"library provides the convenient `fs::read_to_string` function that opens "
"the\n"
"file, creates a new `String`, reads the contents of the file, puts the "
"contents\n"
"into that `String`, and returns it. Of course, using `fs::read_to_string`\n"
"doesn‚Äôt give us the opportunity to explain all the error handling, so we did "
"it\n"
"the longer way first."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:488
msgid "#### Where The `?` Operator Can Be Used"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:490
msgid ""
"The `?` operator can only be used in functions whose return type is "
"compatible\n"
"with the value the `?` is used on. This is because the `?` operator is "
"defined\n"
"to perform an early return of a value out of the function, in the same "
"manner\n"
"as the `match` expression we defined in Listing 9-6. In Listing 9-6, the\n"
"`match` was using a `Result` value, and the early return arm returned an\n"
"`Err(e)` value. The return type of the function has to be a `Result` so "
"that\n"
"it‚Äôs compatible with this `return`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:498
msgid ""
"In Listing 9-10, let‚Äôs look at the error we‚Äôll get if we use the `?` "
"operator\n"
"in a `main` function with a return type incompatible with the type of the "
"value\n"
"we use `?` on:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:504
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::fs::File;\n"
"\n"
"fn main() {\n"
"    let greeting_file = File::open(\"hello.txt\")?;\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:512
msgid ""
"<span class=\"caption\">Listing 9-10: Attempting to use the `?` in the "
"`main`\n"
"function that returns `()` won‚Äôt compile</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:515
msgid ""
"This code opens a file, which might fail. The `?` operator follows the "
"`Result`\n"
"value returned by `File::open`, but this `main` function has the return type "
"of\n"
"`()`, not `Result`. When we compile this code, we get the following error\n"
"message:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:520
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n"
"error[E0277]: the `?` operator can only be used in a function that returns "
"`Result` or `Option` (or another type that implements `FromResidual`)\n"
" --> src/main.rs:4:48\n"
"  |\n"
"3 | fn main() {\n"
"  | --------- this function should return `Result` or `Option` to accept `?"
"`\n"
"4 |     let greeting_file = File::open(\"hello.txt\")?;\n"
"  |                                                ^ cannot use the `?` "
"operator in a function that returns `()`\n"
"  |\n"
"  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is "
"not implemented for `()`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `error-handling` due to previous error\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:537
msgid ""
"This error points out that we‚Äôre only allowed to use the `?` operator in a\n"
"function that returns `Result`, `Option`, or another type that implements\n"
"`FromResidual`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:541
msgid ""
"To fix the error, you have two choices. One choice is to change the return "
"type\n"
"of your function to be compatible with the value you‚Äôre using the `?` "
"operator\n"
"on as long as you have no restrictions preventing that. The other technique "
"is\n"
"to use a `match` or one of the `Result<T, E>` methods to handle the "
"`Result<T,\n"
"E>` in whatever way is appropriate."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:547
msgid ""
"The error message also mentioned that `?` can be used with `Option<T>` "
"values\n"
"as well. As with using `?` on `Result`, you can only use `?` on `Option` in "
"a\n"
"function that returns an `Option`. The behavior of the `?` operator when "
"called\n"
"on an `Option<T>` is similar to its behavior when called on a `Result<T, "
"E>`:\n"
"if the value is `None`, the `None` will be returned early from the function "
"at\n"
"that point. If the value is `Some`, the value inside the `Some` is the\n"
"resulting value of the expression and the function continues. Listing 9-11 "
"has\n"
"an example of a function that finds the last character of the first line in "
"the\n"
"given text:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:557
msgid ""
"```rust\n"
"fn last_char_of_first_line(text: &str) -> Option<char> {\n"
"    text.lines().next()?.chars().last()\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     assert_eq!(\n"
"#         last_char_of_first_line(\"Hello, world\\nHow are you today?\"),\n"
"#         Some('d')\n"
"#     );\n"
"# \n"
"#     assert_eq!(last_char_of_first_line(\"\"), None);\n"
"#     assert_eq!(last_char_of_first_line(\"\\nhi\"), None);\n"
"# }\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:573
msgid ""
"<span class=\"caption\">Listing 9-11: Using the `?` operator on an "
"`Option<T>`\n"
"value</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:576
msgid ""
"This function returns `Option<char>` because it‚Äôs possible that there is a\n"
"character there, but it‚Äôs also possible that there isn‚Äôt. This code takes "
"the\n"
"`text` string slice argument and calls the `lines` method on it, which "
"returns\n"
"an iterator over the lines in the string. Because this function wants to\n"
"examine the first line, it calls `next` on the iterator to get the first "
"value\n"
"from the iterator. If `text` is the empty string, this call to `next` will\n"
"return `None`, in which case we use `?` to stop and return `None` from\n"
"`last_char_of_first_line`. If `text` is not the empty string, `next` will\n"
"return a `Some` value containing a string slice of the first line in `text`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:586
msgid ""
"The `?` extracts the string slice, and we can call `chars` on that string "
"slice\n"
"to get an iterator of its characters. We‚Äôre interested in the last character "
"in\n"
"this first line, so we call `last` to return the last item in the iterator.\n"
"This is an `Option` because it‚Äôs possible that the first line is the empty\n"
"string, for example if `text` starts with a blank line but has characters "
"on\n"
"other lines, as in `\"\\nhi\"`. However, if there is a last character on the "
"first\n"
"line, it will be returned in the `Some` variant. The `?` operator in the "
"middle\n"
"gives us a concise way to express this logic, allowing us to implement the\n"
"function in one line. If we couldn‚Äôt use the `?` operator on `Option`, we‚Äôd\n"
"have to implement this logic using more method calls or a `match` expression."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:597
msgid ""
"Note that you can use the `?` operator on a `Result` in a function that "
"returns\n"
"`Result`, and you can use the `?` operator on an `Option` in a function "
"that\n"
"returns `Option`, but you can‚Äôt mix and match. The `?` operator won‚Äôt\n"
"automatically convert a `Result` to an `Option` or vice versa; in those "
"cases,\n"
"you can use methods like the `ok` method on `Result` or the `ok_or` method "
"on\n"
"`Option` to do the conversion explicitly."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:604
msgid ""
"So far, all the `main` functions we‚Äôve used return `()`. The `main` function "
"is\n"
"special because it‚Äôs the entry and exit point of executable programs, and "
"there\n"
"are restrictions on what its return type can be for the programs to behave "
"as\n"
"expected."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:609
msgid ""
"Luckily, `main` can also return a `Result<(), E>`. Listing 9-12 has the\n"
"code from Listing 9-10 but we‚Äôve changed the return type of `main` to be\n"
"`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. "
"This\n"
"code will now compile:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:614
msgid ""
"```rust,ignore\n"
"use std::error::Error;\n"
"use std::fs::File;\n"
"\n"
"fn main() -> Result<(), Box<dyn Error>> {\n"
"    let greeting_file = File::open(\"hello.txt\")?;\n"
"\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:625
msgid ""
"<span class=\"caption\">Listing 9-12: Changing `main` to return `Result<(), "
"E>`\n"
"allows the use of the `?` operator on `Result` values</span>"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:628
msgid ""
"The `Box<dyn Error>` type is a *trait object*, which we‚Äôll talk about in "
"the\n"
"[‚ÄúUsing Trait Objects that Allow for Values of Different\n"
"Types‚Äù][trait-objects]<!-- ignore --> section in Chapter 17. For now, you "
"can\n"
"read `Box<dyn Error>` to mean ‚Äúany kind of error.‚Äù Using `?` on a `Result`\n"
"value in a `main` function with the error type `Box<dyn Error>` is allowed,\n"
"because it allows any `Err` value to be returned early. Even though the body "
"of\n"
"this `main` function will only ever return errors of type `std::io::Error`, "
"by\n"
"specifying `Box<dyn Error>`, this signature will continue to be correct even "
"if\n"
"more code that returns other errors is added to the body of `main`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:638
msgid ""
"When a `main` function returns a `Result<(), E>`, the executable will\n"
"exit with a value of `0` if `main` returns `Ok(())` and will exit with a\n"
"nonzero value if `main` returns an `Err` value. Executables written in C "
"return\n"
"integers when they exit: programs that exit successfully return the integer\n"
"`0`, and programs that error return some integer other than `0`. Rust also\n"
"returns integers from executables to be compatible with this convention."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:645
msgid ""
"The `main` function may return any types that implement [the\n"
"`std::process::Termination` trait][termination]<!-- ignore -->, which "
"contains\n"
"a function `report` that returns an `ExitCode`. Consult the standard "
"library\n"
"documentation for more information on implementing the `Termination` trait "
"for\n"
"your own types."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:651
msgid ""
"Now that we‚Äôve discussed the details of calling `panic!` or returning "
"`Result`,\n"
"let‚Äôs return to the topic of how to decide which is appropriate to use in "
"which\n"
"cases."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:1
msgid "## To `panic!` or Not to `panic!`"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:3
msgid ""
"So how do you decide when you should call `panic!` and when you should "
"return\n"
"`Result`? When code panics, there‚Äôs no way to recover. You could call `panic!"
"`\n"
"for any error situation, whether there‚Äôs a possible way to recover or not, "
"but\n"
"then you‚Äôre making the decision that a situation is unrecoverable on behalf "
"of\n"
"the calling code. When you choose to return a `Result` value, you give the\n"
"calling code options. The calling code could choose to attempt to recover in "
"a\n"
"way that‚Äôs appropriate for its situation, or it could decide that an `Err`\n"
"value in this case is unrecoverable, so it can call `panic!` and turn your\n"
"recoverable error into an unrecoverable one. Therefore, returning `Result` "
"is a\n"
"good default choice when you‚Äôre defining a function that might fail."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:14
msgid ""
"In situations such as examples, prototype code, and tests, it‚Äôs more\n"
"appropriate to write code that panics instead of returning a `Result`. "
"Let‚Äôs\n"
"explore why, then discuss situations in which the compiler can‚Äôt tell that\n"
"failure is impossible, but you as a human can. The chapter will conclude "
"with\n"
"some general guidelines on how to decide whether to panic in library code."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:20
msgid "### Examples, Prototype Code, and Tests"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:22
msgid ""
"When you‚Äôre writing an example to illustrate some concept, also including "
"robust\n"
"error-handling code can make the example less clear. In\n"
"examples, it‚Äôs understood that a call to a method like `unwrap` that could\n"
"panic is meant as a placeholder for the way you‚Äôd want your application to\n"
"handle errors, which can differ based on what the rest of your code is doing."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:28
msgid ""
"Similarly, the `unwrap` and `expect` methods are very handy when "
"prototyping,\n"
"before you‚Äôre ready to decide how to handle errors. They leave clear markers "
"in\n"
"your code for when you‚Äôre ready to make your program more robust."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:32
msgid ""
"If a method call fails in a test, you‚Äôd want the whole test to fail, even "
"if\n"
"that method isn‚Äôt the functionality under test. Because `panic!` is how a "
"test\n"
"is marked as a failure, calling `unwrap` or `expect` is exactly what should\n"
"happen."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:37
msgid "### Cases in Which You Have More Information Than the Compiler"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:39
msgid ""
"It would also be appropriate to call `unwrap` or `expect` when you have "
"some\n"
"other logic that ensures the `Result` will have an `Ok` value, but the "
"logic\n"
"isn‚Äôt something the compiler understands. You‚Äôll still have a `Result` "
"value\n"
"that you need to handle: whatever operation you‚Äôre calling still has the\n"
"possibility of failing in general, even though it‚Äôs logically impossible in\n"
"your particular situation. If you can ensure by manually inspecting the "
"code\n"
"that you‚Äôll never have an `Err` variant, it‚Äôs perfectly acceptable to call\n"
"`unwrap`, and even better to document the reason you think you‚Äôll never have "
"an\n"
"`Err` variant in the `expect` text. Here‚Äôs an example:"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:49
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::net::IpAddr;\n"
"\n"
"    let home: IpAddr = \"127.0.0.1\"\n"
"        .parse()\n"
"        .expect(\"Hardcoded IP address should be valid\");\n"
"# }\n"
"```"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:59
msgid ""
"We‚Äôre creating an `IpAddr` instance by parsing a hardcoded string. We can "
"see\n"
"that `127.0.0.1` is a valid IP address, so it‚Äôs acceptable to use `expect`\n"
"here. However, having a hardcoded, valid string doesn‚Äôt change the return "
"type\n"
"of the `parse` method: we still get a `Result` value, and the compiler will\n"
"still make us handle the `Result` as if the `Err` variant is a possibility\n"
"because the compiler isn‚Äôt smart enough to see that this string is always a\n"
"valid IP address. If the IP address string came from a user rather than "
"being\n"
"hardcoded into the program and therefore *did* have a possibility of "
"failure,\n"
"we‚Äôd definitely want to handle the `Result` in a more robust way instead.\n"
"Mentioning the assumption that this IP address is hardcoded will prompt us "
"to\n"
"change `expect` to better error handling code if in the future, we need to "
"get\n"
"the IP address from some other source instead."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:72
msgid "### Guidelines for Error Handling"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:74
msgid ""
"It‚Äôs advisable to have your code panic when it‚Äôs possible that your code\n"
"could end up in a bad state. In this context, a *bad state* is when some\n"
"assumption, guarantee, contract, or invariant has been broken, such as when\n"
"invalid values, contradictory values, or missing values are passed to your\n"
"code‚Äîplus one or more of the following:"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:80
msgid ""
"* The bad state is something that is unexpected, as opposed to something "
"that\n"
"  will likely happen occasionally, like a user entering data in the wrong\n"
"  format.\n"
"* Your code after this point needs to rely on not being in this bad state,\n"
"  rather than checking for the problem at every step.\n"
"* There‚Äôs not a good way to encode this information in the types you use. "
"We‚Äôll\n"
"  work through an example of what we mean in the [‚ÄúEncoding States and "
"Behavior\n"
"  as Types‚Äù][encoding]<!-- ignore --> section of Chapter 17."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:89
msgid ""
"If someone calls your code and passes in values that don‚Äôt make sense, it‚Äôs\n"
"best to return an error if you can so the user of the library can decide "
"what\n"
"they want to do in that case. However, in cases where continuing could be\n"
"insecure or harmful, the best choice might be to call `panic!` and alert "
"the\n"
"person using your library to the bug in their code so they can fix it "
"during\n"
"development. Similarly, `panic!` is often appropriate if you‚Äôre calling\n"
"external code that is out of your control and it returns an invalid state "
"that\n"
"you have no way of fixing."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:98
msgid ""
"However, when failure is expected, it‚Äôs more appropriate to return a "
"`Result`\n"
"than to make a `panic!` call. Examples include a parser being given "
"malformed\n"
"data or an HTTP request returning a status that indicates you have hit a "
"rate\n"
"limit. In these cases, returning a `Result` indicates that failure is an\n"
"expected possibility that the calling code must decide how to handle."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:104
msgid ""
"When your code performs an operation that could put a user at risk if it‚Äôs\n"
"called using invalid values, your code should verify the values are valid "
"first\n"
"and panic if the values aren‚Äôt valid. This is mostly for safety reasons:\n"
"attempting to operate on invalid data can expose your code to "
"vulnerabilities.\n"
"This is the main reason the standard library will call `panic!` if you "
"attempt\n"
"an out-of-bounds memory access: trying to access memory that doesn‚Äôt belong "
"to\n"
"the current data structure is a common security problem. Functions often "
"have\n"
"*contracts*: their behavior is only guaranteed if the inputs meet "
"particular\n"
"requirements. Panicking when the contract is violated makes sense because a\n"
"contract violation always indicates a caller-side bug and it‚Äôs not a kind "
"of\n"
"error you want the calling code to have to explicitly handle. In fact, "
"there‚Äôs\n"
"no reasonable way for calling code to recover; the calling *programmers* "
"need\n"
"to fix the code. Contracts for a function, especially when a violation will\n"
"cause a panic, should be explained in the API documentation for the function."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:119
msgid ""
"However, having lots of error checks in all of your functions would be "
"verbose\n"
"and annoying. Fortunately, you can use Rust‚Äôs type system (and thus the "
"type\n"
"checking done by the compiler) to do many of the checks for you. If your\n"
"function has a particular type as a parameter, you can proceed with your "
"code‚Äôs\n"
"logic knowing that the compiler has already ensured you have a valid value. "
"For\n"
"example, if you have a type rather than an `Option`, your program expects "
"to\n"
"have *something* rather than *nothing*. Your code then doesn‚Äôt have to "
"handle\n"
"two cases for the `Some` and `None` variants: it will only have one case "
"for\n"
"definitely having a value. Code trying to pass nothing to your function "
"won‚Äôt\n"
"even compile, so your function doesn‚Äôt have to check for that case at "
"runtime.\n"
"Another example is using an unsigned integer type such as `u32`, which "
"ensures\n"
"the parameter is never negative."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:132
msgid "### Creating Custom Types for Validation"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:134
msgid ""
"Let‚Äôs take the idea of using Rust‚Äôs type system to ensure we have a valid "
"value\n"
"one step further and look at creating a custom type for validation. Recall "
"the\n"
"guessing game in Chapter 2 in which our code asked the user to guess a "
"number\n"
"between 1 and 100. We never validated that the user‚Äôs guess was between "
"those\n"
"numbers before checking it against our secret number; we only validated "
"that\n"
"the guess was positive. In this case, the consequences were not very dire: "
"our\n"
"output of ‚ÄúToo high‚Äù or ‚ÄúToo low‚Äù would still be correct. But it would be a\n"
"useful enhancement to guide the user toward valid guesses and have "
"different\n"
"behavior when a user guesses a number that‚Äôs out of range versus when a "
"user\n"
"types, for example, letters instead."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:145
msgid ""
"One way to do this would be to parse the guess as an `i32` instead of only "
"a\n"
"`u32` to allow potentially negative numbers, and then add a check for the\n"
"number being in range, like so:"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:149
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"    loop {\n"
"        // --snip--\n"
"\n"
"#         println!(\"Please input your guess.\");\n"
"# \n"
"#         let mut guess = String::new();\n"
"# \n"
"#         io::stdin()\n"
"#             .read_line(&mut guess)\n"
"#             .expect(\"Failed to read line\");\n"
"# \n"
"        let guess: i32 = match guess.trim().parse() {\n"
"            Ok(num) => num,\n"
"            Err(_) => continue,\n"
"        };\n"
"\n"
"        if guess < 1 || guess > 100 {\n"
"            println!(\"The secret number will be between 1 and 100.\");\n"
"            continue;\n"
"        }\n"
"\n"
"        match guess.cmp(&secret_number) {\n"
"            // --snip--\n"
"#             Ordering::Less => println!(\"Too small!\"),\n"
"#             Ordering::Greater => println!(\"Too big!\"),\n"
"#             Ordering::Equal => {\n"
"#                 println!(\"You win!\");\n"
"#                 break;\n"
"#             }\n"
"#         }\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:193
msgid ""
"The `if` expression checks whether our value is out of range, tells the "
"user\n"
"about the problem, and calls `continue` to start the next iteration of the "
"loop\n"
"and ask for another guess. After the `if` expression, we can proceed with "
"the\n"
"comparisons between `guess` and the secret number knowing that `guess` is\n"
"between 1 and 100."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:199
msgid ""
"However, this is not an ideal solution: if it was absolutely critical that "
"the\n"
"program only operated on values between 1 and 100, and it had many "
"functions\n"
"with this requirement, having a check like this in every function would be\n"
"tedious (and might impact performance)."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:204
msgid ""
"Instead, we can make a new type and put the validations in a function to "
"create\n"
"an instance of the type rather than repeating the validations everywhere. "
"That\n"
"way, it‚Äôs safe for functions to use the new type in their signatures and\n"
"confidently use the values they receive. Listing 9-13 shows one way to "
"define a\n"
"`Guess` type that will only create an instance of `Guess` if the `new` "
"function\n"
"receives a value between 1 and 100."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:211
msgid ""
"<!-- Deliberately not using rustdoc_include here; the `main` function in "
"the\n"
"file requires the `rand` crate. We do want to include it for reader\n"
"experimentation purposes, but don't want to include it for rustdoc testing\n"
"purposes. -->"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:216
msgid ""
"```rust\n"
"pub struct Guess {\n"
"    value: i32,\n"
"}\n"
"\n"
"impl Guess {\n"
"    pub fn new(value: i32) -> Guess {\n"
"        if value < 1 || value > 100 {\n"
"            panic!(\"Guess value must be between 1 and 100, got {}.\", "
"value);\n"
"        }\n"
"\n"
"        Guess { value }\n"
"    }\n"
"\n"
"    pub fn value(&self) -> i32 {\n"
"        self.value\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:236
msgid ""
"<span class=\"caption\">Listing 9-13: A `Guess` type that will only continue "
"with\n"
"values between 1 and 100</span>"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:239
msgid ""
"First, we define a struct named `Guess` that has a field named `value` that\n"
"holds an `i32`. This is where the number will be stored."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:242
msgid ""
"Then we implement an associated function named `new` on `Guess` that "
"creates\n"
"instances of `Guess` values. The `new` function is defined to have one\n"
"parameter named `value` of type `i32` and to return a `Guess`. The code in "
"the\n"
"body of the `new` function tests `value` to make sure it‚Äôs between 1 and "
"100.\n"
"If `value` doesn‚Äôt pass this test, we make a `panic!` call, which will "
"alert\n"
"the programmer who is writing the calling code that they have a bug they "
"need\n"
"to fix, because creating a `Guess` with a `value` outside this range would\n"
"violate the contract that `Guess::new` is relying on. The conditions in "
"which\n"
"`Guess::new` might panic should be discussed in its public-facing API\n"
"documentation; we‚Äôll cover documentation conventions indicating the "
"possibility\n"
"of a `panic!` in the API documentation that you create in Chapter 14. If\n"
"`value` does pass the test, we create a new `Guess` with its `value` field "
"set\n"
"to the `value` parameter and return the `Guess`."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:256
msgid ""
"Next, we implement a method named `value` that borrows `self`, doesn‚Äôt have "
"any\n"
"other parameters, and returns an `i32`. This kind of method is sometimes "
"called\n"
"a *getter*, because its purpose is to get some data from its fields and "
"return\n"
"it. This public method is necessary because the `value` field of the "
"`Guess`\n"
"struct is private. It‚Äôs important that the `value` field be private so code\n"
"using the `Guess` struct is not allowed to set `value` directly: code "
"outside\n"
"the module *must* use the `Guess::new` function to create an instance of\n"
"`Guess`, thereby ensuring there‚Äôs no way for a `Guess` to have a `value` "
"that\n"
"hasn‚Äôt been checked by the conditions in the `Guess::new` function."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:266
msgid ""
"A function that has a parameter or returns only numbers between 1 and 100 "
"could\n"
"then declare in its signature that it takes or returns a `Guess` rather than "
"an\n"
"`i32` and wouldn‚Äôt need to do any additional checks in its body."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:272
msgid ""
"Rust‚Äôs error handling features are designed to help you write more robust "
"code.\n"
"The `panic!` macro signals that your program is in a state it can‚Äôt handle "
"and\n"
"lets you tell the process to stop instead of trying to proceed with invalid "
"or\n"
"incorrect values. The `Result` enum uses Rust‚Äôs type system to indicate "
"that\n"
"operations might fail in a way that your code could recover from. You can "
"use\n"
"`Result` to tell code that calls your code that it needs to handle "
"potential\n"
"success or failure as well. Using `panic!` and `Result` in the appropriate\n"
"situations will make your code more reliable in the face of inevitable "
"problems."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:281
msgid ""
"Now that you‚Äôve seen useful ways that the standard library uses generics "
"with\n"
"the `Option` and `Result` enums, we‚Äôll talk about how generics work and how "
"you\n"
"can use them in your code."
msgstr ""

#: src/ch10-00-generics.md:1
msgid "# Generic Types, Traits, and Lifetimes"
msgstr ""

#: src/ch10-00-generics.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication\n"
"of concepts. In Rust, one such tool is *generics*: abstract stand-ins for\n"
"concrete types or other properties. We can express the behavior of generics "
"or\n"
"how they relate to other generics without knowing what will be in their "
"place\n"
"when compiling and running the code."
msgstr ""

#: src/ch10-00-generics.md:9
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type\n"
"like `i32` or `String`, in the same way a function takes parameters with\n"
"unknown values to run the same code on multiple concrete values. In fact, "
"we‚Äôve\n"
"already used generics in Chapter 6 with `Option<T>`, Chapter 8 with "
"`Vec<T>`\n"
"and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, "
"you‚Äôll\n"
"explore how to define your own types, functions, and methods with generics!"
msgstr ""

#: src/ch10-00-generics.md:16
msgid ""
"First, we‚Äôll review how to extract a function to reduce code duplication. "
"We‚Äôll\n"
"then use the same technique to make a generic function from two functions "
"that\n"
"differ only in the types of their parameters. We‚Äôll also explain how to use\n"
"generic types in struct and enum definitions."
msgstr ""

#: src/ch10-00-generics.md:21
msgid ""
"Then you‚Äôll learn how to use *traits* to define behavior in a generic way. "
"You\n"
"can combine traits with generic types to constrain a generic type to accept\n"
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""

#: src/ch10-00-generics.md:25
msgid ""
"Finally, we‚Äôll discuss *lifetimes*: a variety of generics that give the\n"
"compiler information about how references relate to each other. Lifetimes "
"allow\n"
"us to give the compiler enough information about borrowed values so that it "
"can\n"
"ensure references will be valid in more situations than it could without "
"our\n"
"help."
msgstr ""

#: src/ch10-00-generics.md:31
msgid "## Removing Duplication by Extracting a Function"
msgstr ""

#: src/ch10-00-generics.md:33
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents\n"
"multiple types to remove code duplication. Before diving into generics "
"syntax,\n"
"then, let‚Äôs first look at how to remove duplication in a way that doesn‚Äôt\n"
"involve generic types by extracting a function that replaces specific "
"values\n"
"with a placeholder that represents multiple values. Then we‚Äôll apply the "
"same\n"
"technique to extract a generic function! By looking at how to recognize\n"
"duplicated code you can extract into a function, you‚Äôll start to recognize\n"
"duplicated code that can use generics."
msgstr ""

#: src/ch10-00-generics.md:42
msgid ""
"We begin with the short program in Listing 10-1 that finds the largest "
"number\n"
"in a list."
msgstr ""

#: src/ch10-00-generics.md:47
msgid ""
"```rust\n"
"fn main() {\n"
"    let number_list = vec![34, 50, 25, 100, 65];\n"
"\n"
"    let mut largest = &number_list[0];\n"
"\n"
"    for number in &number_list {\n"
"        if number > largest {\n"
"            largest = number;\n"
"        }\n"
"    }\n"
"\n"
"    println!(\"The largest number is {}\", largest);\n"
"#     assert_eq!(*largest, 100);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-00-generics.md:64
msgid ""
"<span class=\"caption\">Listing 10-1: Finding the largest number in a list "
"of\n"
"numbers</span>"
msgstr ""

#: src/ch10-00-generics.md:67
msgid ""
"We store a list of integers in the variable `number_list` and place a "
"reference\n"
"to the first number in the list in a variable named `largest`. We then "
"iterate\n"
"through all the numbers in the list, and if the current number is greater "
"than\n"
"the number stored in `largest`, replace the reference in that variable.\n"
"However, if the current number is less than or equal to the largest number "
"seen\n"
"so far, the variable doesn‚Äôt change, and the code moves on to the next "
"number\n"
"in the list. After considering all the numbers in the list, `largest` "
"should\n"
"refer to the largest number, which in this case is 100."
msgstr ""

#: src/ch10-00-generics.md:76
msgid ""
"We've now been tasked with finding the largest number in two different lists "
"of\n"
"numbers. To do so, we can choose to duplicate the code in Listing 10-1 and "
"use\n"
"the same logic at two different places in the program, as shown in Listing "
"10-2."
msgstr ""

#: src/ch10-00-generics.md:82
msgid ""
"```rust\n"
"fn main() {\n"
"    let number_list = vec![34, 50, 25, 100, 65];\n"
"\n"
"    let mut largest = &number_list[0];\n"
"\n"
"    for number in &number_list {\n"
"        if number > largest {\n"
"            largest = number;\n"
"        }\n"
"    }\n"
"\n"
"    println!(\"The largest number is {}\", largest);\n"
"\n"
"    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n"
"\n"
"    let mut largest = &number_list[0];\n"
"\n"
"    for number in &number_list {\n"
"        if number > largest {\n"
"            largest = number;\n"
"        }\n"
"    }\n"
"\n"
"    println!(\"The largest number is {}\", largest);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-00-generics.md:110
msgid ""
"<span class=\"caption\">Listing 10-2: Code to find the largest number in "
"*two*\n"
"lists of numbers</span>"
msgstr ""

#: src/ch10-00-generics.md:113
msgid ""
"Although this code works, duplicating code is tedious and error prone. We "
"also\n"
"have to remember to update the code in multiple places when we want to "
"change\n"
"it."
msgstr ""

#: src/ch10-00-generics.md:117
msgid ""
"To eliminate this duplication, we‚Äôll create an abstraction by defining a\n"
"function that operates on any list of integers passed in a parameter. This\n"
"solution makes our code clearer and lets us express the concept of finding "
"the\n"
"largest number in a list abstractly."
msgstr ""

#: src/ch10-00-generics.md:122
msgid ""
"In Listing 10-3, we extract the code that finds the largest number into a\n"
"function named `largest`. Then we call the function to find the largest "
"number\n"
"in the two lists from Listing 10-2. We could also use the function on any "
"other\n"
"list of `i32` values we might have in the future."
msgstr ""

#: src/ch10-00-generics.md:129
msgid ""
"```rust\n"
"fn largest(list: &[i32]) -> &i32 {\n"
"    let mut largest = &list[0];\n"
"\n"
"    for item in list {\n"
"        if item > largest {\n"
"            largest = item;\n"
"        }\n"
"    }\n"
"\n"
"    largest\n"
"}\n"
"\n"
"fn main() {\n"
"    let number_list = vec![34, 50, 25, 100, 65];\n"
"\n"
"    let result = largest(&number_list);\n"
"    println!(\"The largest number is {}\", result);\n"
"#     assert_eq!(*result, 100);\n"
"\n"
"    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n"
"\n"
"    let result = largest(&number_list);\n"
"    println!(\"The largest number is {}\", result);\n"
"#     assert_eq!(*result, 6000);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-00-generics.md:157
msgid ""
"<span class=\"caption\">Listing 10-3: Abstracted code to find the largest "
"number\n"
"in two lists</span>"
msgstr ""

#: src/ch10-00-generics.md:160
msgid ""
"The `largest` function has a parameter called `list`, which represents any\n"
"concrete slice of `i32` values we might pass into the function. As a "
"result,\n"
"when we call the function, the code runs on the specific values that we "
"pass\n"
"in."
msgstr ""

#: src/ch10-00-generics.md:165
msgid ""
"In summary, here are the steps we took to change the code from Listing 10-2 "
"to\n"
"Listing 10-3:"
msgstr ""

#: src/ch10-00-generics.md:168
msgid ""
"1. Identify duplicate code.\n"
"2. Extract the duplicate code into the body of the function and specify the\n"
"   inputs and return values of that code in the function signature.\n"
"3. Update the two instances of duplicated code to call the function instead."
msgstr ""

#: src/ch10-00-generics.md:173
msgid ""
"Next, we‚Äôll use these same steps with generics to reduce code duplication. "
"In\n"
"the same way that the function body can operate on an abstract `list` "
"instead\n"
"of specific values, generics allow code to operate on abstract types."
msgstr ""

#: src/ch10-00-generics.md:177
msgid ""
"For example, say we had two functions: one that finds the largest item in a\n"
"slice of `i32` values and one that finds the largest item in a slice of "
"`char`\n"
"values. How would we eliminate that duplication? Let‚Äôs find out!"
msgstr ""

#: src/ch10-01-syntax.md:1
msgid "## Generic Data Types"
msgstr ""

#: src/ch10-01-syntax.md:3
msgid ""
"We use generics to create definitions for items like function signatures or\n"
"structs, which we can then use with many different concrete data types. "
"Let‚Äôs\n"
"first look at how to define functions, structs, enums, and methods using\n"
"generics. Then we‚Äôll discuss how generics affect code performance."
msgstr ""

#: src/ch10-01-syntax.md:8
msgid "### In Function Definitions"
msgstr ""

#: src/ch10-01-syntax.md:10
msgid ""
"When defining a function that uses generics, we place the generics in the\n"
"signature of the function where we would usually specify the data types of "
"the\n"
"parameters and return value. Doing so makes our code more flexible and "
"provides\n"
"more functionality to callers of our function while preventing code "
"duplication."
msgstr ""

#: src/ch10-01-syntax.md:15
msgid ""
"Continuing with our `largest` function, Listing 10-4 shows two functions "
"that\n"
"both find the largest value in a slice. We'll then combine these into a "
"single\n"
"function that uses generics."
msgstr ""

#: src/ch10-01-syntax.md:21
msgid ""
"```rust\n"
"fn largest_i32(list: &[i32]) -> &i32 {\n"
"    let mut largest = &list[0];\n"
"\n"
"    for item in list {\n"
"        if item > largest {\n"
"            largest = item;\n"
"        }\n"
"    }\n"
"\n"
"    largest\n"
"}\n"
"\n"
"fn largest_char(list: &[char]) -> &char {\n"
"    let mut largest = &list[0];\n"
"\n"
"    for item in list {\n"
"        if item > largest {\n"
"            largest = item;\n"
"        }\n"
"    }\n"
"\n"
"    largest\n"
"}\n"
"\n"
"fn main() {\n"
"    let number_list = vec![34, 50, 25, 100, 65];\n"
"\n"
"    let result = largest_i32(&number_list);\n"
"    println!(\"The largest number is {}\", result);\n"
"#     assert_eq!(*result, 100);\n"
"\n"
"    let char_list = vec!['y', 'm', 'a', 'q'];\n"
"\n"
"    let result = largest_char(&char_list);\n"
"    println!(\"The largest char is {}\", result);\n"
"#     assert_eq!(*result, 'y');\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:61
msgid ""
"<span class=\"caption\">Listing 10-4: Two functions that differ only in "
"their\n"
"names and the types in their signatures</span>"
msgstr ""

#: src/ch10-01-syntax.md:64
msgid ""
"The `largest_i32` function is the one we extracted in Listing 10-3 that "
"finds\n"
"the largest `i32` in a slice. The `largest_char` function finds the largest\n"
"`char` in a slice. The function bodies have the same code, so let‚Äôs "
"eliminate\n"
"the duplication by introducing a generic type parameter in a single function."
msgstr ""

#: src/ch10-01-syntax.md:69
msgid ""
"To parameterize the types in a new single function, we need to name the "
"type\n"
"parameter, just as we do for the value parameters to a function. You can "
"use\n"
"any identifier as a type parameter name. But we‚Äôll use `T` because, by\n"
"convention, type parameter names in Rust are short, often just a letter, "
"and\n"
"Rust‚Äôs type-naming convention is UpperCamelCase. Short for ‚Äútype,‚Äù `T` is "
"the\n"
"default choice of most Rust programmers."
msgstr ""

#: src/ch10-01-syntax.md:76
msgid ""
"When we use a parameter in the body of the function, we have to declare the\n"
"parameter name in the signature so the compiler knows what that name means.\n"
"Similarly, when we use a type parameter name in a function signature, we "
"have\n"
"to declare the type parameter name before we use it. To define the generic\n"
"`largest` function, place type name declarations inside angle brackets, "
"`<>`,\n"
"between the name of the function and the parameter list, like this:"
msgstr ""

#: src/ch10-01-syntax.md:83
msgid ""
"```rust,ignore\n"
"fn largest<T>(list: &[T]) -> &T {\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:87
msgid ""
"We read this definition as: the function `largest` is generic over some "
"type\n"
"`T`. This function has one parameter named `list`, which is a slice of "
"values\n"
"of type `T`. The `largest` function will return a reference to a value of "
"the\n"
"same type `T`."
msgstr ""

#: src/ch10-01-syntax.md:92
msgid ""
"Listing 10-5 shows the combined `largest` function definition using the "
"generic\n"
"data type in its signature. The listing also shows how we can call the "
"function\n"
"with either a slice of `i32` values or `char` values. Note that this code "
"won‚Äôt\n"
"compile yet, but we‚Äôll fix it later in this chapter."
msgstr ""

#: src/ch10-01-syntax.md:99
msgid ""
"```rust,ignore,does_not_compile\n"
"fn largest<T>(list: &[T]) -> &T {\n"
"    let mut largest = &list[0];\n"
"\n"
"    for item in list {\n"
"        if item > largest {\n"
"            largest = item;\n"
"        }\n"
"    }\n"
"\n"
"    largest\n"
"}\n"
"\n"
"fn main() {\n"
"    let number_list = vec![34, 50, 25, 100, 65];\n"
"\n"
"    let result = largest(&number_list);\n"
"    println!(\"The largest number is {}\", result);\n"
"\n"
"    let char_list = vec!['y', 'm', 'a', 'q'];\n"
"\n"
"    let result = largest(&char_list);\n"
"    println!(\"The largest char is {}\", result);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:125
msgid ""
"<span class=\"caption\">Listing 10-5: The `largest` function using generic "
"type\n"
"parameters; this doesn‚Äôt yet compile</span>"
msgstr ""

#: src/ch10-01-syntax.md:128
msgid "If we compile this code right now, we‚Äôll get this error:"
msgstr ""

#: src/ch10-01-syntax.md:130
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0369]: binary operation `>` cannot be applied to type `&T`\n"
" --> src/main.rs:5:17\n"
"  |\n"
"5 |         if item > largest {\n"
"  |            ---- ^ ------- &T\n"
"  |            |\n"
"  |            &T\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n"
"  |             ++++++++++++++++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0369`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:150
msgid ""
"The help text mentions `std::cmp::PartialOrd`, which is a *trait*, and "
"we‚Äôre\n"
"going to talk about traits in the next section. For now, know that this "
"error\n"
"states that the body of `largest` won‚Äôt work for all possible types that "
"`T`\n"
"could be. Because we want to compare values of type `T` in the body, we can\n"
"only use types whose values can be ordered. To enable comparisons, the "
"standard\n"
"library has the `std::cmp::PartialOrd` trait that you can implement on "
"types\n"
"(see Appendix C for more on this trait). By following the help text's\n"
"suggestion, we restrict the types valid for `T` to only those that "
"implement\n"
"`PartialOrd` and this example will compile, because the standard library\n"
"implements `PartialOrd` on both `i32` and `char`."
msgstr ""

#: src/ch10-01-syntax.md:161
msgid "### In Struct Definitions"
msgstr ""

#: src/ch10-01-syntax.md:163
msgid ""
"We can also define structs to use a generic type parameter in one or more\n"
"fields using the `<>` syntax. Listing 10-6 defines a `Point<T>` struct to "
"hold\n"
"`x` and `y` coordinate values of any type."
msgstr ""

#: src/ch10-01-syntax.md:169
msgid ""
"```rust\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:181
msgid ""
"<span class=\"caption\">Listing 10-6: A `Point<T>` struct that holds `x` and "
"`y`\n"
"values of type `T`</span>"
msgstr ""

#: src/ch10-01-syntax.md:184
msgid ""
"The syntax for using generics in struct definitions is similar to that used "
"in\n"
"function definitions. First, we declare the name of the type parameter "
"inside\n"
"angle brackets just after the name of the struct. Then we use the generic "
"type\n"
"in the struct definition where we would otherwise specify concrete data "
"types."
msgstr ""

#: src/ch10-01-syntax.md:189
msgid ""
"Note that because we‚Äôve used only one generic type to define `Point<T>`, "
"this\n"
"definition says that the `Point<T>` struct is generic over some type `T`, "
"and\n"
"the fields `x` and `y` are *both* that same type, whatever that type may be. "
"If\n"
"we create an instance of a `Point<T>` that has values of different types, as "
"in\n"
"Listing 10-7, our code won‚Äôt compile."
msgstr ""

#: src/ch10-01-syntax.md:197
msgid ""
"```rust,ignore,does_not_compile\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let wont_work = Point { x: 5, y: 4.0 };\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:208
msgid ""
"<span class=\"caption\">Listing 10-7: The fields `x` and `y` must be the "
"same\n"
"type because both have the same generic data type `T`.</span>"
msgstr ""

#: src/ch10-01-syntax.md:211
msgid ""
"In this example, when we assign the integer value 5 to `x`, we let the "
"compiler\n"
"know that the generic type `T` will be an integer for this instance of\n"
"`Point<T>`. Then when we specify 4.0 for `y`, which we‚Äôve defined to have "
"the\n"
"same type as `x`, we‚Äôll get a type mismatch error like this:"
msgstr ""

#: src/ch10-01-syntax.md:216
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:7:38\n"
"  |\n"
"7 |     let wont_work = Point { x: 5, y: 4.0 };\n"
"  |                                      ^^^ expected integer, found "
"floating-point number\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:229
msgid ""
"To define a `Point` struct where `x` and `y` are both generics but could "
"have\n"
"different types, we can use multiple generic type parameters. For example, "
"in\n"
"Listing 10-8, we change the definition of `Point` to be generic over types "
"`T`\n"
"and `U` where `x` is of type `T` and `y` is of type `U`."
msgstr ""

#: src/ch10-01-syntax.md:236
msgid ""
"```rust\n"
"struct Point<T, U> {\n"
"    x: T,\n"
"    y: U,\n"
"}\n"
"\n"
"fn main() {\n"
"    let both_integer = Point { x: 5, y: 10 };\n"
"    let both_float = Point { x: 1.0, y: 4.0 };\n"
"    let integer_and_float = Point { x: 5, y: 4.0 };\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:249
msgid ""
"<span class=\"caption\">Listing 10-8: A `Point<T, U>` generic over two types "
"so\n"
"that `x` and `y` can be values of different types</span>"
msgstr ""

#: src/ch10-01-syntax.md:252
msgid ""
"Now all the instances of `Point` shown are allowed! You can use as many "
"generic\n"
"type parameters in a definition as you want, but using more than a few "
"makes\n"
"your code hard to read. If you're finding you need lots of generic types in\n"
"your code, it could indicate that your code needs restructuring into "
"smaller\n"
"pieces."
msgstr ""

#: src/ch10-01-syntax.md:258
msgid "### In Enum Definitions"
msgstr ""

#: src/ch10-01-syntax.md:260
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their\n"
"variants. Let‚Äôs take another look at the `Option<T>` enum that the standard\n"
"library provides, which we used in Chapter 6:"
msgstr ""

#: src/ch10-01-syntax.md:264
msgid ""
"```rust\n"
"enum Option<T> {\n"
"    Some(T),\n"
"    None,\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:271
msgid ""
"This definition should now make more sense to you. As you can see, the\n"
"`Option<T>` enum is generic over type `T` and has two variants: `Some`, "
"which\n"
"holds one value of type `T`, and a `None` variant that doesn‚Äôt hold any "
"value.\n"
"By using the `Option<T>` enum, we can express the abstract concept of an\n"
"optional value, and because `Option<T>` is generic, we can use this "
"abstraction\n"
"no matter what the type of the optional value is."
msgstr ""

#: src/ch10-01-syntax.md:278
msgid ""
"Enums can use multiple generic types as well. The definition of the "
"`Result`\n"
"enum that we used in Chapter 9 is one example:"
msgstr ""

#: src/ch10-01-syntax.md:288
msgid ""
"The `Result` enum is generic over two types, `T` and `E`, and has two "
"variants:\n"
"`Ok`, which holds a value of type `T`, and `Err`, which holds a value of "
"type\n"
"`E`. This definition makes it convenient to use the `Result` enum anywhere "
"we\n"
"have an operation that might succeed (return a value of some type `T`) or "
"fail\n"
"(return an error of some type `E`). In fact, this is what we used to open a\n"
"file in Listing 9-3, where `T` was filled in with the type `std::fs::File` "
"when\n"
"the file was opened successfully and `E` was filled in with the type\n"
"`std::io::Error` when there were problems opening the file."
msgstr ""

#: src/ch10-01-syntax.md:297
msgid ""
"When you recognize situations in your code with multiple struct or enum\n"
"definitions that differ only in the types of the values they hold, you can\n"
"avoid duplication by using generic types instead."
msgstr ""

#: src/ch10-01-syntax.md:301
msgid "### In Method Definitions"
msgstr ""

#: src/ch10-01-syntax.md:303
msgid ""
"We can implement methods on structs and enums (as we did in Chapter 5) and "
"use\n"
"generic types in their definitions, too. Listing 10-9 shows the `Point<T>`\n"
"struct we defined in Listing 10-6 with a method named `x` implemented on it."
msgstr ""

#: src/ch10-01-syntax.md:309
msgid ""
"```rust\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.x\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point { x: 5, y: 10 };\n"
"\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:328
msgid ""
"<span class=\"caption\">Listing 10-9: Implementing a method named `x` on "
"the\n"
"`Point<T>` struct that will return a reference to the `x` field of type\n"
"`T`</span>"
msgstr ""

#: src/ch10-01-syntax.md:332
msgid ""
"Here, we‚Äôve defined a method named `x` on `Point<T>` that returns a "
"reference\n"
"to the data in the field `x`."
msgstr ""

#: src/ch10-01-syntax.md:335
msgid ""
"Note that we have to declare `T` just after `impl` so we can use `T` to "
"specify\n"
"that we‚Äôre implementing methods on the type `Point<T>`. By declaring `T` as "
"a\n"
"generic type after `impl`, Rust can identify that the type in the angle\n"
"brackets in `Point` is a generic type rather than a concrete type. We could\n"
"have chosen a different name for this generic parameter than the generic\n"
"parameter declared in the struct definition, but using the same name is\n"
"conventional. Methods written within an `impl` that declares the generic "
"type\n"
"will be defined on any instance of the type, no matter what concrete type "
"ends\n"
"up substituting for the generic type."
msgstr ""

#: src/ch10-01-syntax.md:345
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the\n"
"type. We could, for example, implement methods only on `Point<f32>` "
"instances\n"
"rather than on `Point<T>` instances with any generic type. In Listing 10-10 "
"we\n"
"use the concrete type `f32`, meaning we don‚Äôt declare any types after `impl`."
msgstr ""

#: src/ch10-01-syntax.md:352
msgid ""
"```rust\n"
"# struct Point<T> {\n"
"#     x: T,\n"
"#     y: T,\n"
"# }\n"
"# \n"
"# impl<T> Point<T> {\n"
"#     fn x(&self) -> &T {\n"
"#         &self.x\n"
"#     }\n"
"# }\n"
"# \n"
"impl Point<f32> {\n"
"    fn distance_from_origin(&self) -> f32 {\n"
"        (self.x.powi(2) + self.y.powi(2)).sqrt()\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let p = Point { x: 5, y: 10 };\n"
"# \n"
"#     println!(\"p.x = {}\", p.x());\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:377
msgid ""
"<span class=\"caption\">Listing 10-10: An `impl` block that only applies to "
"a\n"
"struct with a particular concrete type for the generic type parameter `T`</"
"span>"
msgstr ""

#: src/ch10-01-syntax.md:380
msgid ""
"This code means the type `Point<f32>` will have a `distance_from_origin`\n"
"method; other instances of `Point<T>` where `T` is not of type `f32` will "
"not\n"
"have this method defined. The method measures how far our point is from the\n"
"point at coordinates (0.0, 0.0) and uses mathematical operations that are\n"
"available only for floating point types."
msgstr ""

#: src/ch10-01-syntax.md:386
msgid ""
"Generic type parameters in a struct definition aren‚Äôt always the same as "
"those\n"
"you use in that same struct‚Äôs method signatures. Listing 10-11 uses the "
"generic\n"
"types `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the `mixup` "
"method\n"
"signature to make the example clearer. The method creates a new `Point`\n"
"instance with the `x` value from the `self` `Point` (of type `X1`) and the "
"`y`\n"
"value from the passed-in `Point` (of type `Y2`)."
msgstr ""

#: src/ch10-01-syntax.md:395
msgid ""
"```rust\n"
"struct Point<X1, Y1> {\n"
"    x: X1,\n"
"    y: Y1,\n"
"}\n"
"\n"
"impl<X1, Y1> Point<X1, Y1> {\n"
"    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {\n"
"        Point {\n"
"            x: self.x,\n"
"            y: other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10.4 };\n"
"    let p2 = Point { x: \"Hello\", y: 'c' };\n"
"\n"
"    let p3 = p1.mixup(p2);\n"
"\n"
"    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:420
msgid ""
"<span class=\"caption\">Listing 10-11: A method that uses generic types "
"different\n"
"from its struct‚Äôs definition</span>"
msgstr ""

#: src/ch10-01-syntax.md:423
msgid ""
"In `main`, we‚Äôve defined a `Point` that has an `i32` for `x` (with value "
"`5`)\n"
"and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` "
"struct\n"
"that has a string slice for `x` (with value `\"Hello\"`) and a `char` for "
"`y`\n"
"(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us "
"`p3`,\n"
"which will have an `i32` for `x`, because `x` came from `p1`. The `p3` "
"variable\n"
"will have a `char` for `y`, because `y` came from `p2`. The `println!` "
"macro\n"
"call will print `p3.x = 5, p3.y = c`."
msgstr ""

#: src/ch10-01-syntax.md:431
msgid ""
"The purpose of this example is to demonstrate a situation in which some "
"generic\n"
"parameters are declared with `impl` and some are declared with the method\n"
"definition. Here, the generic parameters `X1` and `Y1` are declared after\n"
"`impl` because they go with the struct definition. The generic parameters "
"`X2`\n"
"and `Y2` are declared after `fn mixup`, because they‚Äôre only relevant to "
"the\n"
"method."
msgstr ""

#: src/ch10-01-syntax.md:438
msgid "### Performance of Code Using Generics"
msgstr ""

#: src/ch10-01-syntax.md:440
msgid ""
"You might be wondering whether there is a runtime cost when using generic "
"type\n"
"parameters. The good news is that using generic types won't make your "
"program run\n"
"any slower than it would with concrete types."
msgstr ""

#: src/ch10-01-syntax.md:444
msgid ""
"Rust accomplishes this by performing monomorphization of the code using\n"
"generics at compile time. *Monomorphization* is the process of turning "
"generic\n"
"code into specific code by filling in the concrete types that are used when\n"
"compiled. In this process, the compiler does the opposite of the steps we "
"used\n"
"to create the generic function in Listing 10-5: the compiler looks at all "
"the\n"
"places where generic code is called and generates code for the concrete "
"types\n"
"the generic code is called with."
msgstr ""

#: src/ch10-01-syntax.md:452
msgid ""
"Let‚Äôs look at how this works by using the standard library‚Äôs generic\n"
"`Option<T>` enum:"
msgstr ""

#: src/ch10-01-syntax.md:455
msgid ""
"```rust\n"
"let integer = Some(5);\n"
"let float = Some(5.0);\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:460
msgid ""
"When Rust compiles this code, it performs monomorphization. During that\n"
"process, the compiler reads the values that have been used in `Option<T>`\n"
"instances and identifies two kinds of `Option<T>`: one is `i32` and the "
"other\n"
"is `f64`. As such, it expands the generic definition of `Option<T>` into "
"two\n"
"definitions specialized to `i32` and `f64`, thereby replacing the generic\n"
"definition with the specific ones."
msgstr ""

#: src/ch10-01-syntax.md:467
msgid ""
"The monomorphized version of the code looks similar to the following (the\n"
"compiler uses different names than what we‚Äôre using here for illustration):"
msgstr ""

#: src/ch10-01-syntax.md:472
msgid ""
"```rust\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:489
msgid ""
"The generic `Option<T>` is replaced with the specific definitions created "
"by\n"
"the compiler. Because Rust compiles generic code into code that specifies "
"the\n"
"type in each instance, we pay no runtime cost for using generics. When the "
"code\n"
"runs, it performs just as it would if we had duplicated each definition by\n"
"hand. The process of monomorphization makes Rust‚Äôs generics extremely "
"efficient\n"
"at runtime."
msgstr ""

#: src/ch10-02-traits.md:1
msgid "## Traits: Defining Shared Behavior"
msgstr ""

#: src/ch10-02-traits.md:3
msgid ""
"A *trait* defines functionality a particular type has and can share with "
"other\n"
"types. We can use traits to define shared behavior in an abstract way. We "
"can\n"
"use *trait bounds* to specify that a generic type can be any type that has\n"
"certain behavior."
msgstr ""

#: src/ch10-02-traits.md:8
msgid ""
"> Note: Traits are similar to a feature often called *interfaces* in other\n"
"> languages, although with some differences."
msgstr ""

#: src/ch10-02-traits.md:11
msgid "### Defining a Trait"
msgstr ""

#: src/ch10-02-traits.md:13
msgid ""
"A type‚Äôs behavior consists of the methods we can call on that type. "
"Different\n"
"types share the same behavior if we can call the same methods on all of "
"those\n"
"types. Trait definitions are a way to group method signatures together to\n"
"define a set of behaviors necessary to accomplish some purpose."
msgstr ""

#: src/ch10-02-traits.md:18
msgid ""
"For example, let‚Äôs say we have multiple structs that hold various kinds and\n"
"amounts of text: a `NewsArticle` struct that holds a news story filed in a\n"
"particular location and a `Tweet` that can have at most 280 characters "
"along\n"
"with metadata that indicates whether it was a new tweet, a retweet, or a "
"reply\n"
"to another tweet."
msgstr ""

#: src/ch10-02-traits.md:24
msgid ""
"We want to make a media aggregator library crate named `aggregator` that "
"can\n"
"display summaries of data that might be stored in a `NewsArticle` or "
"`Tweet`\n"
"instance. To do this, we need a summary from each type, and we‚Äôll request\n"
"that summary by calling a `summarize` method on an instance. Listing 10-12\n"
"shows the definition of a public `Summary` trait that expresses this "
"behavior."
msgstr ""

#: src/ch10-02-traits.md:32
msgid ""
"```rust,noplayground\n"
"pub trait Summary {\n"
"    fn summarize(&self) -> String;\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:38
msgid ""
"<span class=\"caption\">Listing 10-12: A `Summary` trait that consists of "
"the\n"
"behavior provided by a `summarize` method</span>"
msgstr ""

#: src/ch10-02-traits.md:41
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait‚Äôs "
"name,\n"
"which is `Summary` in this case. We‚Äôve also declared the trait as `pub` so "
"that\n"
"crates depending on this crate can make use of this trait too, as we‚Äôll see "
"in\n"
"a few examples. Inside the curly brackets, we declare the method signatures\n"
"that describe the behaviors of the types that implement this trait, which "
"in\n"
"this case is `fn summarize(&self) -> String`."
msgstr ""

#: src/ch10-02-traits.md:48
msgid ""
"After the method signature, instead of providing an implementation within "
"curly\n"
"brackets, we use a semicolon. Each type implementing this trait must "
"provide\n"
"its own custom behavior for the body of the method. The compiler will "
"enforce\n"
"that any type that has the `Summary` trait will have the method `summarize`\n"
"defined with this signature exactly."
msgstr ""

#: src/ch10-02-traits.md:54
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed\n"
"one per line and each line ends in a semicolon."
msgstr ""

#: src/ch10-02-traits.md:57
msgid "### Implementing a Trait on a Type"
msgstr ""

#: src/ch10-02-traits.md:59
msgid ""
"Now that we‚Äôve defined the desired signatures of the `Summary` trait‚Äôs "
"methods,\n"
"we can implement it on the types in our media aggregator. Listing 10-13 "
"shows\n"
"an implementation of the `Summary` trait on the `NewsArticle` struct that "
"uses\n"
"the headline, the author, and the location to create the return value of\n"
"`summarize`. For the `Tweet` struct, we define `summarize` as the username\n"
"followed by the entire text of the tweet, assuming that tweet content is\n"
"already limited to 280 characters."
msgstr ""

#: src/ch10-02-traits.md:69
msgid ""
"```rust,noplayground\n"
"# pub trait Summary {\n"
"#     fn summarize(&self) -> String;\n"
"# }\n"
"# \n"
"pub struct NewsArticle {\n"
"    pub headline: String,\n"
"    pub location: String,\n"
"    pub author: String,\n"
"    pub content: String,\n"
"}\n"
"\n"
"impl Summary for NewsArticle {\n"
"    fn summarize(&self) -> String {\n"
"        format!(\"{}, by {} ({})\", self.headline, self.author, self."
"location)\n"
"    }\n"
"}\n"
"\n"
"pub struct Tweet {\n"
"    pub username: String,\n"
"    pub content: String,\n"
"    pub reply: bool,\n"
"    pub retweet: bool,\n"
"}\n"
"\n"
"impl Summary for Tweet {\n"
"    fn summarize(&self) -> String {\n"
"        format!(\"{}: {}\", self.username, self.content)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:101
msgid ""
"<span class=\"caption\">Listing 10-13: Implementing the `Summary` trait on "
"the\n"
"`NewsArticle` and `Tweet` types</span>"
msgstr ""

#: src/ch10-02-traits.md:104
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The\n"
"difference is that after `impl`, we put the trait name we want to "
"implement,\n"
"then use the `for` keyword, and then specify the name of the type we want "
"to\n"
"implement the trait for. Within the `impl` block, we put the method "
"signatures\n"
"that the trait definition has defined. Instead of adding a semicolon after "
"each\n"
"signature, we use curly brackets and fill in the method body with the "
"specific\n"
"behavior that we want the methods of the trait to have for the particular "
"type."
msgstr ""

#: src/ch10-02-traits.md:112
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and\n"
"`Tweet`, users of the crate can call the trait methods on instances of\n"
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only\n"
"difference is that the user must bring the trait into scope as well as the\n"
"types. Here‚Äôs an example of how a binary crate could use our `aggregator`\n"
"library crate:"
msgstr ""

#: src/ch10-02-traits.md:119
msgid ""
"```rust,ignore\n"
"use aggregator::{Summary, Tweet};\n"
"\n"
"fn main() {\n"
"    let tweet = Tweet {\n"
"        username: String::from(\"horse_ebooks\"),\n"
"        content: String::from(\n"
"            \"of course, as you probably already know, people\",\n"
"        ),\n"
"        reply: false,\n"
"        retweet: false,\n"
"    };\n"
"\n"
"    println!(\"1 new tweet: {}\", tweet.summarize());\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:136
msgid ""
"This code prints `1 new tweet: horse_ebooks: of course, as you probably "
"already\n"
"know, people`."
msgstr ""

#: src/ch10-02-traits.md:139
msgid ""
"Other crates that depend on the `aggregator` crate can also bring the "
"`Summary`\n"
"trait into scope to implement `Summary` on their own types. One restriction "
"to\n"
"note is that we can implement a trait on a type only if at least one of the\n"
"trait or the type is local to our crate. For example, we can implement "
"standard\n"
"library traits like `Display` on a custom type like `Tweet` as part of our\n"
"`aggregator` crate functionality, because the type `Tweet` is local to our\n"
"`aggregator` crate. We can also implement `Summary` on `Vec<T>` in our\n"
"`aggregator` crate, because the trait `Summary` is local to our "
"`aggregator`\n"
"crate."
msgstr ""

#: src/ch10-02-traits.md:149
msgid ""
"But we can‚Äôt implement external traits on external types. For example, we "
"can‚Äôt\n"
"implement the `Display` trait on `Vec<T>` within our `aggregator` crate,\n"
"because `Display` and `Vec<T>` are both defined in the standard library and\n"
"aren‚Äôt local to our `aggregator` crate. This restriction is part of a "
"property\n"
"called *coherence*, and more specifically the *orphan rule*, so named "
"because\n"
"the parent type is not present. This rule ensures that other people‚Äôs code\n"
"can‚Äôt break your code and vice versa. Without the rule, two crates could\n"
"implement the same trait for the same type, and Rust wouldn‚Äôt know which\n"
"implementation to use."
msgstr ""

#: src/ch10-02-traits.md:159
msgid "### Default Implementations"
msgstr ""

#: src/ch10-02-traits.md:161
msgid ""
"Sometimes it‚Äôs useful to have default behavior for some or all of the "
"methods\n"
"in a trait instead of requiring implementations for all methods on every "
"type.\n"
"Then, as we implement the trait on a particular type, we can keep or "
"override\n"
"each method‚Äôs default behavior."
msgstr ""

#: src/ch10-02-traits.md:166
msgid ""
"In Listing 10-14 we specify a default string for the `summarize` method of "
"the\n"
"`Summary` trait instead of only defining the method signature, as we did in\n"
"Listing 10-12."
msgstr ""

#: src/ch10-02-traits.md:172
msgid ""
"```rust,noplayground\n"
"pub trait Summary {\n"
"    fn summarize(&self) -> String {\n"
"        String::from(\"(Read more...)\")\n"
"    }\n"
"}\n"
"# \n"
"# pub struct NewsArticle {\n"
"#     pub headline: String,\n"
"#     pub location: String,\n"
"#     pub author: String,\n"
"#     pub content: String,\n"
"# }\n"
"# \n"
"# impl Summary for NewsArticle {}\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"# impl Summary for Tweet {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}: {}\", self.username, self.content)\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:202
msgid ""
"<span class=\"caption\">Listing 10-14: Defining a `Summary` trait with a "
"default\n"
"implementation of the `summarize` method</span>"
msgstr ""

#: src/ch10-02-traits.md:205
msgid ""
"To use a default implementation to summarize instances of `NewsArticle`, we\n"
"specify an empty `impl` block with `impl Summary for NewsArticle {}`."
msgstr ""

#: src/ch10-02-traits.md:208
msgid ""
"Even though we‚Äôre no longer defining the `summarize` method on "
"`NewsArticle`\n"
"directly, we‚Äôve provided a default implementation and specified that\n"
"`NewsArticle` implements the `Summary` trait. As a result, we can still "
"call\n"
"the `summarize` method on an instance of `NewsArticle`, like this:"
msgstr ""

#: src/ch10-02-traits.md:213
msgid ""
"```rust,ignore\n"
"# use aggregator::{self, NewsArticle, Summary};\n"
"# \n"
"# fn main() {\n"
"    let article = NewsArticle {\n"
"        headline: String::from(\"Penguins win the Stanley Cup Championship!"
"\"),\n"
"        location: String::from(\"Pittsburgh, PA, USA\"),\n"
"        author: String::from(\"Iceburgh\"),\n"
"        content: String::from(\n"
"            \"The Pittsburgh Penguins once again are the best \\\n"
"             hockey team in the NHL.\",\n"
"        ),\n"
"    };\n"
"\n"
"    println!(\"New article available! {}\", article.summarize());\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:231
msgid "This code prints `New article available! (Read more...)`."
msgstr ""

#: src/ch10-02-traits.md:233
msgid ""
"Creating a default implementation doesn‚Äôt require us to change anything "
"about\n"
"the implementation of `Summary` on `Tweet` in Listing 10-13. The reason is "
"that\n"
"the syntax for overriding a default implementation is the same as the "
"syntax\n"
"for implementing a trait method that doesn‚Äôt have a default implementation."
msgstr ""

#: src/ch10-02-traits.md:238
msgid ""
"Default implementations can call other methods in the same trait, even if "
"those\n"
"other methods don‚Äôt have a default implementation. In this way, a trait can\n"
"provide a lot of useful functionality and only require implementors to "
"specify\n"
"a small part of it. For example, we could define the `Summary` trait to have "
"a\n"
"`summarize_author` method whose implementation is required, and then define "
"a\n"
"`summarize` method that has a default implementation that calls the\n"
"`summarize_author` method:"
msgstr ""

#: src/ch10-02-traits.md:246
msgid ""
"```rust,noplayground\n"
"pub trait Summary {\n"
"    fn summarize_author(&self) -> String;\n"
"\n"
"    fn summarize(&self) -> String {\n"
"        format!(\"(Read more from {}...)\", self.summarize_author())\n"
"    }\n"
"}\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"# impl Summary for Tweet {\n"
"#     fn summarize_author(&self) -> String {\n"
"#         format!(\"@{}\", self.username)\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:269
msgid ""
"To use this version of `Summary`, we only need to define `summarize_author`\n"
"when we implement the trait on a type:"
msgstr ""

#: src/ch10-02-traits.md:272
msgid ""
"```rust,ignore\n"
"# pub trait Summary {\n"
"#     fn summarize_author(&self) -> String;\n"
"# \n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"(Read more from {}...)\", self.summarize_author())\n"
"#     }\n"
"# }\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"impl Summary for Tweet {\n"
"    fn summarize_author(&self) -> String {\n"
"        format!(\"@{}\", self.username)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:295
msgid ""
"After we define `summarize_author`, we can call `summarize` on instances of "
"the\n"
"`Tweet` struct, and the default implementation of `summarize` will call the\n"
"definition of `summarize_author` that we‚Äôve provided. Because we‚Äôve "
"implemented\n"
"`summarize_author`, the `Summary` trait has given us the behavior of the\n"
"`summarize` method without requiring us to write any more code."
msgstr ""

#: src/ch10-02-traits.md:301
msgid ""
"```rust,ignore\n"
"# use aggregator::{self, Summary, Tweet};\n"
"# \n"
"# fn main() {\n"
"    let tweet = Tweet {\n"
"        username: String::from(\"horse_ebooks\"),\n"
"        content: String::from(\n"
"            \"of course, as you probably already know, people\",\n"
"        ),\n"
"        reply: false,\n"
"        retweet: false,\n"
"    };\n"
"\n"
"    println!(\"1 new tweet: {}\", tweet.summarize());\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:318
msgid "This code prints `1 new tweet: (Read more from @horse_ebooks...)`."
msgstr ""

#: src/ch10-02-traits.md:320
msgid ""
"Note that it isn‚Äôt possible to call the default implementation from an\n"
"overriding implementation of that same method."
msgstr ""

#: src/ch10-02-traits.md:323
msgid "### Traits as Parameters"
msgstr ""

#: src/ch10-02-traits.md:325
msgid ""
"Now that you know how to define and implement traits, we can explore how to "
"use\n"
"traits to define functions that accept many different types. We'll use the\n"
"`Summary` trait we implemented on the `NewsArticle` and `Tweet` types in\n"
"Listing 10-13 to define a `notify` function that calls the `summarize` "
"method\n"
"on its `item` parameter, which is of some type that implements the "
"`Summary`\n"
"trait. To do this, we use the `impl Trait` syntax, like this:"
msgstr ""

#: src/ch10-02-traits.md:332
msgid ""
"```rust,ignore\n"
"# pub trait Summary {\n"
"#     fn summarize(&self) -> String;\n"
"# }\n"
"# \n"
"# pub struct NewsArticle {\n"
"#     pub headline: String,\n"
"#     pub location: String,\n"
"#     pub author: String,\n"
"#     pub content: String,\n"
"# }\n"
"# \n"
"# impl Summary for NewsArticle {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}, by {} ({})\", self.headline, self.author, self."
"location)\n"
"#     }\n"
"# }\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"# impl Summary for Tweet {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}: {}\", self.username, self.content)\n"
"#     }\n"
"# }\n"
"# \n"
"pub fn notify(item: &impl Summary) {\n"
"    println!(\"Breaking news! {}\", item.summarize());\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:368
msgid ""
"Instead of a concrete type for the `item` parameter, we specify the `impl`\n"
"keyword and the trait name. This parameter accepts any type that implements "
"the\n"
"specified trait. In the body of `notify`, we can call any methods on `item`\n"
"that come from the `Summary` trait, such as `summarize`. We can call "
"`notify`\n"
"and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the\n"
"function with any other type, such as a `String` or an `i32`, won‚Äôt compile\n"
"because those types don‚Äôt implement `Summary`."
msgstr ""

#: src/ch10-02-traits.md:377
msgid "<a id=\"fixing-the-largest-function-with-trait-bounds\"></a>"
msgstr ""

#: src/ch10-02-traits.md:379
msgid "#### Trait Bound Syntax"
msgstr ""

#: src/ch10-02-traits.md:381
msgid ""
"The `impl Trait` syntax works for straightforward cases but is actually "
"syntax\n"
"sugar for a longer form known as a *trait bound*; it looks like this:"
msgstr ""

#: src/ch10-02-traits.md:384
msgid ""
"```rust,ignore\n"
"pub fn notify<T: Summary>(item: &T) {\n"
"    println!(\"Breaking news! {}\", item.summarize());\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:390
msgid ""
"This longer form is equivalent to the example in the previous section but "
"is\n"
"more verbose. We place trait bounds with the declaration of the generic "
"type\n"
"parameter after a colon and inside angle brackets."
msgstr ""

#: src/ch10-02-traits.md:394
msgid ""
"The `impl Trait` syntax is convenient and makes for more concise code in "
"simple\n"
"cases, while the fuller trait bound syntax can express more complexity in "
"other\n"
"cases. For example, we can have two parameters that implement `Summary`. "
"Doing\n"
"so with the `impl Trait` syntax looks like this:"
msgstr ""

#: src/ch10-02-traits.md:399
msgid ""
"```rust,ignore\n"
"pub fn notify(item1: &impl Summary, item2: &impl Summary) {\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:403
msgid ""
"Using `impl Trait` is appropriate if we want this function to allow `item1` "
"and\n"
"`item2` to have different types (as long as both types implement `Summary`). "
"If\n"
"we want to force both parameters to have the same type, however, we must use "
"a\n"
"trait bound, like this:"
msgstr ""

#: src/ch10-02-traits.md:408
msgid ""
"```rust,ignore\n"
"pub fn notify<T: Summary>(item1: &T, item2: &T) {\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:412
msgid ""
"The generic type `T` specified as the type of the `item1` and `item2`\n"
"parameters constrains the function such that the concrete type of the value\n"
"passed as an argument for `item1` and `item2` must be the same."
msgstr ""

#: src/ch10-02-traits.md:416
msgid "#### Specifying Multiple Trait Bounds with the `+` Syntax"
msgstr ""

#: src/ch10-02-traits.md:418
msgid ""
"We can also specify more than one trait bound. Say we wanted `notify` to "
"use\n"
"display formatting as well as `summarize` on `item`: we specify in the "
"`notify`\n"
"definition that `item` must implement both `Display` and `Summary`. We can "
"do\n"
"so using the `+` syntax:"
msgstr ""

#: src/ch10-02-traits.md:423
msgid ""
"```rust,ignore\n"
"pub fn notify(item: &(impl Summary + Display)) {\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:427
msgid "The `+` syntax is also valid with trait bounds on generic types:"
msgstr ""

#: src/ch10-02-traits.md:429
msgid ""
"```rust,ignore\n"
"pub fn notify<T: Summary + Display>(item: &T) {\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:433
msgid ""
"With the two trait bounds specified, the body of `notify` can call "
"`summarize`\n"
"and use `{}` to format `item`."
msgstr ""

#: src/ch10-02-traits.md:436
msgid "#### Clearer Trait Bounds with `where` Clauses"
msgstr ""

#: src/ch10-02-traits.md:438
msgid ""
"Using too many trait bounds has its downsides. Each generic has its own "
"trait\n"
"bounds, so functions with multiple generic type parameters can contain lots "
"of\n"
"trait bound information between the function‚Äôs name and its parameter list,\n"
"making the function signature hard to read. For this reason, Rust has "
"alternate\n"
"syntax for specifying trait bounds inside a `where` clause after the "
"function\n"
"signature. So instead of writing this:"
msgstr ""

#: src/ch10-02-traits.md:445
msgid ""
"```rust,ignore\n"
"fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 "
"{\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:449
msgid "we can use a `where` clause, like this:"
msgstr ""

#: src/ch10-02-traits.md:451
msgid ""
"```rust,ignore\n"
"fn some_function<T, U>(t: &T, u: &U) -> i32\n"
"where\n"
"    T: Display + Clone,\n"
"    U: Clone + Debug,\n"
"{\n"
"#     unimplemented!()\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:461
msgid ""
"This function‚Äôs signature is less cluttered: the function name, parameter "
"list,\n"
"and return type are close together, similar to a function without lots of "
"trait\n"
"bounds."
msgstr ""

#: src/ch10-02-traits.md:465
msgid "### Returning Types that Implement Traits"
msgstr ""

#: src/ch10-02-traits.md:467
msgid ""
"We can also use the `impl Trait` syntax in the return position to return a\n"
"value of some type that implements a trait, as shown here:"
msgstr ""

#: src/ch10-02-traits.md:470
msgid ""
"```rust,ignore\n"
"# pub trait Summary {\n"
"#     fn summarize(&self) -> String;\n"
"# }\n"
"# \n"
"# pub struct NewsArticle {\n"
"#     pub headline: String,\n"
"#     pub location: String,\n"
"#     pub author: String,\n"
"#     pub content: String,\n"
"# }\n"
"# \n"
"# impl Summary for NewsArticle {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}, by {} ({})\", self.headline, self.author, self."
"location)\n"
"#     }\n"
"# }\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"# impl Summary for Tweet {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}: {}\", self.username, self.content)\n"
"#     }\n"
"# }\n"
"# \n"
"fn returns_summarizable() -> impl Summary {\n"
"    Tweet {\n"
"        username: String::from(\"horse_ebooks\"),\n"
"        content: String::from(\n"
"            \"of course, as you probably already know, people\",\n"
"        ),\n"
"        reply: false,\n"
"        retweet: false,\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:513
msgid ""
"By using `impl Summary` for the return type, we specify that the\n"
"`returns_summarizable` function returns some type that implements the "
"`Summary`\n"
"trait without naming the concrete type. In this case, "
"`returns_summarizable`\n"
"returns a `Tweet`, but the code calling this function doesn‚Äôt need to know "
"that."
msgstr ""

#: src/ch10-02-traits.md:518
msgid ""
"The ability to specify a return type only by the trait it implements is\n"
"especially useful in the context of closures and iterators, which we cover "
"in\n"
"Chapter 13. Closures and iterators create types that only the compiler knows "
"or\n"
"types that are very long to specify. The `impl Trait` syntax lets you "
"concisely\n"
"specify that a function returns some type that implements the `Iterator` "
"trait\n"
"without needing to write out a very long type."
msgstr ""

#: src/ch10-02-traits.md:525
msgid ""
"However, you can only use `impl Trait` if you‚Äôre returning a single type. "
"For\n"
"example, this code that returns either a `NewsArticle` or a `Tweet` with "
"the\n"
"return type specified as `impl Summary` wouldn‚Äôt work:"
msgstr ""

#: src/ch10-02-traits.md:529
msgid ""
"```rust,ignore,does_not_compile\n"
"# pub trait Summary {\n"
"#     fn summarize(&self) -> String;\n"
"# }\n"
"# \n"
"# pub struct NewsArticle {\n"
"#     pub headline: String,\n"
"#     pub location: String,\n"
"#     pub author: String,\n"
"#     pub content: String,\n"
"# }\n"
"# \n"
"# impl Summary for NewsArticle {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}, by {} ({})\", self.headline, self.author, self."
"location)\n"
"#     }\n"
"# }\n"
"# \n"
"# pub struct Tweet {\n"
"#     pub username: String,\n"
"#     pub content: String,\n"
"#     pub reply: bool,\n"
"#     pub retweet: bool,\n"
"# }\n"
"# \n"
"# impl Summary for Tweet {\n"
"#     fn summarize(&self) -> String {\n"
"#         format!(\"{}: {}\", self.username, self.content)\n"
"#     }\n"
"# }\n"
"# \n"
"fn returns_summarizable(switch: bool) -> impl Summary {\n"
"    if switch {\n"
"        NewsArticle {\n"
"            headline: String::from(\n"
"                \"Penguins win the Stanley Cup Championship!\",\n"
"            ),\n"
"            location: String::from(\"Pittsburgh, PA, USA\"),\n"
"            author: String::from(\"Iceburgh\"),\n"
"            content: String::from(\n"
"                \"The Pittsburgh Penguins once again are the best \\\n"
"                 hockey team in the NHL.\",\n"
"            ),\n"
"        }\n"
"    } else {\n"
"        Tweet {\n"
"            username: String::from(\"horse_ebooks\"),\n"
"            content: String::from(\n"
"                \"of course, as you probably already know, people\",\n"
"            ),\n"
"            reply: false,\n"
"            retweet: false,\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:586
msgid ""
"Returning either a `NewsArticle` or a `Tweet` isn‚Äôt allowed due to "
"restrictions\n"
"around how the `impl Trait` syntax is implemented in the compiler. We‚Äôll "
"cover\n"
"how to write a function with this behavior in the [‚ÄúUsing Trait Objects "
"That\n"
"Allow for Values of Different\n"
"Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--\n"
"ignore --> section of Chapter 17."
msgstr ""

#: src/ch10-02-traits.md:593
msgid "### Using Trait Bounds to Conditionally Implement Methods"
msgstr ""

#: src/ch10-02-traits.md:595
msgid ""
"By using a trait bound with an `impl` block that uses generic type "
"parameters,\n"
"we can implement methods conditionally for types that implement the "
"specified\n"
"traits. For example, the type `Pair<T>` in Listing 10-15 always implements "
"the\n"
"`new` function to return a new instance of `Pair<T>` (recall from the\n"
"[‚ÄúDefining Methods‚Äù][methods]<!-- ignore --> section of Chapter 5 that "
"`Self`\n"
"is a type alias for the type of the `impl` block, which in this case is\n"
"`Pair<T>`). But in the next `impl` block, `Pair<T>` only implements the\n"
"`cmp_display` method if its inner type `T` implements the `PartialOrd` "
"trait\n"
"that enables comparison *and* the `Display` trait that enables printing."
msgstr ""

#: src/ch10-02-traits.md:607
msgid ""
"```rust,noplayground\n"
"use std::fmt::Display;\n"
"\n"
"struct Pair<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"impl<T> Pair<T> {\n"
"    fn new(x: T, y: T) -> Self {\n"
"        Self { x, y }\n"
"    }\n"
"}\n"
"\n"
"impl<T: Display + PartialOrd> Pair<T> {\n"
"    fn cmp_display(&self) {\n"
"        if self.x >= self.y {\n"
"            println!(\"The largest member is x = {}\", self.x);\n"
"        } else {\n"
"            println!(\"The largest member is y = {}\", self.y);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:632
msgid ""
"<span class=\"caption\">Listing 10-15: Conditionally implementing methods on "
"a\n"
"generic type depending on trait bounds</span>"
msgstr ""

#: src/ch10-02-traits.md:635
msgid ""
"We can also conditionally implement a trait for any type that implements\n"
"another trait. Implementations of a trait on any type that satisfies the "
"trait\n"
"bounds are called *blanket implementations* and are extensively used in the\n"
"Rust standard library. For example, the standard library implements the\n"
"`ToString` trait on any type that implements the `Display` trait. The "
"`impl`\n"
"block in the standard library looks similar to this code:"
msgstr ""

#: src/ch10-02-traits.md:642
msgid ""
"```rust,ignore\n"
"impl<T: Display> ToString for T {\n"
"    // --snip--\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:648
msgid ""
"Because the standard library has this blanket implementation, we can call "
"the\n"
"`to_string` method defined by the `ToString` trait on any type that "
"implements\n"
"the `Display` trait. For example, we can turn integers into their "
"corresponding\n"
"`String` values like this because integers implement `Display`:"
msgstr ""

#: src/ch10-02-traits.md:653
msgid ""
"```rust\n"
"let s = 3.to_string();\n"
"```"
msgstr ""

#: src/ch10-02-traits.md:657
msgid ""
"Blanket implementations appear in the documentation for the trait in the\n"
"‚ÄúImplementors‚Äù section."
msgstr ""

#: src/ch10-02-traits.md:660
msgid ""
"Traits and trait bounds let us write code that uses generic type parameters "
"to\n"
"reduce duplication but also specify to the compiler that we want the "
"generic\n"
"type to have particular behavior. The compiler can then use the trait bound\n"
"information to check that all the concrete types used with our code provide "
"the\n"
"correct behavior. In dynamically typed languages, we would get an error at\n"
"runtime if we called a method on a type which didn‚Äôt define the method. But "
"Rust\n"
"moves these errors to compile time so we‚Äôre forced to fix the problems "
"before\n"
"our code is even able to run. Additionally, we don‚Äôt have to write code "
"that\n"
"checks for behavior at runtime because we‚Äôve already checked at compile "
"time.\n"
"Doing so improves performance without having to give up the flexibility of\n"
"generics."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:1
msgid "## Validating References with Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:3
msgid ""
"Lifetimes are another kind of generic that we‚Äôve already been using. Rather\n"
"than ensuring that a type has the behavior we want, lifetimes ensure that\n"
"references are valid as long as we need them to be."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:7
msgid ""
"One detail we didn‚Äôt discuss in the [‚ÄúReferences and\n"
"Borrowing‚Äù][references-and-borrowing]<!-- ignore --> section in Chapter 4 "
"is\n"
"that every reference in Rust has a *lifetime*, which is the scope for which\n"
"that reference is valid. Most of the time, lifetimes are implicit and "
"inferred,\n"
"just like most of the time, types are inferred. We must only annotate types\n"
"when multiple types are possible. In a similar way, we must annotate "
"lifetimes\n"
"when the lifetimes of references could be related in a few different ways. "
"Rust\n"
"requires us to annotate the relationships using generic lifetime parameters "
"to\n"
"ensure the actual references used at runtime will definitely be valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:17
msgid ""
"Annotating lifetimes is not a concept most other programming languages\n"
"have, so this is going to feel unfamiliar. Although we won‚Äôt cover lifetimes "
"in\n"
"their entirety in this chapter, we‚Äôll discuss common ways you might "
"encounter\n"
"lifetime syntax so you can get comfortable with the concept."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:22
msgid "### Preventing Dangling References with Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:24
msgid ""
"The main aim of lifetimes is to prevent *dangling references*, which cause "
"a\n"
"program to reference data other than the data it‚Äôs intended to reference.\n"
"Consider the program in Listing 10-16, which has an outer scope and an "
"inner\n"
"scope."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:29
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let r;\n"
"\n"
"    {\n"
"        let x = 5;\n"
"        r = &x;\n"
"    }\n"
"\n"
"    println!(\"r: {}\", r);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:42
msgid ""
"<span class=\"caption\">Listing 10-16: An attempt to use a reference whose "
"value\n"
"has gone out of scope</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:45
msgid ""
"> Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables\n"
"> without giving them an initial value, so the variable name exists in the\n"
"> outer scope. At first glance, this might appear to be in conflict with "
"Rust‚Äôs\n"
"> having no null values. However, if we try to use a variable before giving "
"it\n"
"> a value, we‚Äôll get a compile-time error, which shows that Rust indeed "
"does\n"
"> not allow null values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:52
msgid ""
"The outer scope declares a variable named `r` with no initial value, and "
"the\n"
"inner scope declares a variable named `x` with the initial value of 5. "
"Inside\n"
"the inner scope, we attempt to set the value of `r` as a reference to `x`. "
"Then\n"
"the inner scope ends, and we attempt to print the value in `r`. This code "
"won‚Äôt\n"
"compile because what the value `r` is referring to has gone out of scope "
"before we\n"
"try to use it. Here is the error message:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:59
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `x` does not live long enough\n"
" --> src/main.rs:6:13\n"
"  |\n"
"6 |         r = &x;\n"
"  |             ^^ borrowed value does not live long enough\n"
"7 |     }\n"
"  |     - `x` dropped here while still borrowed\n"
"8 |\n"
"9 |     println!(\"r: {}\", r);\n"
"  |                       - borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:77
msgid ""
"The variable `x` doesn‚Äôt ‚Äúlive long enough.‚Äù The reason is that `x` will be "
"out\n"
"of scope when the inner scope ends on line 7. But `r` is still valid for "
"the\n"
"outer scope; because its scope is larger, we say that it ‚Äúlives longer.‚Äù If\n"
"Rust allowed this code to work, `r` would be referencing memory that was\n"
"deallocated when `x` went out of scope, and anything we tried to do with "
"`r`\n"
"wouldn‚Äôt work correctly. So how does Rust determine that this code is "
"invalid?\n"
"It uses a borrow checker."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:85
msgid "### The Borrow Checker"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:87
msgid ""
"The Rust compiler has a *borrow checker* that compares scopes to determine\n"
"whether all borrows are valid. Listing 10-17 shows the same code as Listing\n"
"10-16 but with annotations showing the lifetimes of the variables."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:91
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let r;                // ---------+-- 'a\n"
"                          //          |\n"
"    {                     //          |\n"
"        let x = 5;        // -+-- 'b  |\n"
"        r = &x;           //  |       |\n"
"    }                     // -+       |\n"
"                          //          |\n"
"    println!(\"r: {}\", r); //          |\n"
"}                         // ---------+\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:104
msgid ""
"<span class=\"caption\">Listing 10-17: Annotations of the lifetimes of `r` "
"and\n"
"`x`, named `'a` and `'b`, respectively</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:107
msgid ""
"Here, we‚Äôve annotated the lifetime of `r` with `'a` and the lifetime of `x`\n"
"with `'b`. As you can see, the inner `'b` block is much smaller than the "
"outer\n"
"`'a` lifetime block. At compile time, Rust compares the size of the two\n"
"lifetimes and sees that `r` has a lifetime of `'a` but that it refers to "
"memory\n"
"with a lifetime of `'b`. The program is rejected because `'b` is shorter "
"than\n"
"`'a`: the subject of the reference doesn‚Äôt live as long as the reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:114
msgid ""
"Listing 10-18 fixes the code so it doesn‚Äôt have a dangling reference and\n"
"compiles without any errors."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:117
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 5;            // ----------+-- 'b\n"
"                          //           |\n"
"    let r = &x;           // --+-- 'a  |\n"
"                          //   |       |\n"
"    println!(\"r: {}\", r); //   |       |\n"
"                          // --+       |\n"
"}                         // ----------+\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:128
msgid ""
"<span class=\"caption\">Listing 10-18: A valid reference because the data "
"has a\n"
"longer lifetime than the reference</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:131
msgid ""
"Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. "
"This\n"
"means `r` can reference `x` because Rust knows that the reference in `r` "
"will\n"
"always be valid while `x` is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:135
msgid ""
"Now that you know where the lifetimes of references are and how Rust "
"analyzes\n"
"lifetimes to ensure references will always be valid, let‚Äôs explore generic\n"
"lifetimes of parameters and return values in the context of functions."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:139
msgid "### Generic Lifetimes in Functions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:141
msgid ""
"We‚Äôll write a function that returns the longer of two string slices. This\n"
"function will take two string slices and return a single string slice. "
"After\n"
"we‚Äôve implemented the `longest` function, the code in Listing 10-19 should\n"
"print `The longest string is abcd`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:148
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    let string1 = String::from(\"abcd\");\n"
"    let string2 = \"xyz\";\n"
"\n"
"    let result = longest(string1.as_str(), string2);\n"
"    println!(\"The longest string is {}\", result);\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:158
msgid ""
"<span class=\"caption\">Listing 10-19: A `main` function that calls the "
"`longest`\n"
"function to find the longer of two string slices</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:161
msgid ""
"Note that we want the function to take string slices, which are references,\n"
"rather than strings, because we don‚Äôt want the `longest` function to take\n"
"ownership of its parameters. Refer to the [‚ÄúString Slices as\n"
"Parameters‚Äù][string-slices-as-parameters]<!-- ignore --> section in Chapter "
"4\n"
"for more discussion about why the parameters we use in Listing 10-19 are "
"the\n"
"ones we want."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:168
msgid ""
"If we try to implement the `longest` function as shown in Listing 10-20, it\n"
"won‚Äôt compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:173
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"#     let string1 = String::from(\"abcd\");\n"
"#     let string2 = \"xyz\";\n"
"# \n"
"#     let result = longest(string1.as_str(), string2);\n"
"#     println!(\"The longest string is {}\", result);\n"
"# }\n"
"# \n"
"fn longest(x: &str, y: &str) -> &str {\n"
"    if x.len() > y.len() {\n"
"        x\n"
"    } else {\n"
"        y\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:191
msgid ""
"<span class=\"caption\">Listing 10-20: An implementation of the `longest`\n"
"function that returns the longer of two string slices but does not yet\n"
"compile</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:195
msgid "Instead, we get the following error that talks about lifetimes:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:197
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:9:33\n"
"  |\n"
"9 | fn longest(x: &str, y: &str) -> &str {\n"
"  |               ----     ----     ^ expected named lifetime parameter\n"
"  |\n"
"  = help: this function's return type contains a borrowed value, but the "
"signature does not say whether it is borrowed from `x` or `y`\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"  |           ++++     ++          ++          ++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:216
msgid ""
"The help text reveals that the return type needs a generic lifetime "
"parameter\n"
"on it because Rust can‚Äôt tell whether the reference being returned refers "
"to\n"
"`x` or `y`. Actually, we don‚Äôt know either, because the `if` block in the "
"body\n"
"of this function returns a reference to `x` and the `else` block returns a\n"
"reference to `y`!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:222
msgid ""
"When we‚Äôre defining this function, we don‚Äôt know the concrete values that "
"will\n"
"be passed into this function, so we don‚Äôt know whether the `if` case or the\n"
"`else` case will execute. We also don‚Äôt know the concrete lifetimes of the\n"
"references that will be passed in, so we can‚Äôt look at the scopes as we did "
"in\n"
"Listings 10-17 and 10-18 to determine whether the reference we return will\n"
"always be valid. The borrow checker can‚Äôt determine this either, because it\n"
"doesn‚Äôt know how the lifetimes of `x` and `y` relate to the lifetime of the\n"
"return value. To fix this error, we‚Äôll add generic lifetime parameters that\n"
"define the relationship between the references so the borrow checker can\n"
"perform its analysis."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:233
msgid "### Lifetime Annotation Syntax"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:235
msgid ""
"Lifetime annotations don‚Äôt change how long any of the references live. "
"Rather,\n"
"they describe the relationships of the lifetimes of multiple references to "
"each\n"
"other without affecting the lifetimes. Just as functions can accept any "
"type\n"
"when the signature specifies a generic type parameter, functions can accept\n"
"references with any lifetime by specifying a generic lifetime parameter."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:241
msgid ""
"Lifetime annotations have a slightly unusual syntax: the names of lifetime\n"
"parameters must start with an apostrophe (`'`) and are usually all "
"lowercase\n"
"and very short, like generic types. Most people use the name `'a` for the "
"first\n"
"lifetime annotation. We place lifetime parameter annotations after the `&` "
"of a\n"
"reference, using a space to separate the annotation from the reference‚Äôs "
"type."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:247
msgid ""
"Here are some examples: a reference to an `i32` without a lifetime "
"parameter, a\n"
"reference to an `i32` that has a lifetime parameter named `'a`, and a "
"mutable\n"
"reference to an `i32` that also has the lifetime `'a`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:251
msgid ""
"```rust,ignore\n"
"&i32        // a reference\n"
"&'a i32     // a reference with an explicit lifetime\n"
"&'a mut i32 // a mutable reference with an explicit lifetime\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:257
msgid ""
"One lifetime annotation by itself doesn‚Äôt have much meaning, because the\n"
"annotations are meant to tell Rust how generic lifetime parameters of "
"multiple\n"
"references relate to each other. Let‚Äôs examine how the lifetime annotations\n"
"relate to each other in the context of the `longest` function."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:262
msgid "### Lifetime Annotations in Function Signatures"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:264
msgid ""
"To use lifetime annotations in function signatures, we need to declare the\n"
"generic *lifetime* parameters inside angle brackets between the function "
"name\n"
"and the parameter list, just as we did with generic *type* parameters."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:268
msgid ""
"We want the signature to express the following constraint: the returned\n"
"reference will be valid as long as both the parameters are valid. This is "
"the\n"
"relationship between lifetimes of the parameters and the return value. "
"We‚Äôll\n"
"name the lifetime `'a` and then add it to each reference, as shown in "
"Listing\n"
"10-21."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:276
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let string1 = String::from(\"abcd\");\n"
"#     let string2 = \"xyz\";\n"
"# \n"
"#     let result = longest(string1.as_str(), string2);\n"
"#     println!(\"The longest string is {}\", result);\n"
"# }\n"
"# \n"
"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"    if x.len() > y.len() {\n"
"        x\n"
"    } else {\n"
"        y\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:294
msgid ""
"<span class=\"caption\">Listing 10-21: The `longest` function definition\n"
"specifying that all the references in the signature must have the same "
"lifetime\n"
"`'a`</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:298
msgid ""
"This code should compile and produce the result we want when we use it with "
"the\n"
"`main` function in Listing 10-19."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:301
msgid ""
"The function signature now tells Rust that for some lifetime `'a`, the "
"function\n"
"takes two parameters, both of which are string slices that live at least as\n"
"long as lifetime `'a`. The function signature also tells Rust that the "
"string\n"
"slice returned from the function will live at least as long as lifetime "
"`'a`.\n"
"In practice, it means that the lifetime of the reference returned by the\n"
"`longest` function is the same as the smaller of the lifetimes of the "
"values\n"
"referred to by the function arguments. These relationships are what we want\n"
"Rust to use when analyzing this code."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:310
msgid ""
"Remember, when we specify the lifetime parameters in this function "
"signature,\n"
"we‚Äôre not changing the lifetimes of any values passed in or returned. "
"Rather,\n"
"we‚Äôre specifying that the borrow checker should reject any values that "
"don‚Äôt\n"
"adhere to these constraints. Note that the `longest` function doesn‚Äôt need "
"to\n"
"know exactly how long `x` and `y` will live, only that some scope can be\n"
"substituted for `'a` that will satisfy this signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:317
msgid ""
"When annotating lifetimes in functions, the annotations go in the function\n"
"signature, not in the function body. The lifetime annotations become part "
"of\n"
"the contract of the function, much like the types in the signature. Having\n"
"function signatures contain the lifetime contract means the analysis the "
"Rust\n"
"compiler does can be simpler. If there‚Äôs a problem with the way a function "
"is\n"
"annotated or the way it is called, the compiler errors can point to the part "
"of\n"
"our code and the constraints more precisely. If, instead, the Rust compiler\n"
"made more inferences about what we intended the relationships of the "
"lifetimes\n"
"to be, the compiler might only be able to point to a use of our code many "
"steps\n"
"away from the cause of the problem."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:328
msgid ""
"When we pass concrete references to `longest`, the concrete lifetime that "
"is\n"
"substituted for `'a` is the part of the scope of `x` that overlaps with the\n"
"scope of `y`. In other words, the generic lifetime `'a` will get the "
"concrete\n"
"lifetime that is equal to the smaller of the lifetimes of `x` and `y`. "
"Because\n"
"we‚Äôve annotated the returned reference with the same lifetime parameter "
"`'a`,\n"
"the returned reference will also be valid for the length of the smaller of "
"the\n"
"lifetimes of `x` and `y`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:336
msgid ""
"Let‚Äôs look at how the lifetime annotations restrict the `longest` function "
"by\n"
"passing in references that have different concrete lifetimes. Listing 10-22 "
"is\n"
"a straightforward example."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:342
msgid ""
"```rust\n"
"fn main() {\n"
"    let string1 = String::from(\"long string is long\");\n"
"\n"
"    {\n"
"        let string2 = String::from(\"xyz\");\n"
"        let result = longest(string1.as_str(), string2.as_str());\n"
"        println!(\"The longest string is {}\", result);\n"
"    }\n"
"}\n"
"# \n"
"# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"#     if x.len() > y.len() {\n"
"#         x\n"
"#     } else {\n"
"#         y\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:362
msgid ""
"<span class=\"caption\">Listing 10-22: Using the `longest` function with\n"
"references to `String` values that have different concrete lifetimes</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:365
msgid ""
"In this example, `string1` is valid until the end of the outer scope, "
"`string2`\n"
"is valid until the end of the inner scope, and `result` references "
"something\n"
"that is valid until the end of the inner scope. Run this code, and you‚Äôll "
"see\n"
"that the borrow checker approves; it will compile and print `The longest "
"string\n"
"is long string is long`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:371
msgid ""
"Next, let‚Äôs try an example that shows that the lifetime of the reference in\n"
"`result` must be the smaller lifetime of the two arguments. We‚Äôll move the\n"
"declaration of the `result` variable outside the inner scope but leave the\n"
"assignment of the value to the `result` variable inside the scope with\n"
"`string2`. Then we‚Äôll move the `println!` that uses `result` to outside the\n"
"inner scope, after the inner scope has ended. The code in Listing 10-23 "
"will\n"
"not compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:381
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let string1 = String::from(\"long string is long\");\n"
"    let result;\n"
"    {\n"
"        let string2 = String::from(\"xyz\");\n"
"        result = longest(string1.as_str(), string2.as_str());\n"
"    }\n"
"    println!(\"The longest string is {}\", result);\n"
"}\n"
"# \n"
"# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"#     if x.len() > y.len() {\n"
"#         x\n"
"#     } else {\n"
"#         y\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:401
msgid ""
"<span class=\"caption\">Listing 10-23: Attempting to use `result` after "
"`string2`\n"
"has gone out of scope</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:404
msgid "When we try to compile this code, we get this error:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:406
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `string2` does not live long enough\n"
" --> src/main.rs:6:44\n"
"  |\n"
"6 |         result = longest(string1.as_str(), string2.as_str());\n"
"  |                                            ^^^^^^^^^^^^^^^^ borrowed "
"value does not live long enough\n"
"7 |     }\n"
"  |     - `string2` dropped here while still borrowed\n"
"8 |     println!(\"The longest string is {}\", result);\n"
"  |                                          ------ borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:423
msgid ""
"The error shows that for `result` to be valid for the `println!` statement,\n"
"`string2` would need to be valid until the end of the outer scope. Rust "
"knows\n"
"this because we annotated the lifetimes of the function parameters and "
"return\n"
"values using the same lifetime parameter `'a`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:428
msgid ""
"As humans, we can look at this code and see that `string1` is longer than\n"
"`string2` and therefore `result` will contain a reference to `string1`.\n"
"Because `string1` has not gone out of scope yet, a reference to `string1` "
"will\n"
"still be valid for the `println!` statement. However, the compiler can‚Äôt "
"see\n"
"that the reference is valid in this case. We‚Äôve told Rust that the lifetime "
"of\n"
"the reference returned by the `longest` function is the same as the smaller "
"of\n"
"the lifetimes of the references passed in. Therefore, the borrow checker\n"
"disallows the code in Listing 10-23 as possibly having an invalid reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:437
msgid ""
"Try designing more experiments that vary the values and lifetimes of the\n"
"references passed in to the `longest` function and how the returned "
"reference\n"
"is used. Make hypotheses about whether or not your experiments will pass "
"the\n"
"borrow checker before you compile; then check to see if you‚Äôre right!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:442
msgid "### Thinking in Terms of Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:444
msgid ""
"The way in which you need to specify lifetime parameters depends on what "
"your\n"
"function is doing. For example, if we changed the implementation of the\n"
"`longest` function to always return the first parameter rather than the "
"longest\n"
"string slice, we wouldn‚Äôt need to specify a lifetime on the `y` parameter. "
"The\n"
"following code will compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:452
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let string1 = String::from(\"abcd\");\n"
"#     let string2 = \"efghijklmnopqrstuvwxyz\";\n"
"# \n"
"#     let result = longest(string1.as_str(), string2);\n"
"#     println!(\"The longest string is {}\", result);\n"
"# }\n"
"# \n"
"fn longest<'a>(x: &'a str, y: &str) -> &'a str {\n"
"    x\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:466
msgid ""
"We‚Äôve specified a lifetime parameter `'a` for the parameter `x` and the "
"return\n"
"type, but not for the parameter `y`, because the lifetime of `y` does not "
"have\n"
"any relationship with the lifetime of `x` or the return value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:470
msgid ""
"When returning a reference from a function, the lifetime parameter for the\n"
"return type needs to match the lifetime parameter for one of the parameters. "
"If\n"
"the reference returned does *not* refer to one of the parameters, it must "
"refer\n"
"to a value created within this function. However, this would be a dangling\n"
"reference because the value will go out of scope at the end of the "
"function.\n"
"Consider this attempted implementation of the `longest` function that won‚Äôt\n"
"compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:480
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"#     let string1 = String::from(\"abcd\");\n"
"#     let string2 = \"xyz\";\n"
"# \n"
"#     let result = longest(string1.as_str(), string2);\n"
"#     println!(\"The longest string is {}\", result);\n"
"# }\n"
"# \n"
"fn longest<'a>(x: &str, y: &str) -> &'a str {\n"
"    let result = String::from(\"really long string\");\n"
"    result.as_str()\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:495
msgid ""
"Here, even though we‚Äôve specified a lifetime parameter `'a` for the return\n"
"type, this implementation will fail to compile because the return value\n"
"lifetime is not related to the lifetime of the parameters at all. Here is "
"the\n"
"error message we get:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:500
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0515]: cannot return reference to local variable `result`\n"
"  --> src/main.rs:11:5\n"
"   |\n"
"11 |     result.as_str()\n"
"   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current "
"function\n"
"\n"
"For more information about this error, try `rustc --explain E0515`.\n"
"error: could not compile `chapter10` due to previous error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:513
msgid ""
"The problem is that `result` goes out of scope and gets cleaned up at the "
"end\n"
"of the `longest` function. We‚Äôre also trying to return a reference to "
"`result`\n"
"from the function. There is no way we can specify lifetime parameters that\n"
"would change the dangling reference, and Rust won‚Äôt let us create a "
"dangling\n"
"reference. In this case, the best fix would be to return an owned data type\n"
"rather than a reference so the calling function is then responsible for\n"
"cleaning up the value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:521
msgid ""
"Ultimately, lifetime syntax is about connecting the lifetimes of various\n"
"parameters and return values of functions. Once they‚Äôre connected, Rust has\n"
"enough information to allow memory-safe operations and disallow operations "
"that\n"
"would create dangling pointers or otherwise violate memory safety."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:526
msgid "### Lifetime Annotations in Struct Definitions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:528
msgid ""
"So far, the structs we‚Äôve defined all hold owned types. We can define "
"structs to\n"
"hold references, but in that case we would need to add a lifetime annotation "
"on\n"
"every reference in the struct‚Äôs definition. Listing 10-24 has a struct "
"named\n"
"`ImportantExcerpt` that holds a string slice."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:535
msgid ""
"```rust\n"
"struct ImportantExcerpt<'a> {\n"
"    part: &'a str,\n"
"}\n"
"\n"
"fn main() {\n"
"    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n"
"    let first_sentence = novel.split('.').next().expect(\"Could not find a "
"'.'\");\n"
"    let i = ImportantExcerpt {\n"
"        part: first_sentence,\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:549
msgid ""
"<span class=\"caption\">Listing 10-24: A struct that holds a reference, "
"requiring\n"
"a lifetime annotation</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:552
msgid ""
"This struct has the single field `part` that holds a string slice, which is "
"a\n"
"reference. As with generic data types, we declare the name of the generic\n"
"lifetime parameter inside angle brackets after the name of the struct so we "
"can\n"
"use the lifetime parameter in the body of the struct definition. This\n"
"annotation means an instance of `ImportantExcerpt` can‚Äôt outlive the "
"reference\n"
"it holds in its `part` field."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:559
msgid ""
"The `main` function here creates an instance of the `ImportantExcerpt` "
"struct\n"
"that holds a reference to the first sentence of the `String` owned by the\n"
"variable `novel`. The data in `novel` exists before the `ImportantExcerpt`\n"
"instance is created. In addition, `novel` doesn‚Äôt go out of scope until "
"after\n"
"the `ImportantExcerpt` goes out of scope, so the reference in the\n"
"`ImportantExcerpt` instance is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:566
msgid "### Lifetime Elision"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:568
msgid ""
"You‚Äôve learned that every reference has a lifetime and that you need to "
"specify\n"
"lifetime parameters for functions or structs that use references. However, "
"in\n"
"Chapter 4 we had a function in Listing 4-9, shown again in Listing 10-25, "
"that\n"
"compiled without lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:575
msgid ""
"```rust\n"
"fn first_word(s: &str) -> &str {\n"
"    let bytes = s.as_bytes();\n"
"\n"
"    for (i, &item) in bytes.iter().enumerate() {\n"
"        if item == b' ' {\n"
"            return &s[0..i];\n"
"        }\n"
"    }\n"
"\n"
"    &s[..]\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let my_string = String::from(\"hello world\");\n"
"# \n"
"#     // first_word works on slices of `String`s\n"
"#     let word = first_word(&my_string[..]);\n"
"# \n"
"#     let my_string_literal = \"hello world\";\n"
"# \n"
"#     // first_word works on slices of string literals\n"
"#     let word = first_word(&my_string_literal[..]);\n"
"# \n"
"#     // Because string literals *are* string slices already,\n"
"#     // this works too, without the slice syntax!\n"
"#     let word = first_word(my_string_literal);\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:605
msgid ""
"<span class=\"caption\">Listing 10-25: A function we defined in Listing 4-9 "
"that\n"
"compiled without lifetime annotations, even though the parameter and return\n"
"type are references</span>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:609
msgid ""
"The reason this function compiles without lifetime annotations is "
"historical:\n"
"in early versions (pre-1.0) of Rust, this code wouldn‚Äôt have compiled "
"because\n"
"every reference needed an explicit lifetime. At that time, the function\n"
"signature would have been written like this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:614 src/ch10-03-lifetime-syntax.md:686
msgid ""
"```rust,ignore\n"
"fn first_word<'a>(s: &'a str) -> &'a str {\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:618
msgid ""
"After writing a lot of Rust code, the Rust team found that Rust programmers\n"
"were entering the same lifetime annotations over and over in particular\n"
"situations. These situations were predictable and followed a few "
"deterministic\n"
"patterns. The developers programmed these patterns into the compiler‚Äôs code "
"so\n"
"the borrow checker could infer the lifetimes in these situations and "
"wouldn‚Äôt\n"
"need explicit annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:625
msgid ""
"This piece of Rust history is relevant because it‚Äôs possible that more\n"
"deterministic patterns will emerge and be added to the compiler. In the "
"future,\n"
"even fewer lifetime annotations might be required."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:629
msgid ""
"The patterns programmed into Rust‚Äôs analysis of references are called the\n"
"*lifetime elision rules*. These aren‚Äôt rules for programmers to follow; "
"they‚Äôre\n"
"a set of particular cases that the compiler will consider, and if your code\n"
"fits these cases, you don‚Äôt need to write the lifetimes explicitly."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:634
msgid ""
"The elision rules don‚Äôt provide full inference. If Rust deterministically\n"
"applies the rules but there is still ambiguity as to what lifetimes the\n"
"references have, the compiler won‚Äôt guess what the lifetime of the "
"remaining\n"
"references should be. Instead of guessing, the compiler will give you an "
"error\n"
"that you can resolve by adding the lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:640
msgid ""
"Lifetimes on function or method parameters are called *input lifetimes*, "
"and\n"
"lifetimes on return values are called *output lifetimes*."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:643
msgid ""
"The compiler uses three rules to figure out the lifetimes of the references\n"
"when there aren‚Äôt explicit annotations. The first rule applies to input\n"
"lifetimes, and the second and third rules apply to output lifetimes. If the\n"
"compiler gets to the end of the three rules and there are still references "
"for\n"
"which it can‚Äôt figure out lifetimes, the compiler will stop with an error.\n"
"These rules apply to `fn` definitions as well as `impl` blocks."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:650
msgid ""
"The first rule is that the compiler assigns a lifetime parameter to each\n"
"parameter that‚Äôs a reference. In other words, a function with one parameter "
"gets\n"
"one lifetime parameter: `fn foo<'a>(x: &'a i32)`; a function with two\n"
"parameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a "
"i32,\n"
"y: &'b i32)`; and so on."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:656
msgid ""
"The second rule is that, if there is exactly one input lifetime parameter, "
"that\n"
"lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a "
"i32)\n"
"-> &'a i32`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:660
msgid ""
"The third rule is that, if there are multiple input lifetime parameters, "
"but\n"
"one of them is `&self` or `&mut self` because this is a method, the lifetime "
"of\n"
"`self` is assigned to all output lifetime parameters. This third rule makes\n"
"methods much nicer to read and write because fewer symbols are necessary."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:665
msgid ""
"Let‚Äôs pretend we‚Äôre the compiler. We‚Äôll apply these rules to figure out the\n"
"lifetimes of the references in the signature of the `first_word` function "
"in\n"
"Listing 10-25. The signature starts without any lifetimes associated with "
"the\n"
"references:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:670
msgid ""
"```rust,ignore\n"
"fn first_word(s: &str) -> &str {\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:674
msgid ""
"Then the compiler applies the first rule, which specifies that each "
"parameter\n"
"gets its own lifetime. We‚Äôll call it `'a` as usual, so now the signature is\n"
"this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:678
msgid ""
"```rust,ignore\n"
"fn first_word<'a>(s: &'a str) -> &str {\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:682
msgid ""
"The second rule applies because there is exactly one input lifetime. The "
"second\n"
"rule specifies that the lifetime of the one input parameter gets assigned "
"to\n"
"the output lifetime, so the signature is now this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:690
msgid ""
"Now all the references in this function signature have lifetimes, and the\n"
"compiler can continue its analysis without needing the programmer to "
"annotate\n"
"the lifetimes in this function signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:694
msgid ""
"Let‚Äôs look at another example, this time using the `longest` function that "
"had\n"
"no lifetime parameters when we started working with it in Listing 10-20:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:697
msgid ""
"```rust,ignore\n"
"fn longest(x: &str, y: &str) -> &str {\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:701
msgid ""
"Let‚Äôs apply the first rule: each parameter gets its own lifetime. This time "
"we\n"
"have two parameters instead of one, so we have two lifetimes:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:704
msgid ""
"```rust,ignore\n"
"fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:708
msgid ""
"You can see that the second rule doesn‚Äôt apply because there is more than "
"one\n"
"input lifetime. The third rule doesn‚Äôt apply either, because `longest` is a\n"
"function rather than a method, so none of the parameters are `self`. After\n"
"working through all three rules, we still haven‚Äôt figured out what the "
"return\n"
"type‚Äôs lifetime is. This is why we got an error trying to compile the code "
"in\n"
"Listing 10-20: the compiler worked through the lifetime elision rules but "
"still\n"
"couldn‚Äôt figure out all the lifetimes of the references in the signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:716
msgid ""
"Because the third rule really only applies in method signatures, we‚Äôll look "
"at\n"
"lifetimes in that context next to see why the third rule means we don‚Äôt have "
"to\n"
"annotate lifetimes in method signatures very often."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:720
msgid "### Lifetime Annotations in Method Definitions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:722
msgid ""
"When we implement methods on a struct with lifetimes, we use the same syntax "
"as\n"
"that of generic type parameters shown in Listing 10-11. Where we declare "
"and\n"
"use the lifetime parameters depends on whether they‚Äôre related to the "
"struct\n"
"fields or the method parameters and return values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:727
msgid ""
"Lifetime names for struct fields always need to be declared after the "
"`impl`\n"
"keyword and then used after the struct‚Äôs name, because those lifetimes are "
"part\n"
"of the struct‚Äôs type."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:731
msgid ""
"In method signatures inside the `impl` block, references might be tied to "
"the\n"
"lifetime of references in the struct‚Äôs fields, or they might be independent. "
"In\n"
"addition, the lifetime elision rules often make it so that lifetime "
"annotations\n"
"aren‚Äôt necessary in method signatures. Let‚Äôs look at some examples using "
"the\n"
"struct named `ImportantExcerpt` that we defined in Listing 10-24."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:737
msgid ""
"First, we‚Äôll use a method named `level` whose only parameter is a reference "
"to\n"
"`self` and whose return value is an `i32`, which is not a reference to "
"anything:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:740
msgid ""
"```rust\n"
"# struct ImportantExcerpt<'a> {\n"
"#     part: &'a str,\n"
"# }\n"
"# \n"
"impl<'a> ImportantExcerpt<'a> {\n"
"    fn level(&self) -> i32 {\n"
"        3\n"
"    }\n"
"}\n"
"# \n"
"# impl<'a> ImportantExcerpt<'a> {\n"
"#     fn announce_and_return_part(&self, announcement: &str) -> &str {\n"
"#         println!(\"Attention please: {}\", announcement);\n"
"#         self.part\n"
"#     }\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let novel = String::from(\"Call me Ishmael. Some years ago...\");\n"
"#     let first_sentence = novel.split('.').next().expect(\"Could not find a "
"'.'\");\n"
"#     let i = ImportantExcerpt {\n"
"#         part: first_sentence,\n"
"#     };\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:767
msgid ""
"The lifetime parameter declaration after `impl` and its use after the type "
"name\n"
"are required, but we‚Äôre not required to annotate the lifetime of the "
"reference\n"
"to `self` because of the first elision rule."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:771
msgid "Here is an example where the third lifetime elision rule applies:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:773
msgid ""
"```rust\n"
"# struct ImportantExcerpt<'a> {\n"
"#     part: &'a str,\n"
"# }\n"
"# \n"
"# impl<'a> ImportantExcerpt<'a> {\n"
"#     fn level(&self) -> i32 {\n"
"#         3\n"
"#     }\n"
"# }\n"
"# \n"
"impl<'a> ImportantExcerpt<'a> {\n"
"    fn announce_and_return_part(&self, announcement: &str) -> &str {\n"
"        println!(\"Attention please: {}\", announcement);\n"
"        self.part\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let novel = String::from(\"Call me Ishmael. Some years ago...\");\n"
"#     let first_sentence = novel.split('.').next().expect(\"Could not find a "
"'.'\");\n"
"#     let i = ImportantExcerpt {\n"
"#         part: first_sentence,\n"
"#     };\n"
"# }\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:800
msgid ""
"There are two input lifetimes, so Rust applies the first lifetime elision "
"rule\n"
"and gives both `&self` and `announcement` their own lifetimes. Then, "
"because\n"
"one of the parameters is `&self`, the return type gets the lifetime of "
"`&self`,\n"
"and all lifetimes have been accounted for."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:805
msgid "### The Static Lifetime"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:807
msgid ""
"One special lifetime we need to discuss is `'static`, which denotes that "
"the\n"
"affected reference *can* live for the entire duration of the program. All\n"
"string literals have the `'static` lifetime, which we can annotate as "
"follows:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:811
msgid ""
"```rust\n"
"let s: &'static str = \"I have a static lifetime.\";\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:815
msgid ""
"The text of this string is stored directly in the program‚Äôs binary, which\n"
"is always available. Therefore, the lifetime of all string literals is\n"
"`'static`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:819
msgid ""
"You might see suggestions to use the `'static` lifetime in error messages. "
"But\n"
"before specifying `'static` as the lifetime for a reference, think about\n"
"whether the reference you have actually lives the entire lifetime of your\n"
"program or not, and whether you want it to. Most of the time, an error "
"message\n"
"suggesting the `'static` lifetime results from attempting to create a "
"dangling\n"
"reference or a mismatch of the available lifetimes. In such cases, the "
"solution\n"
"is fixing those problems, not specifying the `'static` lifetime."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:827
msgid "## Generic Type Parameters, Trait Bounds, and Lifetimes Together"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:829
msgid ""
"Let‚Äôs briefly look at the syntax of specifying generic type parameters, "
"trait\n"
"bounds, and lifetimes all in one function!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:832
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let string1 = String::from(\"abcd\");\n"
"#     let string2 = \"xyz\";\n"
"# \n"
"#     let result = longest_with_an_announcement(\n"
"#         string1.as_str(),\n"
"#         string2,\n"
"#         \"Today is someone's birthday!\",\n"
"#     );\n"
"#     println!(\"The longest string is {}\", result);\n"
"# }\n"
"# \n"
"use std::fmt::Display;\n"
"\n"
"fn longest_with_an_announcement<'a, T>(\n"
"    x: &'a str,\n"
"    y: &'a str,\n"
"    ann: T,\n"
") -> &'a str\n"
"where\n"
"    T: Display,\n"
"{\n"
"    println!(\"Announcement! {}\", ann);\n"
"    if x.len() > y.len() {\n"
"        x\n"
"    } else {\n"
"        y\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:864
msgid ""
"This is the `longest` function from Listing 10-21 that returns the longer "
"of\n"
"two string slices. But now it has an extra parameter named `ann` of the "
"generic\n"
"type `T`, which can be filled in by any type that implements the `Display`\n"
"trait as specified by the `where` clause. This extra parameter will be "
"printed\n"
"using `{}`, which is why the `Display` trait bound is necessary. Because\n"
"lifetimes are a type of generic, the declarations of the lifetime parameter\n"
"`'a` and the generic type parameter `T` go in the same list inside the "
"angle\n"
"brackets after the function name."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:875
msgid ""
"We covered a lot in this chapter! Now that you know about generic type\n"
"parameters, traits and trait bounds, and generic lifetime parameters, "
"you‚Äôre\n"
"ready to write code without repetition that works in many different "
"situations.\n"
"Generic type parameters let you apply the code to different types. Traits "
"and\n"
"trait bounds ensure that even though the types are generic, they‚Äôll have "
"the\n"
"behavior the code needs. You learned how to use lifetime annotations to "
"ensure\n"
"that this flexible code won‚Äôt have any dangling references. And all of this\n"
"analysis happens at compile time, which doesn‚Äôt affect runtime performance!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:884
msgid ""
"Believe it or not, there is much more to learn on the topics we discussed "
"in\n"
"this chapter: Chapter 17 discusses trait objects, which are another way to "
"use\n"
"traits. There are also more complex scenarios involving lifetime "
"annotations\n"
"that you will only need in very advanced scenarios; for those, you should "
"read\n"
"the [Rust Reference][reference]. But next, you‚Äôll learn how to write tests "
"in\n"
"Rust so you can make sure your code is working the way it should."
msgstr ""

#: src/ch11-00-testing.md:1
msgid "# Writing Automated Tests"
msgstr ""

#: src/ch11-00-testing.md:3
msgid ""
"In his 1972 essay ‚ÄúThe Humble Programmer,‚Äù Edsger W. Dijkstra said that\n"
"‚ÄúProgram testing can be a very effective way to show the presence of bugs, "
"but\n"
"it is hopelessly inadequate for showing their absence.‚Äù That doesn‚Äôt mean "
"we\n"
"shouldn‚Äôt try to test as much as we can!"
msgstr ""

#: src/ch11-00-testing.md:8
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend\n"
"it to do. Rust is designed with a high degree of concern about the "
"correctness\n"
"of programs, but correctness is complex and not easy to prove. Rust‚Äôs type\n"
"system shoulders a huge part of this burden, but the type system cannot "
"catch\n"
"everything. As such, Rust includes support for writing automated software "
"tests."
msgstr ""

#: src/ch11-00-testing.md:14
msgid ""
"Say we write a function `add_two` that adds 2 to whatever number is passed "
"to\n"
"it. This function‚Äôs signature accepts an integer as a parameter and returns "
"an\n"
"integer as a result. When we implement and compile that function, Rust does "
"all\n"
"the type checking and borrow checking that you‚Äôve learned so far to ensure\n"
"that, for instance, we aren‚Äôt passing a `String` value or an invalid "
"reference\n"
"to this function. But Rust *can‚Äôt* check that this function will do "
"precisely\n"
"what we intend, which is return the parameter plus 2 rather than, say, the\n"
"parameter plus 10 or the parameter minus 50! That‚Äôs where tests come in."
msgstr ""

#: src/ch11-00-testing.md:23
msgid ""
"We can write tests that assert, for example, that when we pass `3` to the\n"
"`add_two` function, the returned value is `5`. We can run these tests "
"whenever\n"
"we make changes to our code to make sure any existing correct behavior has "
"not\n"
"changed."
msgstr ""

#: src/ch11-00-testing.md:28
msgid ""
"Testing is a complex skill: although we can‚Äôt cover every detail about how "
"to\n"
"write good tests in one chapter, we‚Äôll discuss the mechanics of Rust‚Äôs "
"testing\n"
"facilities. We‚Äôll talk about the annotations and macros available to you "
"when\n"
"writing your tests, the default behavior and options provided for running "
"your\n"
"tests, and how to organize tests into unit tests and integration tests."
msgstr ""

#: src/ch11-01-writing-tests.md:1
msgid "## How to Write Tests"
msgstr ""

#: src/ch11-01-writing-tests.md:3
msgid ""
"Tests are Rust functions that verify that the non-test code is functioning "
"in\n"
"the expected manner. The bodies of test functions typically perform these "
"three\n"
"actions:"
msgstr ""

#: src/ch11-01-writing-tests.md:7
msgid ""
"1. Set up any needed data or state.\n"
"2. Run the code you want to test.\n"
"3. Assert the results are what you expect."
msgstr ""

#: src/ch11-01-writing-tests.md:11
msgid ""
"Let‚Äôs look at the features Rust provides specifically for writing tests "
"that\n"
"take these actions, which include the `test` attribute, a few macros, and "
"the\n"
"`should_panic` attribute."
msgstr ""

#: src/ch11-01-writing-tests.md:15
msgid "### The Anatomy of a Test Function"
msgstr ""

#: src/ch11-01-writing-tests.md:17
msgid ""
"At its simplest, a test in Rust is a function that‚Äôs annotated with the "
"`test`\n"
"attribute. Attributes are metadata about pieces of Rust code; one example "
"is\n"
"the `derive` attribute we used with structs in Chapter 5. To change a "
"function\n"
"into a test function, add `#[test]` on the line before `fn`. When you run "
"your\n"
"tests with the `cargo test` command, Rust builds a test runner binary that "
"runs\n"
"the annotated functions and reports on whether each\n"
"test function passes or fails."
msgstr ""

#: src/ch11-01-writing-tests.md:25
msgid ""
"Whenever we make a new library project with Cargo, a test module with a "
"test\n"
"function in it is automatically generated for us. This module gives you a\n"
"template for writing your tests so you don‚Äôt have to look up the exact\n"
"structure and syntax every time you start a new project. You can add as "
"many\n"
"additional test functions and as many test modules as you want!"
msgstr ""

#: src/ch11-01-writing-tests.md:31
msgid ""
"We‚Äôll explore some aspects of how tests work by experimenting with the "
"template\n"
"test before we actually test any code. Then we‚Äôll write some real-world "
"tests\n"
"that call some code that we‚Äôve written and assert that its behavior is "
"correct."
msgstr ""

#: src/ch11-01-writing-tests.md:35
msgid ""
"Let‚Äôs create a new library project called `adder` that will add two numbers:"
msgstr ""

#: src/ch11-01-writing-tests.md:37
msgid ""
"```console\n"
"$ cargo new adder --lib\n"
"     Created library `adder` project\n"
"$ cd adder\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:43
msgid ""
"The contents of the *src/lib.rs* file in your `adder` library should look "
"like\n"
"Listing 11-1."
msgstr ""

#: src/ch11-01-writing-tests.md:48
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch11-writing-automated-tests\n"
"rm -rf listing-11-01\n"
"cargo new listing-11-01 --lib --name adder\n"
"cd listing-11-01\n"
"cargo test\n"
"git co output.txt\n"
"cd ../../..\n"
"-->"
msgstr ""

#: src/ch11-01-writing-tests.md:58 src/ch11-03-test-organization.md:40
msgid ""
"```rust,noplayground\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert_eq!(result, 4);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:69
msgid ""
"<span class=\"caption\">Listing 11-1: The test module and function "
"generated\n"
"automatically by `cargo new`</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:72
msgid ""
"For now, let‚Äôs ignore the top two lines and focus on the function. Note the\n"
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the\n"
"test runner knows to treat this function as a test. We might also have non-"
"test\n"
"functions in the `tests` module to help set up common scenarios or perform\n"
"common operations, so we always need to indicate which functions are tests."
msgstr ""

#: src/ch11-01-writing-tests.md:78
msgid ""
"The example function body uses the `assert_eq!` macro to assert that "
"`result`,\n"
"which contains the result of adding 2 and 2, equals 4. This assertion serves "
"as\n"
"an example of the format for a typical test. Let‚Äôs run it to see that this "
"test\n"
"passes."
msgstr ""

#: src/ch11-01-writing-tests.md:83
msgid ""
"The `cargo test` command runs all tests in our project, as shown in Listing\n"
"11-2."
msgstr ""

#: src/ch11-01-writing-tests.md:86
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.57s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:105
msgid ""
"<span class=\"caption\">Listing 11-2: The output from running the "
"automatically\n"
"generated test</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:108
msgid ""
"Cargo compiled and ran the test. We see the line `running 1 test`. The next\n"
"line shows the name of the generated test function, called `it_works`, and "
"that\n"
"the result of running that test is `ok`. The overall summary `test result: "
"ok.`\n"
"means that all the tests passed, and the portion that reads `1 passed; 0\n"
"failed` totals the number of tests that passed or failed."
msgstr ""

#: src/ch11-01-writing-tests.md:114
msgid ""
"It‚Äôs possible to mark a test as ignored so it doesn‚Äôt run in a particular\n"
"instance; we‚Äôll cover that in the [‚ÄúIgnoring Some Tests Unless Specifically\n"
"Requested‚Äù][ignoring]<!-- ignore --> section later in this chapter. Because "
"we\n"
"haven‚Äôt done that here, the summary shows `0 ignored`. We can also pass an\n"
"argument to the `cargo test` command to run only tests whose name matches a\n"
"string; this is called *filtering* and we‚Äôll cover that in the [‚ÄúRunning a\n"
"Subset of Tests by Name‚Äù][subset]<!-- ignore --> section. We also haven‚Äôt\n"
"filtered the tests being run, so the end of the summary shows `0 filtered "
"out`."
msgstr ""

#: src/ch11-01-writing-tests.md:123
msgid ""
"The `0 measured` statistic is for benchmark tests that measure performance.\n"
"Benchmark tests are, as of this writing, only available in nightly Rust. "
"See\n"
"[the documentation about benchmark tests][bench] to learn more."
msgstr ""

#: src/ch11-01-writing-tests.md:127
msgid ""
"The next part of the test output starting at `Doc-tests adder` is for the\n"
"results of any documentation tests. We don‚Äôt have any documentation tests "
"yet,\n"
"but Rust can compile any code examples that appear in our API "
"documentation.\n"
"This feature helps keep your docs and your code in sync! We‚Äôll discuss how "
"to\n"
"write documentation tests in the [‚ÄúDocumentation Comments as\n"
"Tests‚Äù][doc-comments]<!-- ignore --> section of Chapter 14. For now, we‚Äôll\n"
"ignore the `Doc-tests` output."
msgstr ""

#: src/ch11-01-writing-tests.md:135
msgid ""
"Let‚Äôs start to customize the test to our own needs. First change the name "
"of\n"
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""

#: src/ch11-01-writing-tests.md:140
msgid ""
"```rust,noplayground\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn exploration() {\n"
"        assert_eq!(2 + 2, 4);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:150
msgid ""
"Then run `cargo test` again. The output now shows `exploration` instead of\n"
"`it_works`:"
msgstr ""

#: src/ch11-01-writing-tests.md:153
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.59s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::exploration ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:172
msgid ""
"Now we‚Äôll add another test, but this time we‚Äôll make a test that fails! "
"Tests\n"
"fail when something in the test function panics. Each test is run in a new\n"
"thread, and when the main thread sees that a test thread has died, the test "
"is\n"
"marked as failed. In Chapter 9, we talked about how the simplest way to "
"panic\n"
"is to call the `panic!` macro. Enter the new test as a function named\n"
"`another`, so your *src/lib.rs* file looks like Listing 11-3."
msgstr ""

#: src/ch11-01-writing-tests.md:181
msgid ""
"```rust,panics,noplayground\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn exploration() {\n"
"        assert_eq!(2 + 2, 4);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn another() {\n"
"        panic!(\"Make this test fail\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:196
msgid ""
"<span class=\"caption\">Listing 11-3: Adding a second test that will fail "
"because\n"
"we call the `panic!` macro</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:199
msgid ""
"Run the tests again using `cargo test`. The output should look like Listing\n"
"11-4, which shows that our `exploration` test passed and `another` failed."
msgstr ""

#: src/ch11-01-writing-tests.md:202
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.72s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::another ... FAILED\n"
"test tests::exploration ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::another stdout ----\n"
"thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::another\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:227
msgid ""
"<span class=\"caption\">Listing 11-4: Test results when one test passes and "
"one\n"
"test fails</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:230
msgid ""
"Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new\n"
"sections appear between the individual results and the summary: the first\n"
"displays the detailed reason for each test failure. In this case, we get "
"the\n"
"details that `another` failed because it `panicked at 'Make this test fail'` "
"on\n"
"line 10 in the *src/lib.rs* file. The next section lists just the names of "
"all\n"
"the failing tests, which is useful when there are lots of tests and lots of\n"
"detailed failing test output. We can use the name of a failing test to run "
"just\n"
"that test to more easily debug it; we‚Äôll talk more about ways to run tests "
"in\n"
"the [‚ÄúControlling How Tests Are Run‚Äù][controlling-how-tests-are-run]<!-- "
"ignore\n"
"--> section."
msgstr ""

#: src/ch11-01-writing-tests.md:241
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We\n"
"had one test pass and one test fail."
msgstr ""

#: src/ch11-01-writing-tests.md:244
msgid ""
"Now that you‚Äôve seen what the test results look like in different "
"scenarios,\n"
"let‚Äôs look at some macros other than `panic!` that are useful in tests."
msgstr ""

#: src/ch11-01-writing-tests.md:247
msgid "### Checking Results with the `assert!` Macro"
msgstr ""

#: src/ch11-01-writing-tests.md:249
msgid ""
"The `assert!` macro, provided by the standard library, is useful when you "
"want\n"
"to ensure that some condition in a test evaluates to `true`. We give the\n"
"`assert!` macro an argument that evaluates to a Boolean. If the value is\n"
"`true`, nothing happens and the test passes. If the value is `false`, the\n"
"`assert!` macro calls `panic!` to cause the test to fail. Using the `assert!"
"`\n"
"macro helps us check that our code is functioning in the way we intend."
msgstr ""

#: src/ch11-01-writing-tests.md:256
msgid ""
"In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`\n"
"method, which are repeated here in Listing 11-5. Let‚Äôs put this code in the\n"
"*src/lib.rs* file, then write some tests for it using the `assert!` macro."
msgstr ""

#: src/ch11-01-writing-tests.md:262
msgid ""
"```rust,noplayground\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn can_hold(&self, other: &Rectangle) -> bool {\n"
"        self.width > other.width && self.height > other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:276
msgid ""
"<span class=\"caption\">Listing 11-5: Using the `Rectangle` struct and its\n"
"`can_hold` method from Chapter 5</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:279
msgid ""
"The `can_hold` method returns a Boolean, which means it‚Äôs a perfect use "
"case\n"
"for the `assert!` macro. In Listing 11-6, we write a test that exercises "
"the\n"
"`can_hold` method by creating a `Rectangle` instance that has a width of 8 "
"and\n"
"a height of 7 and asserting that it can hold another `Rectangle` instance "
"that\n"
"has a width of 5 and a height of 1."
msgstr ""

#: src/ch11-01-writing-tests.md:287
msgid ""
"```rust,noplayground\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"# impl Rectangle {\n"
"#     fn can_hold(&self, other: &Rectangle) -> bool {\n"
"#         self.width > other.width && self.height > other.height\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle {\n"
"            width: 8,\n"
"            height: 7,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            width: 5,\n"
"            height: 1,\n"
"        };\n"
"\n"
"        assert!(larger.can_hold(&smaller));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:320
msgid ""
"<span class=\"caption\">Listing 11-6: A test for `can_hold` that checks "
"whether a\n"
"larger rectangle can indeed hold a smaller rectangle</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:323
msgid ""
"Note that we‚Äôve added a new line inside the `tests` module: `use super::*;"
"`.\n"
"The `tests` module is a regular module that follows the usual visibility "
"rules\n"
"we covered in Chapter 7 in the [‚ÄúPaths for Referring to an Item in the "
"Module\n"
"Tree‚Äù][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -->\n"
"section. Because the `tests` module is an inner module, we need to bring "
"the\n"
"code under test in the outer module into the scope of the inner module. We "
"use\n"
"a glob here so anything we define in the outer module is available to this\n"
"`tests` module."
msgstr ""

#: src/ch11-01-writing-tests.md:332
msgid ""
"We‚Äôve named our test `larger_can_hold_smaller`, and we‚Äôve created the two\n"
"`Rectangle` instances that we need. Then we called the `assert!` macro and\n"
"passed it the result of calling `larger.can_hold(&smaller)`. This expression "
"is\n"
"supposed to return `true`, so our test should pass. Let‚Äôs find out!"
msgstr ""

#: src/ch11-01-writing-tests.md:337
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 1 test\n"
"test tests::larger_can_hold_smaller ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:356
msgid ""
"It does pass! Let‚Äôs add another test, this time asserting that a smaller\n"
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch11-01-writing-tests.md:361
msgid ""
"```rust,noplayground\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"# impl Rectangle {\n"
"#     fn can_hold(&self, other: &Rectangle) -> bool {\n"
"#         self.width > other.width && self.height > other.height\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        // --snip--\n"
"#         let larger = Rectangle {\n"
"#             width: 8,\n"
"#             height: 7,\n"
"#         };\n"
"#         let smaller = Rectangle {\n"
"#             width: 5,\n"
"#             height: 1,\n"
"#         };\n"
"# \n"
"#         assert!(larger.can_hold(&smaller));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle {\n"
"            width: 8,\n"
"            height: 7,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            width: 5,\n"
"            height: 1,\n"
"        };\n"
"\n"
"        assert!(!smaller.can_hold(&larger));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:409
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`,\n"
"we need to negate that result before we pass it to the `assert!` macro. As "
"a\n"
"result, our test will pass if `can_hold` returns `false`:"
msgstr ""

#: src/ch11-01-writing-tests.md:413
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... ok\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:433
msgid ""
"Two tests that pass! Now let‚Äôs see what happens to our test results when we\n"
"introduce a bug in our code. We‚Äôll change the implementation of the "
"`can_hold`\n"
"method by replacing the greater-than sign with a less-than sign when it\n"
"compares the widths:"
msgstr ""

#: src/ch11-01-writing-tests.md:438
msgid ""
"```rust,not_desired_behavior,noplayground\n"
"# #[derive(Debug)]\n"
"# struct Rectangle {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"# }\n"
"# \n"
"// --snip--\n"
"impl Rectangle {\n"
"    fn can_hold(&self, other: &Rectangle) -> bool {\n"
"        self.width < other.width && self.height > other.height\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn larger_can_hold_smaller() {\n"
"#         let larger = Rectangle {\n"
"#             width: 8,\n"
"#             height: 7,\n"
"#         };\n"
"#         let smaller = Rectangle {\n"
"#             width: 5,\n"
"#             height: 1,\n"
"#         };\n"
"# \n"
"#         assert!(larger.can_hold(&smaller));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn smaller_cannot_hold_larger() {\n"
"#         let larger = Rectangle {\n"
"#             width: 8,\n"
"#             height: 7,\n"
"#         };\n"
"#         let smaller = Rectangle {\n"
"#             width: 5,\n"
"#             height: 1,\n"
"#         };\n"
"# \n"
"#         assert!(!smaller.can_hold(&larger));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:486
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch11-01-writing-tests.md:488
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... FAILED\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::larger_can_hold_smaller stdout ----\n"
"thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: "
"larger.can_hold(&smaller)', src/lib.rs:28:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::larger_can_hold_smaller\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:513
msgid ""
"Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` "
"is\n"
"5, the comparison of the widths in `can_hold` now returns `false`: 8 is not\n"
"less than 5."
msgstr ""

#: src/ch11-01-writing-tests.md:517
msgid "### Testing Equality with the `assert_eq!` and `assert_ne!` Macros"
msgstr ""

#: src/ch11-01-writing-tests.md:519
msgid ""
"A common way to verify functionality is to test for equality between the "
"result\n"
"of the code under test and the value you expect the code to return. You "
"could\n"
"do this using the `assert!` macro and passing it an expression using the "
"`==`\n"
"operator. However, this is such a common test that the standard library\n"
"provides a pair of macros‚Äî`assert_eq!` and `assert_ne!`‚Äîto perform this "
"test\n"
"more conveniently. These macros compare two arguments for equality or\n"
"inequality, respectively. They‚Äôll also print the two values if the "
"assertion\n"
"fails, which makes it easier to see *why* the test failed; conversely, the\n"
"`assert!` macro only indicates that it got a `false` value for the `==`\n"
"expression, without printing the values that led to the `false` value."
msgstr ""

#: src/ch11-01-writing-tests.md:530
msgid ""
"In Listing 11-7, we write a function named `add_two` that adds `2` to its\n"
"parameter, then we test this function using the `assert_eq!` macro."
msgstr ""

#: src/ch11-01-writing-tests.md:535
msgid ""
"```rust,noplayground\n"
"pub fn add_two(a: i32) -> i32 {\n"
"    a + 2\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn it_adds_two() {\n"
"        assert_eq!(4, add_two(2));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:551
msgid ""
"<span class=\"caption\">Listing 11-7: Testing the function `add_two` using "
"the\n"
"`assert_eq!` macro</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:554
msgid "Let‚Äôs check that it passes!"
msgstr ""

#: src/ch11-01-writing-tests.md:556
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:575
msgid ""
"We pass `4` as the argument to `assert_eq!`, which is equal to the result "
"of\n"
"calling `add_two(2)`. The line for this test is `test tests::"
"it_adds_two ...\n"
"ok`, and the `ok` text indicates that our test passed!"
msgstr ""

#: src/ch11-01-writing-tests.md:579
msgid ""
"Let‚Äôs introduce a bug into our code to see what `assert_eq!` looks like when "
"it\n"
"fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""

#: src/ch11-01-writing-tests.md:582
msgid ""
"```rust,not_desired_behavior,noplayground\n"
"pub fn add_two(a: i32) -> i32 {\n"
"    a + 3\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn it_adds_two() {\n"
"#         assert_eq!(4, add_two(2));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:598
msgid "Run the tests again:"
msgstr ""

#: src/ch11-01-writing-tests.md:600
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::it_adds_two stdout ----\n"
"thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == "
"right)`\n"
"  left: `4`,\n"
" right: `5`', src/lib.rs:11:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::it_adds_two\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:626
msgid ""
"Our test caught the bug! The `it_adds_two` test failed, and the message "
"tells\n"
"us that the assertion that fails was `` assertion failed: `(left == right)` "
"``\n"
"and what the `left` and `right` values are. This message helps us start\n"
"debugging: the `left` argument was `4` but the `right` argument, where we "
"had\n"
"`add_two(2)`, was `5`. You can imagine that this would be especially "
"helpful\n"
"when we have a lot of tests going on."
msgstr ""

#: src/ch11-01-writing-tests.md:633
msgid ""
"Note that in some languages and test frameworks, the parameters to equality\n"
"assertion functions are called `expected` and `actual`, and the order in "
"which\n"
"we specify the arguments matters. However, in Rust, they‚Äôre called `left` "
"and\n"
"`right`, and the order in which we specify the value we expect and the "
"value\n"
"the code produces doesn‚Äôt matter. We could write the assertion in this test "
"as\n"
"`assert_eq!(add_two(2), 4)`, which would result in the same failure message\n"
"that displays `` assertion failed: `(left == right)` ``."
msgstr ""

#: src/ch11-01-writing-tests.md:641
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and\n"
"fail if they‚Äôre equal. This macro is most useful for cases when we‚Äôre not "
"sure\n"
"what a value *will* be, but we know what the value definitely *shouldn‚Äôt* "
"be.\n"
"For example, if we‚Äôre testing a function that is guaranteed to change its "
"input\n"
"in some way, but the way in which the input is changed depends on the day "
"of\n"
"the week that we run our tests, the best thing to assert might be that the\n"
"output of the function is not equal to the input."
msgstr ""

#: src/ch11-01-writing-tests.md:649
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators\n"
"`==` and `!=`, respectively. When the assertions fail, these macros print "
"their\n"
"arguments using debug formatting, which means the values being compared "
"must\n"
"implement the `PartialEq` and `Debug` traits. All primitive types and most "
"of\n"
"the standard library types implement these traits. For structs and enums "
"that\n"
"you define yourself, you‚Äôll need to implement `PartialEq` to assert equality "
"of\n"
"those types. You‚Äôll also need to implement `Debug` to print the values when "
"the\n"
"assertion fails. Because both traits are derivable traits, as mentioned in\n"
"Listing 5-12 in Chapter 5, this is usually as straightforward as adding the\n"
"`#[derive(PartialEq, Debug)]` annotation to your struct or enum definition. "
"See\n"
"Appendix C, [‚ÄúDerivable Traits,‚Äù][derivable-traits]<!-- ignore --> for more\n"
"details about these and other derivable traits."
msgstr ""

#: src/ch11-01-writing-tests.md:662
msgid "### Adding Custom Failure Messages"
msgstr ""

#: src/ch11-01-writing-tests.md:664
msgid ""
"You can also add a custom message to be printed with the failure message as\n"
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any\n"
"arguments specified after the required arguments are passed along to the\n"
"`format!` macro (discussed in Chapter 8 in the [‚ÄúConcatenation with the `+`\n"
"Operator or the `format!`\n"
"Macro‚Äù][concatenation-with-the--operator-or-the-format-macro]<!-- ignore --"
">\n"
"section), so you can pass a format string that contains `{}` placeholders "
"and\n"
"values to go in those placeholders. Custom messages are useful for "
"documenting\n"
"what an assertion means; when a test fails, you‚Äôll have a better idea of "
"what\n"
"the problem is with the code."
msgstr ""

#: src/ch11-01-writing-tests.md:675
msgid ""
"For example, let‚Äôs say we have a function that greets people by name and we\n"
"want to test that the name we pass into the function appears in the output:"
msgstr ""

#: src/ch11-01-writing-tests.md:680
msgid ""
"```rust,noplayground\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn greeting_contains_name() {\n"
"        let result = greeting(\"Carol\");\n"
"        assert!(result.contains(\"Carol\"));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:697
msgid ""
"The requirements for this program haven‚Äôt been agreed upon yet, and we‚Äôre\n"
"pretty sure the `Hello` text at the beginning of the greeting will change. "
"We\n"
"decided we don‚Äôt want to have to update the test when the requirements "
"change,\n"
"so instead of checking for exact equality to the value returned from the\n"
"`greeting` function, we‚Äôll just assert that the output contains the text of "
"the\n"
"input parameter."
msgstr ""

#: src/ch11-01-writing-tests.md:704
msgid ""
"Now let‚Äôs introduce a bug into this code by changing `greeting` to exclude\n"
"`name` to see what the default test failure looks like:"
msgstr ""

#: src/ch11-01-writing-tests.md:707
msgid ""
"```rust,not_desired_behavior,noplayground\n"
"pub fn greeting(name: &str) -> String {\n"
"    String::from(\"Hello!\")\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn greeting_contains_name() {\n"
"#         let result = greeting(\"Carol\");\n"
"#         assert!(result.contains(\"Carol\"));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:724
msgid "Running this test produces the following:"
msgstr ""

#: src/ch11-01-writing-tests.md:726
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"thread 'tests::greeting_contains_name' panicked at 'assertion failed: result."
"contains(\\\"Carol\\\")', src/lib.rs:12:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:750
msgid ""
"This result just indicates that the assertion failed and which line the\n"
"assertion is on. A more useful failure message would print the value from "
"the\n"
"`greeting` function. Let‚Äôs add a custom failure message composed of a "
"format\n"
"string with a placeholder filled in with the actual value we got from the\n"
"`greeting` function:"
msgstr ""

#: src/ch11-01-writing-tests.md:756
msgid ""
"```rust,ignore\n"
"# pub fn greeting(name: &str) -> String {\n"
"#     String::from(\"Hello!\")\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"    #[test]\n"
"    fn greeting_contains_name() {\n"
"        let result = greeting(\"Carol\");\n"
"        assert!(\n"
"            result.contains(\"Carol\"),\n"
"            \"Greeting did not contain name, value was `{}`\",\n"
"            result\n"
"        );\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:777
msgid "Now when we run the test, we‚Äôll get a more informative error message:"
msgstr ""

#: src/ch11-01-writing-tests.md:779
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.93s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain "
"name, value was `Hello!`', src/lib.rs:12:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:803
msgid ""
"We can see the value we actually got in the test output, which would help "
"us\n"
"debug what happened instead of what we were expecting to happen."
msgstr ""

#: src/ch11-01-writing-tests.md:806
msgid "### Checking for Panics with `should_panic`"
msgstr ""

#: src/ch11-01-writing-tests.md:808
msgid ""
"In addition to checking return values, it‚Äôs important to check that our "
"code\n"
"handles error conditions as we expect. For example, consider the `Guess` "
"type\n"
"that we created in Chapter 9, Listing 9-13. Other code that uses `Guess`\n"
"depends on the guarantee that `Guess` instances will contain only values\n"
"between 1 and 100. We can write a test that ensures that attempting to "
"create a\n"
"`Guess` instance with a value outside that range panics."
msgstr ""

#: src/ch11-01-writing-tests.md:815
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The\n"
"test passes if the code inside the function panics; the test fails if the "
"code\n"
"inside the function doesn‚Äôt panic."
msgstr ""

#: src/ch11-01-writing-tests.md:819
msgid ""
"Listing 11-8 shows a test that checks that the error conditions of `Guess::"
"new`\n"
"happen when we expect them to."
msgstr ""

#: src/ch11-01-writing-tests.md:824
msgid ""
"```rust,noplayground\n"
"pub struct Guess {\n"
"    value: i32,\n"
"}\n"
"\n"
"impl Guess {\n"
"    pub fn new(value: i32) -> Guess {\n"
"        if value < 1 || value > 100 {\n"
"            panic!(\"Guess value must be between 1 and 100, got {}.\", "
"value);\n"
"        }\n"
"\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        Guess::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:851
msgid ""
"<span class=\"caption\">Listing 11-8: Testing that a condition will cause a\n"
"`panic!`</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:854
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and\n"
"before the test function it applies to. Let‚Äôs look at the result when this "
"test\n"
"passes:"
msgstr ""

#: src/ch11-01-writing-tests.md:858
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests guessing_game\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:877
msgid ""
"Looks good! Now let‚Äôs introduce a bug in our code by removing the condition\n"
"that the `new` function will panic if the value is greater than 100:"
msgstr ""

#: src/ch11-01-writing-tests.md:880
msgid ""
"```rust,not_desired_behavior,noplayground\n"
"# pub struct Guess {\n"
"#     value: i32,\n"
"# }\n"
"# \n"
"// --snip--\n"
"impl Guess {\n"
"    pub fn new(value: i32) -> Guess {\n"
"        if value < 1 {\n"
"            panic!(\"Guess value must be between 1 and 100, got {}.\", "
"value);\n"
"        }\n"
"\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     #[should_panic]\n"
"#     fn greater_than_100() {\n"
"#         Guess::new(200);\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:908
msgid "When we run the test in Listing 11-8, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:910
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"note: test did not panic as expected\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:932
msgid ""
"We don‚Äôt get a very helpful message in this case, but when we look at the "
"test\n"
"function, we see that it‚Äôs annotated with `#[should_panic]`. The failure we "
"got\n"
"means that the code in the test function did not cause a panic."
msgstr ""

#: src/ch11-01-writing-tests.md:936
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would\n"
"pass even if the test panics for a different reason from the one we were\n"
"expecting. To make `should_panic` tests more precise, we can add an "
"optional\n"
"`expected` parameter to the `should_panic` attribute. The test harness will\n"
"make sure that the failure message contains the provided text. For example,\n"
"consider the modified code for `Guess` in Listing 11-9 where the `new` "
"function\n"
"panics with different messages depending on whether the value is too small "
"or\n"
"too large."
msgstr ""

#: src/ch11-01-writing-tests.md:947
msgid ""
"```rust,noplayground\n"
"# pub struct Guess {\n"
"#     value: i32,\n"
"# }\n"
"# \n"
"// --snip--\n"
"\n"
"impl Guess {\n"
"    pub fn new(value: i32) -> Guess {\n"
"        if value < 1 {\n"
"            panic!(\n"
"                \"Guess value must be greater than or equal to 1, got {}."
"\",\n"
"                value\n"
"            );\n"
"        } else if value > 100 {\n"
"            panic!(\n"
"                \"Guess value must be less than or equal to 100, got {}.\",\n"
"                value\n"
"            );\n"
"        }\n"
"\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected = \"less than or equal to 100\")]\n"
"    fn greater_than_100() {\n"
"        Guess::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:984
msgid ""
"<span class=\"caption\">Listing 11-9: Testing for a `panic!` with a panic "
"message\n"
"containing a specified substring</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:987
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute‚Äôs\n"
"`expected` parameter is a substring of the message that the `Guess::new`\n"
"function panics with. We could have specified the entire panic message that "
"we\n"
"expect, which in this case would be `Guess value must be less than or equal "
"to\n"
"100, got 200.` What you choose to specify depends on how much of the panic\n"
"message is unique or dynamic and how precise you want your test to be. In "
"this\n"
"case, a substring of the panic message is enough to ensure that the code in "
"the\n"
"test function executes the `else if value > 100` case."
msgstr ""

#: src/ch11-01-writing-tests.md:996
msgid ""
"To see what happens when a `should_panic` test with an `expected` message\n"
"fails, let‚Äôs again introduce a bug into our code by swapping the bodies of "
"the\n"
"`if value < 1` and the `else if value > 100` blocks:"
msgstr ""

#: src/ch11-01-writing-tests.md:1000
msgid ""
"```rust,ignore,not_desired_behavior\n"
"# pub struct Guess {\n"
"#     value: i32,\n"
"# }\n"
"# \n"
"# impl Guess {\n"
"#     pub fn new(value: i32) -> Guess {\n"
"        if value < 1 {\n"
"            panic!(\n"
"                \"Guess value must be less than or equal to 100, got {}.\",\n"
"                value\n"
"            );\n"
"        } else if value > 100 {\n"
"            panic!(\n"
"                \"Guess value must be greater than or equal to 1, got {}."
"\",\n"
"                value\n"
"            );\n"
"        }\n"
"# \n"
"#         Guess { value }\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     #[should_panic(expected = \"less than or equal to 100\")]\n"
"#     fn greater_than_100() {\n"
"#         Guess::new(200);\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:1035
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:1037
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"thread 'tests::greater_than_100' panicked at 'Guess value must be greater "
"than or equal to 1, got 200.', src/lib.rs:13:13\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"note: panic did not contain expected string\n"
"      panic message: `\"Guess value must be greater than or equal to 1, got "
"200.\"`,\n"
" expected substring: `\"less than or equal to 100\"`\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:1063
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected,\n"
"but the panic message did not include the expected string `'Guess value must "
"be\n"
"less than or equal to 100'`. The panic message that we did get in this case "
"was\n"
"`Guess value must be greater than or equal to 1, got 200.` Now we can start\n"
"figuring out where our bug is!"
msgstr ""

#: src/ch11-01-writing-tests.md:1069
msgid "### Using `Result<T, E>` in Tests"
msgstr ""

#: src/ch11-01-writing-tests.md:1071
msgid ""
"Our tests so far all panic when they fail. We can also write tests that use\n"
"`Result<T, E>`! Here‚Äôs the test from Listing 11-1, rewritten to use "
"`Result<T,\n"
"E>` and return an `Err` instead of panicking:"
msgstr ""

#: src/ch11-01-writing-tests.md:1075
msgid ""
"```rust,noplayground\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() -> Result<(), String> {\n"
"        if 2 + 2 == 4 {\n"
"            Ok(())\n"
"        } else {\n"
"            Err(String::from(\"two plus two does not equal four\"))\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:1089
msgid ""
"The `it_works` function now has the `Result<(), String>` return type. In "
"the\n"
"body of the function, rather than calling the `assert_eq!` macro, we return\n"
"`Ok(())` when the test passes and an `Err` with a `String` inside when the "
"test\n"
"fails."
msgstr ""

#: src/ch11-01-writing-tests.md:1094
msgid ""
"Writing tests so they return a `Result<T, E>` enables you to use the "
"question\n"
"mark operator in the body of tests, which can be a convenient way to write\n"
"tests that should fail if any operation within them returns an `Err` variant."
msgstr ""

#: src/ch11-01-writing-tests.md:1098
msgid ""
"You can‚Äôt use the `#[should_panic]` annotation on tests that use `Result<T,\n"
"E>`. To assert that an operation returns an `Err` variant, *don‚Äôt* use the\n"
"question mark operator on the `Result<T, E>` value. Instead, use\n"
"`assert!(value.is_err())`."
msgstr ""

#: src/ch11-01-writing-tests.md:1103
msgid ""
"Now that you know several ways to write tests, let‚Äôs look at what is "
"happening\n"
"when we run our tests and explore the different options we can use with "
"`cargo\n"
"test`."
msgstr ""

#: src/ch11-02-running-tests.md:1
msgid "## Controlling How Tests Are Run"
msgstr ""

#: src/ch11-02-running-tests.md:3
msgid ""
"Just as `cargo run` compiles your code and then runs the resulting binary,\n"
"`cargo test` compiles your code in test mode and runs the resulting test\n"
"binary. The default behavior of the binary produced by `cargo test` is to "
"run\n"
"all the tests in parallel and capture output generated during test runs,\n"
"preventing the output from being displayed and making it easier to read the\n"
"output related to the test results. You can, however, specify command line\n"
"options to change this default behavior."
msgstr ""

#: src/ch11-02-running-tests.md:11
msgid ""
"Some command line options go to `cargo test`, and some go to the resulting "
"test\n"
"binary. To separate these two types of arguments, you list the arguments "
"that\n"
"go to `cargo test` followed by the separator `--` and then the ones that go "
"to\n"
"the test binary. Running `cargo test --help` displays the options you can "
"use\n"
"with `cargo test`, and running `cargo test -- --help` displays the options "
"you\n"
"can use after the separator."
msgstr ""

#: src/ch11-02-running-tests.md:18
msgid "### Running Tests in Parallel or Consecutively"
msgstr ""

#: src/ch11-02-running-tests.md:20
msgid ""
"When you run multiple tests, by default they run in parallel using threads,\n"
"meaning they finish running faster and you get feedback quicker. Because "
"the\n"
"tests are running at the same time, you must make sure your tests don‚Äôt "
"depend\n"
"on each other or on any shared state, including a shared environment, such "
"as\n"
"the current working directory or environment variables."
msgstr ""

#: src/ch11-02-running-tests.md:26
msgid ""
"For example, say each of your tests runs some code that creates a file on "
"disk\n"
"named *test-output.txt* and writes some data to that file. Then each test "
"reads\n"
"the data in that file and asserts that the file contains a particular "
"value,\n"
"which is different in each test. Because the tests run at the same time, "
"one\n"
"test might overwrite the file in the time between another test writing and\n"
"reading the file. The second test will then fail, not because the code is\n"
"incorrect but because the tests have interfered with each other while "
"running\n"
"in parallel. One solution is to make sure each test writes to a different "
"file;\n"
"another solution is to run the tests one at a time."
msgstr ""

#: src/ch11-02-running-tests.md:36
msgid ""
"If you don‚Äôt want to run the tests in parallel or if you want more fine-"
"grained\n"
"control over the number of threads used, you can send the `--test-threads` "
"flag\n"
"and the number of threads you want to use to the test binary. Take a look "
"at\n"
"the following example:"
msgstr ""

#: src/ch11-02-running-tests.md:41
msgid ""
"```console\n"
"$ cargo test -- --test-threads=1\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:45
msgid ""
"We set the number of test threads to `1`, telling the program not to use "
"any\n"
"parallelism. Running the tests using one thread will take longer than "
"running\n"
"them in parallel, but the tests won‚Äôt interfere with each other if they "
"share\n"
"state."
msgstr ""

#: src/ch11-02-running-tests.md:50
msgid "### Showing Function Output"
msgstr ""

#: src/ch11-02-running-tests.md:52
msgid ""
"By default, if a test passes, Rust‚Äôs test library captures anything printed "
"to\n"
"standard output. For example, if we call `println!` in a test and the test\n"
"passes, we won‚Äôt see the `println!` output in the terminal; we‚Äôll see only "
"the\n"
"line that indicates the test passed. If a test fails, we‚Äôll see whatever "
"was\n"
"printed to standard output with the rest of the failure message."
msgstr ""

#: src/ch11-02-running-tests.md:58
msgid ""
"As an example, Listing 11-10 has a silly function that prints the value of "
"its\n"
"parameter and returns 10, as well as a test that passes and a test that "
"fails."
msgstr ""

#: src/ch11-02-running-tests.md:63
msgid ""
"```rust,panics,noplayground\n"
"fn prints_and_returns_10(a: i32) -> i32 {\n"
"    println!(\"I got the value {}\", a);\n"
"    10\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn this_test_will_pass() {\n"
"        let value = prints_and_returns_10(4);\n"
"        assert_eq!(10, value);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn this_test_will_fail() {\n"
"        let value = prints_and_returns_10(8);\n"
"        assert_eq!(5, value);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:87
msgid ""
"<span class=\"caption\">Listing 11-10: Tests for a function that calls\n"
"`println!`</span>"
msgstr ""

#: src/ch11-02-running-tests.md:90
msgid ""
"When we run these tests with `cargo test`, we‚Äôll see the following output:"
msgstr ""

#: src/ch11-02-running-tests.md:92
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"silly_function-160869f38cff9166)\n"
"\n"
"running 2 tests\n"
"test tests::this_test_will_fail ... FAILED\n"
"test tests::this_test_will_pass ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::this_test_will_fail stdout ----\n"
"I got the value 8\n"
"thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == "
"right)`\n"
"  left: `5`,\n"
" right: `10`', src/lib.rs:19:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::this_test_will_fail\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:120
msgid ""
"Note that nowhere in this output do we see `I got the value 4`, which is "
"what\n"
"is printed when the test that passes runs. That output has been captured. "
"The\n"
"output from the test that failed, `I got the value 8`, appears in the "
"section\n"
"of the test summary output, which also shows the cause of the test failure."
msgstr ""

#: src/ch11-02-running-tests.md:125
msgid ""
"If we want to see printed values for passing tests as well, we can tell "
"Rust\n"
"to also show the output of successful tests with `--show-output`."
msgstr ""

#: src/ch11-02-running-tests.md:128
msgid ""
"```console\n"
"$ cargo test -- --show-output\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:132
msgid ""
"When we run the tests in Listing 11-10 again with the `--show-output` flag, "
"we\n"
"see the following output:"
msgstr ""

#: src/ch11-02-running-tests.md:135
msgid ""
"```console\n"
"$ cargo test -- --show-output\n"
"   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"silly_function-160869f38cff9166)\n"
"\n"
"running 2 tests\n"
"test tests::this_test_will_fail ... FAILED\n"
"test tests::this_test_will_pass ... ok\n"
"\n"
"successes:\n"
"\n"
"---- tests::this_test_will_pass stdout ----\n"
"I got the value 4\n"
"\n"
"\n"
"successes:\n"
"    tests::this_test_will_pass\n"
"\n"
"failures:\n"
"\n"
"---- tests::this_test_will_fail stdout ----\n"
"I got the value 8\n"
"thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == "
"right)`\n"
"  left: `5`,\n"
" right: `10`', src/lib.rs:19:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::this_test_will_fail\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:172
msgid "### Running a Subset of Tests by Name"
msgstr ""

#: src/ch11-02-running-tests.md:174
msgid ""
"Sometimes, running a full test suite can take a long time. If you‚Äôre working "
"on\n"
"code in a particular area, you might want to run only the tests pertaining "
"to\n"
"that code. You can choose which tests to run by passing `cargo test` the "
"name\n"
"or names of the test(s) you want to run as an argument."
msgstr ""

#: src/ch11-02-running-tests.md:179
msgid ""
"To demonstrate how to run a subset of tests, we‚Äôll first create three tests "
"for\n"
"our `add_two` function, as shown in Listing 11-11, and choose which ones to "
"run."
msgstr ""

#: src/ch11-02-running-tests.md:184
msgid ""
"```rust,noplayground\n"
"pub fn add_two(a: i32) -> i32 {\n"
"    a + 2\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        assert_eq!(4, add_two(2));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        assert_eq!(5, add_two(3));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn one_hundred() {\n"
"        assert_eq!(102, add_two(100));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:210
msgid ""
"<span class=\"caption\">Listing 11-11: Three tests with three different\n"
"names</span>"
msgstr ""

#: src/ch11-02-running-tests.md:213
msgid ""
"If we run the tests without passing any arguments, as we saw earlier, all "
"the\n"
"tests will run in parallel:"
msgstr ""

#: src/ch11-02-running-tests.md:216
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 3 tests\n"
"test tests::add_three_and_two ... ok\n"
"test tests::add_two_and_two ... ok\n"
"test tests::one_hundred ... ok\n"
"\n"
"test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:237
msgid "#### Running Single Tests"
msgstr ""

#: src/ch11-02-running-tests.md:239
msgid ""
"We can pass the name of any test function to `cargo test` to run only that "
"test:"
msgstr ""

#: src/ch11-02-running-tests.md:241
msgid ""
"```console\n"
"$ cargo test one_hundred\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.69s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::one_hundred ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:254
msgid ""
"Only the test with the name `one_hundred` ran; the other two tests didn‚Äôt "
"match\n"
"that name. The test output lets us know we had more tests that didn‚Äôt run "
"by\n"
"displaying `2 filtered out` at the end."
msgstr ""

#: src/ch11-02-running-tests.md:258
msgid ""
"We can‚Äôt specify the names of multiple tests in this way; only the first "
"value\n"
"given to `cargo test` will be used. But there is a way to run multiple tests."
msgstr ""

#: src/ch11-02-running-tests.md:261
msgid "#### Filtering to Run Multiple Tests"
msgstr ""

#: src/ch11-02-running-tests.md:263
msgid ""
"We can specify part of a test name, and any test whose name matches that "
"value\n"
"will be run. For example, because two of our tests‚Äô names contain `add`, we "
"can\n"
"run those two by running `cargo test add`:"
msgstr ""

#: src/ch11-02-running-tests.md:267
msgid ""
"```console\n"
"$ cargo test add\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::add_three_and_two ... ok\n"
"test tests::add_two_and_two ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:281
msgid ""
"This command ran all tests with `add` in the name and filtered out the test\n"
"named `one_hundred`. Also note that the module in which a test appears "
"becomes\n"
"part of the test‚Äôs name, so we can run all the tests in a module by "
"filtering\n"
"on the module‚Äôs name."
msgstr ""

#: src/ch11-02-running-tests.md:286
msgid "### Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch11-02-running-tests.md:288
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so "
"you\n"
"might want to exclude them during most runs of `cargo test`. Rather than\n"
"listing as arguments all tests you do want to run, you can instead annotate "
"the\n"
"time-consuming tests using the `ignore` attribute to exclude them, as shown\n"
"here:"
msgstr ""

#: src/ch11-02-running-tests.md:296
msgid ""
"```rust,noplayground\n"
"#[test]\n"
"fn it_works() {\n"
"    assert_eq!(2 + 2, 4);\n"
"}\n"
"\n"
"#[test]\n"
"#[ignore]\n"
"fn expensive_test() {\n"
"    // code that takes an hour to run\n"
"}\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:309
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now\n"
"when we run our tests, `it_works` runs, but `expensive_test` doesn‚Äôt:"
msgstr ""

#: src/ch11-02-running-tests.md:312
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test expensive_test ... ignored\n"
"test it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:332
msgid ""
"The `expensive_test` function is listed as `ignored`. If we want to run "
"only\n"
"the ignored tests, we can use `cargo test -- --ignored`:"
msgstr ""

#: src/ch11-02-running-tests.md:335
msgid ""
"```console\n"
"$ cargo test -- --ignored\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test expensive_test ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:354
msgid ""
"By controlling which tests run, you can make sure your `cargo test` results\n"
"will be fast. When you‚Äôre at a point where it makes sense to check the "
"results\n"
"of the `ignored` tests and you have time to wait for the results, you can "
"run\n"
"`cargo test -- --ignored` instead. If you want to run all tests whether "
"they‚Äôre\n"
"ignored or not, you can run `cargo test -- --include-ignored`."
msgstr ""

#: src/ch11-03-test-organization.md:1
msgid "## Test Organization"
msgstr ""

#: src/ch11-03-test-organization.md:3
msgid ""
"As mentioned at the start of the chapter, testing is a complex discipline, "
"and\n"
"different people use different terminology and organization. The Rust "
"community\n"
"thinks about tests in terms of two main categories: unit tests and "
"integration\n"
"tests. *Unit tests* are small and more focused, testing one module in "
"isolation\n"
"at a time, and can test private interfaces. *Integration tests* are "
"entirely\n"
"external to your library and use your code in the same way any other "
"external\n"
"code would, using only the public interface and potentially exercising "
"multiple\n"
"modules per test."
msgstr ""

#: src/ch11-03-test-organization.md:12
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your\n"
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch11-03-test-organization.md:15
msgid "### Unit Tests"
msgstr ""

#: src/ch11-03-test-organization.md:17
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from "
"the\n"
"rest of the code to quickly pinpoint where code is and isn‚Äôt working as\n"
"expected. You‚Äôll put unit tests in the *src* directory in each file with "
"the\n"
"code that they‚Äôre testing. The convention is to create a module named "
"`tests`\n"
"in each file to contain the test functions and to annotate the module with\n"
"`cfg(test)`."
msgstr ""

#: src/ch11-03-test-organization.md:24
msgid "#### The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch11-03-test-organization.md:26
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Rust to compile and "
"run\n"
"the test code only when you run `cargo test`, not when you run `cargo "
"build`.\n"
"This saves compile time when you only want to build the library and saves "
"space\n"
"in the resulting compiled artifact because the tests are not included. "
"You‚Äôll\n"
"see that because integration tests go in a different directory, they don‚Äôt "
"need\n"
"the `#[cfg(test)]` annotation. However, because unit tests go in the same "
"files\n"
"as the code, you‚Äôll use `#[cfg(test)]` to specify that they shouldn‚Äôt be\n"
"included in the compiled result."
msgstr ""

#: src/ch11-03-test-organization.md:35
msgid ""
"Recall that when we generated the new `adder` project in the first section "
"of\n"
"this chapter, Cargo generated this code for us:"
msgstr ""

#: src/ch11-03-test-organization.md:51
msgid ""
"This code is the automatically generated test module. The attribute `cfg`\n"
"stands for *configuration* and tells Rust that the following item should "
"only\n"
"be included given a certain configuration option. In this case, the\n"
"configuration option is `test`, which is provided by Rust for compiling and\n"
"running tests. By using the `cfg` attribute, Cargo compiles our test code "
"only\n"
"if we actively run the tests with `cargo test`. This includes any helper\n"
"functions that might be within this module, in addition to the functions\n"
"annotated with `#[test]`."
msgstr ""

#: src/ch11-03-test-organization.md:60
msgid "#### Testing Private Functions"
msgstr ""

#: src/ch11-03-test-organization.md:62
msgid ""
"There‚Äôs debate within the testing community about whether or not private\n"
"functions should be tested directly, and other languages make it difficult "
"or\n"
"impossible to test private functions. Regardless of which testing ideology "
"you\n"
"adhere to, Rust‚Äôs privacy rules do allow you to test private functions.\n"
"Consider the code in Listing 11-12 with the private function "
"`internal_adder`."
msgstr ""

#: src/ch11-03-test-organization.md:70
msgid ""
"```rust,noplayground\n"
"pub fn add_two(a: i32) -> i32 {\n"
"    internal_adder(a, 2)\n"
"}\n"
"\n"
"fn internal_adder(a: i32, b: i32) -> i32 {\n"
"    a + b\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn internal() {\n"
"        assert_eq!(4, internal_adder(2, 2));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:90
msgid ""
"<span class=\"caption\">Listing 11-12: Testing a private function</span>"
msgstr ""

#: src/ch11-03-test-organization.md:92
msgid ""
"Note that the `internal_adder` function is not marked as `pub`. Tests are "
"just\n"
"Rust code, and the `tests` module is just another module. As we discussed "
"in\n"
"the [‚ÄúPaths for Referring to an Item in the Module Tree‚Äù][paths]<!-- ignore "
"-->\n"
"section, items in child modules can use the items in their ancestor modules. "
"In\n"
"this test, we bring all of the `test` module‚Äôs parent‚Äôs items into scope "
"with\n"
"`use super::*`, and then the test can call `internal_adder`. If you don‚Äôt "
"think\n"
"private functions should be tested, there‚Äôs nothing in Rust that will "
"compel\n"
"you to do so."
msgstr ""

#: src/ch11-03-test-organization.md:101
msgid "### Integration Tests"
msgstr ""

#: src/ch11-03-test-organization.md:103
msgid ""
"In Rust, integration tests are entirely external to your library. They use "
"your\n"
"library in the same way any other code would, which means they can only "
"call\n"
"functions that are part of your library‚Äôs public API. Their purpose is to "
"test\n"
"whether many parts of your library work together correctly. Units of code "
"that\n"
"work correctly on their own could have problems when integrated, so test\n"
"coverage of the integrated code is important as well. To create integration\n"
"tests, you first need a *tests* directory."
msgstr ""

#: src/ch11-03-test-organization.md:111
msgid "#### The *tests* Directory"
msgstr ""

#: src/ch11-03-test-organization.md:113
msgid ""
"We create a *tests* directory at the top level of our project directory, "
"next\n"
"to *src*. Cargo knows to look for integration test files in this directory. "
"We\n"
"can then make as many test files as we want, and Cargo will compile each of "
"the\n"
"files as an individual crate."
msgstr ""

#: src/ch11-03-test-organization.md:118
msgid ""
"Let‚Äôs create an integration test. With the code in Listing 11-12 still in "
"the\n"
"*src/lib.rs* file, make a *tests* directory, and create a new file named\n"
"*tests/integration_test.rs*. Your directory structure should look like this:"
msgstr ""

#: src/ch11-03-test-organization.md:122
msgid ""
"```text\n"
"adder\n"
"‚îú‚îÄ‚îÄ Cargo.lock\n"
"‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îú‚îÄ‚îÄ src\n"
"‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs\n"
"‚îî‚îÄ‚îÄ tests\n"
"    ‚îî‚îÄ‚îÄ integration_test.rs\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:132
msgid ""
"Enter the code in Listing 11-13 into the *tests/integration_test.rs* file:"
msgstr ""

#: src/ch11-03-test-organization.md:134 src/ch11-03-test-organization.md:315
msgid "<span class=\"filename\">Filename: tests/integration_test.rs</span>"
msgstr ""

#: src/ch11-03-test-organization.md:136
msgid ""
"```rust,ignore\n"
"use adder;\n"
"\n"
"#[test]\n"
"fn it_adds_two() {\n"
"    assert_eq!(4, adder::add_two(2));\n"
"}\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:145
msgid ""
"<span class=\"caption\">Listing 11-13: An integration test of a function in "
"the\n"
"`adder` crate</span>"
msgstr ""

#: src/ch11-03-test-organization.md:148
msgid ""
"Each file in the `tests` directory is a separate crate, so we need to bring "
"our\n"
"library into each test crate‚Äôs scope. For that reason we add `use adder` at "
"the\n"
"top of the code, which we didn‚Äôt need in the unit tests."
msgstr ""

#: src/ch11-03-test-organization.md:152
msgid ""
"We don‚Äôt need to annotate any code in *tests/integration_test.rs* with\n"
"`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles "
"files\n"
"in this directory only when we run `cargo test`. Run `cargo test` now:"
msgstr ""

#: src/ch11-03-test-organization.md:156
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 1.31s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-1082c4b063a8fbe6)\n"
"\n"
"running 1 test\n"
"test tests::internal ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-1082c4b063a8fbe6)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:182
msgid ""
"The three sections of output include the unit tests, the integration test, "
"and\n"
"the doc tests. Note that if any test in a section fails, the following "
"sections\n"
"will not be run. For example, if a unit test fails, there won‚Äôt be any "
"output\n"
"for integration and doc tests because those tests will only be run if all "
"unit\n"
"tests are passing."
msgstr ""

#: src/ch11-03-test-organization.md:188
msgid ""
"The first section for the unit tests is the same as we‚Äôve been seeing: one "
"line\n"
"for each unit test (one named `internal` that we added in Listing 11-12) "
"and\n"
"then a summary line for the unit tests."
msgstr ""

#: src/ch11-03-test-organization.md:192
msgid ""
"The integration tests section starts with the line `Running\n"
"tests/integration_test.rs`. Next, there is a line for each test function in\n"
"that integration test and a summary line for the results of the integration\n"
"test just before the `Doc-tests adder` section starts."
msgstr ""

#: src/ch11-03-test-organization.md:197
msgid ""
"Each integration test file has its own section, so if we add more files in "
"the\n"
"*tests* directory, there will be more integration test sections."
msgstr ""

#: src/ch11-03-test-organization.md:200
msgid ""
"We can still run a particular integration test function by specifying the "
"test\n"
"function‚Äôs name as an argument to `cargo test`. To run all the tests in a\n"
"particular integration test file, use the `--test` argument of `cargo test`\n"
"followed by the name of the file:"
msgstr ""

#: src/ch11-03-test-organization.md:205
msgid ""
"```console\n"
"$ cargo test --test integration_test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.64s\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-82e7799c1bc62298)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:218
msgid ""
"This command runs only the tests in the *tests/integration_test.rs* file."
msgstr ""

#: src/ch11-03-test-organization.md:220
msgid "#### Submodules in Integration Tests"
msgstr ""

#: src/ch11-03-test-organization.md:222
msgid ""
"As you add more integration tests, you might want to make more files in the\n"
"*tests* directory to help organize them; for example, you can group the "
"test\n"
"functions by the functionality they‚Äôre testing. As mentioned earlier, each "
"file\n"
"in the *tests* directory is compiled as its own separate crate, which is "
"useful\n"
"for creating separate scopes to more closely imitate the way end users will "
"be\n"
"using your crate. However, this means files in the *tests* directory don‚Äôt\n"
"share the same behavior as files in *src* do, as you learned in Chapter 7\n"
"regarding how to separate code into modules and files."
msgstr ""

#: src/ch11-03-test-organization.md:231
msgid ""
"The different behavior of *tests* directory files is most noticeable when "
"you\n"
"have a set of helper functions to use in multiple integration test files "
"and\n"
"you try to follow the steps in the [‚ÄúSeparating Modules into Different\n"
"Files‚Äù][separating-modules-into-files]<!-- ignore --> section of Chapter 7 "
"to\n"
"extract them into a common module. For example, if we create *tests/common."
"rs*\n"
"and place a function named `setup` in it, we can add some code to `setup` "
"that\n"
"we want to call from multiple test functions in multiple test files:"
msgstr ""

#: src/ch11-03-test-organization.md:239
msgid "<span class=\"filename\">Filename: tests/common.rs</span>"
msgstr ""

#: src/ch11-03-test-organization.md:241
msgid ""
"```rust,noplayground\n"
"pub fn setup() {\n"
"    // setup code specific to your library's tests would go here\n"
"}\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:247
msgid ""
"When we run the tests again, we‚Äôll see a new section in the test output for "
"the\n"
"*common.rs* file, even though this file doesn‚Äôt contain any test functions "
"nor\n"
"did we call the `setup` function from anywhere:"
msgstr ""

#: src/ch11-03-test-organization.md:251
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.89s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::internal ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:283
msgid ""
"Having `common` appear in the test results with `running 0 tests` displayed "
"for\n"
"it is not what we wanted. We just wanted to share some code with the other\n"
"integration test files."
msgstr ""

#: src/ch11-03-test-organization.md:287
msgid ""
"To avoid having `common` appear in the test output, instead of creating\n"
"*tests/common.rs*, we‚Äôll create *tests/common/mod.rs*. The project "
"directory\n"
"now looks like this:"
msgstr ""

#: src/ch11-03-test-organization.md:291
msgid ""
"```text\n"
"‚îú‚îÄ‚îÄ Cargo.lock\n"
"‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îú‚îÄ‚îÄ src\n"
"‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs\n"
"‚îî‚îÄ‚îÄ tests\n"
"    ‚îú‚îÄ‚îÄ common\n"
"    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs\n"
"    ‚îî‚îÄ‚îÄ integration_test.rs\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:302
msgid ""
"This is the older naming convention that Rust also understands that we\n"
"mentioned in the [‚ÄúAlternate File Paths‚Äù][alt-paths]<!-- ignore --> section "
"of\n"
"Chapter 7. Naming the file this way tells Rust not to treat the `common` "
"module\n"
"as an integration test file. When we move the `setup` function code into\n"
"*tests/common/mod.rs* and delete the *tests/common.rs* file, the section in "
"the\n"
"test output will no longer appear. Files in subdirectories of the *tests*\n"
"directory don‚Äôt get compiled as separate crates or have sections in the "
"test\n"
"output."
msgstr ""

#: src/ch11-03-test-organization.md:311
msgid ""
"After we‚Äôve created *tests/common/mod.rs*, we can use it from any of the\n"
"integration test files as a module. Here‚Äôs an example of calling the "
"`setup`\n"
"function from the `it_adds_two` test in *tests/integration_test.rs*:"
msgstr ""

#: src/ch11-03-test-organization.md:317
msgid ""
"```rust,ignore\n"
"use adder;\n"
"\n"
"mod common;\n"
"\n"
"#[test]\n"
"fn it_adds_two() {\n"
"    common::setup();\n"
"    assert_eq!(4, adder::add_two(2));\n"
"}\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:329
msgid ""
"Note that the `mod common;` declaration is the same as the module "
"declaration\n"
"we demonstrated in Listing 7-21. Then in the test function, we can call the\n"
"`common::setup()` function."
msgstr ""

#: src/ch11-03-test-organization.md:333
msgid "#### Integration Tests for Binary Crates"
msgstr ""

#: src/ch11-03-test-organization.md:335
msgid ""
"If our project is a binary crate that only contains a *src/main.rs* file "
"and\n"
"doesn‚Äôt have a *src/lib.rs* file, we can‚Äôt create integration tests in the\n"
"*tests* directory and bring functions defined in the *src/main.rs* file "
"into\n"
"scope with a `use` statement. Only library crates expose functions that "
"other\n"
"crates can use; binary crates are meant to be run on their own."
msgstr ""

#: src/ch11-03-test-organization.md:341
msgid ""
"This is one of the reasons Rust projects that provide a binary have a\n"
"straightforward *src/main.rs* file that calls logic that lives in the\n"
"*src/lib.rs* file. Using that structure, integration tests *can* test the\n"
"library crate with `use` to make the important functionality available.\n"
"If the important functionality works, the small amount of code in the\n"
"*src/main.rs* file will work as well, and that small amount of code doesn‚Äôt\n"
"need to be tested."
msgstr ""

#: src/ch11-03-test-organization.md:351
msgid ""
"Rust‚Äôs testing features provide a way to specify how code should function "
"to\n"
"ensure it continues to work as you expect, even as you make changes. Unit "
"tests\n"
"exercise different parts of a library separately and can test private\n"
"implementation details. Integration tests check that many parts of the "
"library\n"
"work together correctly, and they use the library‚Äôs public API to test the "
"code\n"
"in the same way external code will use it. Even though Rust‚Äôs type system "
"and\n"
"ownership rules help prevent some kinds of bugs, tests are still important "
"to\n"
"reduce logic bugs having to do with how your code is expected to behave."
msgstr ""

#: src/ch11-03-test-organization.md:360
msgid ""
"Let‚Äôs combine the knowledge you learned in this chapter and in previous\n"
"chapters to work on a project!"
msgstr ""

#: src/ch12-00-an-io-project.md:1
msgid "# An I/O Project: Building a Command Line Program"
msgstr ""

#: src/ch12-00-an-io-project.md:3
msgid ""
"This chapter is a recap of the many skills you‚Äôve learned so far and an\n"
"exploration of a few more standard library features. We‚Äôll build a command "
"line\n"
"tool that interacts with file and command line input/output to practice some "
"of\n"
"the Rust concepts you now have under your belt."
msgstr ""

#: src/ch12-00-an-io-project.md:8
msgid ""
"Rust‚Äôs speed, safety, single binary output, and cross-platform support make "
"it\n"
"an ideal language for creating command line tools, so for our project, "
"we‚Äôll\n"
"make our own version of the classic command line search tool `grep`\n"
"(**g**lobally search a **r**egular **e**xpression and **p**rint). In the\n"
"simplest use case, `grep` searches a specified file for a specified string. "
"To\n"
"do so, `grep` takes as its arguments a file path and a string. Then it "
"reads\n"
"the file, finds lines in that file that contain the string argument, and "
"prints\n"
"those lines."
msgstr ""

#: src/ch12-00-an-io-project.md:17
msgid ""
"Along the way, we‚Äôll show how to make our command line tool use the "
"terminal\n"
"features that many other command line tools use. We‚Äôll read the value of an\n"
"environment variable to allow the user to configure the behavior of our "
"tool.\n"
"We‚Äôll also print error messages to the standard error console stream "
"(`stderr`)\n"
"instead of standard output (`stdout`), so, for example, the user can "
"redirect\n"
"successful output to a file while still seeing error messages onscreen."
msgstr ""

#: src/ch12-00-an-io-project.md:24
msgid ""
"One Rust community member, Andrew Gallant, has already created a fully\n"
"featured, very fast version of `grep`, called `ripgrep`. By comparison, our\n"
"version will be fairly simple, but this chapter will give you some of the\n"
"background knowledge you need to understand a real-world project such as\n"
"`ripgrep`."
msgstr ""

#: src/ch12-00-an-io-project.md:30
msgid ""
"Our `grep` project will combine a number of concepts you‚Äôve learned so far:"
msgstr ""

#: src/ch12-00-an-io-project.md:32
msgid ""
"* Organizing code (using what you learned about modules in [Chapter 7]"
"[ch7]<!--\n"
"  ignore -->)\n"
"* Using vectors and strings (collections, [Chapter 8][ch8]<!-- ignore -->)\n"
"* Handling errors ([Chapter 9][ch9]<!-- ignore -->)\n"
"* Using traits and lifetimes where appropriate ([Chapter 10][ch10]<!-- "
"ignore\n"
"  -->)\n"
"* Writing tests ([Chapter 11][ch11]<!-- ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:40
msgid ""
"We‚Äôll also briefly introduce closures, iterators, and trait objects, which\n"
"Chapters [13][ch13]<!-- ignore --> and [17][ch17]<!-- ignore --> will cover "
"in\n"
"detail."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:1
msgid "## Accepting Command Line Arguments"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:3
msgid ""
"Let‚Äôs create a new project with, as always, `cargo new`. We‚Äôll call our "
"project\n"
"`minigrep` to distinguish it from the `grep` tool that you might already "
"have\n"
"on your system."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:7
msgid ""
"```console\n"
"$ cargo new minigrep\n"
"     Created binary (application) `minigrep` project\n"
"$ cd minigrep\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:13
msgid ""
"The first task is to make `minigrep` accept its two command line arguments: "
"the\n"
"file path and a string to search for. That is, we want to be able to run "
"our\n"
"program with `cargo run`, two hyphens to indicate the following arguments "
"are\n"
"for our program rather than for `cargo`, a string to search for, and a path "
"to\n"
"a file to search in, like so:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:19
msgid ""
"```console\n"
"$ cargo run -- searchstring example-filename.txt\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:23
msgid ""
"Right now, the program generated by `cargo new` cannot process arguments we\n"
"give it. Some existing libraries on [crates.io](https://crates.io/) can "
"help\n"
"with writing a program that accepts command line arguments, but because "
"you‚Äôre\n"
"just learning this concept, let‚Äôs implement this capability ourselves."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:28
msgid "### Reading the Argument Values"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:30
msgid ""
"To enable `minigrep` to read the values of command line arguments we pass "
"to\n"
"it, we‚Äôll need the `std::env::args` function provided in Rust‚Äôs standard\n"
"library. This function returns an iterator of the command line arguments "
"passed\n"
"to `minigrep`. We‚Äôll cover iterators fully in [Chapter 13][ch13]<!-- ignore\n"
"-->. For now, you only need to know two details about iterators: iterators\n"
"produce a series of values, and we can call the `collect` method on an "
"iterator\n"
"to turn it into a collection, such as a vector, that contains all the "
"elements\n"
"the iterator produces."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:39
msgid ""
"The code in Listing 12-1 allows your `minigrep` program to read any command\n"
"line arguments passed to it and then collect the values into a vector."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:44
msgid ""
"```rust\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"    dbg!(args);\n"
"}\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:53
msgid ""
"<span class=\"caption\">Listing 12-1: Collecting the command line arguments "
"into\n"
"a vector and printing them</span>"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:56
msgid ""
"First, we bring the `std::env` module into scope with a `use` statement so "
"we\n"
"can use its `args` function. Notice that the `std::env::args` function is\n"
"nested in two levels of modules. As we discussed in [Chapter\n"
"7][ch7-idiomatic-use]<!-- ignore -->, in cases where the desired function "
"is\n"
"nested in more than one module, we‚Äôve chosen to bring the parent module "
"into\n"
"scope rather than the function. By doing so, we can easily use other "
"functions\n"
"from `std::env`. It‚Äôs also less ambiguous than adding `use std::env::args` "
"and\n"
"then calling the function with just `args`, because `args` might easily be\n"
"mistaken for a function that‚Äôs defined in the current module."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:66
msgid ""
"> ### The `args` Function and Invalid Unicode\n"
">\n"
"> Note that `std::env::args` will panic if any argument contains invalid\n"
"> Unicode. If your program needs to accept arguments containing invalid\n"
"> Unicode, use `std::env::args_os` instead. That function returns an "
"iterator\n"
"> that produces `OsString` values instead of `String` values. We‚Äôve chosen "
"to\n"
"> use `std::env::args` here for simplicity, because `OsString` values "
"differ\n"
"> per platform and are more complex to work with than `String` values."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:75
msgid ""
"On the first line of `main`, we call `env::args`, and we immediately use\n"
"`collect` to turn the iterator into a vector containing all the values "
"produced\n"
"by the iterator. We can use the `collect` function to create many kinds of\n"
"collections, so we explicitly annotate the type of `args` to specify that "
"we\n"
"want a vector of strings. Although we very rarely need to annotate types in\n"
"Rust, `collect` is one function you do often need to annotate because Rust\n"
"isn‚Äôt able to infer the kind of collection you want."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:83
msgid ""
"Finally, we print the vector using the debug macro. Let‚Äôs try running the "
"code\n"
"first with no arguments and then with two arguments:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:86
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running `target/debug/minigrep`\n"
"[src/main.rs:5] args = [\n"
"    \"target/debug/minigrep\",\n"
"]\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:96
msgid ""
"```console\n"
"$ cargo run -- needle haystack\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.57s\n"
"     Running `target/debug/minigrep needle haystack`\n"
"[src/main.rs:5] args = [\n"
"    \"target/debug/minigrep\",\n"
"    \"needle\",\n"
"    \"haystack\",\n"
"]\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:108
msgid ""
"Notice that the first value in the vector is `\"target/debug/minigrep\"`, "
"which\n"
"is the name of our binary. This matches the behavior of the arguments list "
"in\n"
"C, letting programs use the name by which they were invoked in their "
"execution.\n"
"It‚Äôs often convenient to have access to the program name in case you want "
"to\n"
"print it in messages or change behavior of the program based on what "
"command\n"
"line alias was used to invoke the program. But for the purposes of this\n"
"chapter, we‚Äôll ignore it and save only the two arguments we need."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:116
msgid "### Saving the Argument Values in Variables"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:118
msgid ""
"The program is currently able to access the values specified as command "
"line\n"
"arguments. Now we need to save the values of the two arguments in variables "
"so\n"
"we can use the values throughout the rest of the program. We do that in "
"Listing\n"
"12-2."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:125
msgid ""
"```rust,should_panic,noplayground\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let query = &args[1];\n"
"    let file_path = &args[2];\n"
"\n"
"    println!(\"Searching for {}\", query);\n"
"    println!(\"In file {}\", file_path);\n"
"}\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:139
msgid ""
"<span class=\"caption\">Listing 12-2: Creating variables to hold the query\n"
"argument and file path argument</span>"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:142
msgid ""
"As we saw when we printed the vector, the program‚Äôs name takes up the first\n"
"value in the vector at `args[0]`, so we‚Äôre starting arguments at index `1`. "
"The\n"
"first argument `minigrep` takes is the string we‚Äôre searching for, so we put "
"a\n"
"reference to the first argument in the variable `query`. The second "
"argument\n"
"will be the file path, so we put a reference to the second argument in the\n"
"variable `file_path`."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:149
msgid ""
"We temporarily print the values of these variables to prove that the code "
"is\n"
"working as we intend. Let‚Äôs run this program again with the arguments "
"`test`\n"
"and `sample.txt`:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:153
msgid ""
"```console\n"
"$ cargo run -- test sample.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep test sample.txt`\n"
"Searching for test\n"
"In file sample.txt\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:162
msgid ""
"Great, the program is working! The values of the arguments we need are "
"being\n"
"saved into the right variables. Later we‚Äôll add some error handling to deal\n"
"with certain potential erroneous situations, such as when the user provides "
"no\n"
"arguments; for now, we‚Äôll ignore that situation and work on adding file-"
"reading\n"
"capabilities instead."
msgstr ""

#: src/ch12-02-reading-a-file.md:1
msgid "## Reading a File"
msgstr ""

#: src/ch12-02-reading-a-file.md:3
msgid ""
"Now we‚Äôll add functionality to read the file specified in the `file_path`\n"
"argument. First, we need a sample file to test it with: we‚Äôll use a file "
"with a\n"
"small amount of text over multiple lines with some repeated words. Listing "
"12-3\n"
"has an Emily Dickinson poem that will work well! Create a file called\n"
"*poem.txt* at the root level of your project, and enter the poem ‚ÄúI‚Äôm "
"Nobody!\n"
"Who are you?‚Äù"
msgstr ""

#: src/ch12-02-reading-a-file.md:10
msgid "<span class=\"filename\">Filename: poem.txt</span>"
msgstr ""

#: src/ch12-02-reading-a-file.md:12
msgid ""
"```text\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"Then there's a pair of us - don't tell!\n"
"They'd banish us, you know.\n"
"\n"
"How dreary to be somebody!\n"
"How public, like a frog\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"```"
msgstr ""

#: src/ch12-02-reading-a-file.md:24
msgid ""
"<span class=\"caption\">Listing 12-3: A poem by Emily Dickinson makes a good "
"test\n"
"case</span>"
msgstr ""

#: src/ch12-02-reading-a-file.md:27
msgid ""
"With the text in place, edit *src/main.rs* and add code to read the file, "
"as\n"
"shown in Listing 12-4."
msgstr ""

#: src/ch12-02-reading-a-file.md:32
msgid ""
"```rust,should_panic,noplayground\n"
"use std::env;\n"
"use std::fs;\n"
"\n"
"fn main() {\n"
"    // --snip--\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let query = &args[1];\n"
"#     let file_path = &args[2];\n"
"# \n"
"#     println!(\"Searching for {}\", query);\n"
"    println!(\"In file {}\", file_path);\n"
"\n"
"    let contents = fs::read_to_string(file_path)\n"
"        .expect(\"Should have been able to read the file\");\n"
"\n"
"    println!(\"With text:\\n{contents}\");\n"
"}\n"
"```"
msgstr ""

#: src/ch12-02-reading-a-file.md:53
msgid ""
"<span class=\"caption\">Listing 12-4: Reading the contents of the file "
"specified\n"
"by the second argument</span>"
msgstr ""

#: src/ch12-02-reading-a-file.md:56
msgid ""
"First, we bring in a relevant part of the standard library with a `use`\n"
"statement: we need `std::fs` to handle files."
msgstr ""

#: src/ch12-02-reading-a-file.md:59
msgid ""
"In `main`, the new statement `fs::read_to_string` takes the `file_path`, "
"opens\n"
"that file, and returns a `std::io::Result<String>` of the file‚Äôs contents."
msgstr ""

#: src/ch12-02-reading-a-file.md:62
msgid ""
"After that, we again add a temporary `println!` statement that prints the "
"value\n"
"of `contents` after the file is read, so we can check that the program is\n"
"working so far."
msgstr ""

#: src/ch12-02-reading-a-file.md:66
msgid ""
"Let‚Äôs run this code with any string as the first command line argument "
"(because\n"
"we haven‚Äôt implemented the searching part yet) and the *poem.txt* file as "
"the\n"
"second argument:"
msgstr ""

#: src/ch12-02-reading-a-file.md:70
msgid ""
"```console\n"
"$ cargo run -- the poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep the poem.txt`\n"
"Searching for the\n"
"In file poem.txt\n"
"With text:\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"Then there's a pair of us - don't tell!\n"
"They'd banish us, you know.\n"
"\n"
"How dreary to be somebody!\n"
"How public, like a frog\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"\n"
"```"
msgstr ""

#: src/ch12-02-reading-a-file.md:90
msgid ""
"Great! The code read and then printed the contents of the file. But the "
"code\n"
"has a few flaws. At the moment, the `main` function has multiple\n"
"responsibilities: generally, functions are clearer and easier to maintain "
"if\n"
"each function is responsible for only one idea. The other problem is that "
"we‚Äôre\n"
"not handling errors as well as we could. The program is still small, so "
"these\n"
"flaws aren‚Äôt a big problem, but as the program grows, it will be harder to "
"fix\n"
"them cleanly. It‚Äôs good practice to begin refactoring early on when "
"developing\n"
"a program, because it‚Äôs much easier to refactor smaller amounts of code. "
"We‚Äôll\n"
"do that next."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:1
msgid "## Refactoring to Improve Modularity and Error Handling"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:3
msgid ""
"To improve our program, we‚Äôll fix four problems that have to do with the\n"
"program‚Äôs structure and how it‚Äôs handling potential errors. First, our "
"`main`\n"
"function now performs two tasks: it parses arguments and reads files. As "
"our\n"
"program grows, the number of separate tasks the `main` function handles "
"will\n"
"increase. As a function gains responsibilities, it becomes more difficult "
"to\n"
"reason about, harder to test, and harder to change without breaking one of "
"its\n"
"parts. It‚Äôs best to separate functionality so each function is responsible "
"for\n"
"one task."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:12
msgid ""
"This issue also ties into the second problem: although `query` and "
"`file_path`\n"
"are configuration variables to our program, variables like `contents` are "
"used\n"
"to perform the program‚Äôs logic. The longer `main` becomes, the more "
"variables\n"
"we‚Äôll need to bring into scope; the more variables we have in scope, the "
"harder\n"
"it will be to keep track of the purpose of each. It‚Äôs best to group the\n"
"configuration variables into one structure to make their purpose clear."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:19
msgid ""
"The third problem is that we‚Äôve used `expect` to print an error message "
"when\n"
"reading the file fails, but the error message just prints `Should have been\n"
"able to read the file`. Reading a file can fail in a number of ways: for\n"
"example, the file could be missing, or we might not have permission to open "
"it.\n"
"Right now, regardless of the situation, we‚Äôd print the same error message "
"for\n"
"everything, which wouldn‚Äôt give the user any information!"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:26
msgid ""
"Fourth, we use `expect` repeatedly to handle different errors, and if the "
"user\n"
"runs our program without specifying enough arguments, they‚Äôll get an `index "
"out\n"
"of bounds` error from Rust that doesn‚Äôt clearly explain the problem. It "
"would\n"
"be best if all the error-handling code were in one place so future "
"maintainers\n"
"had only one place to consult the code if the error-handling logic needed "
"to\n"
"change. Having all the error-handling code in one place will also ensure "
"that\n"
"we‚Äôre printing messages that will be meaningful to our end users."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:34
msgid "Let‚Äôs address these four problems by refactoring our project."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:36
msgid "### Separation of Concerns for Binary Projects"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:38
msgid ""
"The organizational problem of allocating responsibility for multiple tasks "
"to\n"
"the `main` function is common to many binary projects. As a result, the "
"Rust\n"
"community has developed guidelines for splitting the separate concerns of a\n"
"binary program when `main` starts getting large. This process has the "
"following\n"
"steps:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:44
msgid ""
"* Split your program into a *main.rs* and a *lib.rs* and move your "
"program‚Äôs\n"
"  logic to *lib.rs*.\n"
"* As long as your command line parsing logic is small, it can remain in\n"
"  *main.rs*.\n"
"* When the command line parsing logic starts getting complicated, extract "
"it\n"
"  from *main.rs* and move it to *lib.rs*."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:51
msgid ""
"The responsibilities that remain in the `main` function after this process\n"
"should be limited to the following:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:54
msgid ""
"* Calling the command line parsing logic with the argument values\n"
"* Setting up any other configuration\n"
"* Calling a `run` function in *lib.rs*\n"
"* Handling the error if `run` returns an error"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:59
msgid ""
"This pattern is about separating concerns: *main.rs* handles running the\n"
"program, and *lib.rs* handles all the logic of the task at hand. Because "
"you\n"
"can‚Äôt test the `main` function directly, this structure lets you test all "
"of\n"
"your program‚Äôs logic by moving it into functions in *lib.rs*. The code that\n"
"remains in *main.rs* will be small enough to verify its correctness by "
"reading\n"
"it. Let‚Äôs rework our program by following this process."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:66
msgid "#### Extracting the Argument Parser"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:68
msgid ""
"We‚Äôll extract the functionality for parsing arguments into a function that\n"
"`main` will call to prepare for moving the command line parsing logic to\n"
"*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new\n"
"function `parse_config`, which we‚Äôll define in *src/main.rs* for the moment."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:75
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::fs;\n"
"# \n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let (query, file_path) = parse_config(&args);\n"
"\n"
"    // --snip--\n"
"# \n"
"#     println!(\"Searching for {}\", query);\n"
"#     println!(\"In file {}\", file_path);\n"
"# \n"
"#     let contents = fs::read_to_string(file_path)\n"
"#         .expect(\"Should have been able to read the file\");\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"}\n"
"\n"
"fn parse_config(args: &[String]) -> (&str, &str) {\n"
"    let query = &args[1];\n"
"    let file_path = &args[2];\n"
"\n"
"    (query, file_path)\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:103
msgid ""
"<span class=\"caption\">Listing 12-5: Extracting a `parse_config` function "
"from\n"
"`main`</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:106
msgid ""
"We‚Äôre still collecting the command line arguments into a vector, but instead "
"of\n"
"assigning the argument value at index 1 to the variable `query` and the\n"
"argument value at index 2 to the variable `file_path` within the `main`\n"
"function, we pass the whole vector to the `parse_config` function. The\n"
"`parse_config` function then holds the logic that determines which argument\n"
"goes in which variable and passes the values back to `main`. We still "
"create\n"
"the `query` and `file_path` variables in `main`, but `main` no longer has "
"the\n"
"responsibility of determining how the command line arguments and variables\n"
"correspond."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:116
msgid ""
"This rework may seem like overkill for our small program, but we‚Äôre "
"refactoring\n"
"in small, incremental steps. After making this change, run the program again "
"to\n"
"verify that the argument parsing still works. It‚Äôs good to check your "
"progress\n"
"often, to help identify the cause of problems when they occur."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:121
msgid "#### Grouping Configuration Values"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:123
msgid ""
"We can take another small step to improve the `parse_config` function "
"further.\n"
"At the moment, we‚Äôre returning a tuple, but then we immediately break that\n"
"tuple into individual parts again. This is a sign that perhaps we don‚Äôt "
"have\n"
"the right abstraction yet."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:128
msgid ""
"Another indicator that shows there‚Äôs room for improvement is the `config` "
"part\n"
"of `parse_config`, which implies that the two values we return are related "
"and\n"
"are both part of one configuration value. We‚Äôre not currently conveying "
"this\n"
"meaning in the structure of the data other than by grouping the two values "
"into\n"
"a tuple; we‚Äôll instead put the two values into one struct and give each of "
"the\n"
"struct fields a meaningful name. Doing so will make it easier for future\n"
"maintainers of this code to understand how the different values relate to "
"each\n"
"other and what their purpose is."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:137
msgid "Listing 12-6 shows the improvements to the `parse_config` function."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:141
msgid ""
"```rust,should_panic,noplayground\n"
"# use std::env;\n"
"# use std::fs;\n"
"# \n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let config = parse_config(&args);\n"
"\n"
"    println!(\"Searching for {}\", config.query);\n"
"    println!(\"In file {}\", config.file_path);\n"
"\n"
"    let contents = fs::read_to_string(config.file_path)\n"
"        .expect(\"Should have been able to read the file\");\n"
"\n"
"    // --snip--\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"}\n"
"\n"
"struct Config {\n"
"    query: String,\n"
"    file_path: String,\n"
"}\n"
"\n"
"fn parse_config(args: &[String]) -> Config {\n"
"    let query = args[1].clone();\n"
"    let file_path = args[2].clone();\n"
"\n"
"    Config { query, file_path }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:174
msgid ""
"<span class=\"caption\">Listing 12-6: Refactoring `parse_config` to return "
"an\n"
"instance of a `Config` struct</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:177
msgid ""
"We‚Äôve added a struct named `Config` defined to have fields named `query` "
"and\n"
"`file_path`. The signature of `parse_config` now indicates that it returns "
"a\n"
"`Config` value. In the body of `parse_config`, where we used to return\n"
"string slices that reference `String` values in `args`, we now define "
"`Config`\n"
"to contain owned `String` values. The `args` variable in `main` is the owner "
"of\n"
"the argument values and is only letting the `parse_config` function borrow\n"
"them, which means we‚Äôd violate Rust‚Äôs borrowing rules if `Config` tried to "
"take\n"
"ownership of the values in `args`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:186
msgid ""
"There are a number of ways we could manage the `String` data; the easiest,\n"
"though somewhat inefficient, route is to call the `clone` method on the "
"values.\n"
"This will make a full copy of the data for the `Config` instance to own, "
"which\n"
"takes more time and memory than storing a reference to the string data.\n"
"However, cloning the data also makes our code very straightforward because "
"we\n"
"don‚Äôt have to manage the lifetimes of the references; in this circumstance,\n"
"giving up a little performance to gain simplicity is a worthwhile trade-off."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:194
msgid ""
"> ### The Trade-Offs of Using `clone`\n"
">\n"
"> There‚Äôs a tendency among many Rustaceans to avoid using `clone` to fix\n"
"> ownership problems because of its runtime cost. In\n"
"> [Chapter 13][ch13]<!-- ignore -->, you‚Äôll learn how to use more efficient\n"
"> methods in this type of situation. But for now, it‚Äôs okay to copy a few\n"
"> strings to continue making progress because you‚Äôll make these copies only\n"
"> once and your file path and query string are very small. It‚Äôs better to "
"have\n"
"> a working program that‚Äôs a bit inefficient than to try to hyperoptimize "
"code\n"
"> on your first pass. As you become more experienced with Rust, it‚Äôll be\n"
"> easier to start with the most efficient solution, but for now, it‚Äôs\n"
"> perfectly acceptable to call `clone`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:207
msgid ""
"We‚Äôve updated `main` so it places the instance of `Config` returned by\n"
"`parse_config` into a variable named `config`, and we updated the code that\n"
"previously used the separate `query` and `file_path` variables so it now "
"uses\n"
"the fields on the `Config` struct instead."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:212
msgid ""
"Now our code more clearly conveys that `query` and `file_path` are related "
"and\n"
"that their purpose is to configure how the program will work. Any code that\n"
"uses these values knows to find them in the `config` instance in the fields\n"
"named for their purpose."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:217
msgid "#### Creating a Constructor for `Config`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:219
msgid ""
"So far, we‚Äôve extracted the logic responsible for parsing the command line\n"
"arguments from `main` and placed it in the `parse_config` function. Doing "
"so\n"
"helped us to see that the `query` and `file_path` values were related and "
"that\n"
"relationship should be conveyed in our code. We then added a `Config` struct "
"to\n"
"name the related purpose of `query` and `file_path` and to be able to return "
"the\n"
"values‚Äô names as struct field names from the `parse_config` function."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:226
msgid ""
"So now that the purpose of the `parse_config` function is to create a "
"`Config`\n"
"instance, we can change `parse_config` from a plain function to a function\n"
"named `new` that is associated with the `Config` struct. Making this change\n"
"will make the code more idiomatic. We can create instances of types in the\n"
"standard library, such as `String`, by calling `String::new`. Similarly, by\n"
"changing `parse_config` into a `new` function associated with `Config`, "
"we‚Äôll\n"
"be able to create instances of `Config` by calling `Config::new`. Listing "
"12-7\n"
"shows the changes we need to make."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:237
msgid ""
"```rust,should_panic,noplayground\n"
"# use std::env;\n"
"# use std::fs;\n"
"# \n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let config = Config::new(&args);\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"#     let contents = fs::read_to_string(config.file_path)\n"
"#         .expect(\"Should have been able to read the file\");\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"\n"
"    // --snip--\n"
"}\n"
"\n"
"// --snip--\n"
"\n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    fn new(args: &[String]) -> Config {\n"
"        let query = args[1].clone();\n"
"        let file_path = args[2].clone();\n"
"\n"
"        Config { query, file_path }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:274
msgid ""
"<span class=\"caption\">Listing 12-7: Changing `parse_config` into\n"
"`Config::new`</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:277
msgid ""
"We‚Äôve updated `main` where we were calling `parse_config` to instead call\n"
"`Config::new`. We‚Äôve changed the name of `parse_config` to `new` and moved "
"it\n"
"within an `impl` block, which associates the `new` function with `Config`. "
"Try\n"
"compiling this code again to make sure it works."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:282
msgid "### Fixing the Error Handling"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:284
msgid ""
"Now we‚Äôll work on fixing our error handling. Recall that attempting to "
"access\n"
"the values in the `args` vector at index 1 or index 2 will cause the program "
"to\n"
"panic if the vector contains fewer than three items. Try running the "
"program\n"
"without any arguments; it will look like this:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:289
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep`\n"
"thread 'main' panicked at 'index out of bounds: the len is 1 but the index "
"is 1', src/main.rs:27:21\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:298
msgid ""
"The line `index out of bounds: the len is 1 but the index is 1` is an error\n"
"message intended for programmers. It won‚Äôt help our end users understand "
"what\n"
"they should do instead. Let‚Äôs fix that now."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:302
msgid "#### Improving the Error Message"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:304
msgid ""
"In Listing 12-8, we add a check in the `new` function that will verify that "
"the\n"
"slice is long enough before accessing index 1 and 2. If the slice isn‚Äôt "
"long\n"
"enough, the program panics and displays a better error message."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:310
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::fs;\n"
"# \n"
"# fn main() {\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::new(&args);\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"#     let contents = fs::read_to_string(config.file_path)\n"
"#         .expect(\"Should have been able to read the file\");\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"# }\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"    // --snip--\n"
"    fn new(args: &[String]) -> Config {\n"
"        if args.len() < 3 {\n"
"            panic!(\"not enough arguments\");\n"
"        }\n"
"        // --snip--\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Config { query, file_path }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:349
msgid ""
"<span class=\"caption\">Listing 12-8: Adding a check for the number of\n"
"arguments</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:352
msgid ""
"This code is similar to [the `Guess::new` function we wrote in Listing\n"
"9-13][ch9-custom-types]<!-- ignore -->, where we called `panic!` when the\n"
"`value` argument was out of the range of valid values. Instead of checking "
"for\n"
"a range of values here, we‚Äôre checking that the length of `args` is at least "
"3\n"
"and the rest of the function can operate under the assumption that this\n"
"condition has been met. If `args` has fewer than three items, this "
"condition\n"
"will be true, and we call the `panic!` macro to end the program immediately."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:360
msgid ""
"With these extra few lines of code in `new`, let‚Äôs run the program without "
"any\n"
"arguments again to see what the error looks like now:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:363
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep`\n"
"thread 'main' panicked at 'not enough arguments', src/main.rs:26:13\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:372
msgid ""
"This output is better: we now have a reasonable error message. However, we "
"also\n"
"have extraneous information we don‚Äôt want to give to our users. Perhaps "
"using\n"
"the technique we used in Listing 9-13 isn‚Äôt the best to use here: a call to\n"
"`panic!` is more appropriate for a programming problem than a usage "
"problem,\n"
"[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -->. Instead,\n"
"we‚Äôll use the other technique you learned about in Chapter 9‚Äî[returning a\n"
"`Result`][ch9-result]<!-- ignore --> that indicates either success or an "
"error."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:381
msgid "<a id=\"returning-a-result-from-new-instead-of-calling-panic\"></a>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:383
msgid "#### Returning a `Result` Instead of Calling `panic!`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:385
msgid ""
"We can instead return a `Result` value that will contain a `Config` instance "
"in\n"
"the successful case and will describe the problem in the error case. We‚Äôre "
"also\n"
"going to change the function name from `new` to `build` because many\n"
"programmers expect `new` functions to never fail. When `Config::build` is\n"
"communicating to `main`, we can use the `Result` type to signal there was a\n"
"problem. Then we can change `main` to convert an `Err` variant into a more\n"
"practical error for our users without the surrounding text about `thread\n"
"'main'` and `RUST_BACKTRACE` that a call to `panic!` causes."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:394
msgid ""
"Listing 12-9 shows the changes we need to make to the return value of the\n"
"function we‚Äôre now calling `Config::build` and the body of the function "
"needed\n"
"to return a `Result`. Note that this won‚Äôt compile until we update `main` "
"as\n"
"well, which we‚Äôll do in the next listing."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:401
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::env;\n"
"# use std::fs;\n"
"# \n"
"# fn main() {\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::new(&args);\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"#     let contents = fs::read_to_string(config.file_path)\n"
"#         .expect(\"Should have been able to read the file\");\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"# }\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"        if args.len() < 3 {\n"
"            return Err(\"not enough arguments\");\n"
"        }\n"
"\n"
"        let query = args[1].clone();\n"
"        let file_path = args[2].clone();\n"
"\n"
"        Ok(Config { query, file_path })\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:438
msgid ""
"<span class=\"caption\">Listing 12-9: Returning a `Result` from\n"
"`Config::build`</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:441
msgid ""
"Our `build` function returns a `Result` with a `Config` instance in the "
"success\n"
"case and a `&'static str` in the error case. Our error values will always "
"be\n"
"string literals that have the `'static` lifetime."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:445
msgid ""
"We‚Äôve made two changes in the body of the function: instead of calling "
"`panic!`\n"
"when the user doesn‚Äôt pass enough arguments, we now return an `Err` value, "
"and\n"
"we‚Äôve wrapped the `Config` return value in an `Ok`. These changes make the\n"
"function conform to its new type signature."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:450
msgid ""
"Returning an `Err` value from `Config::build` allows the `main` function to\n"
"handle the `Result` value returned from the `build` function and exit the\n"
"process more cleanly in the error case."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:455
msgid "<a id=\"calling-confignew-and-handling-errors\"></a>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:457
msgid "#### Calling `Config::build` and Handling Errors"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:459
msgid ""
"To handle the error case and print a user-friendly message, we need to "
"update\n"
"`main` to handle the `Result` being returned by `Config::build`, as shown "
"in\n"
"Listing 12-10. We‚Äôll also take the responsibility of exiting the command "
"line\n"
"tool with a nonzero error code away from `panic!` and instead implement it "
"by\n"
"hand. A nonzero exit status is a convention to signal to the process that\n"
"called our program that the program exited with an error state."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:468
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::fs;\n"
"use std::process;\n"
"\n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let config = Config::build(&args).unwrap_or_else(|err| {\n"
"        println!(\"Problem parsing arguments: {err}\");\n"
"        process::exit(1);\n"
"    });\n"
"\n"
"    // --snip--\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"#     let contents = fs::read_to_string(config.file_path)\n"
"#         .expect(\"Should have been able to read the file\");\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"# }\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:511
msgid ""
"<span class=\"caption\">Listing 12-10: Exiting with an error code if "
"building a\n"
"`Config` fails</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:514
msgid ""
"In this listing, we‚Äôve used a method we haven‚Äôt covered in detail yet:\n"
"`unwrap_or_else`, which is defined on `Result<T, E>` by the standard "
"library.\n"
"Using `unwrap_or_else` allows us to define some custom, non-`panic!` error\n"
"handling. If the `Result` is an `Ok` value, this method‚Äôs behavior is "
"similar\n"
"to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the "
"value\n"
"is an `Err` value, this method calls the code in the *closure*, which is an\n"
"anonymous function we define and pass as an argument to `unwrap_or_else`. "
"We‚Äôll\n"
"cover closures in more detail in [Chapter 13][ch13]<!-- ignore -->. For "
"now,\n"
"you just need to know that `unwrap_or_else` will pass the inner value of "
"the\n"
"`Err`, which in this case is the static string `\"not enough arguments\"` "
"that we\n"
"added in Listing 12-9, to our closure in the argument `err` that appears\n"
"between the vertical pipes. The code in the closure can then use the `err`\n"
"value when it runs."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:528
msgid ""
"We‚Äôve added a new `use` line to bring `process` from the standard library "
"into\n"
"scope. The code in the closure that will be run in the error case is only "
"two\n"
"lines: we print the `err` value and then call `process::exit`. The\n"
"`process::exit` function will stop the program immediately and return the\n"
"number that was passed as the exit status code. This is similar to the\n"
"`panic!`-based handling we used in Listing 12-8, but we no longer get all "
"the\n"
"extra output. Let‚Äôs try it:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:536
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/minigrep`\n"
"Problem parsing arguments: not enough arguments\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:544
msgid "Great! This output is much friendlier for our users."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:546
msgid "### Extracting Logic from `main`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:548
msgid ""
"Now that we‚Äôve finished refactoring the configuration parsing, let‚Äôs turn "
"to\n"
"the program‚Äôs logic. As we stated in [‚ÄúSeparation of Concerns for Binary\n"
"Projects‚Äù](#separation-of-concerns-for-binary-projects)<!-- ignore -->, "
"we‚Äôll\n"
"extract a function named `run` that will hold all the logic currently in "
"the\n"
"`main` function that isn‚Äôt involved with setting up configuration or "
"handling\n"
"errors. When we‚Äôre done, `main` will be concise and easy to verify by\n"
"inspection, and we‚Äôll be able to write tests for all the other logic."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:556
msgid ""
"Listing 12-11 shows the extracted `run` function. For now, we‚Äôre just "
"making\n"
"the small, incremental improvement of extracting the function. We‚Äôre still\n"
"defining the function in *src/main.rs*."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:562
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::fs;\n"
"# use std::process;\n"
"# \n"
"fn main() {\n"
"    // --snip--\n"
"\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::build(&args).unwrap_or_else(|err| {\n"
"#         println!(\"Problem parsing arguments: {err}\");\n"
"#         process::exit(1);\n"
"#     });\n"
"# \n"
"    println!(\"Searching for {}\", config.query);\n"
"    println!(\"In file {}\", config.file_path);\n"
"\n"
"    run(config);\n"
"}\n"
"\n"
"fn run(config: Config) {\n"
"    let contents = fs::read_to_string(config.file_path)\n"
"        .expect(\"Should have been able to read the file\");\n"
"\n"
"    println!(\"With text:\\n{contents}\");\n"
"}\n"
"\n"
"// --snip--\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:611
msgid ""
"<span class=\"caption\">Listing 12-11: Extracting a `run` function "
"containing the\n"
"rest of the program logic</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:614
msgid ""
"The `run` function now contains all the remaining logic from `main`, "
"starting\n"
"from reading the file. The `run` function takes the `Config` instance as an\n"
"argument."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:618
msgid "#### Returning Errors from the `run` Function"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:620
msgid ""
"With the remaining program logic separated into the `run` function, we can\n"
"improve the error handling, as we did with `Config::build` in Listing 12-9.\n"
"Instead of allowing the program to panic by calling `expect`, the `run`\n"
"function will return a `Result<T, E>` when something goes wrong. This will "
"let\n"
"us further consolidate the logic around handling errors into `main` in a\n"
"user-friendly way. Listing 12-12 shows the changes we need to make to the\n"
"signature and body of `run`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:630
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::fs;\n"
"# use std::process;\n"
"use std::error::Error;\n"
"\n"
"// --snip--\n"
"\n"
"# \n"
"# fn main() {\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::build(&args).unwrap_or_else(|err| {\n"
"#         println!(\"Problem parsing arguments: {err}\");\n"
"#         process::exit(1);\n"
"#     });\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"#     run(config);\n"
"# }\n"
"# \n"
"fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"    let contents = fs::read_to_string(config.file_path)?;\n"
"\n"
"    println!(\"With text:\\n{contents}\");\n"
"\n"
"    Ok(())\n"
"}\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:680
msgid ""
"<span class=\"caption\">Listing 12-12: Changing the `run` function to "
"return\n"
"`Result`</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:683
msgid ""
"We‚Äôve made three significant changes here. First, we changed the return type "
"of\n"
"the `run` function to `Result<(), Box<dyn Error>>`. This function "
"previously\n"
"returned the unit type, `()`, and we keep that as the value returned in the\n"
"`Ok` case."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:688
msgid ""
"For the error type, we used the *trait object* `Box<dyn Error>` (and we‚Äôve\n"
"brought `std::error::Error` into scope with a `use` statement at the top).\n"
"We‚Äôll cover trait objects in [Chapter 17][ch17]<!-- ignore -->. For now, "
"just\n"
"know that `Box<dyn Error>` means the function will return a type that\n"
"implements the `Error` trait, but we don‚Äôt have to specify what particular "
"type\n"
"the return value will be. This gives us flexibility to return error values "
"that\n"
"may be of different types in different error cases. The `dyn` keyword is "
"short\n"
"for ‚Äúdynamic.‚Äù"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:697
msgid ""
"Second, we‚Äôve removed the call to `expect` in favor of the `?` operator, as "
"we\n"
"talked about in [Chapter 9][ch9-question-mark]<!-- ignore -->. Rather than\n"
"`panic!` on an error, `?` will return the error value from the current "
"function\n"
"for the caller to handle."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:702
msgid ""
"Third, the `run` function now returns an `Ok` value in the success case.\n"
"We‚Äôve declared the `run` function‚Äôs success type as `()` in the signature,\n"
"which means we need to wrap the unit type value in the `Ok` value. This\n"
"`Ok(())` syntax might look a bit strange at first, but using `()` like this "
"is\n"
"the idiomatic way to indicate that we‚Äôre calling `run` for its side effects\n"
"only; it doesn‚Äôt return a value we need."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:709
msgid "When you run this code, it will compile but will display a warning:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:711
msgid ""
"```console\n"
"$ cargo run the poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"warning: unused `Result` that must be used\n"
"  --> src/main.rs:19:5\n"
"   |\n"
"19 |     run(config);\n"
"   |     ^^^^^^^^^^^\n"
"   |\n"
"   = note: this `Result` may be an `Err` variant, which should be handled\n"
"   = note: `#[warn(unused_must_use)]` on by default\n"
"\n"
"warning: `minigrep` (bin \"minigrep\") generated 1 warning\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.71s\n"
"     Running `target/debug/minigrep the poem.txt`\n"
"Searching for the\n"
"In file poem.txt\n"
"With text:\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"Then there's a pair of us - don't tell!\n"
"They'd banish us, you know.\n"
"\n"
"How dreary to be somebody!\n"
"How public, like a frog\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:741
msgid ""
"Rust tells us that our code ignored the `Result` value and the `Result` "
"value\n"
"might indicate that an error occurred. But we‚Äôre not checking to see whether "
"or\n"
"not there was an error, and the compiler reminds us that we probably meant "
"to\n"
"have some error-handling code here! Let‚Äôs rectify that problem now."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:746
msgid "#### Handling Errors Returned from `run` in `main`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:748
msgid ""
"We‚Äôll check for errors and handle them using a technique similar to one we "
"used\n"
"with `Config::build` in Listing 12-10, but with a slight difference:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:753
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# use std::process;\n"
"# \n"
"fn main() {\n"
"    // --snip--\n"
"\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::build(&args).unwrap_or_else(|err| {\n"
"#         println!(\"Problem parsing arguments: {err}\");\n"
"#         process::exit(1);\n"
"#     });\n"
"# \n"
"    println!(\"Searching for {}\", config.query);\n"
"    println!(\"In file {}\", config.file_path);\n"
"\n"
"    if let Err(e) = run(config) {\n"
"        println!(\"Application error: {e}\");\n"
"        process::exit(1);\n"
"    }\n"
"}\n"
"# \n"
"# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# struct Config {\n"
"#     query: String,\n"
"#     file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:805
msgid ""
"We use `if let` rather than `unwrap_or_else` to check whether `run` returns "
"an\n"
"`Err` value and call `process::exit(1)` if it does. The `run` function "
"doesn‚Äôt\n"
"return a value that we want to `unwrap` in the same way that `Config::"
"build`\n"
"returns the `Config` instance. Because `run` returns `()` in the success "
"case,\n"
"we only care about detecting an error, so we don‚Äôt need `unwrap_or_else` to\n"
"return the unwrapped value, which would only be `()`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:812
msgid ""
"The bodies of the `if let` and the `unwrap_or_else` functions are the same "
"in\n"
"both cases: we print the error and exit."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:815
msgid "### Splitting Code into a Library Crate"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:817
msgid ""
"Our `minigrep` project is looking good so far! Now we‚Äôll split the\n"
"*src/main.rs* file and put some code into the *src/lib.rs* file. That way "
"we\n"
"can test the code and have a *src/main.rs* file with fewer responsibilities."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:821
msgid ""
"Let‚Äôs move all the code that isn‚Äôt the `main` function from *src/main.rs* "
"to\n"
"*src/lib.rs*:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:824
msgid ""
"* The `run` function definition\n"
"* The relevant `use` statements\n"
"* The definition of `Config`\n"
"* The `Config::build` function definition"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:829
msgid ""
"The contents of *src/lib.rs* should have the signatures shown in Listing "
"12-13\n"
"(we‚Äôve omitted the bodies of the functions for brevity). Note that this "
"won‚Äôt\n"
"compile until we modify *src/main.rs* in Listing 12-14."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:835
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::error::Error;\n"
"use std::fs;\n"
"\n"
"pub struct Config {\n"
"    pub query: String,\n"
"    pub file_path: String,\n"
"}\n"
"\n"
"impl Config {\n"
"    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"        // --snip--\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"    }\n"
"}\n"
"\n"
"pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"    // --snip--\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     println!(\"With text:\\n{contents}\");\n"
"# \n"
"#     Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:868
msgid ""
"<span class=\"caption\">Listing 12-13: Moving `Config` and `run` into\n"
"*src/lib.rs*</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:871
msgid ""
"We‚Äôve made liberal use of the `pub` keyword: on `Config`, on its fields and "
"its\n"
"`build` method, and on the `run` function. We now have a library crate that "
"has\n"
"a public API we can test!"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:875
msgid ""
"Now we need to bring the code we moved to *src/lib.rs* into the scope of "
"the\n"
"binary crate in *src/main.rs*, as shown in Listing 12-14."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:880
msgid ""
"```rust,ignore\n"
"use std::env;\n"
"use std::process;\n"
"\n"
"use minigrep::Config;\n"
"\n"
"fn main() {\n"
"    // --snip--\n"
"#     let args: Vec<String> = env::args().collect();\n"
"# \n"
"#     let config = Config::build(&args).unwrap_or_else(|err| {\n"
"#         println!(\"Problem parsing arguments: {err}\");\n"
"#         process::exit(1);\n"
"#     });\n"
"# \n"
"#     println!(\"Searching for {}\", config.query);\n"
"#     println!(\"In file {}\", config.file_path);\n"
"# \n"
"    if let Err(e) = minigrep::run(config) {\n"
"        // --snip--\n"
"#         println!(\"Application error: {e}\");\n"
"#         process::exit(1);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:906
msgid ""
"<span class=\"caption\">Listing 12-14: Using the `minigrep` library crate "
"in\n"
"*src/main.rs*</span>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:909
msgid ""
"We add a `use minigrep::Config` line to bring the `Config` type from the\n"
"library crate into the binary crate‚Äôs scope, and we prefix the `run` "
"function\n"
"with our crate name. Now all the functionality should be connected and "
"should\n"
"work. Run the program with `cargo run` and make sure everything works\n"
"correctly."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:915
msgid ""
"Whew! That was a lot of work, but we‚Äôve set ourselves up for success in the\n"
"future. Now it‚Äôs much easier to handle errors, and we‚Äôve made the code more\n"
"modular. Almost all of our work will be done in *src/lib.rs* from here on "
"out."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:919
msgid ""
"Let‚Äôs take advantage of this newfound modularity by doing something that "
"would\n"
"have been difficult with the old code but is easy with the new code: we‚Äôll\n"
"write some tests!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:1
msgid "## Developing the Library‚Äôs Functionality with Test-Driven Development"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:3
msgid ""
"Now that we‚Äôve extracted the logic into *src/lib.rs* and left the argument\n"
"collecting and error handling in *src/main.rs*, it‚Äôs much easier to write "
"tests\n"
"for the core functionality of our code. We can call functions directly with\n"
"various arguments and check return values without having to call our binary\n"
"from the command line."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:9
msgid ""
"In this section, we‚Äôll add the searching logic to the `minigrep` program\n"
"using the test-driven development (TDD) process with the following steps:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:12
msgid ""
"1. Write a test that fails and run it to make sure it fails for the reason "
"you\n"
"   expect.\n"
"2. Write or modify just enough code to make the new test pass.\n"
"3. Refactor the code you just added or changed and make sure the tests\n"
"   continue to pass.\n"
"4. Repeat from step 1!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:19
msgid ""
"Though it‚Äôs just one of many ways to write software, TDD can help drive "
"code\n"
"design. Writing the test before you write the code that makes the test pass\n"
"helps to maintain high test coverage throughout the process."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:23
msgid ""
"We‚Äôll test drive the implementation of the functionality that will actually "
"do\n"
"the searching for the query string in the file contents and produce a list "
"of\n"
"lines that match the query. We‚Äôll add this functionality in a function "
"called\n"
"`search`."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:28
msgid "### Writing a Failing Test"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:30
msgid ""
"Because we don‚Äôt need them anymore, let‚Äôs remove the `println!` statements "
"from\n"
"*src/lib.rs* and *src/main.rs* that we used to check the program‚Äôs "
"behavior.\n"
"Then, in *src/lib.rs*, add a `tests` module with a test function, as we did "
"in\n"
"[Chapter 11][ch11-anatomy]<!-- ignore -->. The test function specifies the\n"
"behavior we want the `search` function to have: it will take a query and "
"the\n"
"text to search, and it will return only the lines from the text that "
"contain\n"
"the query. Listing 12-15 shows this test, which won‚Äôt compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:40
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn one_result() {\n"
"        let query = \"duct\";\n"
"        let contents = \"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\";\n"
"\n"
"        assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:85
msgid ""
"<span class=\"caption\">Listing 12-15: Creating a failing test for the "
"`search`\n"
"function we wish we had</span>"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:88
msgid ""
"This test searches for the string `\"duct\"`. The text we‚Äôre searching is "
"three\n"
"lines, only one of which contains `\"duct\"` (Note that the backslash after "
"the\n"
"opening double quote tells Rust not to put a newline character at the "
"beginning\n"
"of the contents of this string literal). We assert that the value returned "
"from\n"
"the `search` function contains only the line we expect."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:94
msgid ""
"We aren‚Äôt yet able to run this test and watch it fail because the test "
"doesn‚Äôt\n"
"even compile: the `search` function doesn‚Äôt exist yet! In accordance with "
"TDD\n"
"principles, we‚Äôll add just enough code to get the test to compile and run "
"by\n"
"adding a definition of the `search` function that always returns an empty\n"
"vector, as shown in Listing 12-16. Then the test should compile and fail\n"
"because an empty vector doesn‚Äôt match a vector containing the line `\"safe,\n"
"fast, productive.\"`"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:104
msgid ""
"```rust,noplayground\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"    vec![]\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn one_result() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:153
msgid ""
"<span class=\"caption\">Listing 12-16: Defining just enough of the `search`\n"
"function so our test will compile</span>"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:156
msgid ""
"Notice that we need to define an explicit lifetime `'a` in the signature of\n"
"`search` and use that lifetime with the `contents` argument and the return\n"
"value. Recall in [Chapter 10][ch10-lifetimes]<!-- ignore --> that the "
"lifetime\n"
"parameters specify which argument lifetime is connected to the lifetime of "
"the\n"
"return value. In this case, we indicate that the returned vector should "
"contain\n"
"string slices that reference slices of the argument `contents` (rather than "
"the\n"
"argument `query`)."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:164
msgid ""
"In other words, we tell Rust that the data returned by the `search` "
"function\n"
"will live as long as the data passed into the `search` function in the\n"
"`contents` argument. This is important! The data referenced *by* a slice "
"needs\n"
"to be valid for the reference to be valid; if the compiler assumes we‚Äôre "
"making\n"
"string slices of `query` rather than `contents`, it will do its safety "
"checking\n"
"incorrectly."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:171
msgid ""
"If we forget the lifetime annotations and try to compile this function, "
"we‚Äôll\n"
"get this error:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:174
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"error[E0106]: missing lifetime specifier\n"
"  --> src/lib.rs:28:51\n"
"   |\n"
"28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n"
"   |                      ----            ----         ^ expected named "
"lifetime parameter\n"
"   |\n"
"   = help: this function's return type contains a borrowed value, but the "
"signature does not say whether it is borrowed from `query` or `contents`\n"
"help: consider introducing a named lifetime parameter\n"
"   |\n"
"28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {\n"
"   |              ++++         ++                 ++              ++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `minigrep` due to previous error\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:193
msgid ""
"Rust can‚Äôt possibly know which of the two arguments we need, so we need to "
"tell\n"
"it explicitly. Because `contents` is the argument that contains all of our "
"text\n"
"and we want to return the parts of that text that match, we know `contents` "
"is\n"
"the argument that should be connected to the return value using the "
"lifetime\n"
"syntax."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:199
msgid ""
"Other programming languages don‚Äôt require you to connect arguments to "
"return\n"
"values in the signature, but this practice will get easier over time. You "
"might\n"
"want to compare this example with the [‚ÄúValidating References with\n"
"Lifetimes‚Äù][validating-references-with-lifetimes]<!-- ignore --> section in\n"
"Chapter 10."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:205
msgid "Now let‚Äôs run the test:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:207
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.97s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 1 test\n"
"test tests::one_result ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::one_result stdout ----\n"
"thread 'tests::one_result' panicked at 'assertion failed: `(left == right)`\n"
"  left: `[\"safe, fast, productive.\"]`,\n"
" right: `[]`', src/lib.rs:44:9\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::one_result\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:233
msgid ""
"Great, the test fails, exactly as we expected. Let‚Äôs get the test to pass!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:235
msgid "### Writing Code to Pass the Test"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:237
msgid ""
"Currently, our test is failing because we always return an empty vector. To "
"fix\n"
"that and implement `search`, our program needs to follow these steps:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:240
msgid ""
"* Iterate through each line of the contents.\n"
"* Check whether the line contains our query string.\n"
"* If it does, add it to the list of values we‚Äôre returning.\n"
"* If it doesn‚Äôt, do nothing.\n"
"* Return the list of results that match."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:246
msgid "Let‚Äôs work through each step, starting with iterating through lines."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:248
msgid "#### Iterating Through Lines with the `lines` Method"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:250
msgid ""
"Rust has a helpful method to handle line-by-line iteration of strings,\n"
"conveniently named `lines`, that works as shown in Listing 12-17. Note this\n"
"won‚Äôt compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:256
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"    for line in contents.lines() {\n"
"        // do something with line\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn one_result() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:307
msgid ""
"<span class=\"caption\">Listing 12-17: Iterating through each line in "
"`contents`\n"
"</span>"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:310
msgid ""
"The `lines` method returns an iterator. We‚Äôll talk about iterators in depth "
"in\n"
"[Chapter 13][ch13-iterators]<!-- ignore -->, but recall that you saw this "
"way\n"
"of using an iterator in [Listing 3-5][ch3-iter]<!-- ignore -->, where we "
"used a\n"
"`for` loop with an iterator to run some code on each item in a collection."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:315
msgid "#### Searching Each Line for the Query"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:317
msgid ""
"Next, we‚Äôll check whether the current line contains our query string.\n"
"Fortunately, strings have a helpful method named `contains` that does this "
"for\n"
"us! Add a call to the `contains` method in the `search` function, as shown "
"in\n"
"Listing 12-18. Note this still won‚Äôt compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:324
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"    for line in contents.lines() {\n"
"        if line.contains(query) {\n"
"            // do something with line\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn one_result() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:377
msgid ""
"<span class=\"caption\">Listing 12-18: Adding functionality to see whether "
"the\n"
"line contains the string in `query`</span>"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:380
msgid ""
"At the moment, we‚Äôre building up functionality. To get it to compile, we "
"need\n"
"to return a value from the body as we indicated we would in the function\n"
"signature."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:384
msgid "#### Storing Matching Lines"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:386
msgid ""
"To finish this function, we need a way to store the matching lines that we "
"want\n"
"to return. For that, we can make a mutable vector before the `for` loop and\n"
"call the `push` method to store a `line` in the vector. After the `for` "
"loop,\n"
"we return the vector, as shown in Listing 12-19."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:393
#: src/ch13-03-improving-our-io-project.md:485
msgid ""
"```rust,ignore\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"    let mut results = Vec::new();\n"
"\n"
"    for line in contents.lines() {\n"
"        if line.contains(query) {\n"
"            results.push(line);\n"
"        }\n"
"    }\n"
"\n"
"    results\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn one_result() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:450
msgid ""
"<span class=\"caption\">Listing 12-19: Storing the lines that match so we "
"can\n"
"return them</span>"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:453
msgid ""
"Now the `search` function should return only the lines that contain "
"`query`,\n"
"and our test should pass. Let‚Äôs run the test:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:456
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 1.22s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 1 test\n"
"test tests::one_result ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests minigrep\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:481
msgid "Our test passed, so we know it works!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:483
msgid ""
"At this point, we could consider opportunities for refactoring the\n"
"implementation of the search function while keeping the tests passing to\n"
"maintain the same functionality. The code in the search function isn‚Äôt too "
"bad,\n"
"but it doesn‚Äôt take advantage of some useful features of iterators. We‚Äôll\n"
"return to this example in [Chapter 13][ch13-iterators]<!-- ignore -->, "
"where\n"
"we‚Äôll explore iterators in detail, and look at how to improve it."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:490
msgid "#### Using the `search` Function in the `run` Function"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:492
msgid ""
"Now that the `search` function is working and tested, we need to call "
"`search`\n"
"from our `run` function. We need to pass the `config.query` value and the\n"
"`contents` that `run` reads from the file to the `search` function. Then "
"`run`\n"
"will print each line returned from `search`:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:499
msgid ""
"```rust,ignore\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"    let contents = fs::read_to_string(config.file_path)?;\n"
"\n"
"    for line in search(&config.query, &contents) {\n"
"        println!(\"{line}\");\n"
"    }\n"
"\n"
"    Ok(())\n"
"}\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn one_result() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:560
msgid ""
"We‚Äôre still using a `for` loop to return each line from `search` and print "
"it."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:562
msgid ""
"Now the entire program should work! Let‚Äôs try it out, first with a word "
"that\n"
"should return exactly one line from the Emily Dickinson poem, ‚Äúfrog‚Äù:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:565
msgid ""
"```console\n"
"$ cargo run -- frog poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.38s\n"
"     Running `target/debug/minigrep frog poem.txt`\n"
"How public, like a frog\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:573
msgid "Cool! Now let‚Äôs try a word that will match multiple lines, like ‚Äúbody‚Äù:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:575
msgid ""
"```console\n"
"$ cargo run -- body poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep body poem.txt`\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:585
msgid ""
"And finally, let‚Äôs make sure that we don‚Äôt get any lines when we search for "
"a\n"
"word that isn‚Äôt anywhere in the poem, such as ‚Äúmonomorphization‚Äù:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:588
msgid ""
"```console\n"
"$ cargo run -- monomorphization poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep monomorphization poem.txt`\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:595
msgid ""
"Excellent! We‚Äôve built our own mini version of a classic tool and learned a "
"lot\n"
"about how to structure applications. We‚Äôve also learned a bit about file "
"input\n"
"and output, lifetimes, testing, and command line parsing."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:599
msgid ""
"To round out this project, we‚Äôll briefly demonstrate how to work with\n"
"environment variables and how to print to standard error, both of which are\n"
"useful when you‚Äôre writing command line programs."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:1
msgid "## Working with Environment Variables"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:3
msgid ""
"We‚Äôll improve `minigrep` by adding an extra feature: an option for\n"
"case-insensitive searching that the user can turn on via an environment\n"
"variable. We could make this feature a command line option and require that\n"
"users enter it each time they want it to apply, but by instead making it an\n"
"environment variable, we allow our users to set the environment variable "
"once\n"
"and have all their searches be case insensitive in that terminal session."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:10
msgid "### Writing a Failing Test for the Case-Insensitive `search` Function"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:12
msgid ""
"We first add a new `search_case_insensitive` function that will be called "
"when\n"
"the environment variable has a value. We‚Äôll continue to follow the TDD "
"process,\n"
"so the first step is again to write a failing test. We‚Äôll add a new test "
"for\n"
"the new `search_case_insensitive` function and rename our old test from\n"
"`one_result` to `case_sensitive` to clarify the differences between the two\n"
"tests, as shown in Listing 12-20."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:21
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     for line in search(&config.query, &contents) {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn case_sensitive() {\n"
"        let query = \"duct\";\n"
"        let contents = \"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\n"
"Duct tape.\";\n"
"\n"
"        assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn case_insensitive() {\n"
"        let query = \"rUsT\";\n"
"        let contents = \"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\n"
"Trust me.\";\n"
"\n"
"        assert_eq!(\n"
"            vec![\"Rust:\", \"Trust me.\"],\n"
"            search_case_insensitive(query, contents)\n"
"        );\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:98
msgid ""
"<span class=\"caption\">Listing 12-20: Adding a new failing test for the\n"
"case-insensitive function we‚Äôre about to add</span>"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:101
msgid ""
"Note that we‚Äôve edited the old test‚Äôs `contents` too. We‚Äôve added a new "
"line\n"
"with the text `\"Duct tape.\"` using a capital D that shouldn‚Äôt match the "
"query\n"
"`\"duct\"` when we‚Äôre searching in a case-sensitive manner. Changing the old "
"test\n"
"in this way helps ensure that we don‚Äôt accidentally break the case-"
"sensitive\n"
"search functionality that we‚Äôve already implemented. This test should pass "
"now\n"
"and should continue to pass as we work on the case-insensitive search."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:108
msgid ""
"The new test for the case-*insensitive* search uses `\"rUsT\"` as its query. "
"In\n"
"the `search_case_insensitive` function we‚Äôre about to add, the query "
"`\"rUsT\"`\n"
"should match the line containing `\"Rust:\"` with a capital R and match the "
"line\n"
"`\"Trust me.\"` even though both have different casing from the query. This "
"is\n"
"our failing test, and it will fail to compile because we haven‚Äôt yet "
"defined\n"
"the `search_case_insensitive` function. Feel free to add a skeleton\n"
"implementation that always returns an empty vector, similar to the way we "
"did\n"
"for the `search` function in Listing 12-16 to see the test compile and fail."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:117
msgid "### Implementing the `search_case_insensitive` Function"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:119
msgid ""
"The `search_case_insensitive` function, shown in Listing 12-21, will be "
"almost\n"
"the same as the `search` function. The only difference is that we‚Äôll "
"lowercase\n"
"the `query` and each `line` so whatever the case of the input arguments,\n"
"they‚Äôll be the same case when we check whether the line contains the query."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:126
msgid ""
"```rust,noplayground\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     for line in search(&config.query, &contents) {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"pub fn search_case_insensitive<'a>(\n"
"    query: &str,\n"
"    contents: &'a str,\n"
") -> Vec<&'a str> {\n"
"    let query = query.to_lowercase();\n"
"    let mut results = Vec::new();\n"
"\n"
"    for line in contents.lines() {\n"
"        if line.to_lowercase().contains(&query) {\n"
"            results.push(line);\n"
"        }\n"
"    }\n"
"\n"
"    results\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:219
msgid ""
"<span class=\"caption\">Listing 12-21: Defining the "
"`search_case_insensitive`\n"
"function to lowercase the query and the line before comparing them</span>"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:222
msgid ""
"First, we lowercase the `query` string and store it in a shadowed variable "
"with\n"
"the same name. Calling `to_lowercase` on the query is necessary so no\n"
"matter whether the user‚Äôs query is `\"rust\"`, `\"RUST\"`, `\"Rust\"`, or "
"`\"rUsT\"`,\n"
"we‚Äôll treat the query as if it were `\"rust\"` and be insensitive to the "
"case.\n"
"While `to_lowercase` will handle basic Unicode, it won‚Äôt be 100% accurate. "
"If\n"
"we were writing a real application, we‚Äôd want to do a bit more work here, "
"but\n"
"this section is about environment variables, not Unicode, so we‚Äôll leave it "
"at\n"
"that here."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:231
msgid ""
"Note that `query` is now a `String` rather than a string slice, because "
"calling\n"
"`to_lowercase` creates new data rather than referencing existing data. Say "
"the\n"
"query is `\"rUsT\"`, as an example: that string slice doesn‚Äôt contain a "
"lowercase\n"
"`u` or `t` for us to use, so we have to allocate a new `String` containing\n"
"`\"rust\"`. When we pass `query` as an argument to the `contains` method "
"now, we\n"
"need to add an ampersand because the signature of `contains` is defined to "
"take\n"
"a string slice."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:239
msgid ""
"Next, we add a call to `to_lowercase` on each `line` to lowercase all\n"
"characters. Now that we‚Äôve converted `line` and `query` to lowercase, we‚Äôll\n"
"find matches no matter what the case of the query is."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:243
msgid "Let‚Äôs see if this implementation passes the tests:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:245
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 1.33s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 2 tests\n"
"test tests::case_insensitive ... ok\n"
"test tests::case_sensitive ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests minigrep\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:271
msgid ""
"Great! They passed. Now, let‚Äôs call the new `search_case_insensitive` "
"function\n"
"from the `run` function. First, we‚Äôll add a configuration option to the\n"
"`Config` struct to switch between case-sensitive and case-insensitive "
"search.\n"
"Adding this field will cause compiler errors because we aren‚Äôt initializing\n"
"this field anywhere yet:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:279
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"pub struct Config {\n"
"    pub query: String,\n"
"    pub file_path: String,\n"
"    pub ignore_case: bool,\n"
"}\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:379
msgid ""
"We added the `ignore_case` field that holds a Boolean. Next, we need the "
"`run`\n"
"function to check the `ignore_case` field‚Äôs value and use that to decide\n"
"whether to call the `search` function or the `search_case_insensitive`\n"
"function, as shown in Listing 12-22. This still won‚Äôt compile yet."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:386
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         Ok(Config { query, file_path })\n"
"#     }\n"
"# }\n"
"# \n"
"pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"    let contents = fs::read_to_string(config.file_path)?;\n"
"\n"
"    let results = if config.ignore_case {\n"
"        search_case_insensitive(&config.query, &contents)\n"
"    } else {\n"
"        search(&config.query, &contents)\n"
"    };\n"
"\n"
"    for line in results {\n"
"        println!(\"{line}\");\n"
"    }\n"
"\n"
"    Ok(())\n"
"}\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:486
msgid ""
"<span class=\"caption\">Listing 12-22: Calling either `search` or\n"
"`search_case_insensitive` based on the value in `config.ignore_case`</span>"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:489
msgid ""
"Finally, we need to check for the environment variable. The functions for\n"
"working with environment variables are in the `env` module in the standard\n"
"library, so we bring that module into scope at the top of *src/lib.rs*. "
"Then\n"
"we‚Äôll use the `var` function from the `env` module to check to see if any "
"value\n"
"has been set for an environment variable named `IGNORE_CASE`, as shown in\n"
"Listing 12-23."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:498
msgid ""
"```rust,noplayground\n"
"use std::env;\n"
"// --snip--\n"
"\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"        if args.len() < 3 {\n"
"            return Err(\"not enough arguments\");\n"
"        }\n"
"\n"
"        let query = args[1].clone();\n"
"        let file_path = args[2].clone();\n"
"\n"
"        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n"
"\n"
"        Ok(Config {\n"
"            query,\n"
"            file_path,\n"
"            ignore_case,\n"
"        })\n"
"    }\n"
"}\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:607
msgid ""
"<span class=\"caption\">Listing 12-23: Checking for any value in an "
"environment\n"
"variable named `IGNORE_CASE`</span>"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:610
msgid ""
"Here, we create a new variable `ignore_case`. To set its value, we call the\n"
"`env::var` function and pass it the name of the `IGNORE_CASE` environment\n"
"variable. The `env::var` function returns a `Result` that will be the\n"
"successful `Ok` variant that contains the value of the environment variable "
"if\n"
"the environment variable is set to any value. It will return the `Err` "
"variant\n"
"if the environment variable is not set."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:617
msgid ""
"We‚Äôre using the `is_ok` method on the `Result` to check whether the "
"environment\n"
"variable is set, which means the program should do a case-insensitive "
"search.\n"
"If the `IGNORE_CASE` environment variable isn‚Äôt set to anything, `is_ok` "
"will\n"
"return false and the program will perform a case-sensitive search. We don‚Äôt\n"
"care about the *value* of the environment variable, just whether it‚Äôs set "
"or\n"
"unset, so we‚Äôre checking `is_ok` rather than using `unwrap`, `expect`, or "
"any\n"
"of the other methods we‚Äôve seen on `Result`."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:625
msgid ""
"We pass the value in the `ignore_case` variable to the `Config` instance so "
"the\n"
"`run` function can read that value and decide whether to call\n"
"`search_case_insensitive` or `search`, as we implemented in Listing 12-22."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:629
msgid ""
"Let‚Äôs give it a try! First, we‚Äôll run our program without the environment\n"
"variable set and with the query `to`, which should match any line that "
"contains\n"
"the word ‚Äúto‚Äù in all lowercase:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:633
msgid ""
"```console\n"
"$ cargo run -- to poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep to poem.txt`\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:642
msgid ""
"Looks like that still works! Now, let‚Äôs run the program with `IGNORE_CASE`\n"
"set to `1` but with the same query `to`."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:645
msgid ""
"```console\n"
"$ IGNORE_CASE=1 cargo run -- to poem.txt\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:649
msgid ""
"If you‚Äôre using PowerShell, you will need to set the environment variable "
"and\n"
"run the program as separate commands:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:652
msgid ""
"```console\n"
"PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:656
msgid ""
"This will make `IGNORE_CASE` persist for the remainder of your shell\n"
"session. It can be unset with the `Remove-Item` cmdlet:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:659
msgid ""
"```console\n"
"PS> Remove-Item Env:IGNORE_CASE\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:663
msgid ""
"We should get lines that contain ‚Äúto‚Äù that might have uppercase letters:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:665
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch12-an-io-project/listing-12-23\n"
"IGNORE_CASE=1 cargo run -- to poem.txt\n"
"can't extract because of the environment variable\n"
"-->"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:671
msgid ""
"```console\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:678
msgid ""
"Excellent, we also got lines containing ‚ÄúTo‚Äù! Our `minigrep` program can now "
"do\n"
"case-insensitive searching controlled by an environment variable. Now you "
"know\n"
"how to manage options set using either command line arguments or "
"environment\n"
"variables."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:683
msgid ""
"Some programs allow arguments *and* environment variables for the same\n"
"configuration. In those cases, the programs decide that one or the other "
"takes\n"
"precedence. For another exercise on your own, try controlling case "
"sensitivity\n"
"through either a command line argument or an environment variable. Decide\n"
"whether the command line argument or the environment variable should take\n"
"precedence if the program is run with one set to case sensitive and one set "
"to\n"
"ignore case."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:691
msgid ""
"The `std::env` module contains many more useful features for dealing with\n"
"environment variables: check out its documentation to see what is available."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:1
msgid "## Writing Error Messages to Standard Error Instead of Standard Output"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:3
msgid ""
"At the moment, we‚Äôre writing all of our output to the terminal using the\n"
"`println!` macro. In most terminals, there are two kinds of output: "
"*standard\n"
"output* (`stdout`) for general information and *standard error* (`stderr`) "
"for\n"
"error messages. This distinction enables users to choose to direct the\n"
"successful output of a program to a file but still print error messages to "
"the\n"
"screen."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:10
msgid ""
"The `println!` macro is only capable of printing to standard output, so we\n"
"have to use something else to print to standard error."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:13
msgid "### Checking Where Errors Are Written"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:15
msgid ""
"First, let‚Äôs observe how the content printed by `minigrep` is currently "
"being\n"
"written to standard output, including any error messages we want to write "
"to\n"
"standard error instead. We‚Äôll do that by redirecting the standard output "
"stream\n"
"to a file while intentionally causing an error. We won‚Äôt redirect the "
"standard\n"
"error stream, so any content sent to standard error will continue to display "
"on\n"
"the screen."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:22
msgid ""
"Command line programs are expected to send error messages to the standard "
"error\n"
"stream so we can still see error messages on the screen even if we redirect "
"the\n"
"standard output stream to a file. Our program is not currently well-"
"behaved:\n"
"we‚Äôre about to see that it saves the error message output to a file instead!"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:27
msgid ""
"To demonstrate this behavior, we‚Äôll run the program with `>` and the file "
"path,\n"
"*output.txt*, that we want to redirect the standard output stream to. We "
"won‚Äôt\n"
"pass any arguments, which should cause an error:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:31
msgid ""
"```console\n"
"$ cargo run > output.txt\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:35
msgid ""
"The `>` syntax tells the shell to write the contents of standard output to\n"
"*output.txt* instead of the screen. We didn‚Äôt see the error message we were\n"
"expecting printed to the screen, so that means it must have ended up in the\n"
"file. This is what *output.txt* contains:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:40
msgid ""
"```text\n"
"Problem parsing arguments: not enough arguments\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:44
msgid ""
"Yup, our error message is being printed to standard output. It‚Äôs much more\n"
"useful for error messages like this to be printed to standard error so only\n"
"data from a successful run ends up in the file. We‚Äôll change that."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:48
msgid "### Printing Errors to Standard Error"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:50
msgid ""
"We‚Äôll use the code in Listing 12-24 to change how error messages are "
"printed.\n"
"Because of the refactoring we did earlier in this chapter, all the code "
"that\n"
"prints error messages is in one function, `main`. The standard library "
"provides\n"
"the `eprintln!` macro that prints to the standard error stream, so let‚Äôs "
"change\n"
"the two places we were calling `println!` to print errors to use `eprintln!"
"`\n"
"instead."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:59
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::process;\n"
"# \n"
"# use minigrep::Config;\n"
"# \n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let config = Config::build(&args).unwrap_or_else(|err| {\n"
"        eprintln!(\"Problem parsing arguments: {err}\");\n"
"        process::exit(1);\n"
"    });\n"
"\n"
"    if let Err(e) = minigrep::run(config) {\n"
"        eprintln!(\"Application error: {e}\");\n"
"        process::exit(1);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:80
msgid ""
"<span class=\"caption\">Listing 12-24: Writing error messages to standard "
"error\n"
"instead of standard output using `eprintln!`</span>"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:83
msgid ""
"Let‚Äôs now run the program again in the same way, without any arguments and\n"
"redirecting standard output with `>`:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:86
msgid ""
"```console\n"
"$ cargo run > output.txt\n"
"Problem parsing arguments: not enough arguments\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:91
msgid ""
"Now we see the error onscreen and *output.txt* contains nothing, which is "
"the\n"
"behavior we expect of command line programs."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:94
msgid ""
"Let‚Äôs run the program again with arguments that don‚Äôt cause an error but "
"still\n"
"redirect standard output to a file, like so:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:97
msgid ""
"```console\n"
"$ cargo run -- to poem.txt > output.txt\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:101
msgid ""
"We won‚Äôt see any output to the terminal, and *output.txt* will contain our\n"
"results:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:104
msgid "<span class=\"filename\">Filename: output.txt</span>"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:106
msgid ""
"```text\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"```"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:111
msgid ""
"This demonstrates that we‚Äôre now using standard output for successful "
"output\n"
"and standard error for error output as appropriate."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:116
msgid ""
"This chapter recapped some of the major concepts you‚Äôve learned so far and\n"
"covered how to perform common I/O operations in Rust. By using command line\n"
"arguments, files, environment variables, and the `eprintln!` macro for "
"printing\n"
"errors, you‚Äôre now prepared to write command line applications. Combined "
"with\n"
"the concepts in previous chapters, your code will be well organized, store "
"data\n"
"effectively in the appropriate data structures, handle errors nicely, and "
"be\n"
"well tested."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:124
msgid ""
"Next, we‚Äôll explore some Rust features that were influenced by functional\n"
"languages: closures and iterators."
msgstr ""

#: src/ch13-00-functional-features.md:1
msgid "# Functional Language Features: Iterators and Closures"
msgstr ""

#: src/ch13-00-functional-features.md:3
msgid ""
"Rust‚Äôs design has taken inspiration from many existing languages and\n"
"techniques, and one significant influence is *functional programming*.\n"
"Programming in a functional style often includes using functions as values "
"by\n"
"passing them in arguments, returning them from other functions, assigning "
"them\n"
"to variables for later execution, and so forth."
msgstr ""

#: src/ch13-00-functional-features.md:9
msgid ""
"In this chapter, we won‚Äôt debate the issue of what functional programming is "
"or\n"
"isn‚Äôt but will instead discuss some features of Rust that are similar to\n"
"features in many languages often referred to as functional."
msgstr ""

#: src/ch13-00-functional-features.md:13
msgid "More specifically, we‚Äôll cover:"
msgstr ""

#: src/ch13-00-functional-features.md:15
msgid ""
"* *Closures*, a function-like construct you can store in a variable\n"
"* *Iterators*, a way of processing a series of elements\n"
"* How to use closures and iterators to improve the I/O project in Chapter "
"12\n"
"* The performance of closures and iterators (Spoiler alert: they‚Äôre faster "
"than\n"
"  you might think!)"
msgstr ""

#: src/ch13-00-functional-features.md:21
msgid ""
"We‚Äôve already covered some other Rust features, such as pattern matching "
"and\n"
"enums, that are also influenced by the functional style. Because mastering\n"
"closures and iterators is an important part of writing idiomatic, fast Rust\n"
"code, we‚Äôll devote this entire chapter to them."
msgstr ""

#: src/ch13-01-closures.md:2
msgid ""
"<a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></"
"a>"
msgstr ""

#: src/ch13-01-closures.md:4
msgid "## Closures: Anonymous Functions that Capture Their Environment"
msgstr ""

#: src/ch13-01-closures.md:6
msgid ""
"Rust‚Äôs closures are anonymous functions you can save in a variable or pass "
"as\n"
"arguments to other functions. You can create the closure in one place and "
"then\n"
"call the closure elsewhere to evaluate it in a different context. Unlike\n"
"functions, closures can capture values from the scope in which they‚Äôre "
"defined.\n"
"We‚Äôll demonstrate how these closure features allow for code reuse and "
"behavior\n"
"customization."
msgstr ""

#: src/ch13-01-closures.md:14
msgid ""
"<a id=\"creating-an-abstraction-of-behavior-with-closures\"></a>\n"
"<a id=\"refactoring-using-functions\"></a>\n"
"<a id=\"refactoring-with-closures-to-store-code\"></a>"
msgstr ""

#: src/ch13-01-closures.md:18
msgid "### Capturing the Environment with Closures"
msgstr ""

#: src/ch13-01-closures.md:20
msgid ""
"We‚Äôll first examine how we can use closures to capture values from the\n"
"environment they‚Äôre defined in for later use. Here‚Äôs the scenario: Every so\n"
"often, our t-shirt company gives away an exclusive, limited-edition shirt "
"to\n"
"someone on our mailing list as a promotion. People on the mailing list can\n"
"optionally add their favorite color to their profile. If the person chosen "
"for\n"
"a free shirt has their favorite color set, they get that color shirt. If "
"the\n"
"person hasn‚Äôt specified a favorite color, they get whatever color the "
"company\n"
"currently has the most of."
msgstr ""

#: src/ch13-01-closures.md:29
msgid ""
"There are many ways to implement this. For this example, we‚Äôre going to use "
"an\n"
"enum called `ShirtColor` that has the variants `Red` and `Blue` (limiting "
"the\n"
"number of colors available for simplicity). We represent the company‚Äôs\n"
"inventory with an `Inventory` struct that has a field named `shirts` that\n"
"contains a `Vec<ShirtColor>` representing the shirt colors currently in "
"stock.\n"
"The method `giveaway` defined on `Inventory` gets the optional shirt\n"
"color preference of the free shirt winner, and returns the shirt color the\n"
"person will get. This setup is shown in Listing 13-1:"
msgstr ""

#: src/ch13-01-closures.md:40
msgid ""
"```rust,noplayground\n"
"#[derive(Debug, PartialEq, Copy, Clone)]\n"
"enum ShirtColor {\n"
"    Red,\n"
"    Blue,\n"
"}\n"
"\n"
"struct Inventory {\n"
"    shirts: Vec<ShirtColor>,\n"
"}\n"
"\n"
"impl Inventory {\n"
"    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {\n"
"        user_preference.unwrap_or_else(|| self.most_stocked())\n"
"    }\n"
"\n"
"    fn most_stocked(&self) -> ShirtColor {\n"
"        let mut num_red = 0;\n"
"        let mut num_blue = 0;\n"
"\n"
"        for color in &self.shirts {\n"
"            match color {\n"
"                ShirtColor::Red => num_red += 1,\n"
"                ShirtColor::Blue => num_blue += 1,\n"
"            }\n"
"        }\n"
"        if num_red > num_blue {\n"
"            ShirtColor::Red\n"
"        } else {\n"
"            ShirtColor::Blue\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let store = Inventory {\n"
"        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n"
"    };\n"
"\n"
"    let user_pref1 = Some(ShirtColor::Red);\n"
"    let giveaway1 = store.giveaway(user_pref1);\n"
"    println!(\n"
"        \"The user with preference {:?} gets {:?}\",\n"
"        user_pref1, giveaway1\n"
"    );\n"
"\n"
"    let user_pref2 = None;\n"
"    let giveaway2 = store.giveaway(user_pref2);\n"
"    println!(\n"
"        \"The user with preference {:?} gets {:?}\",\n"
"        user_pref2, giveaway2\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:95
msgid ""
"<span class=\"caption\">Listing 13-1: Shirt company giveaway situation</span>"
msgstr ""

#: src/ch13-01-closures.md:97
msgid ""
"The `store` defined in `main` has two blue shirts and one red shirt "
"remaining\n"
"to distribute for this limited-edition promotion. We call the `giveaway` "
"method\n"
"for a user with a preference for a red shirt and a user without any "
"preference."
msgstr ""

#: src/ch13-01-closures.md:101
msgid ""
"Again, this code could be implemented in many ways, and here, to focus on\n"
"closures, we‚Äôve stuck to concepts you‚Äôve already learned except for the body "
"of\n"
"the `giveaway` method that uses a closure. In the `giveaway` method, we get "
"the\n"
"user preference as a parameter of type `Option<ShirtColor>` and call the\n"
"`unwrap_or_else` method on `user_preference`. The [`unwrap_or_else` method "
"on\n"
"`Option<T>`][unwrap-or-else]<!-- ignore --> is defined by the standard "
"library.\n"
"It takes one argument: a closure without any arguments that returns a value "
"`T`\n"
"(the same type stored in the `Some` variant of the `Option<T>`, in this "
"case\n"
"`ShirtColor`). If the `Option<T>` is the `Some` variant, `unwrap_or_else`\n"
"returns the value from within the `Some`. If the `Option<T>` is the `None`\n"
"variant, `unwrap_or_else` calls the closure and returns the value returned "
"by\n"
"the closure."
msgstr ""

#: src/ch13-01-closures.md:114
msgid ""
"We specify the closure expression `|| self.most_stocked()` as the argument "
"to\n"
"`unwrap_or_else`. This is a closure that takes no parameters itself (if the\n"
"closure had parameters, they would appear between the two vertical bars). "
"The\n"
"body of the closure calls `self.most_stocked()`. We‚Äôre defining the closure\n"
"here, and the implementation of `unwrap_or_else` will evaluate the closure\n"
"later if the result is needed."
msgstr ""

#: src/ch13-01-closures.md:121
msgid "Running this code prints:"
msgstr ""

#: src/ch13-01-closures.md:123
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n"
"     Running `target/debug/shirt-company`\n"
"The user with preference Some(Red) gets Red\n"
"The user with preference None gets Blue\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:132
msgid ""
"One interesting aspect here is that we‚Äôve passed a closure that calls\n"
"`self.most_stocked()` on the current `Inventory` instance. The standard "
"library\n"
"didn‚Äôt need to know anything about the `Inventory` or `ShirtColor` types we\n"
"defined, or the logic we want to use in this scenario. The closure captures "
"an\n"
"immutable reference to the `self` `Inventory` instance and passes it with "
"the\n"
"code we specify to the `unwrap_or_else` method. Functions, on the other "
"hand,\n"
"are not able to capture their environment in this way."
msgstr ""

#: src/ch13-01-closures.md:140
msgid "### Closure Type Inference and Annotation"
msgstr ""

#: src/ch13-01-closures.md:142
msgid ""
"There are more differences between functions and closures. Closures don‚Äôt\n"
"usually require you to annotate the types of the parameters or the return "
"value\n"
"like `fn` functions do. Type annotations are required on functions because "
"the\n"
"types are part of an explicit interface exposed to your users. Defining "
"this\n"
"interface rigidly is important for ensuring that everyone agrees on what "
"types\n"
"of values a function uses and returns. Closures, on the other hand, aren‚Äôt "
"used\n"
"in an exposed interface like this: they‚Äôre stored in variables and used "
"without\n"
"naming them and exposing them to users of our library."
msgstr ""

#: src/ch13-01-closures.md:151
msgid ""
"Closures are typically short and relevant only within a narrow context "
"rather\n"
"than in any arbitrary scenario. Within these limited contexts, the compiler "
"can\n"
"infer the types of the parameters and the return type, similar to how it‚Äôs "
"able\n"
"to infer the types of most variables (there are rare cases where the "
"compiler\n"
"needs closure type annotations too)."
msgstr ""

#: src/ch13-01-closures.md:157
msgid ""
"As with variables, we can add type annotations if we want to increase\n"
"explicitness and clarity at the cost of being more verbose than is strictly\n"
"necessary. Annotating the types for a closure would look like the "
"definition\n"
"shown in Listing 13-2. In this example, we‚Äôre defining a closure and storing "
"it\n"
"in a variable rather than defining the closure in the spot we pass it as an\n"
"argument as we did in Listing 13-1."
msgstr ""

#: src/ch13-01-closures.md:166
msgid ""
"```rust\n"
"# use std::thread;\n"
"# use std::time::Duration;\n"
"# \n"
"# fn generate_workout(intensity: u32, random_number: u32) {\n"
"    let expensive_closure = |num: u32| -> u32 {\n"
"        println!(\"calculating slowly...\");\n"
"        thread::sleep(Duration::from_secs(2));\n"
"        num\n"
"    };\n"
"# \n"
"#     if intensity < 25 {\n"
"#         println!(\"Today, do {} pushups!\", "
"expensive_closure(intensity));\n"
"#         println!(\"Next, do {} situps!\", expensive_closure(intensity));\n"
"#     } else {\n"
"#         if random_number == 3 {\n"
"#             println!(\"Take a break today! Remember to stay hydrated!\");\n"
"#         } else {\n"
"#             println!(\n"
"#                 \"Today, run for {} minutes!\",\n"
"#                 expensive_closure(intensity)\n"
"#             );\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let simulated_user_specified_value = 10;\n"
"#     let simulated_random_number = 7;\n"
"# \n"
"#     generate_workout(simulated_user_specified_value, "
"simulated_random_number);\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:200
msgid ""
"<span class=\"caption\">Listing 13-2: Adding optional type annotations of "
"the\n"
"parameter and return value types in the closure</span>"
msgstr ""

#: src/ch13-01-closures.md:203
msgid ""
"With type annotations added, the syntax of closures looks more similar to "
"the\n"
"syntax of functions. Here we define a function that adds 1 to its parameter "
"and\n"
"a closure that has the same behavior, for comparison. We‚Äôve added some "
"spaces\n"
"to line up the relevant parts. This illustrates how closure syntax is "
"similar\n"
"to function syntax except for the use of pipes and the amount of syntax that "
"is\n"
"optional:"
msgstr ""

#: src/ch13-01-closures.md:210
msgid ""
"```rust,ignore\n"
"fn  add_one_v1   (x: u32) -> u32 { x + 1 }\n"
"let add_one_v2 = |x: u32| -> u32 { x + 1 };\n"
"let add_one_v3 = |x|             { x + 1 };\n"
"let add_one_v4 = |x|               x + 1  ;\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:217
msgid ""
"The first line shows a function definition, and the second line shows a "
"fully\n"
"annotated closure definition. In the third line, we remove the type "
"annotations\n"
"from the closure definition. In the fourth line, we remove the brackets, "
"which\n"
"are optional because the closure body has only one expression. These are "
"all\n"
"valid definitions that will produce the same behavior when they‚Äôre called. "
"The\n"
"`add_one_v3` and `add_one_v4` lines require the closures to be evaluated to "
"be\n"
"able to compile because the types will be inferred from their usage. This "
"is\n"
"similar to `let v = Vec::new();` needing either type annotations or values "
"of\n"
"some type to be inserted into the `Vec` for Rust to be able to infer the "
"type."
msgstr ""

#: src/ch13-01-closures.md:227
msgid ""
"For closure definitions, the compiler will infer one concrete type for each "
"of\n"
"their parameters and for their return value. For instance, Listing 13-3 "
"shows\n"
"the definition of a short closure that just returns the value it receives as "
"a\n"
"parameter. This closure isn‚Äôt very useful except for the purposes of this\n"
"example. Note that we haven‚Äôt added any type annotations to the definition.\n"
"Because there are no type annotations, we can call the closure with any "
"type,\n"
"which we‚Äôve done here with `String` the first time. If we then try to call\n"
"`example_closure` with an integer, we‚Äôll get an error."
msgstr ""

#: src/ch13-01-closures.md:238
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let example_closure = |x| x;\n"
"\n"
"    let s = example_closure(String::from(\"hello\"));\n"
"    let n = example_closure(5);\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:247
msgid ""
"<span class=\"caption\">Listing 13-3: Attempting to call a closure whose "
"types\n"
"are inferred with two different types</span>"
msgstr ""

#: src/ch13-01-closures.md:250
msgid "The compiler gives us this error:"
msgstr ""

#: src/ch13-01-closures.md:252
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:5:29\n"
"  |\n"
"5 |     let n = example_closure(5);\n"
"  |             --------------- ^- help: try using a conversion method: `."
"to_string()`\n"
"  |             |               |\n"
"  |             |               expected struct `String`, found integer\n"
"  |             arguments to this function are incorrect\n"
"  |\n"
"note: closure parameter defined here\n"
" --> src/main.rs:2:28\n"
"  |\n"
"2 |     let example_closure = |x| x;\n"
"  |                            ^\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `closure-example` due to previous error\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:274
msgid ""
"The first time we call `example_closure` with the `String` value, the "
"compiler\n"
"infers the type of `x` and the return type of the closure to be `String`. "
"Those\n"
"types are then locked into the closure in `example_closure`, and we get a "
"type\n"
"error when we next try to use a different type with the same closure."
msgstr ""

#: src/ch13-01-closures.md:279
msgid "### Capturing References or Moving Ownership"
msgstr ""

#: src/ch13-01-closures.md:281
msgid ""
"Closures can capture values from their environment in three ways, which\n"
"directly map to the three ways a function can take a parameter: borrowing\n"
"immutably, borrowing mutably, and taking ownership. The closure will decide\n"
"which of these to use based on what the body of the function does with the\n"
"captured values."
msgstr ""

#: src/ch13-01-closures.md:287
msgid ""
"In Listing 13-4, we define a closure that captures an immutable reference "
"to\n"
"the vector named `list` because it only needs an immutable reference to "
"print\n"
"the value:"
msgstr ""

#: src/ch13-01-closures.md:293
msgid ""
"```rust\n"
"fn main() {\n"
"    let list = vec![1, 2, 3];\n"
"    println!(\"Before defining closure: {:?}\", list);\n"
"\n"
"    let only_borrows = || println!(\"From closure: {:?}\", list);\n"
"\n"
"    println!(\"Before calling closure: {:?}\", list);\n"
"    only_borrows();\n"
"    println!(\"After calling closure: {:?}\", list);\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:306
msgid ""
"<span class=\"caption\">Listing 13-4: Defining and calling a closure that\n"
"captures an immutable reference</span>"
msgstr ""

#: src/ch13-01-closures.md:309
msgid ""
"This example also illustrates that a variable can bind to a closure "
"definition,\n"
"and we can later call the closure by using the variable name and parentheses "
"as\n"
"if the variable name were a function name."
msgstr ""

#: src/ch13-01-closures.md:313
msgid ""
"Because we can have multiple immutable references to `list` at the same "
"time,\n"
"`list` is still accessible from the code before the closure definition, "
"after\n"
"the closure definition but before the closure is called, and after the "
"closure\n"
"is called. This code compiles, runs, and prints:"
msgstr ""

#: src/ch13-01-closures.md:318
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/closure-example`\n"
"Before defining closure: [1, 2, 3]\n"
"Before calling closure: [1, 2, 3]\n"
"From closure: [1, 2, 3]\n"
"After calling closure: [1, 2, 3]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:329
msgid ""
"Next, in Listing 13-5, we change the closure body so that it adds an element "
"to\n"
"the `list` vector. The closure now captures a mutable reference:"
msgstr ""

#: src/ch13-01-closures.md:334
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut list = vec![1, 2, 3];\n"
"    println!(\"Before defining closure: {:?}\", list);\n"
"\n"
"    let mut borrows_mutably = || list.push(7);\n"
"\n"
"    borrows_mutably();\n"
"    println!(\"After calling closure: {:?}\", list);\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:346
msgid ""
"<span class=\"caption\">Listing 13-5: Defining and calling a closure that\n"
"captures a mutable reference</span>"
msgstr ""

#: src/ch13-01-closures.md:349
msgid "This code compiles, runs, and prints:"
msgstr ""

#: src/ch13-01-closures.md:351
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/closure-example`\n"
"Before defining closure: [1, 2, 3]\n"
"After calling closure: [1, 2, 3, 7]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:360
msgid ""
"Note that there‚Äôs no longer a `println!` between the definition and the call "
"of\n"
"the `borrows_mutably` closure: when `borrows_mutably` is defined, it "
"captures a\n"
"mutable reference to `list`. We don‚Äôt use the closure again after the "
"closure\n"
"is called, so the mutable borrow ends. Between the closure definition and "
"the\n"
"closure call, an immutable borrow to print isn‚Äôt allowed because no other\n"
"borrows are allowed when there‚Äôs a mutable borrow. Try adding a `println!`\n"
"there to see what error message you get!"
msgstr ""

#: src/ch13-01-closures.md:368
msgid ""
"If you want to force the closure to take ownership of the values it uses in "
"the\n"
"environment even though the body of the closure doesn‚Äôt strictly need\n"
"ownership, you can use the `move` keyword before the parameter list."
msgstr ""

#: src/ch13-01-closures.md:372
msgid ""
"This technique is mostly useful when passing a closure to a new thread to "
"move\n"
"the data so that it‚Äôs owned by the new thread. We‚Äôll discuss threads and "
"why\n"
"you would want to use them in detail in Chapter 16 when we talk about\n"
"concurrency, but for now, let‚Äôs briefly explore spawning a new thread using "
"a\n"
"closure that needs the `move` keyword. Listing 13-6 shows Listing 13-4 "
"modified\n"
"to print the vector in a new thread rather than in the main thread:"
msgstr ""

#: src/ch13-01-closures.md:381
msgid ""
"```rust\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let list = vec![1, 2, 3];\n"
"    println!(\"Before defining closure: {:?}\", list);\n"
"\n"
"    thread::spawn(move || println!(\"From thread: {:?}\", list))\n"
"        .join()\n"
"        .unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:394
msgid ""
"<span class=\"caption\">Listing 13-6: Using `move` to force the closure for "
"the\n"
"thread to take ownership of `list`</span>"
msgstr ""

#: src/ch13-01-closures.md:397
msgid ""
"We spawn a new thread, giving the thread a closure to run as an argument. "
"The\n"
"closure body prints out the list. In Listing 13-4, the closure only "
"captured\n"
"`list` using an immutable reference because that's the least amount of "
"access\n"
"to `list` needed to print it. In this example, even though the closure body\n"
"still only needs an immutable reference, we need to specify that `list` "
"should\n"
"be moved into the closure by putting the `move` keyword at the beginning of "
"the\n"
"closure definition. The new thread might finish before the rest of the main\n"
"thread finishes, or the main thread might finish first. If the main thread\n"
"maintained ownership of `list` but ended before the new thread did and "
"dropped\n"
"`list`, the immutable reference in the thread would be invalid. Therefore, "
"the\n"
"compiler requires that `list` be moved into the closure given to the new "
"thread\n"
"so the reference will be valid. Try removing the `move` keyword or using "
"`list`\n"
"in the main thread after the closure is defined to see what compiler errors "
"you\n"
"get!"
msgstr ""

#: src/ch13-01-closures.md:413
msgid ""
"<a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a>\n"
"<a id=\"limitations-of-the-cacher-implementation\"></a>\n"
"<a id=\"moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a>"
msgstr ""

#: src/ch13-01-closures.md:417
msgid "### Moving Captured Values Out of Closures and the `Fn` Traits"
msgstr ""

#: src/ch13-01-closures.md:419
msgid ""
"Once a closure has captured a reference or captured ownership of a value "
"from\n"
"the environment where the closure is defined (thus affecting what, if "
"anything,\n"
"is moved *into* the closure), the code in the body of the closure defines "
"what\n"
"happens to the references or values when the closure is evaluated later "
"(thus\n"
"affecting what, if anything, is moved *out of* the closure). A closure body "
"can\n"
"do any of the following: move a captured value out of the closure, mutate "
"the\n"
"captured value, neither move nor mutate the value, or capture nothing from "
"the\n"
"environment to begin with."
msgstr ""

#: src/ch13-01-closures.md:428
msgid ""
"The way a closure captures and handles values from the environment affects\n"
"which traits the closure implements, and traits are how functions and "
"structs\n"
"can specify what kinds of closures they can use. Closures will "
"automatically\n"
"implement one, two, or all three of these `Fn` traits, in an additive "
"fashion,\n"
"depending on how the closure‚Äôs body handles the values:"
msgstr ""

#: src/ch13-01-closures.md:434
msgid ""
"1. `FnOnce` applies to closures that can be called once. All closures "
"implement\n"
"   at least this trait, because all closures can be called. A closure that\n"
"   moves captured values out of its body will only implement `FnOnce` and "
"none\n"
"   of the other `Fn` traits, because it can only be called once.\n"
"2. `FnMut` applies to closures that don‚Äôt move captured values out of their\n"
"   body, but that might mutate the captured values. These closures can be\n"
"   called more than once.\n"
"3. `Fn` applies to closures that don‚Äôt move captured values out of their "
"body\n"
"   and that don‚Äôt mutate captured values, as well as closures that capture\n"
"   nothing from their environment. These closures can be called more than "
"once\n"
"   without mutating their environment, which is important in cases such as\n"
"   calling a closure multiple times concurrently."
msgstr ""

#: src/ch13-01-closures.md:447
msgid ""
"Let‚Äôs look at the definition of the `unwrap_or_else` method on `Option<T>` "
"that\n"
"we used in Listing 13-1:"
msgstr ""

#: src/ch13-01-closures.md:450
msgid ""
"```rust,ignore\n"
"impl<T> Option<T> {\n"
"    pub fn unwrap_or_else<F>(self, f: F) -> T\n"
"    where\n"
"        F: FnOnce() -> T\n"
"    {\n"
"        match self {\n"
"            Some(x) => x,\n"
"            None => f(),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:464
msgid ""
"Recall that `T` is the generic type representing the type of the value in "
"the\n"
"`Some` variant of an `Option`. That type `T` is also the return type of the\n"
"`unwrap_or_else` function: code that calls `unwrap_or_else` on an\n"
"`Option<String>`, for example, will get a `String`."
msgstr ""

#: src/ch13-01-closures.md:469
msgid ""
"Next, notice that the `unwrap_or_else` function has the additional generic "
"type\n"
"parameter `F`. The `F` type is the type of the parameter named `f`, which "
"is\n"
"the closure we provide when calling `unwrap_or_else`."
msgstr ""

#: src/ch13-01-closures.md:473
msgid ""
"The trait bound specified on the generic type `F` is `FnOnce() -> T`, which\n"
"means `F` must be able to be called once, take no arguments, and return a "
"`T`.\n"
"Using `FnOnce` in the trait bound expresses the constraint that\n"
"`unwrap_or_else` is only going to call `f` at most one time. In the body of\n"
"`unwrap_or_else`, we can see that if the `Option` is `Some`, `f` won‚Äôt be\n"
"called. If the `Option` is `None`, `f` will be called once. Because all\n"
"closures implement `FnOnce`, `unwrap_or_else` accepts the most different "
"kinds\n"
"of closures and is as flexible as it can be."
msgstr ""

#: src/ch13-01-closures.md:482
msgid ""
"> Note: Functions can implement all three of the `Fn` traits too. If what "
"we\n"
"> want to do doesn‚Äôt require capturing a value from the environment, we can "
"use\n"
"> the name of a function rather than a closure where we need something that\n"
"> implements one of the `Fn` traits. For example, on an `Option<Vec<T>>` "
"value,\n"
"> we could call `unwrap_or_else(Vec::new)` to get a new, empty vector if "
"the\n"
"> value is `None`."
msgstr ""

#: src/ch13-01-closures.md:489
msgid ""
"Now let‚Äôs look at the standard library method `sort_by_key` defined on "
"slices,\n"
"to see how that differs from `unwrap_or_else` and why `sort_by_key` uses\n"
"`FnMut` instead of `FnOnce` for the trait bound. The closure gets one "
"argument\n"
"in the form of a reference to the current item in the slice being "
"considered,\n"
"and returns a value of type `K` that can be ordered. This function is "
"useful\n"
"when you want to sort a slice by a particular attribute of each item. In\n"
"Listing 13-7, we have a list of `Rectangle` instances and we use "
"`sort_by_key`\n"
"to order them by their `width` attribute from low to high:"
msgstr ""

#: src/ch13-01-closures.md:500
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list = [\n"
"        Rectangle { width: 10, height: 1 },\n"
"        Rectangle { width: 3, height: 5 },\n"
"        Rectangle { width: 7, height: 12 },\n"
"    ];\n"
"\n"
"    list.sort_by_key(|r| r.width);\n"
"    println!(\"{:#?}\", list);\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:519
msgid ""
"<span class=\"caption\">Listing 13-7: Using `sort_by_key` to order "
"rectangles by\n"
"width</span>"
msgstr ""

#: src/ch13-01-closures.md:522
msgid "This code prints:"
msgstr ""

#: src/ch13-01-closures.md:524
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n"
"     Running `target/debug/rectangles`\n"
"[\n"
"    Rectangle {\n"
"        width: 3,\n"
"        height: 5,\n"
"    },\n"
"    Rectangle {\n"
"        width: 7,\n"
"        height: 12,\n"
"    },\n"
"    Rectangle {\n"
"        width: 10,\n"
"        height: 1,\n"
"    },\n"
"]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:545
msgid ""
"The reason `sort_by_key` is defined to take an `FnMut` closure is that it "
"calls\n"
"the closure multiple times: once for each item in the slice. The closure `|"
"r|\n"
"r.width` doesn‚Äôt capture, mutate, or move out anything from its environment, "
"so\n"
"it meets the trait bound requirements."
msgstr ""

#: src/ch13-01-closures.md:550
msgid ""
"In contrast, Listing 13-8 shows an example of a closure that implements "
"just\n"
"the `FnOnce` trait, because it moves a value out of the environment. The\n"
"compiler won‚Äôt let us use this closure with `sort_by_key`:"
msgstr ""

#: src/ch13-01-closures.md:556
msgid ""
"```rust,ignore,does_not_compile\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list = [\n"
"        Rectangle { width: 10, height: 1 },\n"
"        Rectangle { width: 3, height: 5 },\n"
"        Rectangle { width: 7, height: 12 },\n"
"    ];\n"
"\n"
"    let mut sort_operations = vec![];\n"
"    let value = String::from(\"by key called\");\n"
"\n"
"    list.sort_by_key(|r| {\n"
"        sort_operations.push(value);\n"
"        r.width\n"
"    });\n"
"    println!(\"{:#?}\", list);\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:581
msgid ""
"<span class=\"caption\">Listing 13-8: Attempting to use an `FnOnce` closure "
"with\n"
"`sort_by_key`</span>"
msgstr ""

#: src/ch13-01-closures.md:584
msgid ""
"This is a contrived, convoluted way (that doesn‚Äôt work) to try and count "
"the\n"
"number of times `sort_by_key` gets called when sorting `list`. This code\n"
"attempts to do this counting by pushing `value`‚Äîa `String` from the "
"closure‚Äôs\n"
"environment‚Äîinto the `sort_operations` vector. The closure captures `value`\n"
"then moves `value` out of the closure by transferring ownership of `value` "
"to\n"
"the `sort_operations` vector. This closure can be called once; trying to "
"call\n"
"it a second time wouldn‚Äôt work because `value` would no longer be in the\n"
"environment to be pushed into `sort_operations` again! Therefore, this "
"closure\n"
"only implements `FnOnce`. When we try to compile this code, we get this "
"error\n"
"that `value` can‚Äôt be moved out of the closure because the closure must\n"
"implement `FnMut`:"
msgstr ""

#: src/ch13-01-closures.md:596
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` "
"closure\n"
"  --> src/main.rs:18:30\n"
"   |\n"
"15 |     let value = String::from(\"by key called\");\n"
"   |         ----- captured outer variable\n"
"16 |\n"
"17 |     list.sort_by_key(|r| {\n"
"   |                      --- captured by this `FnMut` closure\n"
"18 |         sort_operations.push(value);\n"
"   |                              ^^^^^ move occurs because `value` has type "
"`String`, which does not implement the `Copy` trait\n"
"\n"
"For more information about this error, try `rustc --explain E0507`.\n"
"error: could not compile `rectangles` due to previous error\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:614
msgid ""
"The error points to the line in the closure body that moves `value` out of "
"the\n"
"environment. To fix this, we need to change the closure body so that it "
"doesn‚Äôt\n"
"move values out of the environment. To count the number of times "
"`sort_by_key`\n"
"is called, keeping a counter in the environment and incrementing its value "
"in\n"
"the closure body is a more straightforward way to calculate that. The "
"closure\n"
"in Listing 13-9 works with `sort_by_key` because it is only capturing a "
"mutable\n"
"reference to the `num_sort_operations` counter and can therefore be called "
"more\n"
"than once:"
msgstr ""

#: src/ch13-01-closures.md:625
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list = [\n"
"        Rectangle { width: 10, height: 1 },\n"
"        Rectangle { width: 3, height: 5 },\n"
"        Rectangle { width: 7, height: 12 },\n"
"    ];\n"
"\n"
"    let mut num_sort_operations = 0;\n"
"    list.sort_by_key(|r| {\n"
"        num_sort_operations += 1;\n"
"        r.width\n"
"    });\n"
"    println!(\"{:#?}, sorted in {num_sort_operations} operations\", list);\n"
"}\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:648
msgid ""
"<span class=\"caption\">Listing 13-9: Using an `FnMut` closure with "
"`sort_by_key`\n"
"is allowed</span>"
msgstr ""

#: src/ch13-01-closures.md:651
msgid ""
"The `Fn` traits are important when defining or using functions or types "
"that\n"
"make use of closures. In the next section, we‚Äôll discuss iterators. Many\n"
"iterator methods take closure arguments, so keep these closure details in "
"mind\n"
"as we continue!"
msgstr ""

#: src/ch13-02-iterators.md:1
msgid "## Processing a Series of Items with Iterators"
msgstr ""

#: src/ch13-02-iterators.md:3
msgid ""
"The iterator pattern allows you to perform some task on a sequence of items "
"in\n"
"turn. An iterator is responsible for the logic of iterating over each item "
"and\n"
"determining when the sequence has finished. When you use iterators, you "
"don‚Äôt\n"
"have to reimplement that logic yourself."
msgstr ""

#: src/ch13-02-iterators.md:8
msgid ""
"In Rust, iterators are *lazy*, meaning they have no effect until you call\n"
"methods that consume the iterator to use it up. For example, the code in\n"
"Listing 13-10 creates an iterator over the items in the vector `v1` by "
"calling\n"
"the `iter` method defined on `Vec<T>`. This code by itself doesn‚Äôt do "
"anything\n"
"useful."
msgstr ""

#: src/ch13-02-iterators.md:14
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v1 = vec![1, 2, 3];\n"
"\n"
"    let v1_iter = v1.iter();\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:22
msgid "<span class=\"caption\">Listing 13-10: Creating an iterator</span>"
msgstr ""

#: src/ch13-02-iterators.md:24
msgid ""
"The iterator is stored in the `v1_iter` variable. Once we‚Äôve created an\n"
"iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, "
"we\n"
"iterated over an array using a `for` loop to execute some code on each of "
"its\n"
"items. Under the hood this implicitly created and then consumed an "
"iterator,\n"
"but we glossed over how exactly that works until now."
msgstr ""

#: src/ch13-02-iterators.md:30
msgid ""
"In the example in Listing 13-11, we separate the creation of the iterator "
"from\n"
"the use of the iterator in the `for` loop. When the `for` loop is called "
"using\n"
"the iterator in `v1_iter`, each element in the iterator is used in one\n"
"iteration of the loop, which prints out each value."
msgstr ""

#: src/ch13-02-iterators.md:35
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v1 = vec![1, 2, 3];\n"
"\n"
"    let v1_iter = v1.iter();\n"
"\n"
"    for val in v1_iter {\n"
"        println!(\"Got: {}\", val);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:47
msgid ""
"<span class=\"caption\">Listing 13-11: Using an iterator in a `for` loop</"
"span>"
msgstr ""

#: src/ch13-02-iterators.md:49
msgid ""
"In languages that don‚Äôt have iterators provided by their standard "
"libraries,\n"
"you would likely write this same functionality by starting a variable at "
"index\n"
"0, using that variable to index into the vector to get a value, and\n"
"incrementing the variable value in a loop until it reached the total number "
"of\n"
"items in the vector."
msgstr ""

#: src/ch13-02-iterators.md:55
msgid ""
"Iterators handle all that logic for you, cutting down on repetitive code "
"you\n"
"could potentially mess up. Iterators give you more flexibility to use the "
"same\n"
"logic with many different kinds of sequences, not just data structures you "
"can\n"
"index into, like vectors. Let‚Äôs examine how iterators do that."
msgstr ""

#: src/ch13-02-iterators.md:60
msgid "### The `Iterator` Trait and the `next` Method"
msgstr ""

#: src/ch13-02-iterators.md:62
msgid ""
"All iterators implement a trait named `Iterator` that is defined in the\n"
"standard library. The definition of the trait looks like this:"
msgstr ""

#: src/ch13-02-iterators.md:65
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"\n"
"    // methods with default implementations elided\n"
"}\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:75
msgid ""
"Notice this definition uses some new syntax: `type Item` and `Self::Item`,\n"
"which are defining an *associated type* with this trait. We‚Äôll talk about\n"
"associated types in depth in Chapter 19. For now, all you need to know is "
"that\n"
"this code says implementing the `Iterator` trait requires that you also "
"define\n"
"an `Item` type, and this `Item` type is used in the return type of the "
"`next`\n"
"method. In other words, the `Item` type will be the type returned from the\n"
"iterator."
msgstr ""

#: src/ch13-02-iterators.md:83
msgid ""
"The `Iterator` trait only requires implementors to define one method: the\n"
"`next` method, which returns one item of the iterator at a time wrapped in\n"
"`Some` and, when iteration is over, returns `None`."
msgstr ""

#: src/ch13-02-iterators.md:87
msgid ""
"We can call the `next` method on iterators directly; Listing 13-12 "
"demonstrates\n"
"what values are returned from repeated calls to `next` on the iterator "
"created\n"
"from the vector."
msgstr ""

#: src/ch13-02-iterators.md:93
msgid ""
"```rust,noplayground\n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"    #[test]\n"
"    fn iterator_demonstration() {\n"
"        let v1 = vec![1, 2, 3];\n"
"\n"
"        let mut v1_iter = v1.iter();\n"
"\n"
"        assert_eq!(v1_iter.next(), Some(&1));\n"
"        assert_eq!(v1_iter.next(), Some(&2));\n"
"        assert_eq!(v1_iter.next(), Some(&3));\n"
"        assert_eq!(v1_iter.next(), None);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:110
msgid ""
"<span class=\"caption\">Listing 13-12: Calling the `next` method on an\n"
"iterator</span>"
msgstr ""

#: src/ch13-02-iterators.md:113
msgid ""
"Note that we needed to make `v1_iter` mutable: calling the `next` method on "
"an\n"
"iterator changes internal state that the iterator uses to keep track of "
"where\n"
"it is in the sequence. In other words, this code *consumes*, or uses up, "
"the\n"
"iterator. Each call to `next` eats up an item from the iterator. We didn‚Äôt "
"need\n"
"to make `v1_iter` mutable when we used a `for` loop because the loop took\n"
"ownership of `v1_iter` and made it mutable behind the scenes."
msgstr ""

#: src/ch13-02-iterators.md:120
msgid ""
"Also note that the values we get from the calls to `next` are immutable\n"
"references to the values in the vector. The `iter` method produces an "
"iterator\n"
"over immutable references. If we want to create an iterator that takes\n"
"ownership of `v1` and returns owned values, we can call `into_iter` instead "
"of\n"
"`iter`. Similarly, if we want to iterate over mutable references, we can "
"call\n"
"`iter_mut` instead of `iter`."
msgstr ""

#: src/ch13-02-iterators.md:127
msgid "### Methods that Consume the Iterator"
msgstr ""

#: src/ch13-02-iterators.md:129
msgid ""
"The `Iterator` trait has a number of different methods with default\n"
"implementations provided by the standard library; you can find out about "
"these\n"
"methods by looking in the standard library API documentation for the "
"`Iterator`\n"
"trait. Some of these methods call the `next` method in their definition, "
"which\n"
"is why you‚Äôre required to implement the `next` method when implementing the\n"
"`Iterator` trait."
msgstr ""

#: src/ch13-02-iterators.md:136
msgid ""
"Methods that call `next` are called *consuming adaptors*, because calling "
"them\n"
"uses up the iterator. One example is the `sum` method, which takes ownership "
"of\n"
"the iterator and iterates through the items by repeatedly calling `next`, "
"thus\n"
"consuming the iterator. As it iterates through, it adds each item to a "
"running\n"
"total and returns the total when iteration is complete. Listing 13-13 has a\n"
"test illustrating a use of the `sum` method:"
msgstr ""

#: src/ch13-02-iterators.md:145
msgid ""
"```rust,noplayground\n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"    #[test]\n"
"    fn iterator_sum() {\n"
"        let v1 = vec![1, 2, 3];\n"
"\n"
"        let v1_iter = v1.iter();\n"
"\n"
"        let total: i32 = v1_iter.sum();\n"
"\n"
"        assert_eq!(total, 6);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:161
msgid ""
"<span class=\"caption\">Listing 13-13: Calling the `sum` method to get the "
"total\n"
"of all items in the iterator</span>"
msgstr ""

#: src/ch13-02-iterators.md:164
msgid ""
"We aren‚Äôt allowed to use `v1_iter` after the call to `sum` because `sum` "
"takes\n"
"ownership of the iterator we call it on."
msgstr ""

#: src/ch13-02-iterators.md:167
msgid "### Methods that Produce Other Iterators"
msgstr ""

#: src/ch13-02-iterators.md:169
msgid ""
"*Iterator adaptors* are methods defined on the `Iterator` trait that don‚Äôt\n"
"consume the iterator. Instead, they produce different iterators by changing\n"
"some aspect of the original iterator."
msgstr ""

#: src/ch13-02-iterators.md:173
msgid ""
"Listing 13-14 shows an example of calling the iterator adaptor method "
"`map`,\n"
"which takes a closure to call on each item as the items are iterated "
"through.\n"
"The `map` method returns a new iterator that produces the modified items. "
"The\n"
"closure here creates a new iterator in which each item from the vector will "
"be\n"
"incremented by 1:"
msgstr ""

#: src/ch13-02-iterators.md:181
msgid ""
"```rust,not_desired_behavior\n"
"# fn main() {\n"
"    let v1: Vec<i32> = vec![1, 2, 3];\n"
"\n"
"    v1.iter().map(|x| x + 1);\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:189
msgid ""
"<span class=\"caption\">Listing 13-14: Calling the iterator adaptor `map` "
"to\n"
"create a new iterator</span>"
msgstr ""

#: src/ch13-02-iterators.md:192
msgid "However, this code produces a warning:"
msgstr ""

#: src/ch13-02-iterators.md:194
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling iterators v0.1.0 (file:///projects/iterators)\n"
"warning: unused `Map` that must be used\n"
" --> src/main.rs:4:5\n"
"  |\n"
"4 |     v1.iter().map(|x| x + 1);\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: iterators are lazy and do nothing unless consumed\n"
"  = note: `#[warn(unused_must_use)]` on by default\n"
"\n"
"warning: `iterators` (bin \"iterators\") generated 1 warning\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\n"
"     Running `target/debug/iterators`\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:211
msgid ""
"The code in Listing 13-14 doesn‚Äôt do anything; the closure we‚Äôve specified\n"
"never gets called. The warning reminds us why: iterator adaptors are lazy, "
"and\n"
"we need to consume the iterator here."
msgstr ""

#: src/ch13-02-iterators.md:215
msgid ""
"To fix this warning and consume the iterator, we‚Äôll use the `collect` "
"method,\n"
"which we used in Chapter 12 with `env::args` in Listing 12-1. This method\n"
"consumes the iterator and collects the resulting values into a collection "
"data\n"
"type."
msgstr ""

#: src/ch13-02-iterators.md:220
msgid ""
"In Listing 13-15, we collect the results of iterating over the iterator "
"that‚Äôs\n"
"returned from the call to `map` into a vector. This vector will end up\n"
"containing each item from the original vector incremented by 1."
msgstr ""

#: src/ch13-02-iterators.md:226
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v1: Vec<i32> = vec![1, 2, 3];\n"
"\n"
"    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n"
"\n"
"    assert_eq!(v2, vec![2, 3, 4]);\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:236
msgid ""
"<span class=\"caption\">Listing 13-15: Calling the `map` method to create a "
"new\n"
"iterator and then calling the `collect` method to consume the new iterator "
"and\n"
"create a vector</span>"
msgstr ""

#: src/ch13-02-iterators.md:240
msgid ""
"Because `map` takes a closure, we can specify any operation we want to "
"perform\n"
"on each item. This is a great example of how closures let you customize "
"some\n"
"behavior while reusing the iteration behavior that the `Iterator` trait\n"
"provides."
msgstr ""

#: src/ch13-02-iterators.md:245
msgid ""
"You can chain multiple calls to iterator adaptors to perform complex actions "
"in\n"
"a readable way. But because all iterators are lazy, you have to call one of "
"the\n"
"consuming adaptor methods to get results from calls to iterator adaptors."
msgstr ""

#: src/ch13-02-iterators.md:249
msgid "### Using Closures that Capture Their Environment"
msgstr ""

#: src/ch13-02-iterators.md:251
msgid ""
"Many iterator adapters take closures as arguments, and commonly the "
"closures\n"
"we‚Äôll specify as arguments to iterator adapters will be closures that "
"capture\n"
"their environment."
msgstr ""

#: src/ch13-02-iterators.md:255
msgid ""
"For this example, we‚Äôll use the `filter` method that takes a closure. The\n"
"closure gets an item from the iterator and returns a `bool`. If the closure\n"
"returns `true`, the value will be included in the iteration produced by\n"
"`filter`. If the closure returns `false`, the value won‚Äôt be included."
msgstr ""

#: src/ch13-02-iterators.md:260
msgid ""
"In Listing 13-16, we use `filter` with a closure that captures the "
"`shoe_size`\n"
"variable from its environment to iterate over a collection of `Shoe` struct\n"
"instances. It will return only shoes that are the specified size."
msgstr ""

#: src/ch13-02-iterators.md:266
msgid ""
"```rust,noplayground\n"
"#[derive(PartialEq, Debug)]\n"
"struct Shoe {\n"
"    size: u32,\n"
"    style: String,\n"
"}\n"
"\n"
"fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n"
"    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn filters_by_size() {\n"
"        let shoes = vec![\n"
"            Shoe {\n"
"                size: 10,\n"
"                style: String::from(\"sneaker\"),\n"
"            },\n"
"            Shoe {\n"
"                size: 13,\n"
"                style: String::from(\"sandal\"),\n"
"            },\n"
"            Shoe {\n"
"                size: 10,\n"
"                style: String::from(\"boot\"),\n"
"            },\n"
"        ];\n"
"\n"
"        let in_my_size = shoes_in_size(shoes, 10);\n"
"\n"
"        assert_eq!(\n"
"            in_my_size,\n"
"            vec![\n"
"                Shoe {\n"
"                    size: 10,\n"
"                    style: String::from(\"sneaker\")\n"
"                },\n"
"                Shoe {\n"
"                    size: 10,\n"
"                    style: String::from(\"boot\")\n"
"                },\n"
"            ]\n"
"        );\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:317
msgid ""
"<span class=\"caption\">Listing 13-16: Using the `filter` method with a "
"closure\n"
"that captures `shoe_size`</span>"
msgstr ""

#: src/ch13-02-iterators.md:320
msgid ""
"The `shoes_in_size` function takes ownership of a vector of shoes and a "
"shoe\n"
"size as parameters. It returns a vector containing only shoes of the "
"specified\n"
"size."
msgstr ""

#: src/ch13-02-iterators.md:324
msgid ""
"In the body of `shoes_in_size`, we call `into_iter` to create an iterator\n"
"that takes ownership of the vector. Then we call `filter` to adapt that\n"
"iterator into a new iterator that only contains elements for which the "
"closure\n"
"returns `true`."
msgstr ""

#: src/ch13-02-iterators.md:329
msgid ""
"The closure captures the `shoe_size` parameter from the environment and\n"
"compares the value with each shoe‚Äôs size, keeping only shoes of the size\n"
"specified. Finally, calling `collect` gathers the values returned by the\n"
"adapted iterator into a vector that‚Äôs returned by the function."
msgstr ""

#: src/ch13-02-iterators.md:334
msgid ""
"The test shows that when we call `shoes_in_size`, we get back only shoes\n"
"that have the same size as the value we specified."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:1
msgid "## Improving Our I/O Project"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:3
msgid ""
"With this new knowledge about iterators, we can improve the I/O project in\n"
"Chapter 12 by using iterators to make places in the code clearer and more\n"
"concise. Let‚Äôs look at how iterators can improve our implementation of the\n"
"`Config::build` function and the `search` function."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:8
msgid "### Removing a `clone` Using an Iterator"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:10
msgid ""
"In Listing 12-6, we added code that took a slice of `String` values and "
"created\n"
"an instance of the `Config` struct by indexing into the slice and cloning "
"the\n"
"values, allowing the `Config` struct to own those values. In Listing 13-17,\n"
"we‚Äôve reproduced the implementation of the `Config::build` function as it "
"was\n"
"in Listing 12-23:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:18
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n"
"        if args.len() < 3 {\n"
"            return Err(\"not enough arguments\");\n"
"        }\n"
"\n"
"        let query = args[1].clone();\n"
"        let file_path = args[2].clone();\n"
"\n"
"        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n"
"\n"
"        Ok(Config {\n"
"            query,\n"
"            file_path,\n"
"            ignore_case,\n"
"        })\n"
"    }\n"
"}\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:125
msgid ""
"<span class=\"caption\">Listing 13-17: Reproduction of the `Config::build`\n"
"function from Listing 12-23</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:128
msgid ""
"At the time, we said not to worry about the inefficient `clone` calls "
"because\n"
"we would remove them in the future. Well, that time is now!"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:131
msgid ""
"We needed `clone` here because we have a slice with `String` elements in "
"the\n"
"parameter `args`, but the `build` function doesn‚Äôt own `args`. To return\n"
"ownership of a `Config` instance, we had to clone the values from the "
"`query`\n"
"and `file_path` fields of `Config` so the `Config` instance can own its "
"values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:136
msgid ""
"With our new knowledge about iterators, we can change the `build` function "
"to\n"
"take ownership of an iterator as its argument instead of borrowing a slice.\n"
"We‚Äôll use the iterator functionality instead of the code that checks the "
"length\n"
"of the slice and indexes into specific locations. This will clarify what "
"the\n"
"`Config::build` function is doing because the iterator will access the "
"values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:142
msgid ""
"Once `Config::build` takes ownership of the iterator and stops using "
"indexing\n"
"operations that borrow, we can move the `String` values from the iterator "
"into\n"
"`Config` rather than calling `clone` and making a new allocation."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:146
msgid "#### Using the Returned Iterator Directly"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:148
msgid ""
"Open your I/O project‚Äôs *src/main.rs* file, which should look like this:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:152
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::process;\n"
"# \n"
"# use minigrep::Config;\n"
"# \n"
"fn main() {\n"
"    let args: Vec<String> = env::args().collect();\n"
"\n"
"    let config = Config::build(&args).unwrap_or_else(|err| {\n"
"        eprintln!(\"Problem parsing arguments: {err}\");\n"
"        process::exit(1);\n"
"    });\n"
"\n"
"    // --snip--\n"
"# \n"
"#     if let Err(e) = minigrep::run(config) {\n"
"#         eprintln!(\"Application error: {e}\");\n"
"#         process::exit(1);\n"
"#     }\n"
"}\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:175
msgid ""
"We‚Äôll first change the start of the `main` function that we had in Listing\n"
"12-24 to the code in Listing 13-18, which this time uses an iterator. This\n"
"won‚Äôt compile until we update `Config::build` as well."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:181
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::env;\n"
"# use std::process;\n"
"# \n"
"# use minigrep::Config;\n"
"# \n"
"fn main() {\n"
"    let config = Config::build(env::args()).unwrap_or_else(|err| {\n"
"        eprintln!(\"Problem parsing arguments: {err}\");\n"
"        process::exit(1);\n"
"    });\n"
"\n"
"    // --snip--\n"
"# \n"
"#     if let Err(e) = minigrep::run(config) {\n"
"#         eprintln!(\"Application error: {e}\");\n"
"#         process::exit(1);\n"
"#     }\n"
"}\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:202
msgid ""
"<span class=\"caption\">Listing 13-18: Passing the return value of `env::"
"args` to\n"
"`Config::build`</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:205
msgid ""
"The `env::args` function returns an iterator! Rather than collecting the\n"
"iterator values into a vector and then passing a slice to `Config::build`, "
"now\n"
"we‚Äôre passing ownership of the iterator returned from `env::args` to\n"
"`Config::build` directly."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:210
msgid ""
"Next, we need to update the definition of `Config::build`. In your I/O\n"
"project‚Äôs *src/lib.rs* file, let‚Äôs change the signature of `Config::build` "
"to\n"
"look like Listing 13-19. This still won‚Äôt compile because we need to update "
"the\n"
"function body."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:217
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::env;\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    pub fn build(\n"
"        mut args: impl Iterator<Item = String>,\n"
"    ) -> Result<Config, &'static str> {\n"
"        // --snip--\n"
"#         if args.len() < 3 {\n"
"#             return Err(\"not enough arguments\");\n"
"#         }\n"
"# \n"
"#         let query = args[1].clone();\n"
"#         let file_path = args[2].clone();\n"
"# \n"
"#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n"
"# \n"
"#         Ok(Config {\n"
"#             query,\n"
"#             file_path,\n"
"#             ignore_case,\n"
"#         })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:327
msgid ""
"<span class=\"caption\">Listing 13-19: Updating the signature of `Config::"
"build`\n"
"to expect an iterator</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:330
msgid ""
"The standard library documentation for the `env::args` function shows that "
"the\n"
"type of the iterator it returns is `std::env::Args`, and that type "
"implements\n"
"the `Iterator` trait and returns `String` values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:334
msgid ""
"We‚Äôve updated the signature of the `Config::build` function so the "
"parameter\n"
"`args` has a generic type with the trait bounds `impl Iterator<Item = "
"String>`\n"
"instead of `&[String]`. This usage of the `impl Trait` syntax we discussed "
"in\n"
"the [‚ÄúTraits as Parameters‚Äù][impl-trait]<!-- ignore --> section of Chapter "
"10\n"
"means that `args` can be any type that implements the `Iterator` type and\n"
"returns `String` items."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:341
msgid ""
"Because we‚Äôre taking ownership of `args` and we‚Äôll be mutating `args` by\n"
"iterating over it, we can add the `mut` keyword into the specification of "
"the\n"
"`args` parameter to make it mutable."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:345
msgid "#### Using `Iterator` Trait Methods Instead of Indexing"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:347
msgid ""
"Next, we‚Äôll fix the body of `Config::build`. Because `args` implements the\n"
"`Iterator` trait, we know we can call the `next` method on it! Listing "
"13-20\n"
"updates the code from Listing 12-23 to use the `next` method:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:353
msgid ""
"```rust,noplayground\n"
"# use std::env;\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"impl Config {\n"
"    pub fn build(\n"
"        mut args: impl Iterator<Item = String>,\n"
"    ) -> Result<Config, &'static str> {\n"
"        args.next();\n"
"\n"
"        let query = match args.next() {\n"
"            Some(arg) => arg,\n"
"            None => return Err(\"Didn't get a query string\"),\n"
"        };\n"
"\n"
"        let file_path = match args.next() {\n"
"            Some(arg) => arg,\n"
"            None => return Err(\"Didn't get a file path\"),\n"
"        };\n"
"\n"
"        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n"
"\n"
"        Ok(Config {\n"
"            query,\n"
"            file_path,\n"
"            ignore_case,\n"
"        })\n"
"    }\n"
"}\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.contains(query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:467
msgid ""
"<span class=\"caption\">Listing 13-20: Changing the body of `Config::build` "
"to use\n"
"iterator methods</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:470
msgid ""
"Remember that the first value in the return value of `env::args` is the name "
"of\n"
"the program. We want to ignore that and get to the next value, so first we "
"call\n"
"`next` and do nothing with the return value. Second, we call `next` to get "
"the\n"
"value we want to put in the `query` field of `Config`. If `next` returns a\n"
"`Some`, we use a `match` to extract the value. If it returns `None`, it "
"means\n"
"not enough arguments were given and we return early with an `Err` value. We "
"do\n"
"the same thing for the `file_path` value."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:478
msgid "### Making Code Clearer with Iterator Adaptors"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:480
msgid ""
"We can also take advantage of iterators in the `search` function in our I/O\n"
"project, which is reproduced here in Listing 13-21 as it was in Listing "
"12-19:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:542
msgid ""
"<span class=\"caption\">Listing 13-21: The implementation of the `search`\n"
"function from Listing 12-19</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:545
msgid ""
"We can write this code in a more concise way using iterator adaptor "
"methods.\n"
"Doing so also lets us avoid having a mutable intermediate `results` vector. "
"The\n"
"functional programming style prefers to minimize the amount of mutable state "
"to\n"
"make code clearer. Removing the mutable state might enable a future "
"enhancement\n"
"to make searching happen in parallel, because we wouldn‚Äôt have to manage\n"
"concurrent access to the `results` vector. Listing 13-22 shows this change:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:554
msgid ""
"```rust,ignore\n"
"# use std::env;\n"
"# use std::error::Error;\n"
"# use std::fs;\n"
"# \n"
"# pub struct Config {\n"
"#     pub query: String,\n"
"#     pub file_path: String,\n"
"#     pub ignore_case: bool,\n"
"# }\n"
"# \n"
"# impl Config {\n"
"#     pub fn build(\n"
"#         mut args: impl Iterator<Item = String>,\n"
"#     ) -> Result<Config, &'static str> {\n"
"#         args.next();\n"
"# \n"
"#         let query = match args.next() {\n"
"#             Some(arg) => arg,\n"
"#             None => return Err(\"Didn't get a query string\"),\n"
"#         };\n"
"# \n"
"#         let file_path = match args.next() {\n"
"#             Some(arg) => arg,\n"
"#             None => return Err(\"Didn't get a file path\"),\n"
"#         };\n"
"# \n"
"#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n"
"# \n"
"#         Ok(Config {\n"
"#             query,\n"
"#             file_path,\n"
"#             ignore_case,\n"
"#         })\n"
"#     }\n"
"# }\n"
"# \n"
"# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n"
"#     let contents = fs::read_to_string(config.file_path)?;\n"
"# \n"
"#     let results = if config.ignore_case {\n"
"#         search_case_insensitive(&config.query, &contents)\n"
"#     } else {\n"
"#         search(&config.query, &contents)\n"
"#     };\n"
"# \n"
"#     for line in results {\n"
"#         println!(\"{line}\");\n"
"#     }\n"
"# \n"
"#     Ok(())\n"
"# }\n"
"# \n"
"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n"
"    contents\n"
"        .lines()\n"
"        .filter(|line| line.contains(query))\n"
"        .collect()\n"
"}\n"
"# \n"
"# pub fn search_case_insensitive<'a>(\n"
"#     query: &str,\n"
"#     contents: &'a str,\n"
"# ) -> Vec<&'a str> {\n"
"#     let query = query.to_lowercase();\n"
"#     let mut results = Vec::new();\n"
"# \n"
"#     for line in contents.lines() {\n"
"#         if line.to_lowercase().contains(&query) {\n"
"#             results.push(line);\n"
"#         }\n"
"#     }\n"
"# \n"
"#     results\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"# \n"
"#     #[test]\n"
"#     fn case_sensitive() {\n"
"#         let query = \"duct\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\";\n"
"# \n"
"#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, "
"contents));\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     fn case_insensitive() {\n"
"#         let query = \"rUsT\";\n"
"#         let contents = \"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\";\n"
"# \n"
"#         assert_eq!(\n"
"#             vec![\"Rust:\", \"Trust me.\"],\n"
"#             search_case_insensitive(query, contents)\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:663
msgid ""
"<span class=\"caption\">Listing 13-22: Using iterator adaptor methods in "
"the\n"
"implementation of the `search` function</span>"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:666
msgid ""
"Recall that the purpose of the `search` function is to return all lines in\n"
"`contents` that contain the `query`. Similar to the `filter` example in "
"Listing\n"
"13-16, this code uses the `filter` adaptor to keep only the lines that\n"
"`line.contains(query)` returns `true` for. We then collect the matching "
"lines\n"
"into another vector with `collect`. Much simpler! Feel free to make the "
"same\n"
"change to use iterator methods in the `search_case_insensitive` function as\n"
"well."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:674
msgid "### Choosing Between Loops or Iterators"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:676
msgid ""
"The next logical question is which style you should choose in your own code "
"and\n"
"why: the original implementation in Listing 13-21 or the version using\n"
"iterators in Listing 13-22. Most Rust programmers prefer to use the "
"iterator\n"
"style. It‚Äôs a bit tougher to get the hang of at first, but once you get a "
"feel\n"
"for the various iterator adaptors and what they do, iterators can be easier "
"to\n"
"understand. Instead of fiddling with the various bits of looping and "
"building\n"
"new vectors, the code focuses on the high-level objective of the loop. This\n"
"abstracts away some of the commonplace code so it‚Äôs easier to see the "
"concepts\n"
"that are unique to this code, such as the filtering condition each element "
"in\n"
"the iterator must pass."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:687
msgid ""
"But are the two implementations truly equivalent? The intuitive assumption\n"
"might be that the more low-level loop will be faster. Let‚Äôs talk about\n"
"performance."
msgstr ""

#: src/ch13-04-performance.md:1
msgid "## Comparing Performance: Loops vs. Iterators"
msgstr ""

#: src/ch13-04-performance.md:3
msgid ""
"To determine whether to use loops or iterators, you need to know which\n"
"implementation is faster: the version of the `search` function with an "
"explicit\n"
"`for` loop or the version with iterators."
msgstr ""

#: src/ch13-04-performance.md:7
msgid ""
"We ran a benchmark by loading the entire contents of *The Adventures of\n"
"Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for "
"the\n"
"word *the* in the contents. Here are the results of the benchmark on the\n"
"version of `search` using the `for` loop and the version using iterators:"
msgstr ""

#: src/ch13-04-performance.md:12
msgid ""
"```text\n"
"test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)\n"
"test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)\n"
"```"
msgstr ""

#: src/ch13-04-performance.md:17
msgid ""
"The iterator version was slightly faster! We won‚Äôt explain the benchmark "
"code\n"
"here, because the point is not to prove that the two versions are "
"equivalent\n"
"but to get a general sense of how these two implementations compare\n"
"performance-wise."
msgstr ""

#: src/ch13-04-performance.md:22
msgid ""
"For a more comprehensive benchmark, you should check using various texts of\n"
"various sizes as the `contents`, different words and words of different "
"lengths\n"
"as the `query`, and all kinds of other variations. The point is this:\n"
"iterators, although a high-level abstraction, get compiled down to roughly "
"the\n"
"same code as if you‚Äôd written the lower-level code yourself. Iterators are "
"one\n"
"of Rust‚Äôs *zero-cost abstractions*, by which we mean using the abstraction\n"
"imposes no additional runtime overhead. This is analogous to how Bjarne\n"
"Stroustrup, the original designer and implementor of C++, defines\n"
"*zero-overhead* in ‚ÄúFoundations of C++‚Äù (2012):"
msgstr ""

#: src/ch13-04-performance.md:32
msgid ""
"> In general, C++ implementations obey the zero-overhead principle: What "
"you\n"
"> don‚Äôt use, you don‚Äôt pay for. And further: What you do use, you couldn‚Äôt "
"hand\n"
"> code any better."
msgstr ""

#: src/ch13-04-performance.md:36
msgid ""
"As another example, the following code is taken from an audio decoder. The\n"
"decoding algorithm uses the linear prediction mathematical operation to\n"
"estimate future values based on a linear function of the previous samples. "
"This\n"
"code uses an iterator chain to do some math on three variables in scope: a\n"
"`buffer` slice of data, an array of 12 `coefficients`, and an amount by "
"which\n"
"to shift data in `qlp_shift`. We‚Äôve declared the variables within this "
"example\n"
"but not given them any values; although this code doesn‚Äôt have much meaning\n"
"outside of its context, it‚Äôs still a concise, real-world example of how "
"Rust\n"
"translates high-level ideas to low-level code."
msgstr ""

#: src/ch13-04-performance.md:46
msgid ""
"```rust,ignore\n"
"let buffer: &mut [i32];\n"
"let coefficients: [i64; 12];\n"
"let qlp_shift: i16;\n"
"\n"
"for i in 12..buffer.len() {\n"
"    let prediction = coefficients.iter()\n"
"                                 .zip(&buffer[i - 12..i])\n"
"                                 .map(|(&c, &s)| c * s as i64)\n"
"                                 .sum::<i64>() >> qlp_shift;\n"
"    let delta = buffer[i];\n"
"    buffer[i] = prediction as i32 + delta;\n"
"}\n"
"```"
msgstr ""

#: src/ch13-04-performance.md:61
msgid ""
"To calculate the value of `prediction`, this code iterates through each of "
"the\n"
"12 values in `coefficients` and uses the `zip` method to pair the "
"coefficient\n"
"values with the previous 12 values in `buffer`. Then, for each pair, we\n"
"multiply the values together, sum all the results, and shift the bits in "
"the\n"
"sum `qlp_shift` bits to the right."
msgstr ""

#: src/ch13-04-performance.md:67
msgid ""
"Calculations in applications like audio decoders often prioritize "
"performance\n"
"most highly. Here, we‚Äôre creating an iterator, using two adaptors, and then\n"
"consuming the value. What assembly code would this Rust code compile to? "
"Well,\n"
"as of this writing, it compiles down to the same assembly you‚Äôd write by "
"hand.\n"
"There‚Äôs no loop at all corresponding to the iteration over the values in\n"
"`coefficients`: Rust knows that there are 12 iterations, so it ‚Äúunrolls‚Äù "
"the\n"
"loop. *Unrolling* is an optimization that removes the overhead of the loop\n"
"controlling code and instead generates repetitive code for each iteration "
"of\n"
"the loop."
msgstr ""

#: src/ch13-04-performance.md:77
msgid ""
"All of the coefficients get stored in registers, which means accessing the\n"
"values is very fast. There are no bounds checks on the array access at "
"runtime.\n"
"All these optimizations that Rust is able to apply make the resulting code\n"
"extremely efficient. Now that you know this, you can use iterators and "
"closures\n"
"without fear! They make code seem like it‚Äôs higher level but don‚Äôt impose a\n"
"runtime performance penalty for doing so."
msgstr ""

#: src/ch13-04-performance.md:86
msgid ""
"Closures and iterators are Rust features inspired by functional programming\n"
"language ideas. They contribute to Rust‚Äôs capability to clearly express\n"
"high-level ideas at low-level performance. The implementations of closures "
"and\n"
"iterators are such that runtime performance is not affected. This is part "
"of\n"
"Rust‚Äôs goal to strive to provide zero-cost abstractions."
msgstr ""

#: src/ch13-04-performance.md:92
msgid ""
"Now that we‚Äôve improved the expressiveness of our I/O project, let‚Äôs look "
"at\n"
"some more features of `cargo` that will help us share the project with the\n"
"world."
msgstr ""

#: src/ch14-00-more-about-cargo.md:1
msgid "# More About Cargo and Crates.io"
msgstr ""

#: src/ch14-00-more-about-cargo.md:3
msgid ""
"So far we‚Äôve used only the most basic features of Cargo to build, run, and "
"test\n"
"our code, but it can do a lot more. In this chapter, we‚Äôll discuss some of "
"its\n"
"other, more advanced features to show you how to do the following:"
msgstr ""

#: src/ch14-00-more-about-cargo.md:7
msgid ""
"* Customize your build through release profiles\n"
"* Publish libraries on [crates.io](https://crates.io/)<!-- ignore -->\n"
"* Organize large projects with workspaces\n"
"* Install binaries from [crates.io](https://crates.io/)<!-- ignore -->\n"
"* Extend Cargo using custom commands"
msgstr ""

#: src/ch14-00-more-about-cargo.md:13
msgid ""
"Cargo can do even more than the functionality we cover in this chapter, so "
"for\n"
"a full explanation of all its features, see [its\n"
"documentation](https://doc.rust-lang.org/cargo/)."
msgstr ""

#: src/ch14-01-release-profiles.md:1
msgid "## Customizing Builds with Release Profiles"
msgstr ""

#: src/ch14-01-release-profiles.md:3
msgid ""
"In Rust, *release profiles* are predefined and customizable profiles with\n"
"different configurations that allow a programmer to have more control over\n"
"various options for compiling code. Each profile is configured independently "
"of\n"
"the others."
msgstr ""

#: src/ch14-01-release-profiles.md:8
msgid ""
"Cargo has two main profiles: the `dev` profile Cargo uses when you run "
"`cargo\n"
"build` and the `release` profile Cargo uses when you run `cargo build\n"
"--release`. The `dev` profile is defined with good defaults for "
"development,\n"
"and the `release` profile has good defaults for release builds."
msgstr ""

#: src/ch14-01-release-profiles.md:13
msgid "These profile names might be familiar from the output of your builds:"
msgstr ""

#: src/ch14-01-release-profiles.md:15
msgid ""
"<!-- manual-regeneration\n"
"anywhere, run:\n"
"cargo build\n"
"cargo build --release\n"
"and ensure output below is accurate\n"
"-->"
msgstr ""

#: src/ch14-01-release-profiles.md:22
msgid ""
"```console\n"
"$ cargo build\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"$ cargo build --release\n"
"    Finished release [optimized] target(s) in 0.0s\n"
"```"
msgstr ""

#: src/ch14-01-release-profiles.md:29
msgid ""
"The `dev` and `release` are these different profiles used by the compiler."
msgstr ""

#: src/ch14-01-release-profiles.md:31
msgid ""
"Cargo has default settings for each of the profiles that apply when you "
"haven't\n"
"explicitly added any `[profile.*]` sections in the project‚Äôs *Cargo.toml* "
"file.\n"
"By adding `[profile.*]` sections for any profile you want to customize, you\n"
"override any subset of the default settings. For example, here are the "
"default\n"
"values for the `opt-level` setting for the `dev` and `release` profiles:"
msgstr ""

#: src/ch14-01-release-profiles.md:39
msgid ""
"```toml\n"
"[profile.dev]\n"
"opt-level = 0\n"
"\n"
"[profile.release]\n"
"opt-level = 3\n"
"```"
msgstr ""

#: src/ch14-01-release-profiles.md:47
msgid ""
"The `opt-level` setting controls the number of optimizations Rust will apply "
"to\n"
"your code, with a range of 0 to 3. Applying more optimizations extends\n"
"compiling time, so if you‚Äôre in development and compiling your code often,\n"
"you‚Äôll want fewer optimizations to compile faster even if the resulting "
"code\n"
"runs slower. The default `opt-level` for `dev` is therefore `0`. When "
"you‚Äôre\n"
"ready to release your code, it‚Äôs best to spend more time compiling. You‚Äôll "
"only\n"
"compile in release mode once, but you‚Äôll run the compiled program many "
"times,\n"
"so release mode trades longer compile time for code that runs faster. That "
"is\n"
"why the default `opt-level` for the `release` profile is `3`."
msgstr ""

#: src/ch14-01-release-profiles.md:57
msgid ""
"You can override a default setting by adding a different value for it in\n"
"*Cargo.toml*. For example, if we want to use optimization level 1 in the\n"
"development profile, we can add these two lines to our project‚Äôs *Cargo."
"toml*\n"
"file:"
msgstr ""

#: src/ch14-01-release-profiles.md:64
msgid ""
"```toml\n"
"[profile.dev]\n"
"opt-level = 1\n"
"```"
msgstr ""

#: src/ch14-01-release-profiles.md:69
msgid ""
"This code overrides the default setting of `0`. Now when we run `cargo "
"build`,\n"
"Cargo will use the defaults for the `dev` profile plus our customization to\n"
"`opt-level`. Because we set `opt-level` to `1`, Cargo will apply more\n"
"optimizations than the default, but not as many as in a release build."
msgstr ""

#: src/ch14-01-release-profiles.md:74
msgid ""
"For the full list of configuration options and defaults for each profile, "
"see\n"
"[Cargo‚Äôs documentation](https://doc.rust-lang.org/cargo/reference/profiles."
"html)."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:1
msgid "## Publishing a Crate to Crates.io"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:3
msgid ""
"We‚Äôve used packages from [crates.io](https://crates.io/)<!-- ignore --> as\n"
"dependencies of our project, but you can also share your code with other "
"people\n"
"by publishing your own packages. The crate registry at\n"
"[crates.io](https://crates.io/)<!-- ignore --> distributes the source code "
"of\n"
"your packages, so it primarily hosts code that is open source."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:9
msgid ""
"Rust and Cargo have features that make your published package easier for "
"people\n"
"to find and use. We‚Äôll talk about some of these features next and then "
"explain\n"
"how to publish a package."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:13
msgid "### Making Useful Documentation Comments"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:15
msgid ""
"Accurately documenting your packages will help other users know how and when "
"to\n"
"use them, so it‚Äôs worth investing the time to write documentation. In "
"Chapter\n"
"3, we discussed how to comment Rust code using two slashes, `//`. Rust also "
"has\n"
"a particular kind of comment for documentation, known conveniently as a\n"
"*documentation comment*, that will generate HTML documentation. The HTML\n"
"displays the contents of documentation comments for public API items "
"intended\n"
"for programmers interested in knowing how to *use* your crate as opposed to "
"how\n"
"your crate is *implemented*."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:24
msgid ""
"Documentation comments use three slashes, `///`, instead of two and support\n"
"Markdown notation for formatting the text. Place documentation comments "
"just\n"
"before the item they‚Äôre documenting. Listing 14-1 shows documentation "
"comments\n"
"for an `add_one` function in a crate named `my_crate`."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:31
msgid ""
"```rust,ignore\n"
"/// Adds one to the number given.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let arg = 5;\n"
"/// let answer = my_crate::add_one(arg);\n"
"///\n"
"/// assert_eq!(6, answer);\n"
"/// ```\n"
"pub fn add_one(x: i32) -> i32 {\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:47
msgid ""
"<span class=\"caption\">Listing 14-1: A documentation comment for a\n"
"function</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:50
msgid ""
"Here, we give a description of what the `add_one` function does, start a\n"
"section with the heading `Examples`, and then provide code that "
"demonstrates\n"
"how to use the `add_one` function. We can generate the HTML documentation "
"from\n"
"this documentation comment by running `cargo doc`. This command runs the\n"
"`rustdoc` tool distributed with Rust and puts the generated HTML "
"documentation\n"
"in the *target/doc* directory."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:57
msgid ""
"For convenience, running `cargo doc --open` will build the HTML for your\n"
"current crate‚Äôs documentation (as well as the documentation for all of your\n"
"crate‚Äôs dependencies) and open the result in a web browser. Navigate to the\n"
"`add_one` function and you‚Äôll see how the text in the documentation comments "
"is\n"
"rendered, as shown in Figure 14-1:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:63
msgid ""
"<img alt=\"Rendered HTML documentation for the `add_one` function of "
"`my_crate`\" src=\"img/trpl14-01.png\" class=\"center\" />"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:65
msgid ""
"<span class=\"caption\">Figure 14-1: HTML documentation for the `add_one`\n"
"function</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:68
msgid "#### Commonly Used Sections"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:70
msgid ""
"We used the `# Examples` Markdown heading in Listing 14-1 to create a "
"section\n"
"in the HTML with the title ‚ÄúExamples.‚Äù Here are some other sections that "
"crate\n"
"authors commonly use in their documentation:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:74
msgid ""
"* **Panics**: The scenarios in which the function being documented could\n"
"  panic. Callers of the function who don‚Äôt want their programs to panic "
"should\n"
"  make sure they don‚Äôt call the function in these situations.\n"
"* **Errors**: If the function returns a `Result`, describing the kinds of\n"
"  errors that might occur and what conditions might cause those errors to "
"be\n"
"  returned can be helpful to callers so they can write code to handle the\n"
"  different kinds of errors in different ways.\n"
"* **Safety**: If the function is `unsafe` to call (we discuss unsafety in\n"
"  Chapter 19), there should be a section explaining why the function is "
"unsafe\n"
"  and covering the invariants that the function expects callers to uphold."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:85
msgid ""
"Most documentation comments don‚Äôt need all of these sections, but this is a\n"
"good checklist to remind you of the aspects of your code users will be\n"
"interested in knowing about."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:89
msgid "#### Documentation Comments as Tests"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:91
msgid ""
"Adding example code blocks in your documentation comments can help "
"demonstrate\n"
"how to use your library, and doing so has an additional bonus: running "
"`cargo\n"
"test` will run the code examples in your documentation as tests! Nothing is\n"
"better than documentation with examples. But nothing is worse than examples\n"
"that don‚Äôt work because the code has changed since the documentation was\n"
"written. If we run `cargo test` with the documentation for the `add_one`\n"
"function from Listing 14-1, we will see a section in the test results like "
"this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:99
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/listing-14-01/\n"
"cargo test\n"
"copy just the doc-tests section below\n"
"-->"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:105
msgid ""
"```text\n"
"   Doc-tests my_crate\n"
"\n"
"running 1 test\n"
"test src/lib.rs - add_one (line 5) ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.27s\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:114
msgid ""
"Now if we change either the function or the example so the `assert_eq!` in "
"the\n"
"example panics and run `cargo test` again, we‚Äôll see that the doc tests "
"catch\n"
"that the example and the code are out of sync with each other!"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:118
msgid "#### Commenting Contained Items"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:120
msgid ""
"The style of doc comment `//!` adds documentation to the item that contains "
"the\n"
"comments rather than to the items following the comments. We typically use\n"
"these doc comments inside the crate root file (*src/lib.rs* by convention) "
"or\n"
"inside a module to document the crate or the module as a whole."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:125
msgid ""
"For example, to add documentation that describes the purpose of the "
"`my_crate`\n"
"crate that contains the `add_one` function, we add documentation comments "
"that\n"
"start with `//!` to the beginning of the *src/lib.rs* file, as shown in "
"Listing\n"
"14-2:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:132
msgid ""
"```rust,ignore\n"
"//! # My Crate\n"
"//!\n"
"//! `my_crate` is a collection of utilities to make performing certain\n"
"//! calculations more convenient.\n"
"\n"
"/// Adds one to the number given.\n"
"// --snip--\n"
"# ///\n"
"# /// # Examples\n"
"# ///\n"
"# /// ```\n"
"# /// let arg = 5;\n"
"# /// let answer = my_crate::add_one(arg);\n"
"# ///\n"
"# /// assert_eq!(6, answer);\n"
"# /// ```\n"
"# pub fn add_one(x: i32) -> i32 {\n"
"#     x + 1\n"
"# }\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:154
msgid ""
"<span class=\"caption\">Listing 14-2: Documentation for the `my_crate` crate "
"as a\n"
"whole</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:157
msgid ""
"Notice there isn‚Äôt any code after the last line that begins with `//!`. "
"Because\n"
"we started the comments with `//!` instead of `///`, we‚Äôre documenting the "
"item\n"
"that contains this comment rather than an item that follows this comment. "
"In\n"
"this case, that item is the *src/lib.rs* file, which is the crate root. "
"These\n"
"comments describe the entire crate."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:163
msgid ""
"When we run `cargo doc --open`, these comments will display on the front\n"
"page of the documentation for `my_crate` above the list of public items in "
"the\n"
"crate, as shown in Figure 14-2:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:167
msgid ""
"<img alt=\"Rendered HTML documentation with a comment for the crate as a "
"whole\" src=\"img/trpl14-02.png\" class=\"center\" />"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:169
msgid ""
"<span class=\"caption\">Figure 14-2: Rendered documentation for `my_crate`,\n"
"including the comment describing the crate as a whole</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:172
msgid ""
"Documentation comments within items are useful for describing crates and\n"
"modules especially. Use them to explain the overall purpose of the container "
"to\n"
"help your users understand the crate‚Äôs organization."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:176
msgid "### Exporting a Convenient Public API with `pub use`"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:178
msgid ""
"The structure of your public API is a major consideration when publishing a\n"
"crate. People who use your crate are less familiar with the structure than "
"you\n"
"are and might have difficulty finding the pieces they want to use if your "
"crate\n"
"has a large module hierarchy."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:183
msgid ""
"In Chapter 7, we covered how to make items public using the `pub` keyword, "
"and\n"
"bring items into a scope with the `use` keyword. However, the structure "
"that\n"
"makes sense to you while you‚Äôre developing a crate might not be very "
"convenient\n"
"for your users. You might want to organize your structs in a hierarchy\n"
"containing multiple levels, but then people who want to use a type you‚Äôve\n"
"defined deep in the hierarchy might have trouble finding out that type "
"exists.\n"
"They might also be annoyed at having to enter `use`\n"
"`my_crate::some_module::another_module::UsefulType;` rather than `use`\n"
"`my_crate::UsefulType;`."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:193
msgid ""
"The good news is that if the structure *isn‚Äôt* convenient for others to use\n"
"from another library, you don‚Äôt have to rearrange your internal "
"organization:\n"
"instead, you can re-export items to make a public structure that‚Äôs "
"different\n"
"from your private structure by using `pub use`. Re-exporting takes a public\n"
"item in one location and makes it public in another location, as if it were\n"
"defined in the other location instead."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:200
msgid ""
"For example, say we made a library named `art` for modeling artistic "
"concepts.\n"
"Within this library are two modules: a `kinds` module containing two enums\n"
"named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a\n"
"function named `mix`, as shown in Listing 14-3:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:207
msgid ""
"```rust,noplayground,test_harness\n"
"//! # Art\n"
"//!\n"
"//! A library for modeling artistic concepts.\n"
"\n"
"pub mod kinds {\n"
"    /// The primary colors according to the RYB color model.\n"
"    pub enum PrimaryColor {\n"
"        Red,\n"
"        Yellow,\n"
"        Blue,\n"
"    }\n"
"\n"
"    /// The secondary colors according to the RYB color model.\n"
"    pub enum SecondaryColor {\n"
"        Orange,\n"
"        Green,\n"
"        Purple,\n"
"    }\n"
"}\n"
"\n"
"pub mod utils {\n"
"    use crate::kinds::*;\n"
"\n"
"    /// Combines two primary colors in equal amounts to create\n"
"    /// a secondary color.\n"
"    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n"
"        // --snip--\n"
"#         unimplemented!();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:240
msgid ""
"<span class=\"caption\">Listing 14-3: An `art` library with items organized "
"into\n"
"`kinds` and `utils` modules</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:243
msgid ""
"Figure 14-3 shows what the front page of the documentation for this crate\n"
"generated by `cargo doc` would look like:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:246
msgid ""
"<img alt=\"Rendered documentation for the `art` crate that lists the `kinds` "
"and `utils` modules\" src=\"img/trpl14-03.png\" class=\"center\" />"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:248
msgid ""
"<span class=\"caption\">Figure 14-3: Front page of the documentation for "
"`art`\n"
"that lists the `kinds` and `utils` modules</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:251
msgid ""
"Note that the `PrimaryColor` and `SecondaryColor` types aren‚Äôt listed on "
"the\n"
"front page, nor is the `mix` function. We have to click `kinds` and `utils` "
"to\n"
"see them."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:255
msgid ""
"Another crate that depends on this library would need `use` statements that\n"
"bring the items from `art` into scope, specifying the module structure "
"that‚Äôs\n"
"currently defined. Listing 14-4 shows an example of a crate that uses the\n"
"`PrimaryColor` and `mix` items from the `art` crate:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:262
msgid ""
"```rust,ignore\n"
"use art::kinds::PrimaryColor;\n"
"use art::utils::mix;\n"
"\n"
"fn main() {\n"
"    let red = PrimaryColor::Red;\n"
"    let yellow = PrimaryColor::Yellow;\n"
"    mix(red, yellow);\n"
"}\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:273
msgid ""
"<span class=\"caption\">Listing 14-4: A crate using the `art` crate‚Äôs items "
"with\n"
"its internal structure exported</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:276
msgid ""
"The author of the code in Listing 14-4, which uses the `art` crate, had to\n"
"figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the\n"
"`utils` module. The module structure of the `art` crate is more relevant to\n"
"developers working on the `art` crate than to those using it. The internal\n"
"structure doesn‚Äôt contain any useful information for someone trying to\n"
"understand how to use the `art` crate, but rather causes confusion because\n"
"developers who use it have to figure out where to look, and must specify "
"the\n"
"module names in the `use` statements."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:285
msgid ""
"To remove the internal organization from the public API, we can modify the\n"
"`art` crate code in Listing 14-3 to add `pub use` statements to re-export "
"the\n"
"items at the top level, as shown in Listing 14-5:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:291
msgid ""
"```rust,ignore\n"
"//! # Art\n"
"//!\n"
"//! A library for modeling artistic concepts.\n"
"\n"
"pub use self::kinds::PrimaryColor;\n"
"pub use self::kinds::SecondaryColor;\n"
"pub use self::utils::mix;\n"
"\n"
"pub mod kinds {\n"
"    // --snip--\n"
"#     /// The primary colors according to the RYB color model.\n"
"#     pub enum PrimaryColor {\n"
"#         Red,\n"
"#         Yellow,\n"
"#         Blue,\n"
"#     }\n"
"# \n"
"#     /// The secondary colors according to the RYB color model.\n"
"#     pub enum SecondaryColor {\n"
"#         Orange,\n"
"#         Green,\n"
"#         Purple,\n"
"#     }\n"
"}\n"
"\n"
"pub mod utils {\n"
"    // --snip--\n"
"#     use crate::kinds::*;\n"
"# \n"
"#     /// Combines two primary colors in equal amounts to create\n"
"#     /// a secondary color.\n"
"#     pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n"
"#         SecondaryColor::Orange\n"
"#     }\n"
"}\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:329
msgid ""
"<span class=\"caption\">Listing 14-5: Adding `pub use` statements to re-"
"export\n"
"items</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:332
msgid ""
"The API documentation that `cargo doc` generates for this crate will now "
"list\n"
"and link re-exports on the front page, as shown in Figure 14-4, making the\n"
"`PrimaryColor` and `SecondaryColor` types and the `mix` function easier to "
"find."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:336
msgid ""
"<img alt=\"Rendered documentation for the `art` crate with the re-exports on "
"the front page\" src=\"img/trpl14-04.png\" class=\"center\" />"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:338
msgid ""
"<span class=\"caption\">Figure 14-4: The front page of the documentation for "
"`art`\n"
"that lists the re-exports</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:341
msgid ""
"The `art` crate users can still see and use the internal structure from "
"Listing\n"
"14-3 as demonstrated in Listing 14-4, or they can use the more convenient\n"
"structure in Listing 14-5, as shown in Listing 14-6:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:347
msgid ""
"```rust,ignore\n"
"use art::mix;\n"
"use art::PrimaryColor;\n"
"\n"
"fn main() {\n"
"    // --snip--\n"
"#     let red = PrimaryColor::Red;\n"
"#     let yellow = PrimaryColor::Yellow;\n"
"#     mix(red, yellow);\n"
"}\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:359
msgid ""
"<span class=\"caption\">Listing 14-6: A program using the re-exported items "
"from\n"
"the `art` crate</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:362
msgid ""
"In cases where there are many nested modules, re-exporting the types at the "
"top\n"
"level with `pub use` can make a significant difference in the experience of\n"
"people who use the crate. Another common use of `pub use` is to re-export\n"
"definitions of a dependency in the current crate to make that crate's\n"
"definitions part of your crate‚Äôs public API."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:368
msgid ""
"Creating a useful public API structure is more of an art than a science, "
"and\n"
"you can iterate to find the API that works best for your users. Choosing "
"`pub\n"
"use` gives you flexibility in how you structure your crate internally and\n"
"decouples that internal structure from what you present to your users. Look "
"at\n"
"some of the code of crates you‚Äôve installed to see if their internal "
"structure\n"
"differs from their public API."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:375
msgid "### Setting Up a Crates.io Account"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:377
msgid ""
"Before you can publish any crates, you need to create an account on\n"
"[crates.io](https://crates.io/)<!-- ignore --> and get an API token. To do "
"so,\n"
"visit the home page at [crates.io](https://crates.io/)<!-- ignore --> and "
"log\n"
"in via a GitHub account. (The GitHub account is currently a requirement, "
"but\n"
"the site might support other ways of creating an account in the future.) "
"Once\n"
"you‚Äôre logged in, visit your account settings at\n"
"[https://crates.io/me/](https://crates.io/me/)<!-- ignore --> and retrieve "
"your\n"
"API key. Then run the `cargo login` command with your API key, like this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:386
msgid ""
"```console\n"
"$ cargo login abcdefghijklmnopqrstuvwxyz012345\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:390
msgid ""
"This command will inform Cargo of your API token and store it locally in\n"
"*~/.cargo/credentials*. Note that this token is a *secret*: do not share it\n"
"with anyone else. If you do share it with anyone for any reason, you should\n"
"revoke it and generate a new token on [crates.io](https://crates.io/)<!-- "
"ignore\n"
"-->."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:396
msgid "### Adding Metadata to a New Crate"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:398
msgid ""
"Let‚Äôs say you have a crate you want to publish. Before publishing, you‚Äôll "
"need\n"
"to add some metadata in the `[package]` section of the crate‚Äôs *Cargo.toml*\n"
"file."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:402
msgid ""
"Your crate will need a unique name. While you‚Äôre working on a crate "
"locally,\n"
"you can name a crate whatever you‚Äôd like. However, crate names on\n"
"[crates.io](https://crates.io/)<!-- ignore --> are allocated on a first-"
"come,\n"
"first-served basis. Once a crate name is taken, no one else can publish a "
"crate\n"
"with that name. Before attempting to publish a crate, search for the name "
"you\n"
"want to use. If the name has been used, you will need to find another name "
"and\n"
"edit the `name` field in the *Cargo.toml* file under the `[package]` section "
"to\n"
"use the new name for publishing, like so:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:413
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:418
msgid ""
"Even if you‚Äôve chosen a unique name, when you run `cargo publish` to "
"publish\n"
"the crate at this point, you‚Äôll get a warning and then an error:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:421
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/listing-14-01/\n"
"cargo publish\n"
"copy just the relevant lines below\n"
"-->"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:427
msgid ""
"```console\n"
"$ cargo publish\n"
"    Updating crates.io index\n"
"warning: manifest has no description, license, license-file, documentation, "
"homepage or repository.\n"
"See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata "
"for more info.\n"
"--snip--\n"
"error: failed to publish to registry at https://crates.io\n"
"\n"
"Caused by:\n"
"  the remote server responded with an error: missing or empty metadata "
"fields: description, license. Please see https://doc.rust-lang.org/cargo/"
"reference/manifest.html for how to upload metadata\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:439
msgid ""
"This errors because you‚Äôre missing some crucial information: a description "
"and\n"
"license are required so people will know what your crate does and under "
"what\n"
"terms they can use it. In *Cargo.toml*, add a description that's just a\n"
"sentence or two, because it will appear with your crate in search results. "
"For\n"
"the `license` field, you need to give a *license identifier value*. The "
"[Linux\n"
"Foundation‚Äôs Software Package Data Exchange (SPDX)][spdx] lists the "
"identifiers\n"
"you can use for this value. For example, to specify that you‚Äôve licensed "
"your\n"
"crate using the MIT License, add the `MIT` identifier:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:450
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"license = \"MIT\"\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:456
msgid ""
"If you want to use a license that doesn‚Äôt appear in the SPDX, you need to "
"place\n"
"the text of that license in a file, include the file in your project, and "
"then\n"
"use `license-file` to specify the name of that file instead of using the\n"
"`license` key."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:461
msgid ""
"Guidance on which license is appropriate for your project is beyond the "
"scope\n"
"of this book. Many people in the Rust community license their projects in "
"the\n"
"same way as Rust by using a dual license of `MIT OR Apache-2.0`. This "
"practice\n"
"demonstrates that you can also specify multiple license identifiers "
"separated\n"
"by `OR` to have multiple licenses for your project."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:467
msgid ""
"With a unique name, the version, your description, and a license added, the\n"
"*Cargo.toml* file for a project that is ready to publish might look like "
"this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:472
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"description = \"A fun game where you guess what number the computer has "
"chosen.\"\n"
"license = \"MIT OR Apache-2.0\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:483
msgid ""
"[Cargo‚Äôs documentation](https://doc.rust-lang.org/cargo/) describes other\n"
"metadata you can specify to ensure others can discover and use your crate "
"more\n"
"easily."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:487
msgid "### Publishing to Crates.io"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:489
msgid ""
"Now that you‚Äôve created an account, saved your API token, chosen a name for\n"
"your crate, and specified the required metadata, you‚Äôre ready to publish!\n"
"Publishing a crate uploads a specific version to\n"
"[crates.io](https://crates.io/)<!-- ignore --> for others to use."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:494
msgid ""
"Be careful, because a publish is *permanent*. The version can never be\n"
"overwritten, and the code cannot be deleted. One major goal of\n"
"[crates.io](https://crates.io/)<!-- ignore --> is to act as a permanent "
"archive\n"
"of code so that builds of all projects that depend on crates from\n"
"[crates.io](https://crates.io/)<!-- ignore --> will continue to work. "
"Allowing\n"
"version deletions would make fulfilling that goal impossible. However, there "
"is\n"
"no limit to the number of crate versions you can publish."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:502
msgid "Run the `cargo publish` command again. It should succeed now:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:504
msgid ""
"<!-- manual-regeneration\n"
"go to some valid crate, publish a new version\n"
"cargo publish\n"
"copy just the relevant lines below\n"
"-->"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:510
msgid ""
"```console\n"
"$ cargo publish\n"
"    Updating crates.io index\n"
"   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"   Compiling guessing_game v0.1.0\n"
"(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.19s\n"
"   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:521
msgid ""
"Congratulations! You‚Äôve now shared your code with the Rust community, and\n"
"anyone can easily add your crate as a dependency of their project."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:524
msgid "### Publishing a New Version of an Existing Crate"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:526
msgid ""
"When you‚Äôve made changes to your crate and are ready to release a new "
"version,\n"
"you change the `version` value specified in your *Cargo.toml* file and\n"
"republish. Use the [Semantic Versioning rules][semver] to decide what an\n"
"appropriate next version number is based on the kinds of changes you‚Äôve "
"made.\n"
"Then run `cargo publish` to upload the new version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:532
#: src/ch14-04-installing-binaries.md:1 src/ch15-02-deref.md:22
msgid "<!-- Old link, do not remove -->"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:533
msgid "<a id=\"removing-versions-from-cratesio-with-cargo-yank\"></a>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:535
msgid "### Deprecating Versions from Crates.io with `cargo yank`"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:537
msgid ""
"Although you can‚Äôt remove previous versions of a crate, you can prevent any\n"
"future projects from adding them as a new dependency. This is useful when a\n"
"crate version is broken for one reason or another. In such situations, "
"Cargo\n"
"supports *yanking* a crate version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:542
msgid ""
"Yanking a version prevents new projects from depending on that version "
"while\n"
"allowing all existing projects that depend on it to continue. Essentially, "
"a\n"
"yank means that all projects with a *Cargo.lock* will not break, and any "
"future\n"
"*Cargo.lock* files generated will not use the yanked version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:547
msgid ""
"To yank a version of a crate, in the directory of the crate that you‚Äôve\n"
"previously published, run `cargo yank` and specify which version you want "
"to\n"
"yank. For example, if we've published a crate named `guessing_game` version\n"
"1.0.1 and we want to yank it, in the project directory for `guessing_game` "
"we'd\n"
"run:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:553
msgid ""
"<!-- manual-regeneration:\n"
"cargo yank carol-test --version 2.1.0\n"
"cargo yank carol-test --version 2.1.0 --undo\n"
"-->"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:558
msgid ""
"```console\n"
"$ cargo yank --vers 1.0.1\n"
"    Updating crates.io index\n"
"        Yank guessing_game@1.0.1\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:564
msgid ""
"By adding `--undo` to the command, you can also undo a yank and allow "
"projects\n"
"to start depending on a version again:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:567
msgid ""
"```console\n"
"$ cargo yank --vers 1.0.1 --undo\n"
"    Updating crates.io index\n"
"      Unyank guessing_game@1.0.1\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:573
msgid ""
"A yank *does not* delete any code. It cannot, for example, delete "
"accidentally\n"
"uploaded secrets. If that happens, you must reset those secrets immediately."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:1
msgid "## Cargo Workspaces"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:3
msgid ""
"In Chapter 12, we built a package that included a binary crate and a "
"library\n"
"crate. As your project develops, you might find that the library crate\n"
"continues to get bigger and you want to split your package further into\n"
"multiple library crates. Cargo offers a feature called *workspaces* that "
"can\n"
"help manage multiple related packages that are developed in tandem."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:9
msgid "### Creating a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:11
msgid ""
"A *workspace* is a set of packages that share the same *Cargo.lock* and "
"output\n"
"directory. Let‚Äôs make a project using a workspace‚Äîwe‚Äôll use trivial code so "
"we\n"
"can concentrate on the structure of the workspace. There are multiple ways "
"to\n"
"structure a workspace, so we'll just show one common way. We‚Äôll have a\n"
"workspace containing a binary and two libraries. The binary, which will "
"provide\n"
"the main functionality, will depend on the two libraries. One library will\n"
"provide an `add_one` function, and a second library an `add_two` function.\n"
"These three crates will be part of the same workspace. We‚Äôll start by "
"creating\n"
"a new directory for the workspace:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:21
msgid ""
"```console\n"
"$ mkdir add\n"
"$ cd add\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:26
msgid ""
"Next, in the *add* directory, we create the *Cargo.toml* file that will\n"
"configure the entire workspace. This file won‚Äôt have a `[package]` section.\n"
"Instead, it will start with a `[workspace]` section that will allow us to "
"add\n"
"members to the workspace by specifying the path to the package with our "
"binary\n"
"crate; in this case, that path is *adder*:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:34
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"members = [\n"
"    \"adder\",\n"
"]\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:42
msgid ""
"Next, we‚Äôll create the `adder` binary crate by running `cargo new` within "
"the\n"
"*add* directory:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:45
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add\n"
"rm -rf adder\n"
"cargo new adder\n"
"copy output below\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:52
msgid ""
"```console\n"
"$ cargo new adder\n"
"     Created binary (application) `adder` package\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:57
msgid ""
"At this point, we can build the workspace by running `cargo build`. The "
"files\n"
"in your *add* directory should look like this:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:60
msgid ""
"```text\n"
"‚îú‚îÄ‚îÄ Cargo.lock\n"
"‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îú‚îÄ‚îÄ adder\n"
"‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îÇ   ‚îî‚îÄ‚îÄ src\n"
"‚îÇ       ‚îî‚îÄ‚îÄ main.rs\n"
"‚îî‚îÄ‚îÄ target\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:70
msgid ""
"The workspace has one *target* directory at the top level that the compiled\n"
"artifacts will be placed into; the `adder` package doesn‚Äôt have its own\n"
"*target* directory. Even if we were to run `cargo build` from inside the\n"
"*adder* directory, the compiled artifacts would still end up in *add/"
"target*\n"
"rather than *add/adder/target*. Cargo structures the *target* directory in "
"a\n"
"workspace like this because the crates in a workspace are meant to depend "
"on\n"
"each other. If each crate had its own *target* directory, each crate would "
"have\n"
"to recompile each of the other crates in the workspace to place the "
"artifacts\n"
"in its own *target* directory. By sharing one *target* directory, the "
"crates\n"
"can avoid unnecessary rebuilding."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:81
msgid "### Creating the Second Package in the Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:83
msgid ""
"Next, let‚Äôs create another member package in the workspace and call it\n"
"`add_one`. Change the top-level *Cargo.toml* to specify the *add_one* path "
"in\n"
"the `members` list:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:89
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"members = [\n"
"    \"adder\",\n"
"    \"add_one\",\n"
"]\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:98
msgid "Then generate a new library crate named `add_one`:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:100
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/output-only-02-add-one/add\n"
"rm -rf add_one\n"
"cargo new add_one --lib\n"
"copy output below\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:107
msgid ""
"```console\n"
"$ cargo new add_one --lib\n"
"     Created library `add_one` package\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:112
msgid "Your *add* directory should now have these directories and files:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:114
msgid ""
"```text\n"
"‚îú‚îÄ‚îÄ Cargo.lock\n"
"‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îú‚îÄ‚îÄ add_one\n"
"‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îÇ   ‚îî‚îÄ‚îÄ src\n"
"‚îÇ       ‚îî‚îÄ‚îÄ lib.rs\n"
"‚îú‚îÄ‚îÄ adder\n"
"‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml\n"
"‚îÇ   ‚îî‚îÄ‚îÄ src\n"
"‚îÇ       ‚îî‚îÄ‚îÄ main.rs\n"
"‚îî‚îÄ‚îÄ target\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:128
msgid "In the *add_one/src/lib.rs* file, let‚Äôs add an `add_one` function:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:130 src/ch14-03-cargo-workspaces.md:298
msgid "<span class=\"filename\">Filename: add_one/src/lib.rs</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:132
msgid ""
"```rust,noplayground\n"
"pub fn add_one(x: i32) -> i32 {\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:138
msgid ""
"Now we can have the `adder` package with our binary depend on the `add_one`\n"
"package that has our library. First, we‚Äôll need to add a path dependency on\n"
"`add_one` to *adder/Cargo.toml*."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:142
msgid "<span class=\"filename\">Filename: adder/Cargo.toml</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:144
msgid ""
"```toml\n"
"[dependencies]\n"
"add_one = { path = \"../add_one\" }\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:149
msgid ""
"Cargo doesn‚Äôt assume that crates in a workspace will depend on each other, "
"so\n"
"we need to be explicit about the dependency relationships."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:152
msgid ""
"Next, let‚Äôs use the `add_one` function (from the `add_one` crate) in the\n"
"`adder` crate. Open the *adder/src/main.rs* file and add a `use` line at "
"the\n"
"top to bring the new `add_one` library crate into scope. Then change the "
"`main`\n"
"function to call the `add_one` function, as in Listing 14-7."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:157
msgid "<span class=\"filename\">Filename: adder/src/main.rs</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:159
msgid ""
"```rust,ignore\n"
"use add_one;\n"
"\n"
"fn main() {\n"
"    let num = 10;\n"
"    println!(\"Hello, world! {num} plus one is {}!\", add_one::"
"add_one(num));\n"
"}\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:168
msgid ""
"<span class=\"caption\">Listing 14-7: Using the `add_one` library crate from "
"the\n"
" `adder` crate</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:171
msgid ""
"Let‚Äôs build the workspace by running `cargo build` in the top-level *add*\n"
"directory!"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:174
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/listing-14-07/add\n"
"cargo build\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:180
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.68s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:187
msgid ""
"To run the binary crate from the *add* directory, we can specify which\n"
"package in the workspace we want to run by using the `-p` argument and the\n"
"package name with `cargo run`:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:191
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/listing-14-07/add\n"
"cargo run -p adder\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:197
msgid ""
"```console\n"
"$ cargo run -p adder\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/adder`\n"
"Hello, world! 10 plus one is 11!\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:204
msgid ""
"This runs the code in *adder/src/main.rs*, which depends on the `add_one` "
"crate."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:206
msgid "#### Depending on an External Package in a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:208
msgid ""
"Notice that the workspace has only one *Cargo.lock* file at the top level,\n"
"rather than having a *Cargo.lock* in each crate‚Äôs directory. This ensures "
"that\n"
"all crates are using the same version of all dependencies. If we add the "
"`rand`\n"
"package to the *adder/Cargo.toml* and *add_one/Cargo.toml* files, Cargo "
"will\n"
"resolve both of those to one version of `rand` and record that in the one\n"
"*Cargo.lock*. Making all crates in the workspace use the same dependencies\n"
"means the crates will always be compatible with each other. Let‚Äôs add the\n"
"`rand` crate to the `[dependencies]` section in the *add_one/Cargo.toml* "
"file\n"
"so we can use the `rand` crate in the `add_one` crate:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:218
msgid ""
"<!-- When updating the version of `rand` used, also update the version of\n"
"`rand` used in these files so they all match:\n"
"* ch02-00-guessing-game-tutorial.md\n"
"* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:224
msgid "<span class=\"filename\">Filename: add_one/Cargo.toml</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:231
msgid ""
"We can now add `use rand;` to the *add_one/src/lib.rs* file, and building "
"the\n"
"whole workspace by running `cargo build` in the *add* directory will bring "
"in\n"
"and compile the `rand` crate. We will get one warning because we aren‚Äôt\n"
"referring to the `rand` we brought into scope:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:236
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-"
"dependency/add\n"
"cargo build\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:242
msgid ""
"```console\n"
"$ cargo build\n"
"    Updating crates.io index\n"
"  Downloaded rand v0.8.5\n"
"   --snip--\n"
"   Compiling rand v0.8.5\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"warning: unused import: `rand`\n"
" --> add_one/src/lib.rs:1:5\n"
"  |\n"
"1 | use rand;\n"
"  |     ^^^^\n"
"  |\n"
"  = note: `#[warn(unused_imports)]` on by default\n"
"\n"
"warning: `add_one` (lib) generated 1 warning\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 10.18s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:262
msgid ""
"The top-level *Cargo.lock* now contains information about the dependency of\n"
"`add_one` on `rand`. However, even though `rand` is used somewhere in the\n"
"workspace, we can‚Äôt use it in other crates in the workspace unless we add\n"
"`rand` to their *Cargo.toml* files as well. For example, if we add `use rand;"
"`\n"
"to the *adder/src/main.rs* file for the `adder` package, we‚Äôll get an error:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:268
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/output-only-03-use-rand/add\n"
"cargo build\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:274
msgid ""
"```console\n"
"$ cargo build\n"
"  --snip--\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"error[E0432]: unresolved import `rand`\n"
" --> adder/src/main.rs:2:5\n"
"  |\n"
"2 | use rand;\n"
"  |     ^^^^ no external crate `rand`\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:285
msgid ""
"To fix this, edit the *Cargo.toml* file for the `adder` package and "
"indicate\n"
"that `rand` is a dependency for it as well. Building the `adder` package "
"will\n"
"add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no\n"
"additional copies of `rand` will be downloaded. Cargo has ensured that "
"every\n"
"crate in every package in the workspace using the `rand` package will be "
"using\n"
"the same version, saving us space and ensuring that the crates in the "
"workspace\n"
"will be compatible with each other."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:293
msgid "#### Adding a Test to a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:295
msgid ""
"For another enhancement, let‚Äôs add a test of the `add_one::add_one` "
"function\n"
"within the `add_one` crate:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:300
msgid ""
"```rust,noplayground\n"
"pub fn add_one(x: i32) -> i32 {\n"
"    x + 1\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn it_works() {\n"
"        assert_eq!(3, add_one(2));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:316
msgid ""
"Now run `cargo test` in the top-level *add* directory. Running `cargo test` "
"in\n"
"a workspace structured like this one will run the tests for all the crates "
"in\n"
"the workspace:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:320
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add\n"
"cargo test\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in\n"
"paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:327
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.27s\n"
"     Running unittests src/lib.rs (target/debug/deps/add_one-"
"f0253159197f7841)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"adder-49979ff40686fa8e)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests add_one\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:352
msgid ""
"The first section of the output shows that the `it_works` test in the "
"`add_one`\n"
"crate passed. The next section shows that zero tests were found in the "
"`adder`\n"
"crate, and then the last section shows zero documentation tests were found "
"in\n"
"the `add_one` crate."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:357
msgid ""
"We can also run tests for one particular crate in a workspace from the\n"
"top-level directory by using the `-p` flag and specifying the name of the "
"crate\n"
"we want to test:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:361
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add\n"
"cargo test -p add_one\n"
"copy output below; the output updating script doesn't handle subdirectories "
"in paths properly\n"
"-->"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:367
msgid ""
"```console\n"
"$ cargo test -p add_one\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n"
"     Running unittests src/lib.rs (target/debug/deps/add_one-"
"b3235fea9a156f74)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests add_one\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:384
msgid ""
"This output shows `cargo test` only ran the tests for the `add_one` crate "
"and\n"
"didn‚Äôt run the `adder` crate tests."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:387
msgid ""
"If you publish the crates in the workspace to [crates.io](https://crates."
"io/),\n"
"each crate in the workspace will need to be published separately. Like "
"`cargo\n"
"test`, we can publish a particular crate in our workspace by using the `-p`\n"
"flag and specifying the name of the crate we want to publish."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:392
msgid ""
"For additional practice, add an `add_two` crate to this workspace in a "
"similar\n"
"way as the `add_one` crate!"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:395
msgid ""
"As your project grows, consider using a workspace: it‚Äôs easier to "
"understand\n"
"smaller, individual components than one big blob of code. Furthermore, "
"keeping\n"
"the crates in a workspace can make coordination between crates easier if "
"they\n"
"are often changed at the same time."
msgstr ""

#: src/ch14-04-installing-binaries.md:2
msgid "<a id=\"installing-binaries-from-cratesio-with-cargo-install\"></a>"
msgstr ""

#: src/ch14-04-installing-binaries.md:4
msgid "## Installing Binaries with `cargo install`"
msgstr ""

#: src/ch14-04-installing-binaries.md:6
msgid ""
"The `cargo install` command allows you to install and use binary crates\n"
"locally. This isn‚Äôt intended to replace system packages; it‚Äôs meant to be a\n"
"convenient way for Rust developers to install tools that others have shared "
"on\n"
"[crates.io](https://crates.io/)<!-- ignore -->. Note that you can only "
"install\n"
"packages that have binary targets. A *binary target* is the runnable "
"program\n"
"that is created if the crate has a *src/main.rs* file or another file "
"specified\n"
"as a binary, as opposed to a library target that isn‚Äôt runnable on its own "
"but\n"
"is suitable for including within other programs. Usually, crates have\n"
"information in the *README* file about whether a crate is a library, has a\n"
"binary target, or both."
msgstr ""

#: src/ch14-04-installing-binaries.md:17
msgid ""
"All binaries installed with `cargo install` are stored in the installation\n"
"root‚Äôs *bin* folder. If you installed Rust using *rustup.rs* and don‚Äôt have "
"any\n"
"custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure "
"that\n"
"directory is in your `$PATH` to be able to run programs you‚Äôve installed "
"with\n"
"`cargo install`."
msgstr ""

#: src/ch14-04-installing-binaries.md:23
msgid ""
"For example, in Chapter 12 we mentioned that there‚Äôs a Rust implementation "
"of\n"
"the `grep` tool called `ripgrep` for searching files. To install `ripgrep`, "
"we\n"
"can run the following:"
msgstr ""

#: src/ch14-04-installing-binaries.md:27
msgid ""
"<!-- manual-regeneration\n"
"cargo install something you don't have, copy relevant output below\n"
"-->"
msgstr ""

#: src/ch14-04-installing-binaries.md:31
msgid ""
"```console\n"
"$ cargo install ripgrep\n"
"    Updating crates.io index\n"
"  Downloaded ripgrep v13.0.0\n"
"  Downloaded 1 crate (243.3 KB) in 0.88s\n"
"  Installing ripgrep v13.0.0\n"
"--snip--\n"
"   Compiling ripgrep v13.0.0\n"
"    Finished release [optimized + debuginfo] target(s) in 3m 10s\n"
"  Installing ~/.cargo/bin/rg\n"
"   Installed package `ripgrep v13.0.0` (executable `rg`)\n"
"```"
msgstr ""

#: src/ch14-04-installing-binaries.md:44
msgid ""
"The second-to-last line of the output shows the location and the name of "
"the\n"
"installed binary, which in the case of `ripgrep` is `rg`. As long as the\n"
"installation directory is in your `$PATH`, as mentioned previously, you can\n"
"then run `rg --help` and start using a faster, rustier tool for searching "
"files!"
msgstr ""

#: src/ch14-05-extending-cargo.md:1
msgid "## Extending Cargo with Custom Commands"
msgstr ""

#: src/ch14-05-extending-cargo.md:3
msgid ""
"Cargo is designed so you can extend it with new subcommands without having "
"to\n"
"modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you "
"can\n"
"run it as if it was a Cargo subcommand by running `cargo something`. Custom\n"
"commands like this are also listed when you run `cargo --list`. Being able "
"to\n"
"use `cargo install` to install extensions and then run them just like the\n"
"built-in Cargo tools is a super convenient benefit of Cargo‚Äôs design!"
msgstr ""

#: src/ch14-05-extending-cargo.md:12
msgid ""
"Sharing code with Cargo and [crates.io](https://crates.io/)<!-- ignore --> "
"is\n"
"part of what makes the Rust ecosystem useful for many different tasks. "
"Rust‚Äôs\n"
"standard library is small and stable, but crates are easy to share, use, "
"and\n"
"improve on a timeline different from that of the language. Don‚Äôt be shy "
"about\n"
"sharing code that‚Äôs useful to you on [crates.io](https://crates.io/)<!-- "
"ignore\n"
"-->; it‚Äôs likely that it will be useful to someone else as well!"
msgstr ""

#: src/ch15-00-smart-pointers.md:1
msgid "# Smart Pointers"
msgstr ""

#: src/ch15-00-smart-pointers.md:3
msgid ""
"A *pointer* is a general concept for a variable that contains an address in\n"
"memory. This address refers to, or ‚Äúpoints at,‚Äù some other data. The most\n"
"common kind of pointer in Rust is a reference, which you learned about in\n"
"Chapter 4. References are indicated by the `&` symbol and borrow the value "
"they\n"
"point to. They don‚Äôt have any special capabilities other than referring to\n"
"data, and have no overhead."
msgstr ""

#: src/ch15-00-smart-pointers.md:10
msgid ""
"*Smart pointers*, on the other hand, are data structures that act like a\n"
"pointer but also have additional metadata and capabilities. The concept of\n"
"smart pointers isn‚Äôt unique to Rust: smart pointers originated in C++ and "
"exist\n"
"in other languages as well. Rust has a variety of smart pointers defined in "
"the\n"
"standard library that provide functionality beyond that provided by "
"references.\n"
"To explore the general concept, we‚Äôll look at a couple of different examples "
"of\n"
"smart pointers, including a *reference counting* smart pointer type. This\n"
"pointer enables you to allow data to have multiple owners by keeping track "
"of\n"
"the number of owners and, when no owners remain, cleaning up the data."
msgstr ""

#: src/ch15-00-smart-pointers.md:20
msgid ""
"Rust, with its concept of ownership and borrowing, has an additional "
"difference\n"
"between references and smart pointers: while references only borrow data, "
"in\n"
"many cases, smart pointers *own* the data they point to."
msgstr ""

#: src/ch15-00-smart-pointers.md:24
msgid ""
"Though we didn‚Äôt call them as such at the time, we‚Äôve already encountered a "
"few\n"
"smart pointers in this book, including `String` and `Vec<T>` in Chapter 8. "
"Both\n"
"these types count as smart pointers because they own some memory and allow "
"you\n"
"to manipulate it. They also have metadata and extra capabilities or "
"guarantees.\n"
"`String`, for example, stores its capacity as metadata and has the extra\n"
"ability to ensure its data will always be valid UTF-8."
msgstr ""

#: src/ch15-00-smart-pointers.md:31
msgid ""
"Smart pointers are usually implemented using structs. Unlike an ordinary\n"
"struct, smart pointers implement the `Deref` and `Drop` traits. The `Deref`\n"
"trait allows an instance of the smart pointer struct to behave like a "
"reference\n"
"so you can write your code to work with either references or smart "
"pointers.\n"
"The `Drop` trait allows you to customize the code that‚Äôs run when an "
"instance\n"
"of the smart pointer goes out of scope. In this chapter, we‚Äôll discuss both\n"
"traits and demonstrate why they‚Äôre important to smart pointers."
msgstr ""

#: src/ch15-00-smart-pointers.md:39
msgid ""
"Given that the smart pointer pattern is a general design pattern used\n"
"frequently in Rust, this chapter won‚Äôt cover every existing smart pointer. "
"Many\n"
"libraries have their own smart pointers, and you can even write your own. "
"We‚Äôll\n"
"cover the most common smart pointers in the standard library:"
msgstr ""

#: src/ch15-00-smart-pointers.md:44
msgid ""
"* `Box<T>` for allocating values on the heap\n"
"* `Rc<T>`, a reference counting type that enables multiple ownership\n"
"* `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that "
"enforces\n"
"  the borrowing rules at runtime instead of compile time"
msgstr ""

#: src/ch15-00-smart-pointers.md:49
msgid ""
"In addition, we‚Äôll cover the *interior mutability* pattern where an "
"immutable\n"
"type exposes an API for mutating an interior value. We‚Äôll also discuss\n"
"*reference cycles*: how they can leak memory and how to prevent them."
msgstr ""

#: src/ch15-00-smart-pointers.md:53
msgid "Let‚Äôs dive in!"
msgstr ""

#: src/ch15-01-box.md:1
msgid "## Using `Box<T>` to Point to Data on the Heap"
msgstr ""

#: src/ch15-01-box.md:3
msgid ""
"The most straightforward smart pointer is a *box*, whose type is written\n"
"`Box<T>`. Boxes allow you to store data on the heap rather than the stack. "
"What\n"
"remains on the stack is the pointer to the heap data. Refer to Chapter 4 to\n"
"review the difference between the stack and the heap."
msgstr ""

#: src/ch15-01-box.md:8
msgid ""
"Boxes don‚Äôt have performance overhead, other than storing their data on the\n"
"heap instead of on the stack. But they don‚Äôt have many extra capabilities\n"
"either. You‚Äôll use them most often in these situations:"
msgstr ""

#: src/ch15-01-box.md:12
msgid ""
"* When you have a type whose size can‚Äôt be known at compile time and you "
"want\n"
"  to use a value of that type in a context that requires an exact size\n"
"* When you have a large amount of data and you want to transfer ownership "
"but\n"
"  ensure the data won‚Äôt be copied when you do so\n"
"* When you want to own a value and you care only that it‚Äôs a type that\n"
"  implements a particular trait rather than being of a specific type"
msgstr ""

#: src/ch15-01-box.md:19
msgid ""
"We‚Äôll demonstrate the first situation in the [‚ÄúEnabling Recursive Types "
"with\n"
"Boxes‚Äù](#enabling-recursive-types-with-boxes)<!-- ignore --> section. In "
"the\n"
"second case, transferring ownership of a large amount of data can take a "
"long\n"
"time because the data is copied around on the stack. To improve performance "
"in\n"
"this situation, we can store the large amount of data on the heap in a box.\n"
"Then, only the small amount of pointer data is copied around on the stack,\n"
"while the data it references stays in one place on the heap. The third case "
"is\n"
"known as a *trait object*, and Chapter 17 devotes an entire section, "
"[‚ÄúUsing\n"
"Trait Objects That Allow for Values of Different Types,‚Äù][trait-"
"objects]<!--\n"
"ignore --> just to that topic. So what you learn here you‚Äôll apply again in\n"
"Chapter 17!"
msgstr ""

#: src/ch15-01-box.md:31
msgid "### Using a `Box<T>` to Store Data on the Heap"
msgstr ""

#: src/ch15-01-box.md:33
msgid ""
"Before we discuss the heap storage use case for `Box<T>`, we‚Äôll cover the\n"
"syntax and how to interact with values stored within a `Box<T>`."
msgstr ""

#: src/ch15-01-box.md:36
msgid ""
"Listing 15-1 shows how to use a box to store an `i32` value on the heap:"
msgstr ""

#: src/ch15-01-box.md:40
msgid ""
"```rust\n"
"fn main() {\n"
"    let b = Box::new(5);\n"
"    println!(\"b = {}\", b);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-01-box.md:47
msgid ""
"<span class=\"caption\">Listing 15-1: Storing an `i32` value on the heap "
"using a\n"
"box</span>"
msgstr ""

#: src/ch15-01-box.md:50
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the\n"
"value `5`, which is allocated on the heap. This program will print `b = 5`; "
"in\n"
"this case, we can access the data in the box similar to how we would if "
"this\n"
"data were on the stack. Just like any owned value, when a box goes out of\n"
"scope, as `b` does at the end of `main`, it will be deallocated. The\n"
"deallocation happens both for the box (stored on the stack) and the data it\n"
"points to (stored on the heap)."
msgstr ""

#: src/ch15-01-box.md:58
msgid ""
"Putting a single value on the heap isn‚Äôt very useful, so you won‚Äôt use boxes "
"by\n"
"themselves in this way very often. Having values like a single `i32` on the\n"
"stack, where they‚Äôre stored by default, is more appropriate in the majority "
"of\n"
"situations. Let‚Äôs look at a case where boxes allow us to define types that "
"we\n"
"wouldn‚Äôt be allowed to if we didn‚Äôt have boxes."
msgstr ""

#: src/ch15-01-box.md:64
msgid "### Enabling Recursive Types with Boxes"
msgstr ""

#: src/ch15-01-box.md:66
msgid ""
"A value of *recursive type* can have another value of the same type as part "
"of\n"
"itself. Recursive types pose an issue because at compile time Rust needs to\n"
"know how much space a type takes up. However, the nesting of values of\n"
"recursive types could theoretically continue infinitely, so Rust can‚Äôt know "
"how\n"
"much space the value needs. Because boxes have a known size, we can enable\n"
"recursive types by inserting a box in the recursive type definition."
msgstr ""

#: src/ch15-01-box.md:73
msgid ""
"As an example of a recursive type, let‚Äôs explore the *cons list*. This is a "
"data\n"
"type commonly found in functional programming languages. The cons list type\n"
"we‚Äôll define is straightforward except for the recursion; therefore, the\n"
"concepts in the example we‚Äôll work with will be useful any time you get "
"into\n"
"more complex situations involving recursive types."
msgstr ""

#: src/ch15-01-box.md:79
msgid "#### More Information About the Cons List"
msgstr ""

#: src/ch15-01-box.md:81
msgid ""
"A *cons list* is a data structure that comes from the Lisp programming "
"language\n"
"and its dialects and is made up of nested pairs, and is the Lisp version of "
"a\n"
"linked list. Its name comes from the `cons` function (short for ‚Äúconstruct\n"
"function‚Äù) in Lisp that constructs a new pair from its two arguments. By\n"
"calling `cons` on a pair consisting of a value and another pair, we can\n"
"construct cons lists made up of recursive pairs."
msgstr ""

#: src/ch15-01-box.md:88
msgid ""
"For example, here‚Äôs a pseudocode representation of a cons list containing "
"the\n"
"list 1, 2, 3 with each pair in parentheses:"
msgstr ""

#: src/ch15-01-box.md:91
msgid ""
"```text\n"
"(1, (2, (3, Nil)))\n"
"```"
msgstr ""

#: src/ch15-01-box.md:95
msgid ""
"Each item in a cons list contains two elements: the value of the current "
"item\n"
"and the next item. The last item in the list contains only a value called "
"`Nil`\n"
"without a next item. A cons list is produced by recursively calling the "
"`cons`\n"
"function. The canonical name to denote the base case of the recursion is "
"`Nil`.\n"
"Note that this is not the same as the ‚Äúnull‚Äù or ‚Äúnil‚Äù concept in Chapter 6,\n"
"which is an invalid or absent value."
msgstr ""

#: src/ch15-01-box.md:102
msgid ""
"The cons list isn‚Äôt a commonly used data structure in Rust. Most of the "
"time\n"
"when you have a list of items in Rust, `Vec<T>` is a better choice to use.\n"
"Other, more complex recursive data types *are* useful in various "
"situations,\n"
"but by starting with the cons list in this chapter, we can explore how "
"boxes\n"
"let us define a recursive data type without much distraction."
msgstr ""

#: src/ch15-01-box.md:108
msgid ""
"Listing 15-2 contains an enum definition for a cons list. Note that this "
"code\n"
"won‚Äôt compile yet because the `List` type doesn‚Äôt have a known size, which\n"
"we‚Äôll demonstrate."
msgstr ""

#: src/ch15-01-box.md:114
msgid ""
"```rust,ignore,does_not_compile\n"
"enum List {\n"
"    Cons(i32, List),\n"
"    Nil,\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch15-01-box.md:123
msgid ""
"<span class=\"caption\">Listing 15-2: The first attempt at defining an enum "
"to\n"
"represent a cons list data structure of `i32` values</span>"
msgstr ""

#: src/ch15-01-box.md:126
msgid ""
"> Note: We‚Äôre implementing a cons list that holds only `i32` values for the\n"
"> purposes of this example. We could have implemented it using generics, as "
"we\n"
"> discussed in Chapter 10, to define a cons list type that could store "
"values of\n"
"> any type."
msgstr ""

#: src/ch15-01-box.md:131
msgid ""
"Using the `List` type to store the list `1, 2, 3` would look like the code "
"in\n"
"Listing 15-3:"
msgstr ""

#: src/ch15-01-box.md:136
msgid ""
"```rust,ignore,does_not_compile\n"
"# enum List {\n"
"#     Cons(i32, List),\n"
"#     Nil,\n"
"# }\n"
"# \n"
"use crate::List::{Cons, Nil};\n"
"\n"
"fn main() {\n"
"    let list = Cons(1, Cons(2, Cons(3, Nil)));\n"
"}\n"
"```"
msgstr ""

#: src/ch15-01-box.md:149
msgid ""
"<span class=\"caption\">Listing 15-3: Using the `List` enum to store the "
"list `1,\n"
"2, 3`</span>"
msgstr ""

#: src/ch15-01-box.md:152
msgid ""
"The first `Cons` value holds `1` and another `List` value. This `List` value "
"is\n"
"another `Cons` value that holds `2` and another `List` value. This `List` "
"value\n"
"is one more `Cons` value that holds `3` and a `List` value, which is "
"finally\n"
"`Nil`, the non-recursive variant that signals the end of the list."
msgstr ""

#: src/ch15-01-box.md:157
msgid ""
"If we try to compile the code in Listing 15-3, we get the error shown in\n"
"Listing 15-4:"
msgstr ""

#: src/ch15-01-box.md:160
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"error[E0072]: recursive type `List` has infinite size\n"
" --> src/main.rs:1:1\n"
"  |\n"
"1 | enum List {\n"
"  | ^^^^^^^^^\n"
"2 |     Cons(i32, List),\n"
"  |               ---- recursive without indirection\n"
"  |\n"
"help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the "
"cycle\n"
"  |\n"
"2 |     Cons(i32, Box<List>),\n"
"  |               ++++    +\n"
"\n"
"For more information about this error, try `rustc --explain E0072`.\n"
"error: could not compile `cons-list` due to previous error\n"
"```"
msgstr ""

#: src/ch15-01-box.md:180
msgid ""
"<span class=\"caption\">Listing 15-4: The error we get when attempting to "
"define\n"
"a recursive enum</span>"
msgstr ""

#: src/ch15-01-box.md:183
msgid ""
"The error shows this type ‚Äúhas infinite size.‚Äù The reason is that we‚Äôve "
"defined\n"
"`List` with a variant that is recursive: it holds another value of itself\n"
"directly. As a result, Rust can‚Äôt figure out how much space it needs to "
"store a\n"
"`List` value. Let‚Äôs break down why we get this error. First, we‚Äôll look at "
"how\n"
"Rust decides how much space it needs to store a value of a non-recursive "
"type."
msgstr ""

#: src/ch15-01-box.md:189
msgid "#### Computing the Size of a Non-Recursive Type"
msgstr ""

#: src/ch15-01-box.md:191
msgid ""
"Recall the `Message` enum we defined in Listing 6-2 when we discussed enum\n"
"definitions in Chapter 6:"
msgstr ""

#: src/ch15-01-box.md:205
msgid ""
"To determine how much space to allocate for a `Message` value, Rust goes\n"
"through each of the variants to see which variant needs the most space. "
"Rust\n"
"sees that `Message::Quit` doesn‚Äôt need any space, `Message::Move` needs "
"enough\n"
"space to store two `i32` values, and so forth. Because only one variant will "
"be\n"
"used, the most space a `Message` value will need is the space it would take "
"to\n"
"store the largest of its variants."
msgstr ""

#: src/ch15-01-box.md:212
msgid ""
"Contrast this with what happens when Rust tries to determine how much space "
"a\n"
"recursive type like the `List` enum in Listing 15-2 needs. The compiler "
"starts\n"
"by looking at the `Cons` variant, which holds a value of type `i32` and a "
"value\n"
"of type `List`. Therefore, `Cons` needs an amount of space equal to the size "
"of\n"
"an `i32` plus the size of a `List`. To figure out how much memory the "
"`List`\n"
"type needs, the compiler looks at the variants, starting with the `Cons`\n"
"variant. The `Cons` variant holds a value of type `i32` and a value of type\n"
"`List`, and this process continues infinitely, as shown in Figure 15-1."
msgstr ""

#: src/ch15-01-box.md:221
msgid ""
"<img alt=\"An infinite Cons list\" src=\"img/trpl15-01.svg\" "
"class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch15-01-box.md:223
msgid ""
"<span class=\"caption\">Figure 15-1: An infinite `List` consisting of "
"infinite\n"
"`Cons` variants</span>"
msgstr ""

#: src/ch15-01-box.md:226
msgid "#### Using `Box<T>` to Get a Recursive Type with a Known Size"
msgstr ""

#: src/ch15-01-box.md:228
msgid ""
"Because Rust can‚Äôt figure out how much space to allocate for recursively\n"
"defined types, the compiler gives an error with this helpful suggestion:"
msgstr ""

#: src/ch15-01-box.md:231
msgid ""
"<!-- manual-regeneration\n"
"after doing automatic regeneration, look at listings/ch15-smart-pointers/"
"listing-15-03/output.txt and copy the relevant line\n"
"-->"
msgstr ""

#: src/ch15-01-box.md:235
msgid ""
"```text\n"
"help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` "
"representable\n"
"  |\n"
"2 |     Cons(i32, Box<List>),\n"
"  |               ++++    +\n"
"```"
msgstr ""

#: src/ch15-01-box.md:242
msgid ""
"In this suggestion, ‚Äúindirection‚Äù means that instead of storing a value\n"
"directly, we should change the data structure to store the value indirectly "
"by\n"
"storing a pointer to the value instead."
msgstr ""

#: src/ch15-01-box.md:246
msgid ""
"Because a `Box<T>` is a pointer, Rust always knows how much space a "
"`Box<T>`\n"
"needs: a pointer‚Äôs size doesn‚Äôt change based on the amount of data it‚Äôs\n"
"pointing to. This means we can put a `Box<T>` inside the `Cons` variant "
"instead\n"
"of another `List` value directly. The `Box<T>` will point to the next "
"`List`\n"
"value that will be on the heap rather than inside the `Cons` variant.\n"
"Conceptually, we still have a list, created with lists holding other lists, "
"but\n"
"this implementation is now more like placing the items next to one another\n"
"rather than inside one another."
msgstr ""

#: src/ch15-01-box.md:255
msgid ""
"We can change the definition of the `List` enum in Listing 15-2 and the "
"usage\n"
"of the `List` in Listing 15-3 to the code in Listing 15-5, which will "
"compile:"
msgstr ""

#: src/ch15-01-box.md:260
msgid ""
"```rust\n"
"enum List {\n"
"    Cons(i32, Box<List>),\n"
"    Nil,\n"
"}\n"
"\n"
"use crate::List::{Cons, Nil};\n"
"\n"
"fn main() {\n"
"    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::"
"new(Nil))))));\n"
"}\n"
"```"
msgstr ""

#: src/ch15-01-box.md:273
msgid ""
"<span class=\"caption\">Listing 15-5: Definition of `List` that uses "
"`Box<T>` in\n"
"order to have a known size</span>"
msgstr ""

#: src/ch15-01-box.md:276
msgid ""
"The `Cons` variant needs the size of an `i32` plus the space to store the\n"
"box‚Äôs pointer data. The `Nil` variant stores no values, so it needs less "
"space\n"
"than the `Cons` variant. We now know that any `List` value will take up the\n"
"size of an `i32` plus the size of a box‚Äôs pointer data. By using a box, "
"we‚Äôve\n"
"broken the infinite, recursive chain, so the compiler can figure out the "
"size\n"
"it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant\n"
"looks like now."
msgstr ""

#: src/ch15-01-box.md:284
msgid ""
"<img alt=\"A finite Cons list\" src=\"img/trpl15-02.svg\" class=\"center\" />"
msgstr ""

#: src/ch15-01-box.md:286
msgid ""
"<span class=\"caption\">Figure 15-2: A `List` that is not infinitely sized\n"
"because `Cons` holds a `Box`</span>"
msgstr ""

#: src/ch15-01-box.md:289
msgid ""
"Boxes provide only the indirection and heap allocation; they don‚Äôt have any\n"
"other special capabilities, like those we‚Äôll see with the other smart "
"pointer\n"
"types. They also don‚Äôt have the performance overhead that these special\n"
"capabilities incur, so they can be useful in cases like the cons list where "
"the\n"
"indirection is the only feature we need. We‚Äôll look at more use cases for "
"boxes\n"
"in Chapter 17, too."
msgstr ""

#: src/ch15-01-box.md:296
msgid ""
"The `Box<T>` type is a smart pointer because it implements the `Deref` "
"trait,\n"
"which allows `Box<T>` values to be treated like references. When a `Box<T>`\n"
"value goes out of scope, the heap data that the box is pointing to is "
"cleaned\n"
"up as well because of the `Drop` trait implementation. These two traits will "
"be\n"
"even more important to the functionality provided by the other smart "
"pointer\n"
"types we‚Äôll discuss in the rest of this chapter. Let‚Äôs explore these two "
"traits\n"
"in more detail."
msgstr ""

#: src/ch15-02-deref.md:1
msgid ""
"## Treating Smart Pointers Like Regular References with the `Deref` Trait"
msgstr ""

#: src/ch15-02-deref.md:3
msgid ""
"Implementing the `Deref` trait allows you to customize the behavior of the\n"
"*dereference operator* `*` (not to be confused with the multiplication or "
"glob\n"
"operator). By implementing `Deref` in such a way that a smart pointer can "
"be\n"
"treated like a regular reference, you can write code that operates on\n"
"references and use that code with smart pointers too."
msgstr ""

#: src/ch15-02-deref.md:9
msgid ""
"Let‚Äôs first look at how the dereference operator works with regular "
"references.\n"
"Then we‚Äôll try to define a custom type that behaves like `Box<T>`, and see "
"why\n"
"the dereference operator doesn‚Äôt work like a reference on our newly defined\n"
"type. We‚Äôll explore how implementing the `Deref` trait makes it possible "
"for\n"
"smart pointers to work in ways similar to references. Then we‚Äôll look at\n"
"Rust‚Äôs *deref coercion* feature and how it lets us work with either "
"references\n"
"or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:17
msgid ""
"> Note: there‚Äôs one big difference between the `MyBox<T>` type we‚Äôre about "
"to\n"
"> build and the real `Box<T>`: our version will not store its data on the "
"heap.\n"
"> We are focusing this example on `Deref`, so where the data is actually "
"stored\n"
"> is less important than the pointer-like behavior."
msgstr ""

#: src/ch15-02-deref.md:23
msgid ""
"<a id=\"following-the-pointer-to-the-value-with-the-dereference-operator\"></"
"a>"
msgstr ""

#: src/ch15-02-deref.md:25
msgid "### Following the Pointer to the Value"
msgstr ""

#: src/ch15-02-deref.md:27
msgid ""
"A regular reference is a type of pointer, and one way to think of a pointer "
"is\n"
"as an arrow to a value stored somewhere else. In Listing 15-6, we create a\n"
"reference to an `i32` value and then use the dereference operator to follow "
"the\n"
"reference to the value:"
msgstr ""

#: src/ch15-02-deref.md:34
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 5;\n"
"    let y = &x;\n"
"\n"
"    assert_eq!(5, x);\n"
"    assert_eq!(5, *y);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:44
msgid ""
"<span class=\"caption\">Listing 15-6: Using the dereference operator to "
"follow a\n"
"reference to an `i32` value</span>"
msgstr ""

#: src/ch15-02-deref.md:47
msgid ""
"The variable `x` holds an `i32` value `5`. We set `y` equal to a reference "
"to\n"
"`x`. We can assert that `x` is equal to `5`. However, if we want to make an\n"
"assertion about the value in `y`, we have to use `*y` to follow the "
"reference\n"
"to the value it‚Äôs pointing to (hence *dereference*) so the compiler can "
"compare\n"
"the actual value. Once we dereference `y`, we have access to the integer "
"value\n"
"`y` is pointing to that we can compare with `5`."
msgstr ""

#: src/ch15-02-deref.md:54
msgid ""
"If we tried to write `assert_eq!(5, y);` instead, we would get this "
"compilation\n"
"error:"
msgstr ""

#: src/ch15-02-deref.md:57
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0277]: can't compare `{integer}` with `&{integer}`\n"
" --> src/main.rs:6:5\n"
"  |\n"
"6 |     assert_eq!(5, y);\n"
"  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"
"  |\n"
"  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}"
"`\n"
"  = help: the following other types implement trait `PartialEq<Rhs>`:\n"
"            f32\n"
"            f64\n"
"            i128\n"
"            i16\n"
"            i32\n"
"            i64\n"
"            i8\n"
"            isize\n"
"          and 6 others\n"
"  = note: this error originates in the macro `assert_eq` (in Nightly builds, "
"run with -Z macro-backtrace for more info)\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `deref-example` due to previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:83
msgid ""
"Comparing a number and a reference to a number isn‚Äôt allowed because "
"they‚Äôre\n"
"different types. We must use the dereference operator to follow the "
"reference\n"
"to the value it‚Äôs pointing to."
msgstr ""

#: src/ch15-02-deref.md:87
msgid "### Using `Box<T>` Like a Reference"
msgstr ""

#: src/ch15-02-deref.md:89
msgid ""
"We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a\n"
"reference; the dereference operator used on the `Box<T>` in Listing 15-7\n"
"functions in the same way as the dereference operator used on the reference "
"in\n"
"Listing 15-6:"
msgstr ""

#: src/ch15-02-deref.md:96
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 5;\n"
"    let y = Box::new(x);\n"
"\n"
"    assert_eq!(5, x);\n"
"    assert_eq!(5, *y);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:106
msgid ""
"<span class=\"caption\">Listing 15-7: Using the dereference operator on a\n"
"`Box<i32>`</span>"
msgstr ""

#: src/ch15-02-deref.md:109
msgid ""
"The main difference between Listing 15-7 and Listing 15-6 is that here we "
"set\n"
"`y` to be an instance of a `Box<T>` pointing to a copied value of `x` "
"rather\n"
"than a reference pointing to the value of `x`. In the last assertion, we "
"can\n"
"use the dereference operator to follow the pointer of the `Box<T>` in the "
"same\n"
"way that we did when `y` was a reference. Next, we‚Äôll explore what is "
"special\n"
"about `Box<T>` that enables us to use the dereference operator by defining "
"our\n"
"own type."
msgstr ""

#: src/ch15-02-deref.md:117
msgid "### Defining Our Own Smart Pointer"
msgstr ""

#: src/ch15-02-deref.md:119
msgid ""
"Let‚Äôs build a smart pointer similar to the `Box<T>` type provided by the\n"
"standard library to experience how smart pointers behave differently from\n"
"references by default. Then we‚Äôll look at how to add the ability to use the\n"
"dereference operator."
msgstr ""

#: src/ch15-02-deref.md:124
msgid ""
"The `Box<T>` type is ultimately defined as a tuple struct with one element, "
"so\n"
"Listing 15-8 defines a `MyBox<T>` type in the same way. We‚Äôll also define a\n"
"`new` function to match the `new` function defined on `Box<T>`."
msgstr ""

#: src/ch15-02-deref.md:130
msgid ""
"```rust\n"
"struct MyBox<T>(T);\n"
"\n"
"impl<T> MyBox<T> {\n"
"    fn new(x: T) -> MyBox<T> {\n"
"        MyBox(x)\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:142
msgid "<span class=\"caption\">Listing 15-8: Defining a `MyBox<T>` type</span>"
msgstr ""

#: src/ch15-02-deref.md:144
msgid ""
"We define a struct named `MyBox` and declare a generic parameter `T`, "
"because\n"
"we want our type to hold values of any type. The `MyBox` type is a tuple "
"struct\n"
"with one element of type `T`. The `MyBox::new` function takes one parameter "
"of\n"
"type `T` and returns a `MyBox` instance that holds the value passed in."
msgstr ""

#: src/ch15-02-deref.md:149
msgid ""
"Let‚Äôs try adding the `main` function in Listing 15-7 to Listing 15-8 and\n"
"changing it to use the `MyBox<T>` type we‚Äôve defined instead of `Box<T>`. "
"The\n"
"code in Listing 15-9 won‚Äôt compile because Rust doesn‚Äôt know how to "
"dereference\n"
"`MyBox`."
msgstr ""

#: src/ch15-02-deref.md:156
msgid ""
"```rust,ignore,does_not_compile\n"
"# struct MyBox<T>(T);\n"
"# \n"
"# impl<T> MyBox<T> {\n"
"#     fn new(x: T) -> MyBox<T> {\n"
"#         MyBox(x)\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let x = 5;\n"
"    let y = MyBox::new(x);\n"
"\n"
"    assert_eq!(5, x);\n"
"    assert_eq!(5, *y);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:174
msgid ""
"<span class=\"caption\">Listing 15-9: Attempting to use `MyBox<T>` in the "
"same\n"
"way we used references and `Box<T>`</span>"
msgstr ""

#: src/ch15-02-deref.md:177
msgid "Here‚Äôs the resulting compilation error:"
msgstr ""

#: src/ch15-02-deref.md:179
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n"
"  --> src/main.rs:14:19\n"
"   |\n"
"14 |     assert_eq!(5, *y);\n"
"   |                   ^^\n"
"\n"
"For more information about this error, try `rustc --explain E0614`.\n"
"error: could not compile `deref-example` due to previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:192
msgid ""
"Our `MyBox<T>` type can‚Äôt be dereferenced because we haven‚Äôt implemented "
"that\n"
"ability on our type. To enable dereferencing with the `*` operator, we\n"
"implement the `Deref` trait."
msgstr ""

#: src/ch15-02-deref.md:196
msgid "### Treating a Type Like a Reference by Implementing the `Deref` Trait"
msgstr ""

#: src/ch15-02-deref.md:198
msgid ""
"As discussed in the [‚ÄúImplementing a Trait on a Type‚Äù][impl-trait]<!-- "
"ignore\n"
"--> section of Chapter 10, to implement a trait, we need to provide\n"
"implementations for the trait‚Äôs required methods. The `Deref` trait, "
"provided\n"
"by the standard library, requires us to implement one method named `deref` "
"that\n"
"borrows `self` and returns a reference to the inner data. Listing 15-10\n"
"contains an implementation of `Deref` to add to the definition of `MyBox`:"
msgstr ""

#: src/ch15-02-deref.md:207
msgid ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"impl<T> Deref for MyBox<T> {\n"
"    type Target = T;\n"
"\n"
"    fn deref(&self) -> &Self::Target {\n"
"        &self.0\n"
"    }\n"
"}\n"
"# \n"
"# struct MyBox<T>(T);\n"
"# \n"
"# impl<T> MyBox<T> {\n"
"#     fn new(x: T) -> MyBox<T> {\n"
"#         MyBox(x)\n"
"#     }\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let x = 5;\n"
"#     let y = MyBox::new(x);\n"
"# \n"
"#     assert_eq!(5, x);\n"
"#     assert_eq!(5, *y);\n"
"# }\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:235
msgid ""
"<span class=\"caption\">Listing 15-10: Implementing `Deref` on `MyBox<T>`</"
"span>"
msgstr ""

#: src/ch15-02-deref.md:237
msgid ""
"The `type Target = T;` syntax defines an associated type for the `Deref`\n"
"trait to use. Associated types are a slightly different way of declaring a\n"
"generic parameter, but you don‚Äôt need to worry about them for now; we‚Äôll "
"cover\n"
"them in more detail in Chapter 19."
msgstr ""

#: src/ch15-02-deref.md:242
msgid ""
"We fill in the body of the `deref` method with `&self.0` so `deref` returns "
"a\n"
"reference to the value we want to access with the `*` operator; recall from "
"the\n"
"[‚ÄúUsing Tuple Structs without Named Fields to Create Different\n"
"Types‚Äù][tuple-structs]<!-- ignore --> section of Chapter 5 that `.0` "
"accesses\n"
"the first value in a tuple struct. The `main` function in Listing 15-9 that\n"
"calls `*` on the `MyBox<T>` value now compiles, and the assertions pass!"
msgstr ""

#: src/ch15-02-deref.md:249
msgid ""
"Without the `Deref` trait, the compiler can only dereference `&` "
"references.\n"
"The `deref` method gives the compiler the ability to take a value of any "
"type\n"
"that implements `Deref` and call the `deref` method to get a `&` reference "
"that\n"
"it knows how to dereference."
msgstr ""

#: src/ch15-02-deref.md:254
msgid ""
"When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran "
"this\n"
"code:"
msgstr ""

#: src/ch15-02-deref.md:257
msgid ""
"```rust,ignore\n"
"*(y.deref())\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:261
msgid ""
"Rust substitutes the `*` operator with a call to the `deref` method and then "
"a\n"
"plain dereference so we don‚Äôt have to think about whether or not we need to\n"
"call the `deref` method. This Rust feature lets us write code that "
"functions\n"
"identically whether we have a regular reference or a type that implements\n"
"`Deref`."
msgstr ""

#: src/ch15-02-deref.md:267
msgid ""
"The reason the `deref` method returns a reference to a value, and that the\n"
"plain dereference outside the parentheses in `*(y.deref())` is still "
"necessary,\n"
"is to do with the ownership system. If the `deref` method returned the "
"value\n"
"directly instead of a reference to the value, the value would be moved out "
"of\n"
"`self`. We don‚Äôt want to take ownership of the inner value inside `MyBox<T>` "
"in\n"
"this case or in most cases where we use the dereference operator."
msgstr ""

#: src/ch15-02-deref.md:274
msgid ""
"Note that the `*` operator is replaced with a call to the `deref` method "
"and\n"
"then a call to the `*` operator just once, each time we use a `*` in our "
"code.\n"
"Because the substitution of the `*` operator does not recurse infinitely, "
"we\n"
"end up with data of type `i32`, which matches the `5` in `assert_eq!` in\n"
"Listing 15-9."
msgstr ""

#: src/ch15-02-deref.md:280
msgid "### Implicit Deref Coercions with Functions and Methods"
msgstr ""

#: src/ch15-02-deref.md:282
msgid ""
"*Deref coercion* converts a reference to a type that implements the `Deref`\n"
"trait into a reference to another type. For example, deref coercion can "
"convert\n"
"`&String` to `&str` because `String` implements the `Deref` trait such that "
"it\n"
"returns `&str`. Deref coercion is a convenience Rust performs on arguments "
"to\n"
"functions and methods, and works only on types that implement the `Deref`\n"
"trait. It happens automatically when we pass a reference to a particular "
"type‚Äôs\n"
"value as an argument to a function or method that doesn‚Äôt match the "
"parameter\n"
"type in the function or method definition. A sequence of calls to the "
"`deref`\n"
"method converts the type we provided into the type the parameter needs."
msgstr ""

#: src/ch15-02-deref.md:292
msgid ""
"Deref coercion was added to Rust so that programmers writing function and\n"
"method calls don‚Äôt need to add as many explicit references and dereferences\n"
"with `&` and `*`. The deref coercion feature also lets us write more code "
"that\n"
"can work for either references or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:297
msgid ""
"To see deref coercion in action, let‚Äôs use the `MyBox<T>` type we defined "
"in\n"
"Listing 15-8 as well as the implementation of `Deref` that we added in "
"Listing\n"
"15-10. Listing 15-11 shows the definition of a function that has a string "
"slice\n"
"parameter:"
msgstr ""

#: src/ch15-02-deref.md:304
msgid ""
"```rust\n"
"fn hello(name: &str) {\n"
"    println!(\"Hello, {name}!\");\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:312
msgid ""
"<span class=\"caption\">Listing 15-11: A `hello` function that has the "
"parameter\n"
"`name` of type `&str`</span>"
msgstr ""

#: src/ch15-02-deref.md:315
msgid ""
"We can call the `hello` function with a string slice as an argument, such "
"as\n"
"`hello(\"Rust\");` for example. Deref coercion makes it possible to call "
"`hello`\n"
"with a reference to a value of type `MyBox<String>`, as shown in Listing "
"15-12:"
msgstr ""

#: src/ch15-02-deref.md:321
msgid ""
"```rust\n"
"# use std::ops::Deref;\n"
"# \n"
"# impl<T> Deref for MyBox<T> {\n"
"#     type Target = T;\n"
"# \n"
"#     fn deref(&self) -> &T {\n"
"#         &self.0\n"
"#     }\n"
"# }\n"
"# \n"
"# struct MyBox<T>(T);\n"
"# \n"
"# impl<T> MyBox<T> {\n"
"#     fn new(x: T) -> MyBox<T> {\n"
"#         MyBox(x)\n"
"#     }\n"
"# }\n"
"# \n"
"# fn hello(name: &str) {\n"
"#     println!(\"Hello, {name}!\");\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let m = MyBox::new(String::from(\"Rust\"));\n"
"    hello(&m);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:350
msgid ""
"<span class=\"caption\">Listing 15-12: Calling `hello` with a reference to "
"a\n"
"`MyBox<String>` value, which works because of deref coercion</span>"
msgstr ""

#: src/ch15-02-deref.md:353
msgid ""
"Here we‚Äôre calling the `hello` function with the argument `&m`, which is a\n"
"reference to a `MyBox<String>` value. Because we implemented the `Deref` "
"trait\n"
"on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into "
"`&String`\n"
"by calling `deref`. The standard library provides an implementation of "
"`Deref`\n"
"on `String` that returns a string slice, and this is in the API "
"documentation\n"
"for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, "
"which\n"
"matches the `hello` function‚Äôs definition."
msgstr ""

#: src/ch15-02-deref.md:361
msgid ""
"If Rust didn‚Äôt implement deref coercion, we would have to write the code in\n"
"Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a "
"value\n"
"of type `&MyBox<String>`."
msgstr ""

#: src/ch15-02-deref.md:367
msgid ""
"```rust\n"
"# use std::ops::Deref;\n"
"# \n"
"# impl<T> Deref for MyBox<T> {\n"
"#     type Target = T;\n"
"# \n"
"#     fn deref(&self) -> &T {\n"
"#         &self.0\n"
"#     }\n"
"# }\n"
"# \n"
"# struct MyBox<T>(T);\n"
"# \n"
"# impl<T> MyBox<T> {\n"
"#     fn new(x: T) -> MyBox<T> {\n"
"#         MyBox(x)\n"
"#     }\n"
"# }\n"
"# \n"
"# fn hello(name: &str) {\n"
"#     println!(\"Hello, {name}!\");\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let m = MyBox::new(String::from(\"Rust\"));\n"
"    hello(&(*m)[..]);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:396
msgid ""
"<span class=\"caption\">Listing 15-13: The code we would have to write if "
"Rust\n"
"didn‚Äôt have deref coercion</span>"
msgstr ""

#: src/ch15-02-deref.md:399
msgid ""
"The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` "
"and\n"
"`[..]` take a string slice of the `String` that is equal to the whole string "
"to\n"
"match the signature of `hello`. This code without deref coercions is harder "
"to\n"
"read, write, and understand with all of these symbols involved. Deref "
"coercion\n"
"allows Rust to handle these conversions for us automatically."
msgstr ""

#: src/ch15-02-deref.md:405
msgid ""
"When the `Deref` trait is defined for the types involved, Rust will analyze "
"the\n"
"types and use `Deref::deref` as many times as necessary to get a reference "
"to\n"
"match the parameter‚Äôs type. The number of times that `Deref::deref` needs to "
"be\n"
"inserted is resolved at compile time, so there is no runtime penalty for "
"taking\n"
"advantage of deref coercion!"
msgstr ""

#: src/ch15-02-deref.md:411
msgid "### How Deref Coercion Interacts with Mutability"
msgstr ""

#: src/ch15-02-deref.md:413
msgid ""
"Similar to how you use the `Deref` trait to override the `*` operator on\n"
"immutable references, you can use the `DerefMut` trait to override the `*`\n"
"operator on mutable references."
msgstr ""

#: src/ch15-02-deref.md:417
msgid ""
"Rust does deref coercion when it finds types and trait implementations in "
"three\n"
"cases:"
msgstr ""

#: src/ch15-02-deref.md:420
msgid ""
"* From `&T` to `&U` when `T: Deref<Target=U>`\n"
"* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`\n"
"* From `&mut T` to `&U` when `T: Deref<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:424
msgid ""
"The first two cases are the same as each other except that the second\n"
"implements mutability. The first case states that if you have a `&T`, and "
"`T`\n"
"implements `Deref` to some type `U`, you can get a `&U` transparently. The\n"
"second case states that the same deref coercion happens for mutable "
"references."
msgstr ""

#: src/ch15-02-deref.md:429
msgid ""
"The third case is trickier: Rust will also coerce a mutable reference to an\n"
"immutable one. But the reverse is *not* possible: immutable references will\n"
"never coerce to mutable references. Because of the borrowing rules, if you "
"have\n"
"a mutable reference, that mutable reference must be the only reference to "
"that\n"
"data (otherwise, the program wouldn‚Äôt compile). Converting one mutable\n"
"reference to one immutable reference will never break the borrowing rules.\n"
"Converting an immutable reference to a mutable reference would require that "
"the\n"
"initial immutable reference is the only immutable reference to that data, "
"but\n"
"the borrowing rules don‚Äôt guarantee that. Therefore, Rust can‚Äôt make the\n"
"assumption that converting an immutable reference to a mutable reference is\n"
"possible."
msgstr ""

#: src/ch15-03-drop.md:1
msgid "## Running Code on Cleanup with the `Drop` Trait"
msgstr ""

#: src/ch15-03-drop.md:3
msgid ""
"The second trait important to the smart pointer pattern is `Drop`, which "
"lets\n"
"you customize what happens when a value is about to go out of scope. You "
"can\n"
"provide an implementation for the `Drop` trait on any type, and that code "
"can\n"
"be used to release resources like files or network connections."
msgstr ""

#: src/ch15-03-drop.md:8
msgid ""
"We‚Äôre introducing `Drop` in the context of smart pointers because the\n"
"functionality of the `Drop` trait is almost always used when implementing a\n"
"smart pointer. For example, when a `Box<T>` is dropped it will deallocate "
"the\n"
"space on the heap that the box points to."
msgstr ""

#: src/ch15-03-drop.md:13
msgid ""
"In some languages, for some types, the programmer must call code to free "
"memory\n"
"or resources every time they finish using an instance of those types. "
"Examples\n"
"include file handles, sockets, or locks. If they forget, the system might\n"
"become overloaded and crash. In Rust, you can specify that a particular bit "
"of\n"
"code be run whenever a value goes out of scope, and the compiler will "
"insert\n"
"this code automatically. As a result, you don‚Äôt need to be careful about\n"
"placing cleanup code everywhere in a program that an instance of a "
"particular\n"
"type is finished with‚Äîyou still won‚Äôt leak resources!"
msgstr ""

#: src/ch15-03-drop.md:22
msgid ""
"You specify the code to run when a value goes out of scope by implementing "
"the\n"
"`Drop` trait. The `Drop` trait requires you to implement one method named\n"
"`drop` that takes a mutable reference to `self`. To see when Rust calls "
"`drop`,\n"
"let‚Äôs implement `drop` with `println!` statements for now."
msgstr ""

#: src/ch15-03-drop.md:27
msgid ""
"Listing 15-14 shows a `CustomSmartPointer` struct whose only custom\n"
"functionality is that it will print `Dropping CustomSmartPointer!` when the\n"
"instance goes out of scope, to show when Rust runs the `drop` function."
msgstr ""

#: src/ch15-03-drop.md:33
msgid ""
"```rust\n"
"struct CustomSmartPointer {\n"
"    data: String,\n"
"}\n"
"\n"
"impl Drop for CustomSmartPointer {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping CustomSmartPointer with data `{}`!\", self."
"data);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let c = CustomSmartPointer {\n"
"        data: String::from(\"my stuff\"),\n"
"    };\n"
"    let d = CustomSmartPointer {\n"
"        data: String::from(\"other stuff\"),\n"
"    };\n"
"    println!(\"CustomSmartPointers created.\");\n"
"}\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:55
msgid ""
"<span class=\"caption\">Listing 15-14: A `CustomSmartPointer` struct that\n"
"implements the `Drop` trait where we would put our cleanup code</span>"
msgstr ""

#: src/ch15-03-drop.md:58
msgid ""
"The `Drop` trait is included in the prelude, so we don‚Äôt need to bring it "
"into\n"
"scope. We implement the `Drop` trait on `CustomSmartPointer` and provide an\n"
"implementation for the `drop` method that calls `println!`. The body of the\n"
"`drop` function is where you would place any logic that you wanted to run "
"when\n"
"an instance of your type goes out of scope. We‚Äôre printing some text here "
"to\n"
"demonstrate visually when Rust will call `drop`."
msgstr ""

#: src/ch15-03-drop.md:65
msgid ""
"In `main`, we create two instances of `CustomSmartPointer` and then print\n"
"`CustomSmartPointers created`. At the end of `main`, our instances of\n"
"`CustomSmartPointer` will go out of scope, and Rust will call the code we "
"put\n"
"in the `drop` method, printing our final message. Note that we didn‚Äôt need "
"to\n"
"call the `drop` method explicitly."
msgstr ""

#: src/ch15-03-drop.md:71
msgid "When we run this program, we‚Äôll see the following output:"
msgstr ""

#: src/ch15-03-drop.md:73
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running `target/debug/drop-example`\n"
"CustomSmartPointers created.\n"
"Dropping CustomSmartPointer with data `other stuff`!\n"
"Dropping CustomSmartPointer with data `my stuff`!\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:83
msgid ""
"Rust automatically called `drop` for us when our instances went out of "
"scope,\n"
"calling the code we specified. Variables are dropped in the reverse order "
"of\n"
"their creation, so `d` was dropped before `c`. This example‚Äôs purpose is to\n"
"give you a visual guide to how the `drop` method works; usually you would\n"
"specify the cleanup code that your type needs to run rather than a print\n"
"message."
msgstr ""

#: src/ch15-03-drop.md:90
msgid "### Dropping a Value Early with `std::mem::drop`"
msgstr ""

#: src/ch15-03-drop.md:92
msgid ""
"Unfortunately, it‚Äôs not straightforward to disable the automatic `drop`\n"
"functionality. Disabling `drop` isn‚Äôt usually necessary; the whole point of "
"the\n"
"`Drop` trait is that it‚Äôs taken care of automatically. Occasionally, "
"however,\n"
"you might want to clean up a value early. One example is when using smart\n"
"pointers that manage locks: you might want to force the `drop` method that\n"
"releases the lock so that other code in the same scope can acquire the "
"lock.\n"
"Rust doesn‚Äôt let you call the `Drop` trait‚Äôs `drop` method manually; "
"instead\n"
"you have to call the `std::mem::drop` function provided by the standard "
"library\n"
"if you want to force a value to be dropped before the end of its scope."
msgstr ""

#: src/ch15-03-drop.md:102
msgid ""
"If we try to call the `Drop` trait‚Äôs `drop` method manually by modifying "
"the\n"
"`main` function from Listing 15-14, as shown in Listing 15-15, we‚Äôll get a\n"
"compiler error:"
msgstr ""

#: src/ch15-03-drop.md:108
msgid ""
"```rust,ignore,does_not_compile\n"
"# struct CustomSmartPointer {\n"
"#     data: String,\n"
"# }\n"
"# \n"
"# impl Drop for CustomSmartPointer {\n"
"#     fn drop(&mut self) {\n"
"#         println!(\"Dropping CustomSmartPointer with data `{}`!\", self."
"data);\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let c = CustomSmartPointer {\n"
"        data: String::from(\"some data\"),\n"
"    };\n"
"    println!(\"CustomSmartPointer created.\");\n"
"    c.drop();\n"
"    println!(\"CustomSmartPointer dropped before the end of main.\");\n"
"}\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:129
msgid ""
"<span class=\"caption\">Listing 15-15: Attempting to call the `drop` method "
"from\n"
"the `Drop` trait manually to clean up early</span>"
msgstr ""

#: src/ch15-03-drop.md:132
msgid "When we try to compile this code, we‚Äôll get this error:"
msgstr ""

#: src/ch15-03-drop.md:134
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"error[E0040]: explicit use of destructor method\n"
"  --> src/main.rs:16:7\n"
"   |\n"
"16 |     c.drop();\n"
"   |     --^^^^--\n"
"   |     | |\n"
"   |     | explicit destructor calls not allowed\n"
"   |     help: consider using `drop` function: `drop(c)`\n"
"\n"
"For more information about this error, try `rustc --explain E0040`.\n"
"error: could not compile `drop-example` due to previous error\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:150
msgid ""
"This error message states that we‚Äôre not allowed to explicitly call `drop`. "
"The\n"
"error message uses the term *destructor*, which is the general programming "
"term\n"
"for a function that cleans up an instance. A *destructor* is analogous to a\n"
"*constructor*, which creates an instance. The `drop` function in Rust is "
"one\n"
"particular destructor."
msgstr ""

#: src/ch15-03-drop.md:156
msgid ""
"Rust doesn‚Äôt let us call `drop` explicitly because Rust would still\n"
"automatically call `drop` on the value at the end of `main`. This would "
"cause a\n"
"*double free* error because Rust would be trying to clean up the same value\n"
"twice."
msgstr ""

#: src/ch15-03-drop.md:161
msgid ""
"We can‚Äôt disable the automatic insertion of `drop` when a value goes out of\n"
"scope, and we can‚Äôt call the `drop` method explicitly. So, if we need to "
"force\n"
"a value to be cleaned up early, we use the `std::mem::drop` function."
msgstr ""

#: src/ch15-03-drop.md:165
msgid ""
"The `std::mem::drop` function is different from the `drop` method in the "
"`Drop`\n"
"trait. We call it by passing as an argument the value we want to force "
"drop.\n"
"The function is in the prelude, so we can modify `main` in Listing 15-15 to\n"
"call the `drop` function, as shown in Listing 15-16:"
msgstr ""

#: src/ch15-03-drop.md:172
msgid ""
"```rust\n"
"# struct CustomSmartPointer {\n"
"#     data: String,\n"
"# }\n"
"# \n"
"# impl Drop for CustomSmartPointer {\n"
"#     fn drop(&mut self) {\n"
"#         println!(\"Dropping CustomSmartPointer with data `{}`!\", self."
"data);\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let c = CustomSmartPointer {\n"
"        data: String::from(\"some data\"),\n"
"    };\n"
"    println!(\"CustomSmartPointer created.\");\n"
"    drop(c);\n"
"    println!(\"CustomSmartPointer dropped before the end of main.\");\n"
"}\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:193
msgid ""
"<span class=\"caption\">Listing 15-16: Calling `std::mem::drop` to "
"explicitly\n"
"drop a value before it goes out of scope</span>"
msgstr ""

#: src/ch15-03-drop.md:196
msgid "Running this code will print the following:"
msgstr ""

#: src/ch15-03-drop.md:198
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n"
"     Running `target/debug/drop-example`\n"
"CustomSmartPointer created.\n"
"Dropping CustomSmartPointer with data `some data`!\n"
"CustomSmartPointer dropped before the end of main.\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:208
msgid ""
"The text ```Dropping CustomSmartPointer with data `some data`!``` is "
"printed\n"
"between the `CustomSmartPointer created.` and `CustomSmartPointer dropped\n"
"before the end of main.` text, showing that the `drop` method code is called "
"to\n"
"drop `c` at that point."
msgstr ""

#: src/ch15-03-drop.md:213
msgid ""
"You can use code specified in a `Drop` trait implementation in many ways to\n"
"make cleanup convenient and safe: for instance, you could use it to create "
"your\n"
"own memory allocator! With the `Drop` trait and Rust‚Äôs ownership system, "
"you\n"
"don‚Äôt have to remember to clean up because Rust does it automatically."
msgstr ""

#: src/ch15-03-drop.md:218
msgid ""
"You also don‚Äôt have to worry about problems resulting from accidentally\n"
"cleaning up values still in use: the ownership system that makes sure\n"
"references are always valid also ensures that `drop` gets called only once "
"when\n"
"the value is no longer being used."
msgstr ""

#: src/ch15-03-drop.md:223
msgid ""
"Now that we‚Äôve examined `Box<T>` and some of the characteristics of smart\n"
"pointers, let‚Äôs look at a few other smart pointers defined in the standard\n"
"library."
msgstr ""

#: src/ch15-04-rc.md:1
msgid "## `Rc<T>`, the Reference Counted Smart Pointer"
msgstr ""

#: src/ch15-04-rc.md:3
msgid ""
"In the majority of cases, ownership is clear: you know exactly which "
"variable\n"
"owns a given value. However, there are cases when a single value might have\n"
"multiple owners. For example, in graph data structures, multiple edges "
"might\n"
"point to the same node, and that node is conceptually owned by all of the "
"edges\n"
"that point to it. A node shouldn‚Äôt be cleaned up unless it doesn‚Äôt have any\n"
"edges pointing to it and so has no owners."
msgstr ""

#: src/ch15-04-rc.md:10
msgid ""
"You have to enable multiple ownership explicitly by using the Rust type\n"
"`Rc<T>`, which is an abbreviation for *reference counting*. The `Rc<T>` "
"type\n"
"keeps track of the number of references to a value to determine whether or "
"not\n"
"the value is still in use. If there are zero references to a value, the "
"value\n"
"can be cleaned up without any references becoming invalid."
msgstr ""

#: src/ch15-04-rc.md:16
msgid ""
"Imagine `Rc<T>` as a TV in a family room. When one person enters to watch "
"TV,\n"
"they turn it on. Others can come into the room and watch the TV. When the "
"last\n"
"person leaves the room, they turn off the TV because it‚Äôs no longer being "
"used.\n"
"If someone turns off the TV while others are still watching it, there would "
"be\n"
"uproar from the remaining TV watchers!"
msgstr ""

#: src/ch15-04-rc.md:22
msgid ""
"We use the `Rc<T>` type when we want to allocate some data on the heap for\n"
"multiple parts of our program to read and we can‚Äôt determine at compile "
"time\n"
"which part will finish using the data last. If we knew which part would "
"finish\n"
"last, we could just make that part the data‚Äôs owner, and the normal "
"ownership\n"
"rules enforced at compile time would take effect."
msgstr ""

#: src/ch15-04-rc.md:28
msgid ""
"Note that `Rc<T>` is only for use in single-threaded scenarios. When we "
"discuss\n"
"concurrency in Chapter 16, we‚Äôll cover how to do reference counting in\n"
"multithreaded programs."
msgstr ""

#: src/ch15-04-rc.md:32
msgid "### Using `Rc<T>` to Share Data"
msgstr ""

#: src/ch15-04-rc.md:34
msgid ""
"Let‚Äôs return to our cons list example in Listing 15-5. Recall that we "
"defined\n"
"it using `Box<T>`. This time, we‚Äôll create two lists that both share "
"ownership\n"
"of a third list. Conceptually, this looks similar to Figure 15-3:"
msgstr ""

#: src/ch15-04-rc.md:38
msgid ""
"<img alt=\"Two lists that share ownership of a third list\" src=\"img/"
"trpl15-03.svg\" class=\"center\" />"
msgstr ""

#: src/ch15-04-rc.md:40
msgid ""
"<span class=\"caption\">Figure 15-3: Two lists, `b` and `c`, sharing "
"ownership of\n"
"a third list, `a`</span>"
msgstr ""

#: src/ch15-04-rc.md:43
msgid ""
"We‚Äôll create list `a` that contains 5 and then 10. Then we‚Äôll make two more\n"
"lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`\n"
"lists will then continue on to the first `a` list containing 5 and 10. In "
"other\n"
"words, both lists will share the first list containing 5 and 10."
msgstr ""

#: src/ch15-04-rc.md:48
msgid ""
"Trying to implement this scenario using our definition of `List` with "
"`Box<T>`\n"
"won‚Äôt work, as shown in Listing 15-17:"
msgstr ""

#: src/ch15-04-rc.md:53
msgid ""
"```rust,ignore,does_not_compile\n"
"enum List {\n"
"    Cons(i32, Box<List>),\n"
"    Nil,\n"
"}\n"
"\n"
"use crate::List::{Cons, Nil};\n"
"\n"
"fn main() {\n"
"    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n"
"    let b = Cons(3, Box::new(a));\n"
"    let c = Cons(4, Box::new(a));\n"
"}\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:68
msgid ""
"<span class=\"caption\">Listing 15-17: Demonstrating we‚Äôre not allowed to "
"have\n"
"two lists using `Box<T>` that try to share ownership of a third list</span>"
msgstr ""

#: src/ch15-04-rc.md:71
msgid "When we compile this code, we get this error:"
msgstr ""

#: src/ch15-04-rc.md:73
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"error[E0382]: use of moved value: `a`\n"
"  --> src/main.rs:11:30\n"
"   |\n"
"9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n"
"   |         - move occurs because `a` has type `List`, which does not "
"implement the `Copy` trait\n"
"10 |     let b = Cons(3, Box::new(a));\n"
"   |                              - value moved here\n"
"11 |     let c = Cons(4, Box::new(a));\n"
"   |                              ^ value used here after move\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `cons-list` due to previous error\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:90
msgid ""
"The `Cons` variants own the data they hold, so when we create the `b` list, "
"`a`\n"
"is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when\n"
"creating `c`, we‚Äôre not allowed to because `a` has been moved."
msgstr ""

#: src/ch15-04-rc.md:94
msgid ""
"We could change the definition of `Cons` to hold references instead, but "
"then\n"
"we would have to specify lifetime parameters. By specifying lifetime\n"
"parameters, we would be specifying that every element in the list will live "
"at\n"
"least as long as the entire list. This is the case for the elements and "
"lists\n"
"in Listing 15-17, but not in every scenario."
msgstr ""

#: src/ch15-04-rc.md:100
msgid ""
"Instead, we‚Äôll change our definition of `List` to use `Rc<T>` in place of\n"
"`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a "
"value\n"
"and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking\n"
"ownership of `a`, we‚Äôll clone the `Rc<List>` that `a` is holding, thereby\n"
"increasing the number of references from one to two and letting `a` and `b`\n"
"share ownership of the data in that `Rc<List>`. We‚Äôll also clone `a` when\n"
"creating `c`, increasing the number of references from two to three. Every "
"time\n"
"we call `Rc::clone`, the reference count to the data within the `Rc<List>` "
"will\n"
"increase, and the data won‚Äôt be cleaned up unless there are zero references "
"to\n"
"it."
msgstr ""

#: src/ch15-04-rc.md:113
msgid ""
"```rust\n"
"enum List {\n"
"    Cons(i32, Rc<List>),\n"
"    Nil,\n"
"}\n"
"\n"
"use crate::List::{Cons, Nil};\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n"
"    let b = Cons(3, Rc::clone(&a));\n"
"    let c = Cons(4, Rc::clone(&a));\n"
"}\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:129
msgid ""
"<span class=\"caption\">Listing 15-18: A definition of `List` that uses\n"
"`Rc<T>`</span>"
msgstr ""

#: src/ch15-04-rc.md:132
msgid ""
"We need to add a `use` statement to bring `Rc<T>` into scope because it‚Äôs "
"not\n"
"in the prelude. In `main`, we create the list holding 5 and 10 and store it "
"in\n"
"a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the\n"
"`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an\n"
"argument."
msgstr ""

#: src/ch15-04-rc.md:138
msgid ""
"We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust‚Äôs\n"
"convention is to use `Rc::clone` in this case. The implementation of\n"
"`Rc::clone` doesn‚Äôt make a deep copy of all the data like most types‚Äô\n"
"implementations of `clone` do. The call to `Rc::clone` only increments the\n"
"reference count, which doesn‚Äôt take much time. Deep copies of data can take "
"a\n"
"lot of time. By using `Rc::clone` for reference counting, we can visually\n"
"distinguish between the deep-copy kinds of clones and the kinds of clones "
"that\n"
"increase the reference count. When looking for performance problems in the\n"
"code, we only need to consider the deep-copy clones and can disregard calls "
"to\n"
"`Rc::clone`."
msgstr ""

#: src/ch15-04-rc.md:149
msgid "### Cloning an `Rc<T>` Increases the Reference Count"
msgstr ""

#: src/ch15-04-rc.md:151
msgid ""
"Let‚Äôs change our working example in Listing 15-18 so we can see the "
"reference\n"
"counts changing as we create and drop references to the `Rc<List>` in `a`."
msgstr ""

#: src/ch15-04-rc.md:154
msgid ""
"In Listing 15-19, we‚Äôll change `main` so it has an inner scope around list "
"`c`;\n"
"then we can see how the reference count changes when `c` goes out of scope."
msgstr ""

#: src/ch15-04-rc.md:159
msgid ""
"```rust\n"
"# enum List {\n"
"#     Cons(i32, Rc<List>),\n"
"#     Nil,\n"
"# }\n"
"# \n"
"# use crate::List::{Cons, Nil};\n"
"# use std::rc::Rc;\n"
"# \n"
"fn main() {\n"
"    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n"
"    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n"
"    let b = Cons(3, Rc::clone(&a));\n"
"    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n"
"    {\n"
"        let c = Cons(4, Rc::clone(&a));\n"
"        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n"
"    }\n"
"    println!(\"count after c goes out of scope = {}\", Rc::"
"strong_count(&a));\n"
"}\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:181
msgid ""
"<span class=\"caption\">Listing 15-19: Printing the reference count</span>"
msgstr ""

#: src/ch15-04-rc.md:183
msgid ""
"At each point in the program where the reference count changes, we print "
"the\n"
"reference count, which we get by calling the `Rc::strong_count` function. "
"This\n"
"function is named `strong_count` rather than `count` because the `Rc<T>` "
"type\n"
"also has a `weak_count`; we‚Äôll see what `weak_count` is used for in the\n"
"[‚ÄúPreventing Reference Cycles: Turning an `Rc<T>` into a\n"
"`Weak<T>`‚Äù][preventing-ref-cycles]<!-- ignore --> section."
msgstr ""

#: src/ch15-04-rc.md:190
msgid "This code prints the following:"
msgstr ""

#: src/ch15-04-rc.md:192
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n"
"     Running `target/debug/cons-list`\n"
"count after creating a = 1\n"
"count after creating b = 2\n"
"count after creating c = 3\n"
"count after c goes out of scope = 2\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:203
msgid ""
"We can see that the `Rc<List>` in `a` has an initial reference count of 1; "
"then\n"
"each time we call `clone`, the count goes up by 1. When `c` goes out of "
"scope,\n"
"the count goes down by 1. We don‚Äôt have to call a function to decrease the\n"
"reference count like we have to call `Rc::clone` to increase the reference\n"
"count: the implementation of the `Drop` trait decreases the reference count\n"
"automatically when an `Rc<T>` value goes out of scope."
msgstr ""

#: src/ch15-04-rc.md:210
msgid ""
"What we can‚Äôt see in this example is that when `b` and then `a` go out of "
"scope\n"
"at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up\n"
"completely. Using `Rc<T>` allows a single value to have multiple owners, "
"and\n"
"the count ensures that the value remains valid as long as any of the owners\n"
"still exist."
msgstr ""

#: src/ch15-04-rc.md:216
msgid ""
"Via immutable references, `Rc<T>` allows you to share data between multiple\n"
"parts of your program for reading only. If `Rc<T>` allowed you to have "
"multiple\n"
"mutable references too, you might violate one of the borrowing rules "
"discussed\n"
"in Chapter 4: multiple mutable borrows to the same place can cause data "
"races\n"
"and inconsistencies. But being able to mutate data is very useful! In the "
"next\n"
"section, we‚Äôll discuss the interior mutability pattern and the `RefCell<T>`\n"
"type that you can use in conjunction with an `Rc<T>` to work with this\n"
"immutability restriction."
msgstr ""

#: src/ch15-05-interior-mutability.md:1
msgid "## `RefCell<T>` and the Interior Mutability Pattern"
msgstr ""

#: src/ch15-05-interior-mutability.md:3
msgid ""
"*Interior mutability* is a design pattern in Rust that allows you to mutate\n"
"data even when there are immutable references to that data; normally, this\n"
"action is disallowed by the borrowing rules. To mutate data, the pattern "
"uses\n"
"`unsafe` code inside a data structure to bend Rust‚Äôs usual rules that "
"govern\n"
"mutation and borrowing. Unsafe code indicates to the compiler that we‚Äôre\n"
"checking the rules manually instead of relying on the compiler to check "
"them\n"
"for us; we will discuss unsafe code more in Chapter 19."
msgstr ""

#: src/ch15-05-interior-mutability.md:11
msgid ""
"We can use types that use the interior mutability pattern only when we can\n"
"ensure that the borrowing rules will be followed at runtime, even though "
"the\n"
"compiler can‚Äôt guarantee that. The `unsafe` code involved is then wrapped in "
"a\n"
"safe API, and the outer type is still immutable."
msgstr ""

#: src/ch15-05-interior-mutability.md:16
msgid ""
"Let‚Äôs explore this concept by looking at the `RefCell<T>` type that follows "
"the\n"
"interior mutability pattern."
msgstr ""

#: src/ch15-05-interior-mutability.md:19
msgid "### Enforcing Borrowing Rules at Runtime with `RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:21
msgid ""
"Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the "
"data\n"
"it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?\n"
"Recall the borrowing rules you learned in Chapter 4:"
msgstr ""

#: src/ch15-05-interior-mutability.md:25
msgid ""
"* At any given time, you can have *either* (but not both) one mutable "
"reference\n"
"  or any number of immutable references.\n"
"* References must always be valid."
msgstr ""

#: src/ch15-05-interior-mutability.md:29
msgid ""
"With references and `Box<T>`, the borrowing rules‚Äô invariants are enforced "
"at\n"
"compile time. With `RefCell<T>`, these invariants are enforced *at "
"runtime*.\n"
"With references, if you break these rules, you‚Äôll get a compiler error. "
"With\n"
"`RefCell<T>`, if you break these rules, your program will panic and exit."
msgstr ""

#: src/ch15-05-interior-mutability.md:34
msgid ""
"The advantages of checking the borrowing rules at compile time are that "
"errors\n"
"will be caught sooner in the development process, and there is no impact on\n"
"runtime performance because all the analysis is completed beforehand. For "
"those\n"
"reasons, checking the borrowing rules at compile time is the best choice in "
"the\n"
"majority of cases, which is why this is Rust‚Äôs default."
msgstr ""

#: src/ch15-05-interior-mutability.md:40
msgid ""
"The advantage of checking the borrowing rules at runtime instead is that\n"
"certain memory-safe scenarios are then allowed, where they would‚Äôve been\n"
"disallowed by the compile-time checks. Static analysis, like the Rust "
"compiler,\n"
"is inherently conservative. Some properties of code are impossible to detect "
"by\n"
"analyzing the code: the most famous example is the Halting Problem, which "
"is\n"
"beyond the scope of this book but is an interesting topic to research."
msgstr ""

#: src/ch15-05-interior-mutability.md:47
msgid ""
"Because some analysis is impossible, if the Rust compiler can‚Äôt be sure the\n"
"code complies with the ownership rules, it might reject a correct program; "
"in\n"
"this way, it‚Äôs conservative. If Rust accepted an incorrect program, users\n"
"wouldn‚Äôt be able to trust in the guarantees Rust makes. However, if Rust\n"
"rejects a correct program, the programmer will be inconvenienced, but "
"nothing\n"
"catastrophic can occur. The `RefCell<T>` type is useful when you‚Äôre sure "
"your\n"
"code follows the borrowing rules but the compiler is unable to understand "
"and\n"
"guarantee that."
msgstr ""

#: src/ch15-05-interior-mutability.md:56
msgid ""
"Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded "
"scenarios\n"
"and will give you a compile-time error if you try using it in a "
"multithreaded\n"
"context. We‚Äôll talk about how to get the functionality of `RefCell<T>` in a\n"
"multithreaded program in Chapter 16."
msgstr ""

#: src/ch15-05-interior-mutability.md:61
msgid ""
"Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:"
msgstr ""

#: src/ch15-05-interior-mutability.md:63
msgid ""
"* `Rc<T>` enables multiple owners of the same data; `Box<T>` and "
"`RefCell<T>`\n"
"  have single owners.\n"
"* `Box<T>` allows immutable or mutable borrows checked at compile time; "
"`Rc<T>`\n"
"  allows only immutable borrows checked at compile time; `RefCell<T>` "
"allows\n"
"  immutable or mutable borrows checked at runtime.\n"
"* Because `RefCell<T>` allows mutable borrows checked at runtime, you can\n"
"  mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is\n"
"  immutable."
msgstr ""

#: src/ch15-05-interior-mutability.md:72
msgid ""
"Mutating the value inside an immutable value is the *interior mutability*\n"
"pattern. Let‚Äôs look at a situation in which interior mutability is useful "
"and\n"
"examine how it‚Äôs possible."
msgstr ""

#: src/ch15-05-interior-mutability.md:76
msgid "### Interior Mutability: A Mutable Borrow to an Immutable Value"
msgstr ""

#: src/ch15-05-interior-mutability.md:78
msgid ""
"A consequence of the borrowing rules is that when you have an immutable "
"value,\n"
"you can‚Äôt borrow it mutably. For example, this code won‚Äôt compile:"
msgstr ""

#: src/ch15-05-interior-mutability.md:81
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let x = 5;\n"
"    let y = &mut x;\n"
"}\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:88
msgid "If you tried to compile this code, you‚Äôd get the following error:"
msgstr ""

#: src/ch15-05-interior-mutability.md:90
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling borrowing v0.1.0 (file:///projects/borrowing)\n"
"error[E0596]: cannot borrow `x` as mutable, as it is not declared as "
"mutable\n"
" --> src/main.rs:3:13\n"
"  |\n"
"2 |     let x = 5;\n"
"  |         - help: consider changing this to be mutable: `mut x`\n"
"3 |     let y = &mut x;\n"
"  |             ^^^^^^ cannot borrow as mutable\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `borrowing` due to previous error\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:105
msgid ""
"However, there are situations in which it would be useful for a value to "
"mutate\n"
"itself in its methods but appear immutable to other code. Code outside the\n"
"value‚Äôs methods would not be able to mutate the value. Using `RefCell<T>` "
"is\n"
"one way to get the ability to have interior mutability, but `RefCell<T>`\n"
"doesn‚Äôt get around the borrowing rules completely: the borrow checker in "
"the\n"
"compiler allows this interior mutability, and the borrowing rules are "
"checked\n"
"at runtime instead. If you violate the rules, you‚Äôll get a `panic!` instead "
"of\n"
"a compiler error."
msgstr ""

#: src/ch15-05-interior-mutability.md:114
msgid ""
"Let‚Äôs work through a practical example where we can use `RefCell<T>` to "
"mutate\n"
"an immutable value and see why that is useful."
msgstr ""

#: src/ch15-05-interior-mutability.md:117
msgid "#### A Use Case for Interior Mutability: Mock Objects"
msgstr ""

#: src/ch15-05-interior-mutability.md:119
msgid ""
"Sometimes during testing a programmer will use a type in place of another "
"type,\n"
"in order to observe particular behavior and assert it‚Äôs implemented "
"correctly.\n"
"This placeholder type is called a *test double*. Think of it in the sense of "
"a\n"
"‚Äústunt double‚Äù in filmmaking, where a person steps in and substitutes for "
"an\n"
"actor to do a particular tricky scene. Test doubles stand in for other "
"types\n"
"when we‚Äôre running tests. *Mock objects* are specific types of test doubles\n"
"that record what happens during a test so you can assert that the correct\n"
"actions took place."
msgstr ""

#: src/ch15-05-interior-mutability.md:128
msgid ""
"Rust doesn‚Äôt have objects in the same sense as other languages have "
"objects,\n"
"and Rust doesn‚Äôt have mock object functionality built into the standard "
"library\n"
"as some other languages do. However, you can definitely create a struct "
"that\n"
"will serve the same purposes as a mock object."
msgstr ""

#: src/ch15-05-interior-mutability.md:133
msgid ""
"Here‚Äôs the scenario we‚Äôll test: we‚Äôll create a library that tracks a value\n"
"against a maximum value and sends messages based on how close to the "
"maximum\n"
"value the current value is. This library could be used to keep track of a\n"
"user‚Äôs quota for the number of API calls they‚Äôre allowed to make, for "
"example."
msgstr ""

#: src/ch15-05-interior-mutability.md:138
msgid ""
"Our library will only provide the functionality of tracking how close to "
"the\n"
"maximum a value is and what the messages should be at what times. "
"Applications\n"
"that use our library will be expected to provide the mechanism for sending "
"the\n"
"messages: the application could put a message in the application, send an\n"
"email, send a text message, or something else. The library doesn‚Äôt need to "
"know\n"
"that detail. All it needs is something that implements a trait we‚Äôll "
"provide\n"
"called `Messenger`. Listing 15-20 shows the library code:"
msgstr ""

#: src/ch15-05-interior-mutability.md:148
msgid ""
"```rust,noplayground\n"
"pub trait Messenger {\n"
"    fn send(&self, msg: &str);\n"
"}\n"
"\n"
"pub struct LimitTracker<'a, T: Messenger> {\n"
"    messenger: &'a T,\n"
"    value: usize,\n"
"    max: usize,\n"
"}\n"
"\n"
"impl<'a, T> LimitTracker<'a, T>\n"
"where\n"
"    T: Messenger,\n"
"{\n"
"    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n"
"        LimitTracker {\n"
"            messenger,\n"
"            value: 0,\n"
"            max,\n"
"        }\n"
"    }\n"
"\n"
"    pub fn set_value(&mut self, value: usize) {\n"
"        self.value = value;\n"
"\n"
"        let percentage_of_max = self.value as f64 / self.max as f64;\n"
"\n"
"        if percentage_of_max >= 1.0 {\n"
"            self.messenger.send(\"Error: You are over your quota!\");\n"
"        } else if percentage_of_max >= 0.9 {\n"
"            self.messenger\n"
"                .send(\"Urgent warning: You've used up over 90% of your "
"quota!\");\n"
"        } else if percentage_of_max >= 0.75 {\n"
"            self.messenger\n"
"                .send(\"Warning: You've used up over 75% of your quota!\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:189
msgid ""
"<span class=\"caption\">Listing 15-20: A library to keep track of how close "
"a\n"
"value is to a maximum value and warn when the value is at certain levels</"
"span>"
msgstr ""

#: src/ch15-05-interior-mutability.md:192
msgid ""
"One important part of this code is that the `Messenger` trait has one "
"method\n"
"called `send` that takes an immutable reference to `self` and the text of "
"the\n"
"message. This trait is the interface our mock object needs to implement so "
"that\n"
"the mock can be used in the same way a real object is. The other important "
"part\n"
"is that we want to test the behavior of the `set_value` method on the\n"
"`LimitTracker`. We can change what we pass in for the `value` parameter, "
"but\n"
"`set_value` doesn‚Äôt return anything for us to make assertions on. We want to "
"be\n"
"able to say that if we create a `LimitTracker` with something that "
"implements\n"
"the `Messenger` trait and a particular value for `max`, when we pass "
"different\n"
"numbers for `value`, the messenger is told to send the appropriate messages."
msgstr ""

#: src/ch15-05-interior-mutability.md:203
msgid ""
"We need a mock object that, instead of sending an email or text message when "
"we\n"
"call `send`, will only keep track of the messages it‚Äôs told to send. We can\n"
"create a new instance of the mock object, create a `LimitTracker` that uses "
"the\n"
"mock object, call the `set_value` method on `LimitTracker`, and then check "
"that\n"
"the mock object has the messages we expect. Listing 15-21 shows an attempt "
"to\n"
"implement a mock object to do just that, but the borrow checker won‚Äôt allow "
"it:"
msgstr ""

#: src/ch15-05-interior-mutability.md:212
msgid ""
"```rust,ignore,does_not_compile\n"
"# pub trait Messenger {\n"
"#     fn send(&self, msg: &str);\n"
"# }\n"
"# \n"
"# pub struct LimitTracker<'a, T: Messenger> {\n"
"#     messenger: &'a T,\n"
"#     value: usize,\n"
"#     max: usize,\n"
"# }\n"
"# \n"
"# impl<'a, T> LimitTracker<'a, T>\n"
"# where\n"
"#     T: Messenger,\n"
"# {\n"
"#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n"
"#         LimitTracker {\n"
"#             messenger,\n"
"#             value: 0,\n"
"#             max,\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn set_value(&mut self, value: usize) {\n"
"#         self.value = value;\n"
"# \n"
"#         let percentage_of_max = self.value as f64 / self.max as f64;\n"
"# \n"
"#         if percentage_of_max >= 1.0 {\n"
"#             self.messenger.send(\"Error: You are over your quota!\");\n"
"#         } else if percentage_of_max >= 0.9 {\n"
"#             self.messenger\n"
"#                 .send(\"Urgent warning: You've used up over 90% of your "
"quota!\");\n"
"#         } else if percentage_of_max >= 0.75 {\n"
"#             self.messenger\n"
"#                 .send(\"Warning: You've used up over 75% of your quota!"
"\");\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    struct MockMessenger {\n"
"        sent_messages: Vec<String>,\n"
"    }\n"
"\n"
"    impl MockMessenger {\n"
"        fn new() -> MockMessenger {\n"
"            MockMessenger {\n"
"                sent_messages: vec![],\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    impl Messenger for MockMessenger {\n"
"        fn send(&self, message: &str) {\n"
"            self.sent_messages.push(String::from(message));\n"
"        }\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn it_sends_an_over_75_percent_warning_message() {\n"
"        let mock_messenger = MockMessenger::new();\n"
"        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n"
"\n"
"        limit_tracker.set_value(80);\n"
"\n"
"        assert_eq!(mock_messenger.sent_messages.len(), 1);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:286
msgid ""
"<span class=\"caption\">Listing 15-21: An attempt to implement a "
"`MockMessenger`\n"
"that isn‚Äôt allowed by the borrow checker</span>"
msgstr ""

#: src/ch15-05-interior-mutability.md:289
msgid ""
"This test code defines a `MockMessenger` struct that has a `sent_messages`\n"
"field with a `Vec` of `String` values to keep track of the messages it‚Äôs "
"told\n"
"to send. We also define an associated function `new` to make it convenient "
"to\n"
"create new `MockMessenger` values that start with an empty list of messages. "
"We\n"
"then implement the `Messenger` trait for `MockMessenger` so we can give a\n"
"`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, "
"we\n"
"take the message passed in as a parameter and store it in the "
"`MockMessenger`\n"
"list of `sent_messages`."
msgstr ""

#: src/ch15-05-interior-mutability.md:298
msgid ""
"In the test, we‚Äôre testing what happens when the `LimitTracker` is told to "
"set\n"
"`value` to something that is more than 75 percent of the `max` value. First, "
"we\n"
"create a new `MockMessenger`, which will start with an empty list of "
"messages.\n"
"Then we create a new `LimitTracker` and give it a reference to the new\n"
"`MockMessenger` and a `max` value of 100. We call the `set_value` method on "
"the\n"
"`LimitTracker` with a value of 80, which is more than 75 percent of 100. "
"Then\n"
"we assert that the list of messages that the `MockMessenger` is keeping "
"track\n"
"of should now have one message in it."
msgstr ""

#: src/ch15-05-interior-mutability.md:307
msgid "However, there‚Äôs one problem with this test, as shown here:"
msgstr ""

#: src/ch15-05-interior-mutability.md:309
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n"
"error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind "
"a `&` reference\n"
"  --> src/lib.rs:58:13\n"
"   |\n"
"2  |     fn send(&self, msg: &str);\n"
"   |             ----- help: consider changing that to be a mutable "
"reference: `&mut self`\n"
"...\n"
"58 |             self.sent_messages.push(String::from(message));\n"
"   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a "
"`&` reference, so the data it refers to cannot be borrowed as mutable\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `limit-tracker` due to previous error\n"
"warning: build failed, waiting for other jobs to finish...\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:326
msgid ""
"We can‚Äôt modify the `MockMessenger` to keep track of the messages, because "
"the\n"
"`send` method takes an immutable reference to `self`. We also can‚Äôt take "
"the\n"
"suggestion from the error text to use `&mut self` instead, because then the\n"
"signature of `send` wouldn‚Äôt match the signature in the `Messenger` trait\n"
"definition (feel free to try and see what error message you get)."
msgstr ""

#: src/ch15-05-interior-mutability.md:332
msgid ""
"This is a situation in which interior mutability can help! We‚Äôll store the\n"
"`sent_messages` within a `RefCell<T>`, and then the `send` method will be\n"
"able to modify `sent_messages` to store the messages we‚Äôve seen. Listing "
"15-22\n"
"shows what that looks like:"
msgstr ""

#: src/ch15-05-interior-mutability.md:339
msgid ""
"```rust,noplayground\n"
"# pub trait Messenger {\n"
"#     fn send(&self, msg: &str);\n"
"# }\n"
"# \n"
"# pub struct LimitTracker<'a, T: Messenger> {\n"
"#     messenger: &'a T,\n"
"#     value: usize,\n"
"#     max: usize,\n"
"# }\n"
"# \n"
"# impl<'a, T> LimitTracker<'a, T>\n"
"# where\n"
"#     T: Messenger,\n"
"# {\n"
"#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n"
"#         LimitTracker {\n"
"#             messenger,\n"
"#             value: 0,\n"
"#             max,\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn set_value(&mut self, value: usize) {\n"
"#         self.value = value;\n"
"# \n"
"#         let percentage_of_max = self.value as f64 / self.max as f64;\n"
"# \n"
"#         if percentage_of_max >= 1.0 {\n"
"#             self.messenger.send(\"Error: You are over your quota!\");\n"
"#         } else if percentage_of_max >= 0.9 {\n"
"#             self.messenger\n"
"#                 .send(\"Urgent warning: You've used up over 90% of your "
"quota!\");\n"
"#         } else if percentage_of_max >= 0.75 {\n"
"#             self.messenger\n"
"#                 .send(\"Warning: You've used up over 75% of your quota!"
"\");\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::cell::RefCell;\n"
"\n"
"    struct MockMessenger {\n"
"        sent_messages: RefCell<Vec<String>>,\n"
"    }\n"
"\n"
"    impl MockMessenger {\n"
"        fn new() -> MockMessenger {\n"
"            MockMessenger {\n"
"                sent_messages: RefCell::new(vec![]),\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    impl Messenger for MockMessenger {\n"
"        fn send(&self, message: &str) {\n"
"            self.sent_messages.borrow_mut().push(String::from(message));\n"
"        }\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn it_sends_an_over_75_percent_warning_message() {\n"
"        // --snip--\n"
"#         let mock_messenger = MockMessenger::new();\n"
"#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n"
"# \n"
"#         limit_tracker.set_value(80);\n"
"\n"
"        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:415
msgid ""
"<span class=\"caption\">Listing 15-22: Using `RefCell<T>` to mutate an "
"inner\n"
"value while the outer value is considered immutable</span>"
msgstr ""

#: src/ch15-05-interior-mutability.md:418
msgid ""
"The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of\n"
"`Vec<String>`. In the `new` function, we create a new "
"`RefCell<Vec<String>>`\n"
"instance around the empty vector."
msgstr ""

#: src/ch15-05-interior-mutability.md:422
msgid ""
"For the implementation of the `send` method, the first parameter is still "
"an\n"
"immutable borrow of `self`, which matches the trait definition. We call\n"
"`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a\n"
"mutable reference to the value inside the `RefCell<Vec<String>>`, which is "
"the\n"
"vector. Then we can call `push` on the mutable reference to the vector to "
"keep\n"
"track of the messages sent during the test."
msgstr ""

#: src/ch15-05-interior-mutability.md:429
msgid ""
"The last change we have to make is in the assertion: to see how many items "
"are\n"
"in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get "
"an\n"
"immutable reference to the vector."
msgstr ""

#: src/ch15-05-interior-mutability.md:433
msgid ""
"Now that you‚Äôve seen how to use `RefCell<T>`, let‚Äôs dig into how it works!"
msgstr ""

#: src/ch15-05-interior-mutability.md:435
msgid "#### Keeping Track of Borrows at Runtime with `RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:437
msgid ""
"When creating immutable and mutable references, we use the `&` and `&mut`\n"
"syntax, respectively. With `RefCell<T>`, we use the `borrow` and "
"`borrow_mut`\n"
"methods, which are part of the safe API that belongs to `RefCell<T>`. The\n"
"`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`\n"
"returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so "
"we\n"
"can treat them like regular references."
msgstr ""

#: src/ch15-05-interior-mutability.md:444
msgid ""
"The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart\n"
"pointers are currently active. Every time we call `borrow`, the "
"`RefCell<T>`\n"
"increases its count of how many immutable borrows are active. When a "
"`Ref<T>`\n"
"value goes out of scope, the count of immutable borrows goes down by one. "
"Just\n"
"like the compile-time borrowing rules, `RefCell<T>` lets us have many "
"immutable\n"
"borrows or one mutable borrow at any point in time."
msgstr ""

#: src/ch15-05-interior-mutability.md:451
msgid ""
"If we try to violate these rules, rather than getting a compiler error as "
"we\n"
"would with references, the implementation of `RefCell<T>` will panic at\n"
"runtime. Listing 15-23 shows a modification of the implementation of `send` "
"in\n"
"Listing 15-22. We‚Äôre deliberately trying to create two mutable borrows "
"active\n"
"for the same scope to illustrate that `RefCell<T>` prevents us from doing "
"this\n"
"at runtime."
msgstr ""

#: src/ch15-05-interior-mutability.md:460
msgid ""
"```rust,ignore,panics\n"
"# pub trait Messenger {\n"
"#     fn send(&self, msg: &str);\n"
"# }\n"
"# \n"
"# pub struct LimitTracker<'a, T: Messenger> {\n"
"#     messenger: &'a T,\n"
"#     value: usize,\n"
"#     max: usize,\n"
"# }\n"
"# \n"
"# impl<'a, T> LimitTracker<'a, T>\n"
"# where\n"
"#     T: Messenger,\n"
"# {\n"
"#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n"
"#         LimitTracker {\n"
"#             messenger,\n"
"#             value: 0,\n"
"#             max,\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn set_value(&mut self, value: usize) {\n"
"#         self.value = value;\n"
"# \n"
"#         let percentage_of_max = self.value as f64 / self.max as f64;\n"
"# \n"
"#         if percentage_of_max >= 1.0 {\n"
"#             self.messenger.send(\"Error: You are over your quota!\");\n"
"#         } else if percentage_of_max >= 0.9 {\n"
"#             self.messenger\n"
"#                 .send(\"Urgent warning: You've used up over 90% of your "
"quota!\");\n"
"#         } else if percentage_of_max >= 0.75 {\n"
"#             self.messenger\n"
"#                 .send(\"Warning: You've used up over 75% of your quota!"
"\");\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::*;\n"
"#     use std::cell::RefCell;\n"
"# \n"
"#     struct MockMessenger {\n"
"#         sent_messages: RefCell<Vec<String>>,\n"
"#     }\n"
"# \n"
"#     impl MockMessenger {\n"
"#         fn new() -> MockMessenger {\n"
"#             MockMessenger {\n"
"#                 sent_messages: RefCell::new(vec![]),\n"
"#             }\n"
"#         }\n"
"#     }\n"
"# \n"
"    impl Messenger for MockMessenger {\n"
"        fn send(&self, message: &str) {\n"
"            let mut one_borrow = self.sent_messages.borrow_mut();\n"
"            let mut two_borrow = self.sent_messages.borrow_mut();\n"
"\n"
"            one_borrow.push(String::from(message));\n"
"            two_borrow.push(String::from(message));\n"
"        }\n"
"    }\n"
"# \n"
"#     #[test]\n"
"#     fn it_sends_an_over_75_percent_warning_message() {\n"
"#         let mock_messenger = MockMessenger::new();\n"
"#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n"
"# \n"
"#         limit_tracker.set_value(80);\n"
"# \n"
"#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:539
msgid ""
"<span class=\"caption\">Listing 15-23: Creating two mutable references in "
"the\n"
"same scope to see that `RefCell<T>` will panic</span>"
msgstr ""

#: src/ch15-05-interior-mutability.md:542
msgid ""
"We create a variable `one_borrow` for the `RefMut<T>` smart pointer "
"returned\n"
"from `borrow_mut`. Then we create another mutable borrow in the same way in "
"the\n"
"variable `two_borrow`. This makes two mutable references in the same scope,\n"
"which isn‚Äôt allowed. When we run the tests for our library, the code in "
"Listing\n"
"15-23 will compile without any errors, but the test will fail:"
msgstr ""

#: src/ch15-05-interior-mutability.md:548
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n"
"    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n"
"     Running unittests src/lib.rs (target/debug/deps/limit_tracker-"
"e599811fa246dbde)\n"
"\n"
"running 1 test\n"
"test tests::it_sends_an_over_75_percent_warning_message ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::it_sends_an_over_75_percent_warning_message stdout ----\n"
"thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at "
"'already borrowed: BorrowMutError', src/lib.rs:60:53\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::it_sends_an_over_75_percent_warning_message\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:572
msgid ""
"Notice that the code panicked with the message `already borrowed:\n"
"BorrowMutError`. This is how `RefCell<T>` handles violations of the "
"borrowing\n"
"rules at runtime."
msgstr ""

#: src/ch15-05-interior-mutability.md:576
msgid ""
"Choosing to catch borrowing errors at runtime rather than compile time, as\n"
"we‚Äôve done here, means you‚Äôd potentially be finding mistakes in your code "
"later\n"
"in the development process: possibly not until your code was deployed to\n"
"production. Also, your code would incur a small runtime performance penalty "
"as\n"
"a result of keeping track of the borrows at runtime rather than compile "
"time.\n"
"However, using `RefCell<T>` makes it possible to write a mock object that "
"can\n"
"modify itself to keep track of the messages it has seen while you‚Äôre using "
"it\n"
"in a context where only immutable values are allowed. You can use "
"`RefCell<T>`\n"
"despite its trade-offs to get more functionality than regular references\n"
"provide."
msgstr ""

#: src/ch15-05-interior-mutability.md:587
msgid ""
"### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and "
"`RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:589
msgid ""
"A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall "
"that\n"
"`Rc<T>` lets you have multiple owners of some data, but it only gives "
"immutable\n"
"access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you "
"can\n"
"get a value that can have multiple owners *and* that you can mutate!"
msgstr ""

#: src/ch15-05-interior-mutability.md:594
msgid ""
"For example, recall the cons list example in Listing 15-18 where we used\n"
"`Rc<T>` to allow multiple lists to share ownership of another list. Because\n"
"`Rc<T>` holds only immutable values, we can‚Äôt change any of the values in "
"the\n"
"list once we‚Äôve created them. Let‚Äôs add in `RefCell<T>` to gain the ability "
"to\n"
"change the values in the lists. Listing 15-24 shows that by using a\n"
"`RefCell<T>` in the `Cons` definition, we can modify the value stored in "
"all\n"
"the lists:"
msgstr ""

#: src/ch15-05-interior-mutability.md:604
msgid ""
"```rust\n"
"#[derive(Debug)]\n"
"enum List {\n"
"    Cons(Rc<RefCell<i32>>, Rc<List>),\n"
"    Nil,\n"
"}\n"
"\n"
"use crate::List::{Cons, Nil};\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let value = Rc::new(RefCell::new(5));\n"
"\n"
"    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n"
"\n"
"    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n"
"    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n"
"\n"
"    *value.borrow_mut() += 10;\n"
"\n"
"    println!(\"a after = {:?}\", a);\n"
"    println!(\"b after = {:?}\", b);\n"
"    println!(\"c after = {:?}\", c);\n"
"}\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:631
msgid ""
"<span class=\"caption\">Listing 15-24: Using `Rc<RefCell<i32>>` to create a\n"
"`List` that we can mutate</span>"
msgstr ""

#: src/ch15-05-interior-mutability.md:634
msgid ""
"We create a value that is an instance of `Rc<RefCell<i32>>` and store it in "
"a\n"
"variable named `value` so we can access it directly later. Then we create a\n"
"`List` in `a` with a `Cons` variant that holds `value`. We need to clone\n"
"`value` so both `a` and `value` have ownership of the inner `5` value "
"rather\n"
"than transferring ownership from `value` to `a` or having `a` borrow from\n"
"`value`."
msgstr ""

#: src/ch15-05-interior-mutability.md:641
msgid ""
"We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, "
"they\n"
"can both refer to `a`, which is what we did in Listing 15-18."
msgstr ""

#: src/ch15-05-interior-mutability.md:644
msgid ""
"After we‚Äôve created the lists in `a`, `b`, and `c`, we want to add 10 to "
"the\n"
"value in `value`. We do this by calling `borrow_mut` on `value`, which uses "
"the\n"
"automatic dereferencing feature we discussed in Chapter 5 (see the section\n"
"[‚ÄúWhere‚Äôs the `->` Operator?‚Äù][wheres-the---operator]<!-- ignore -->) to\n"
"dereference the `Rc<T>` to the inner `RefCell<T>` value. The `borrow_mut`\n"
"method returns a `RefMut<T>` smart pointer, and we use the dereference "
"operator\n"
"on it and change the inner value."
msgstr ""

#: src/ch15-05-interior-mutability.md:652
msgid ""
"When we print `a`, `b`, and `c`, we can see that they all have the modified\n"
"value of 15 rather than 5:"
msgstr ""

#: src/ch15-05-interior-mutability.md:655
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.63s\n"
"     Running `target/debug/cons-list`\n"
"a after = Cons(RefCell { value: 15 }, Nil)\n"
"b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\n"
"c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:665
msgid ""
"This technique is pretty neat! By using `RefCell<T>`, we have an outwardly\n"
"immutable `List` value. But we can use the methods on `RefCell<T>` that "
"provide\n"
"access to its interior mutability so we can modify our data when we need "
"to.\n"
"The runtime checks of the borrowing rules protect us from data races, and "
"it‚Äôs\n"
"sometimes worth trading a bit of speed for this flexibility in our data\n"
"structures. Note that `RefCell<T>` does not work for multithreaded code!\n"
"`Mutex<T>` is the thread-safe version of `RefCell<T>` and we‚Äôll discuss\n"
"`Mutex<T>` in Chapter 16."
msgstr ""

#: src/ch15-06-reference-cycles.md:1
msgid "## Reference Cycles Can Leak Memory"
msgstr ""

#: src/ch15-06-reference-cycles.md:3
msgid ""
"Rust‚Äôs memory safety guarantees make it difficult, but not impossible, to\n"
"accidentally create memory that is never cleaned up (known as a *memory "
"leak*).\n"
"Preventing memory leaks entirely is not one of Rust‚Äôs guarantees, meaning\n"
"memory leaks are memory safe in Rust. We can see that Rust allows memory "
"leaks\n"
"by using `Rc<T>` and `RefCell<T>`: it‚Äôs possible to create references where\n"
"items refer to each other in a cycle. This creates memory leaks because the\n"
"reference count of each item in the cycle will never reach 0, and the "
"values\n"
"will never be dropped."
msgstr ""

#: src/ch15-06-reference-cycles.md:12
msgid "### Creating a Reference Cycle"
msgstr ""

#: src/ch15-06-reference-cycles.md:14
msgid ""
"Let‚Äôs look at how a reference cycle might happen and how to prevent it,\n"
"starting with the definition of the `List` enum and a `tail` method in "
"Listing\n"
"15-25:"
msgstr ""

#: src/ch15-06-reference-cycles.md:20
msgid ""
"```rust\n"
"use crate::List::{Cons, Nil};\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug)]\n"
"enum List {\n"
"    Cons(i32, RefCell<Rc<List>>),\n"
"    Nil,\n"
"}\n"
"\n"
"impl List {\n"
"    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n"
"        match self {\n"
"            Cons(_, item) => Some(item),\n"
"            Nil => None,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:43
msgid ""
"<span class=\"caption\">Listing 15-25: A cons list definition that holds a\n"
"`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:46
msgid ""
"We‚Äôre using another variation of the `List` definition from Listing 15-5. "
"The\n"
"second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning "
"that\n"
"instead of having the ability to modify the `i32` value as we did in "
"Listing\n"
"15-24, we want to modify the `List` value a `Cons` variant is pointing to.\n"
"We‚Äôre also adding a `tail` method to make it convenient for us to access "
"the\n"
"second item if we have a `Cons` variant."
msgstr ""

#: src/ch15-06-reference-cycles.md:53
msgid ""
"In Listing 15-26, we‚Äôre adding a `main` function that uses the definitions "
"in\n"
"Listing 15-25. This code creates a list in `a` and a list in `b` that points "
"to\n"
"the list in `a`. Then it modifies the list in `a` to point to `b`, creating "
"a\n"
"reference cycle. There are `println!` statements along the way to show what "
"the\n"
"reference counts are at various points in this process."
msgstr ""

#: src/ch15-06-reference-cycles.md:61
msgid ""
"```rust\n"
"# use crate::List::{Cons, Nil};\n"
"# use std::cell::RefCell;\n"
"# use std::rc::Rc;\n"
"# \n"
"# #[derive(Debug)]\n"
"# enum List {\n"
"#     Cons(i32, RefCell<Rc<List>>),\n"
"#     Nil,\n"
"# }\n"
"# \n"
"# impl List {\n"
"#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n"
"#         match self {\n"
"#             Cons(_, item) => Some(item),\n"
"#             Nil => None,\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n"
"\n"
"    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n"
"    println!(\"a next item = {:?}\", a.tail());\n"
"\n"
"    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n"
"\n"
"    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n"
"    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n"
"    println!(\"b next item = {:?}\", b.tail());\n"
"\n"
"    if let Some(link) = a.tail() {\n"
"        *link.borrow_mut() = Rc::clone(&b);\n"
"    }\n"
"\n"
"    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n"
"    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n"
"\n"
"    // Uncomment the next line to see that we have a cycle;\n"
"    // it will overflow the stack\n"
"    // println!(\"a next item = {:?}\", a.tail());\n"
"}\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:106
msgid ""
"<span class=\"caption\">Listing 15-26: Creating a reference cycle of two "
"`List`\n"
"values pointing to each other</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:109
msgid ""
"We create an `Rc<List>` instance holding a `List` value in the variable `a`\n"
"with an initial list of `5, Nil`. We then create an `Rc<List>` instance "
"holding\n"
"another `List` value in the variable `b` that contains the value 10 and "
"points\n"
"to the list in `a`."
msgstr ""

#: src/ch15-06-reference-cycles.md:114
msgid ""
"We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We do\n"
"that by using the `tail` method to get a reference to the "
"`RefCell<Rc<List>>`\n"
"in `a`, which we put in the variable `link`. Then we use the `borrow_mut`\n"
"method on the `RefCell<Rc<List>>` to change the value inside from an "
"`Rc<List>`\n"
"that holds a `Nil` value to the `Rc<List>` in `b`."
msgstr ""

#: src/ch15-06-reference-cycles.md:120
msgid ""
"When we run this code, keeping the last `println!` commented out for the\n"
"moment, we‚Äôll get this output:"
msgstr ""

#: src/ch15-06-reference-cycles.md:123
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.53s\n"
"     Running `target/debug/cons-list`\n"
"a initial rc count = 1\n"
"a next item = Some(RefCell { value: Nil })\n"
"a rc count after b creation = 2\n"
"b initial rc count = 1\n"
"b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\n"
"b rc count after changing a = 2\n"
"a rc count after changing a = 2\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:137
msgid ""
"The reference count of the `Rc<List>` instances in both `a` and `b` are 2 "
"after\n"
"we change the list in `a` to point to `b`. At the end of `main`, Rust drops "
"the\n"
"variable `b`, which decreases the reference count of the `b` `Rc<List>` "
"instance\n"
"from 2 to 1. The memory that `Rc<List>` has on the heap won‚Äôt be dropped at\n"
"this point, because its reference count is 1, not 0. Then Rust drops `a`, "
"which\n"
"decreases the reference count of the `a` `Rc<List>` instance from 2 to 1 as\n"
"well. This instance‚Äôs memory can‚Äôt be dropped either, because the other\n"
"`Rc<List>` instance still refers to it. The memory allocated to the list "
"will\n"
"remain uncollected forever. To visualize this reference cycle, we‚Äôve created "
"a\n"
"diagram in Figure 15-4."
msgstr ""

#: src/ch15-06-reference-cycles.md:148
msgid ""
"<img alt=\"Reference cycle of lists\" src=\"img/trpl15-04.svg\" "
"class=\"center\" />"
msgstr ""

#: src/ch15-06-reference-cycles.md:150
msgid ""
"<span class=\"caption\">Figure 15-4: A reference cycle of lists `a` and `b`\n"
"pointing to each other</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:153
msgid ""
"If you uncomment the last `println!` and run the program, Rust will try to\n"
"print this cycle with `a` pointing to `b` pointing to `a` and so forth until "
"it\n"
"overflows the stack."
msgstr ""

#: src/ch15-06-reference-cycles.md:157
msgid ""
"Compared to a real-world program, the consequences of creating a reference "
"cycle\n"
"in this example aren‚Äôt very dire: right after we create the reference "
"cycle,\n"
"the program ends. However, if a more complex program allocated lots of "
"memory\n"
"in a cycle and held onto it for a long time, the program would use more "
"memory\n"
"than it needed and might overwhelm the system, causing it to run out of\n"
"available memory."
msgstr ""

#: src/ch15-06-reference-cycles.md:164
msgid ""
"Creating reference cycles is not easily done, but it‚Äôs not impossible "
"either.\n"
"If you have `RefCell<T>` values that contain `Rc<T>` values or similar "
"nested\n"
"combinations of types with interior mutability and reference counting, you "
"must\n"
"ensure that you don‚Äôt create cycles; you can‚Äôt rely on Rust to catch them.\n"
"Creating a reference cycle would be a logic bug in your program that you "
"should\n"
"use automated tests, code reviews, and other software development practices "
"to\n"
"minimize."
msgstr ""

#: src/ch15-06-reference-cycles.md:172
msgid ""
"Another solution for avoiding reference cycles is reorganizing your data\n"
"structures so that some references express ownership and some references "
"don‚Äôt.\n"
"As a result, you can have cycles made up of some ownership relationships "
"and\n"
"some non-ownership relationships, and only the ownership relationships "
"affect\n"
"whether or not a value can be dropped. In Listing 15-25, we always want "
"`Cons`\n"
"variants to own their list, so reorganizing the data structure isn‚Äôt "
"possible.\n"
"Let‚Äôs look at an example using graphs made up of parent nodes and child "
"nodes\n"
"to see when non-ownership relationships are an appropriate way to prevent\n"
"reference cycles."
msgstr ""

#: src/ch15-06-reference-cycles.md:182
msgid "### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`"
msgstr ""

#: src/ch15-06-reference-cycles.md:184
msgid ""
"So far, we‚Äôve demonstrated that calling `Rc::clone` increases the\n"
"`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only "
"cleaned\n"
"up if its `strong_count` is 0. You can also create a *weak reference* to "
"the\n"
"value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a\n"
"reference to the `Rc<T>`. Strong references are how you can share ownership "
"of\n"
"an `Rc<T>` instance. Weak references don‚Äôt express an ownership "
"relationship,\n"
"and their count doesn‚Äôt affect when an `Rc<T>` instance is cleaned up. They\n"
"won‚Äôt cause a reference cycle because any cycle involving some weak "
"references\n"
"will be broken once the strong reference count of values involved is 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:194
msgid ""
"When you call `Rc::downgrade`, you get a smart pointer of type `Weak<T>`.\n"
"Instead of increasing the `strong_count` in the `Rc<T>` instance by 1, "
"calling\n"
"`Rc::downgrade` increases the `weak_count` by 1. The `Rc<T>` type uses\n"
"`weak_count` to keep track of how many `Weak<T>` references exist, similar "
"to\n"
"`strong_count`. The difference is the `weak_count` doesn‚Äôt need to be 0 for "
"the\n"
"`Rc<T>` instance to be cleaned up."
msgstr ""

#: src/ch15-06-reference-cycles.md:201
msgid ""
"Because the value that `Weak<T>` references might have been dropped, to do\n"
"anything with the value that a `Weak<T>` is pointing to, you must make sure "
"the\n"
"value still exists. Do this by calling the `upgrade` method on a `Weak<T>`\n"
"instance, which will return an `Option<Rc<T>>`. You‚Äôll get a result of "
"`Some`\n"
"if the `Rc<T>` value has not been dropped yet and a result of `None` if the\n"
"`Rc<T>` value has been dropped. Because `upgrade` returns an "
"`Option<Rc<T>>`,\n"
"Rust will ensure that the `Some` case and the `None` case are handled, and\n"
"there won‚Äôt be an invalid pointer."
msgstr ""

#: src/ch15-06-reference-cycles.md:210
msgid ""
"As an example, rather than using a list whose items know only about the "
"next\n"
"item, we‚Äôll create a tree whose items know about their children items *and*\n"
"their parent items."
msgstr ""

#: src/ch15-06-reference-cycles.md:214
msgid "#### Creating a Tree Data Structure: a `Node` with Child Nodes"
msgstr ""

#: src/ch15-06-reference-cycles.md:216
msgid ""
"To start, we‚Äôll build a tree with nodes that know about their child nodes.\n"
"We‚Äôll create a struct named `Node` that holds its own `i32` value as well "
"as\n"
"references to its children `Node` values:"
msgstr ""

#: src/ch15-06-reference-cycles.md:222
msgid ""
"```rust\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i32,\n"
"    children: RefCell<Vec<Rc<Node>>>,\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let leaf = Rc::new(Node {\n"
"#         value: 3,\n"
"#         children: RefCell::new(vec![]),\n"
"#     });\n"
"# \n"
"#     let branch = Rc::new(Node {\n"
"#         value: 5,\n"
"#         children: RefCell::new(vec![Rc::clone(&leaf)]),\n"
"#     });\n"
"# }\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:245
msgid ""
"We want a `Node` to own its children, and we want to share that ownership "
"with\n"
"variables so we can access each `Node` in the tree directly. To do this, we\n"
"define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to\n"
"modify which nodes are children of another node, so we have a `RefCell<T>` "
"in\n"
"`children` around the `Vec<Rc<Node>>`."
msgstr ""

#: src/ch15-06-reference-cycles.md:251
msgid ""
"Next, we‚Äôll use our struct definition and create one `Node` instance named\n"
"`leaf` with the value 3 and no children, and another instance named "
"`branch`\n"
"with the value 5 and `leaf` as one of its children, as shown in Listing "
"15-27:"
msgstr ""

#: src/ch15-06-reference-cycles.md:257
msgid ""
"```rust\n"
"# use std::cell::RefCell;\n"
"# use std::rc::Rc;\n"
"# \n"
"# #[derive(Debug)]\n"
"# struct Node {\n"
"#     value: i32,\n"
"#     children: RefCell<Vec<Rc<Node>>>,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let leaf = Rc::new(Node {\n"
"        value: 3,\n"
"        children: RefCell::new(vec![]),\n"
"    });\n"
"\n"
"    let branch = Rc::new(Node {\n"
"        value: 5,\n"
"        children: RefCell::new(vec![Rc::clone(&leaf)]),\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:280
msgid ""
"<span class=\"caption\">Listing 15-27: Creating a `leaf` node with no "
"children\n"
"and a `branch` node with `leaf` as one of its children</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:283
msgid ""
"We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the\n"
"`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from\n"
"`branch` to `leaf` through `branch.children`, but there‚Äôs no way to get "
"from\n"
"`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` "
"and\n"
"doesn‚Äôt know they‚Äôre related. We want `leaf` to know that `branch` is its\n"
"parent. We‚Äôll do that next."
msgstr ""

#: src/ch15-06-reference-cycles.md:290
msgid "#### Adding a Reference from a Child to Its Parent"
msgstr ""

#: src/ch15-06-reference-cycles.md:292
msgid ""
"To make the child node aware of its parent, we need to add a `parent` field "
"to\n"
"our `Node` struct definition. The trouble is in deciding what the type of\n"
"`parent` should be. We know it can‚Äôt contain an `Rc<T>`, because that would\n"
"create a reference cycle with `leaf.parent` pointing to `branch` and\n"
"`branch.children` pointing to `leaf`, which would cause their "
"`strong_count`\n"
"values to never be 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:299
msgid ""
"Thinking about the relationships another way, a parent node should own its\n"
"children: if a parent node is dropped, its child nodes should be dropped as\n"
"well. However, a child should not own its parent: if we drop a child node, "
"the\n"
"parent should still exist. This is a case for weak references!"
msgstr ""

#: src/ch15-06-reference-cycles.md:304
msgid ""
"So instead of `Rc<T>`, we‚Äôll make the type of `parent` use `Weak<T>`,\n"
"specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition "
"looks\n"
"like this:"
msgstr ""

#: src/ch15-06-reference-cycles.md:310
msgid ""
"```rust\n"
"use std::cell::RefCell;\n"
"use std::rc::{Rc, Weak};\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i32,\n"
"    parent: RefCell<Weak<Node>>,\n"
"    children: RefCell<Vec<Rc<Node>>>,\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let leaf = Rc::new(Node {\n"
"#         value: 3,\n"
"#         parent: RefCell::new(Weak::new()),\n"
"#         children: RefCell::new(vec![]),\n"
"#     });\n"
"# \n"
"#     println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n"
"# \n"
"#     let branch = Rc::new(Node {\n"
"#         value: 5,\n"
"#         parent: RefCell::new(Weak::new()),\n"
"#         children: RefCell::new(vec![Rc::clone(&leaf)]),\n"
"#     });\n"
"# \n"
"#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n"
"# \n"
"#     println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n"
"# }\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:342
msgid ""
"A node will be able to refer to its parent node but doesn‚Äôt own its parent.\n"
"In Listing 15-28, we update `main` to use this new definition so the `leaf`\n"
"node will have a way to refer to its parent, `branch`:"
msgstr ""

#: src/ch15-06-reference-cycles.md:348
msgid ""
"```rust\n"
"# use std::cell::RefCell;\n"
"# use std::rc::{Rc, Weak};\n"
"# \n"
"# #[derive(Debug)]\n"
"# struct Node {\n"
"#     value: i32,\n"
"#     parent: RefCell<Weak<Node>>,\n"
"#     children: RefCell<Vec<Rc<Node>>>,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let leaf = Rc::new(Node {\n"
"        value: 3,\n"
"        parent: RefCell::new(Weak::new()),\n"
"        children: RefCell::new(vec![]),\n"
"    });\n"
"\n"
"    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n"
"\n"
"    let branch = Rc::new(Node {\n"
"        value: 5,\n"
"        parent: RefCell::new(Weak::new()),\n"
"        children: RefCell::new(vec![Rc::clone(&leaf)]),\n"
"    });\n"
"\n"
"    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n"
"\n"
"    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n"
"}\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:380
msgid ""
"<span class=\"caption\">Listing 15-28: A `leaf` node with a weak reference "
"to its\n"
"parent node `branch`</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:383
msgid ""
"Creating the `leaf` node looks similar to Listing 15-27 with the exception "
"of\n"
"the `parent` field: `leaf` starts out without a parent, so we create a new,\n"
"empty `Weak<Node>` reference instance."
msgstr ""

#: src/ch15-06-reference-cycles.md:387
msgid ""
"At this point, when we try to get a reference to the parent of `leaf` by "
"using\n"
"the `upgrade` method, we get a `None` value. We see this in the output from "
"the\n"
"first `println!` statement:"
msgstr ""

#: src/ch15-06-reference-cycles.md:391
msgid ""
"```text\n"
"leaf parent = None\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:395
msgid ""
"When we create the `branch` node, it will also have a new `Weak<Node>`\n"
"reference in the `parent` field, because `branch` doesn‚Äôt have a parent "
"node.\n"
"We still have `leaf` as one of the children of `branch`. Once we have the\n"
"`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`\n"
"reference to its parent. We use the `borrow_mut` method on the\n"
"`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the\n"
"`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` "
"from\n"
"the `Rc<Node>` in `branch.`"
msgstr ""

#: src/ch15-06-reference-cycles.md:404
msgid ""
"When we print the parent of `leaf` again, this time we‚Äôll get a `Some` "
"variant\n"
"holding `branch`: now `leaf` can access its parent! When we print `leaf`, "
"we\n"
"also avoid the cycle that eventually ended in a stack overflow like we had "
"in\n"
"Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:"
msgstr ""

#: src/ch15-06-reference-cycles.md:409
msgid ""
"```text\n"
"leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\n"
"children: RefCell { value: [Node { value: 3, parent: RefCell { value: "
"(Weak) },\n"
"children: RefCell { value: [] } }] } })\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:415
msgid ""
"The lack of infinite output indicates that this code didn‚Äôt create a "
"reference\n"
"cycle. We can also tell this by looking at the values we get from calling\n"
"`Rc::strong_count` and `Rc::weak_count`."
msgstr ""

#: src/ch15-06-reference-cycles.md:419
msgid "#### Visualizing Changes to `strong_count` and `weak_count`"
msgstr ""

#: src/ch15-06-reference-cycles.md:421
msgid ""
"Let‚Äôs look at how the `strong_count` and `weak_count` values of the "
"`Rc<Node>`\n"
"instances change by creating a new inner scope and moving the creation of\n"
"`branch` into that scope. By doing so, we can see what happens when `branch` "
"is\n"
"created and then dropped when it goes out of scope. The modifications are "
"shown\n"
"in Listing 15-29:"
msgstr ""

#: src/ch15-06-reference-cycles.md:429
msgid ""
"```rust\n"
"# use std::cell::RefCell;\n"
"# use std::rc::{Rc, Weak};\n"
"# \n"
"# #[derive(Debug)]\n"
"# struct Node {\n"
"#     value: i32,\n"
"#     parent: RefCell<Weak<Node>>,\n"
"#     children: RefCell<Vec<Rc<Node>>>,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let leaf = Rc::new(Node {\n"
"        value: 3,\n"
"        parent: RefCell::new(Weak::new()),\n"
"        children: RefCell::new(vec![]),\n"
"    });\n"
"\n"
"    println!(\n"
"        \"leaf strong = {}, weak = {}\",\n"
"        Rc::strong_count(&leaf),\n"
"        Rc::weak_count(&leaf),\n"
"    );\n"
"\n"
"    {\n"
"        let branch = Rc::new(Node {\n"
"            value: 5,\n"
"            parent: RefCell::new(Weak::new()),\n"
"            children: RefCell::new(vec![Rc::clone(&leaf)]),\n"
"        });\n"
"\n"
"        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n"
"\n"
"        println!(\n"
"            \"branch strong = {}, weak = {}\",\n"
"            Rc::strong_count(&branch),\n"
"            Rc::weak_count(&branch),\n"
"        );\n"
"\n"
"        println!(\n"
"            \"leaf strong = {}, weak = {}\",\n"
"            Rc::strong_count(&leaf),\n"
"            Rc::weak_count(&leaf),\n"
"        );\n"
"    }\n"
"\n"
"    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n"
"    println!(\n"
"        \"leaf strong = {}, weak = {}\",\n"
"        Rc::strong_count(&leaf),\n"
"        Rc::weak_count(&leaf),\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:484
msgid ""
"<span class=\"caption\">Listing 15-29: Creating `branch` in an inner scope "
"and\n"
"examining strong and weak reference counts</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:487
msgid ""
"After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak\n"
"count of 0. In the inner scope, we create `branch` and associate it with\n"
"`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`\n"
"will have a strong count of 1 and a weak count of 1 (for `leaf.parent` "
"pointing\n"
"to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we‚Äôll "
"see\n"
"it will have a strong count of 2, because `branch` now has a clone of the\n"
"`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a "
"weak\n"
"count of 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:496
msgid ""
"When the inner scope ends, `branch` goes out of scope and the strong count "
"of\n"
"the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of "
"1\n"
"from `leaf.parent` has no bearing on whether or not `Node` is dropped, so "
"we\n"
"don‚Äôt get any memory leaks!"
msgstr ""

#: src/ch15-06-reference-cycles.md:501
msgid ""
"If we try to access the parent of `leaf` after the end of the scope, we‚Äôll "
"get\n"
"`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a "
"strong\n"
"count of 1 and a weak count of 0, because the variable `leaf` is now the "
"only\n"
"reference to the `Rc<Node>` again."
msgstr ""

#: src/ch15-06-reference-cycles.md:506
msgid ""
"All of the logic that manages the counts and value dropping is built into\n"
"`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By\n"
"specifying that the relationship from a child to its parent should be a\n"
"`Weak<T>` reference in the definition of `Node`, you‚Äôre able to have parent\n"
"nodes point to child nodes and vice versa without creating a reference "
"cycle\n"
"and memory leaks."
msgstr ""

#: src/ch15-06-reference-cycles.md:515
msgid ""
"This chapter covered how to use smart pointers to make different guarantees "
"and\n"
"trade-offs from those Rust makes by default with regular references. The\n"
"`Box<T>` type has a known size and points to data allocated on the heap. "
"The\n"
"`Rc<T>` type keeps track of the number of references to data on the heap so\n"
"that data can have multiple owners. The `RefCell<T>` type with its interior\n"
"mutability gives us a type that we can use when we need an immutable type "
"but\n"
"need to change an inner value of that type; it also enforces the borrowing\n"
"rules at runtime instead of at compile time."
msgstr ""

#: src/ch15-06-reference-cycles.md:524
msgid ""
"Also discussed were the `Deref` and `Drop` traits, which enable a lot of "
"the\n"
"functionality of smart pointers. We explored reference cycles that can "
"cause\n"
"memory leaks and how to prevent them using `Weak<T>`."
msgstr ""

#: src/ch15-06-reference-cycles.md:528
msgid ""
"If this chapter has piqued your interest and you want to implement your own\n"
"smart pointers, check out [‚ÄúThe Rustonomicon‚Äù][nomicon] for more useful\n"
"information."
msgstr ""

#: src/ch15-06-reference-cycles.md:532
msgid ""
"Next, we‚Äôll talk about concurrency in Rust. You‚Äôll even learn about a few "
"new\n"
"smart pointers."
msgstr ""

#: src/ch16-00-concurrency.md:1
msgid "# Fearless Concurrency"
msgstr ""

#: src/ch16-00-concurrency.md:3
msgid ""
"Handling concurrent programming safely and efficiently is another of Rust‚Äôs\n"
"major goals. *Concurrent programming*, where different parts of a program\n"
"execute independently, and *parallel programming*, where different parts of "
"a\n"
"program execute at the same time, are becoming increasingly important as "
"more\n"
"computers take advantage of their multiple processors. Historically,\n"
"programming in these contexts has been difficult and error prone: Rust hopes "
"to\n"
"change that."
msgstr ""

#: src/ch16-00-concurrency.md:11
msgid ""
"Initially, the Rust team thought that ensuring memory safety and preventing\n"
"concurrency problems were two separate challenges to be solved with "
"different\n"
"methods. Over time, the team discovered that the ownership and type systems "
"are\n"
"a powerful set of tools to help manage memory safety *and* concurrency\n"
"problems! By leveraging ownership and type checking, many concurrency "
"errors\n"
"are compile-time errors in Rust rather than runtime errors. Therefore, "
"rather\n"
"than making you spend lots of time trying to reproduce the exact "
"circumstances\n"
"under which a runtime concurrency bug occurs, incorrect code will refuse to\n"
"compile and present an error explaining the problem. As a result, you can "
"fix\n"
"your code while you‚Äôre working on it rather than potentially after it has "
"been\n"
"shipped to production. We‚Äôve nicknamed this aspect of Rust *fearless*\n"
"*concurrency*. Fearless concurrency allows you to write code that is free "
"of\n"
"subtle bugs and is easy to refactor without introducing new bugs."
msgstr ""

#: src/ch16-00-concurrency.md:25
msgid ""
"> Note: For simplicity‚Äôs sake, we‚Äôll refer to many of the problems as\n"
"> *concurrent* rather than being more precise by saying *concurrent and/or\n"
"> parallel*. If this book were about concurrency and/or parallelism, we‚Äôd "
"be\n"
"> more specific. For this chapter, please mentally substitute *concurrent\n"
"> and/or parallel* whenever we use *concurrent*."
msgstr ""

#: src/ch16-00-concurrency.md:31
msgid ""
"Many languages are dogmatic about the solutions they offer for handling\n"
"concurrent problems. For example, Erlang has elegant functionality for\n"
"message-passing concurrency but has only obscure ways to share state "
"between\n"
"threads. Supporting only a subset of possible solutions is a reasonable\n"
"strategy for higher-level languages, because a higher-level language "
"promises\n"
"benefits from giving up some control to gain abstractions. However, lower-"
"level\n"
"languages are expected to provide the solution with the best performance in "
"any\n"
"given situation and have fewer abstractions over the hardware. Therefore, "
"Rust\n"
"offers a variety of tools for modeling problems in whatever way is "
"appropriate\n"
"for your situation and requirements."
msgstr ""

#: src/ch16-00-concurrency.md:42
msgid "Here are the topics we‚Äôll cover in this chapter:"
msgstr ""

#: src/ch16-00-concurrency.md:44
msgid ""
"* How to create threads to run multiple pieces of code at the same time\n"
"* *Message-passing* concurrency, where channels send messages between "
"threads\n"
"* *Shared-state* concurrency, where multiple threads have access to some "
"piece\n"
"  of data\n"
"* The `Sync` and `Send` traits, which extend Rust‚Äôs concurrency guarantees "
"to\n"
"  user-defined types as well as types provided by the standard library"
msgstr ""

#: src/ch16-01-threads.md:1
msgid "## Using Threads to Run Code Simultaneously"
msgstr ""

#: src/ch16-01-threads.md:3
msgid ""
"In most current operating systems, an executed program‚Äôs code is run in a\n"
"*process*, and the operating system will manage multiple processes at once.\n"
"Within a program, you can also have independent parts that run "
"simultaneously.\n"
"The features that run these independent parts are called *threads*. For\n"
"example, a web server could have multiple threads so that it could respond "
"to\n"
"more than one request at the same time."
msgstr ""

#: src/ch16-01-threads.md:10
msgid ""
"Splitting the computation in your program into multiple threads to run "
"multiple\n"
"tasks at the same time can improve performance, but it also adds "
"complexity.\n"
"Because threads can run simultaneously, there‚Äôs no inherent guarantee about "
"the\n"
"order in which parts of your code on different threads will run. This can "
"lead\n"
"to problems, such as:"
msgstr ""

#: src/ch16-01-threads.md:16
msgid ""
"* Race conditions, where threads are accessing data or resources in an\n"
"  inconsistent order\n"
"* Deadlocks, where two threads are waiting for each other, preventing both\n"
"  threads from continuing\n"
"* Bugs that happen only in certain situations and are hard to reproduce and "
"fix\n"
"  reliably"
msgstr ""

#: src/ch16-01-threads.md:23
msgid ""
"Rust attempts to mitigate the negative effects of using threads, but\n"
"programming in a multithreaded context still takes careful thought and "
"requires\n"
"a code structure that is different from that in programs running in a "
"single\n"
"thread."
msgstr ""

#: src/ch16-01-threads.md:28
msgid ""
"Programming languages implement threads in a few different ways, and many\n"
"operating systems provide an API the language can call for creating new\n"
"threads. The Rust standard library uses a *1:1* model of thread "
"implementation,\n"
"whereby a program uses one operating system thread per one language thread.\n"
"There are crates that implement other models of threading that make "
"different\n"
"tradeoffs to the 1:1 model."
msgstr ""

#: src/ch16-01-threads.md:35
msgid "### Creating a New Thread with `spawn`"
msgstr ""

#: src/ch16-01-threads.md:37
msgid ""
"To create a new thread, we call the `thread::spawn` function and pass it a\n"
"closure (we talked about closures in Chapter 13) containing the code we want "
"to\n"
"run in the new thread. The example in Listing 16-1 prints some text from a "
"main\n"
"thread and other text from a new thread:"
msgstr ""

#: src/ch16-01-threads.md:44
msgid ""
"```rust\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"hi number {} from the spawned thread!\", i);\n"
"            thread::sleep(Duration::from_millis(1));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"hi number {} from the main thread!\", i);\n"
"        thread::sleep(Duration::from_millis(1));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:63
msgid ""
"<span class=\"caption\">Listing 16-1: Creating a new thread to print one "
"thing\n"
"while the main thread prints something else</span>"
msgstr ""

#: src/ch16-01-threads.md:66
msgid ""
"Note that when the main thread of a Rust program completes, all spawned "
"threads\n"
"are shut down, whether or not they have finished running. The output from "
"this\n"
"program might be a little different every time, but it will look similar to "
"the\n"
"following:"
msgstr ""

#: src/ch16-01-threads.md:71 src/ch16-01-threads.md:145
#: src/ch16-01-threads.md:197 src/ch16-02-message-passing.md:149
#: src/ch16-02-message-passing.md:276 src/ch16-02-message-passing.md:357
#: src/ch16-03-shared-state.md:325
msgid ""
"<!-- Not extracting output because changes to this output aren't "
"significant;\n"
"the changes are likely to be due to the threads running differently rather "
"than\n"
"changes in the compiler -->"
msgstr ""

#: src/ch16-01-threads.md:75
msgid ""
"```text\n"
"hi number 1 from the main thread!\n"
"hi number 1 from the spawned thread!\n"
"hi number 2 from the main thread!\n"
"hi number 2 from the spawned thread!\n"
"hi number 3 from the main thread!\n"
"hi number 3 from the spawned thread!\n"
"hi number 4 from the main thread!\n"
"hi number 4 from the spawned thread!\n"
"hi number 5 from the spawned thread!\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:87
msgid ""
"The calls to `thread::sleep` force a thread to stop its execution for a "
"short\n"
"duration, allowing a different thread to run. The threads will probably "
"take\n"
"turns, but that isn‚Äôt guaranteed: it depends on how your operating system\n"
"schedules the threads. In this run, the main thread printed first, even "
"though\n"
"the print statement from the spawned thread appears first in the code. And "
"even\n"
"though we told the spawned thread to print until `i` is 9, it only got to 5\n"
"before the main thread shut down."
msgstr ""

#: src/ch16-01-threads.md:95
msgid ""
"If you run this code and only see output from the main thread, or don‚Äôt see "
"any\n"
"overlap, try increasing the numbers in the ranges to create more "
"opportunities\n"
"for the operating system to switch between the threads."
msgstr ""

#: src/ch16-01-threads.md:99
msgid "### Waiting for All Threads to Finish Using `join` Handles"
msgstr ""

#: src/ch16-01-threads.md:101
msgid ""
"The code in Listing 16-1 not only stops the spawned thread prematurely most "
"of\n"
"the time due to the main thread ending, but because there is no guarantee "
"on\n"
"the order in which threads run, we also can‚Äôt guarantee that the spawned "
"thread\n"
"will get to run at all!"
msgstr ""

#: src/ch16-01-threads.md:106
msgid ""
"We can fix the problem of the spawned thread not running or ending "
"prematurely\n"
"by saving the return value of `thread::spawn` in a variable. The return type "
"of\n"
"`thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned value that, when "
"we\n"
"call the `join` method on it, will wait for its thread to finish. Listing "
"16-2\n"
"shows how to use the `JoinHandle` of the thread we created in Listing 16-1 "
"and\n"
"call `join` to make sure the spawned thread finishes before `main` exits:"
msgstr ""

#: src/ch16-01-threads.md:115
msgid ""
"```rust\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let handle = thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"hi number {} from the spawned thread!\", i);\n"
"            thread::sleep(Duration::from_millis(1));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"hi number {} from the main thread!\", i);\n"
"        thread::sleep(Duration::from_millis(1));\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:136
msgid ""
"<span class=\"caption\">Listing 16-2: Saving a `JoinHandle` from `thread::"
"spawn`\n"
"to guarantee the thread is run to completion</span>"
msgstr ""

#: src/ch16-01-threads.md:139
msgid ""
"Calling `join` on the handle blocks the thread currently running until the\n"
"thread represented by the handle terminates. *Blocking* a thread means that\n"
"thread is prevented from performing work or exiting. Because we‚Äôve put the "
"call\n"
"to `join` after the main thread‚Äôs `for` loop, running Listing 16-2 should\n"
"produce output similar to this:"
msgstr ""

#: src/ch16-01-threads.md:149
msgid ""
"```text\n"
"hi number 1 from the main thread!\n"
"hi number 2 from the main thread!\n"
"hi number 1 from the spawned thread!\n"
"hi number 3 from the main thread!\n"
"hi number 2 from the spawned thread!\n"
"hi number 4 from the main thread!\n"
"hi number 3 from the spawned thread!\n"
"hi number 4 from the spawned thread!\n"
"hi number 5 from the spawned thread!\n"
"hi number 6 from the spawned thread!\n"
"hi number 7 from the spawned thread!\n"
"hi number 8 from the spawned thread!\n"
"hi number 9 from the spawned thread!\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:165
msgid ""
"The two threads continue alternating, but the main thread waits because of "
"the\n"
"call to `handle.join()` and does not end until the spawned thread is "
"finished."
msgstr ""

#: src/ch16-01-threads.md:168
msgid ""
"But let‚Äôs see what happens when we instead move `handle.join()` before the\n"
"`for` loop in `main`, like this:"
msgstr ""

#: src/ch16-01-threads.md:173
msgid ""
"```rust\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let handle = thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"hi number {} from the spawned thread!\", i);\n"
"            thread::sleep(Duration::from_millis(1));\n"
"        }\n"
"    });\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"hi number {} from the main thread!\", i);\n"
"        thread::sleep(Duration::from_millis(1));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:194
msgid ""
"The main thread will wait for the spawned thread to finish and then run its\n"
"`for` loop, so the output won‚Äôt be interleaved anymore, as shown here:"
msgstr ""

#: src/ch16-01-threads.md:201
msgid ""
"```text\n"
"hi number 1 from the spawned thread!\n"
"hi number 2 from the spawned thread!\n"
"hi number 3 from the spawned thread!\n"
"hi number 4 from the spawned thread!\n"
"hi number 5 from the spawned thread!\n"
"hi number 6 from the spawned thread!\n"
"hi number 7 from the spawned thread!\n"
"hi number 8 from the spawned thread!\n"
"hi number 9 from the spawned thread!\n"
"hi number 1 from the main thread!\n"
"hi number 2 from the main thread!\n"
"hi number 3 from the main thread!\n"
"hi number 4 from the main thread!\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:217
msgid ""
"Small details, such as where `join` is called, can affect whether or not "
"your\n"
"threads run at the same time."
msgstr ""

#: src/ch16-01-threads.md:220
msgid "### Using `move` Closures with Threads"
msgstr ""

#: src/ch16-01-threads.md:222
msgid ""
"We'll often use the `move` keyword with closures passed to `thread::spawn`\n"
"because the closure will then take ownership of the values it uses from the\n"
"environment, thus transferring ownership of those values from one thread to\n"
"another. In the [‚ÄúCapturing References or Moving Ownership‚Äù][capture]<!-- "
"ignore\n"
"--> section of Chapter 13, we discussed `move` in the context of closures. "
"Now,\n"
"we‚Äôll concentrate more on the interaction between `move` and `thread::spawn`."
msgstr ""

#: src/ch16-01-threads.md:229
msgid ""
"Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no\n"
"arguments: we‚Äôre not using any data from the main thread in the spawned\n"
"thread‚Äôs code. To use data from the main thread in the spawned thread, the\n"
"spawned thread‚Äôs closure must capture the values it needs. Listing 16-3 "
"shows\n"
"an attempt to create a vector in the main thread and use it in the spawned\n"
"thread. However, this won‚Äôt yet work, as you‚Äôll see in a moment."
msgstr ""

#: src/ch16-01-threads.md:238
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = vec![1, 2, 3];\n"
"\n"
"    let handle = thread::spawn(|| {\n"
"        println!(\"Here's a vector: {:?}\", v);\n"
"    });\n"
"\n"
"    handle.join().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:252
msgid ""
"<span class=\"caption\">Listing 16-3: Attempting to use a vector created by "
"the\n"
"main thread in another thread</span>"
msgstr ""

#: src/ch16-01-threads.md:255
msgid ""
"The closure uses `v`, so it will capture `v` and make it part of the "
"closure‚Äôs\n"
"environment. Because `thread::spawn` runs this closure in a new thread, we\n"
"should be able to access `v` inside that new thread. But when we compile "
"this\n"
"example, we get the following error:"
msgstr ""

#: src/ch16-01-threads.md:260
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling threads v0.1.0 (file:///projects/threads)\n"
"error[E0373]: closure may outlive the current function, but it borrows `v`, "
"which is owned by the current function\n"
" --> src/main.rs:6:32\n"
"  |\n"
"6 |     let handle = thread::spawn(|| {\n"
"  |                                ^^ may outlive borrowed value `v`\n"
"7 |         println!(\"Here's a vector: {:?}\", v);\n"
"  |                                           - `v` is borrowed here\n"
"  |\n"
"note: function requires argument type to outlive `'static`\n"
" --> src/main.rs:6:18\n"
"  |\n"
"6 |       let handle = thread::spawn(|| {\n"
"  |  __________________^\n"
"7 | |         println!(\"Here's a vector: {:?}\", v);\n"
"8 | |     });\n"
"  | |______^\n"
"help: to force the closure to take ownership of `v` (and any other "
"referenced variables), use the `move` keyword\n"
"  |\n"
"6 |     let handle = thread::spawn(move || {\n"
"  |                                ++++\n"
"\n"
"For more information about this error, try `rustc --explain E0373`.\n"
"error: could not compile `threads` due to previous error\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:288
msgid ""
"Rust *infers* how to capture `v`, and because `println!` only needs a "
"reference\n"
"to `v`, the closure tries to borrow `v`. However, there‚Äôs a problem: Rust "
"can‚Äôt\n"
"tell how long the spawned thread will run, so it doesn‚Äôt know if the "
"reference\n"
"to `v` will always be valid."
msgstr ""

#: src/ch16-01-threads.md:293
msgid ""
"Listing 16-4 provides a scenario that‚Äôs more likely to have a reference to "
"`v`\n"
"that won‚Äôt be valid:"
msgstr ""

#: src/ch16-01-threads.md:298
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = vec![1, 2, 3];\n"
"\n"
"    let handle = thread::spawn(|| {\n"
"        println!(\"Here's a vector: {:?}\", v);\n"
"    });\n"
"\n"
"    drop(v); // oh no!\n"
"\n"
"    handle.join().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:314
msgid ""
"<span class=\"caption\">Listing 16-4: A thread with a closure that attempts "
"to\n"
"capture a reference to `v` from a main thread that drops `v`</span>"
msgstr ""

#: src/ch16-01-threads.md:317
msgid ""
"If Rust allowed us to run this code, there‚Äôs a possibility the spawned "
"thread\n"
"would be immediately put in the background without running at all. The "
"spawned\n"
"thread has a reference to `v` inside, but the main thread immediately drops\n"
"`v`, using the `drop` function we discussed in Chapter 15. Then, when the\n"
"spawned thread starts to execute, `v` is no longer valid, so a reference to "
"it\n"
"is also invalid. Oh no!"
msgstr ""

#: src/ch16-01-threads.md:324
msgid ""
"To fix the compiler error in Listing 16-3, we can use the error message‚Äôs\n"
"advice:"
msgstr ""

#: src/ch16-01-threads.md:327
msgid ""
"<!-- manual-regeneration\n"
"after automatic regeneration, look at listings/ch16-fearless-concurrency/"
"listing-16-03/output.txt and copy the relevant part\n"
"-->"
msgstr ""

#: src/ch16-01-threads.md:331
msgid ""
"```text\n"
"help: to force the closure to take ownership of `v` (and any other "
"referenced variables), use the `move` keyword\n"
"  |\n"
"6 |     let handle = thread::spawn(move || {\n"
"  |                                ++++\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:338
msgid ""
"By adding the `move` keyword before the closure, we force the closure to "
"take\n"
"ownership of the values it‚Äôs using rather than allowing Rust to infer that "
"it\n"
"should borrow the values. The modification to Listing 16-3 shown in Listing\n"
"16-5 will compile and run as we intend:"
msgstr ""

#: src/ch16-01-threads.md:345
msgid ""
"```rust\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = vec![1, 2, 3];\n"
"\n"
"    let handle = thread::spawn(move || {\n"
"        println!(\"Here's a vector: {:?}\", v);\n"
"    });\n"
"\n"
"    handle.join().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:359
msgid ""
"<span class=\"caption\">Listing 16-5: Using the `move` keyword to force a "
"closure\n"
"to take ownership of the values it uses</span>"
msgstr ""

#: src/ch16-01-threads.md:362
msgid ""
"We might be tempted to try the same thing to fix the code in Listing 16-4 "
"where\n"
"the main thread called `drop` by using a `move` closure. However, this fix "
"will\n"
"not work because what Listing 16-4 is trying to do is disallowed for a\n"
"different reason. If we added `move` to the closure, we would move `v` into "
"the\n"
"closure‚Äôs environment, and we could no longer call `drop` on it in the main\n"
"thread. We would get this compiler error instead:"
msgstr ""

#: src/ch16-01-threads.md:369
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling threads v0.1.0 (file:///projects/threads)\n"
"error[E0382]: use of moved value: `v`\n"
"  --> src/main.rs:10:10\n"
"   |\n"
"4  |     let v = vec![1, 2, 3];\n"
"   |         - move occurs because `v` has type `Vec<i32>`, which does not "
"implement the `Copy` trait\n"
"5  |\n"
"6  |     let handle = thread::spawn(move || {\n"
"   |                                ------- value moved into closure here\n"
"7  |         println!(\"Here's a vector: {:?}\", v);\n"
"   |                                           - variable moved due to use "
"in closure\n"
"...\n"
"10 |     drop(v); // oh no!\n"
"   |          ^ value used here after move\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `threads` due to previous error\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:390
msgid ""
"Rust‚Äôs ownership rules have saved us again! We got an error from the code "
"in\n"
"Listing 16-3 because Rust was being conservative and only borrowing `v` for "
"the\n"
"thread, which meant the main thread could theoretically invalidate the "
"spawned\n"
"thread‚Äôs reference. By telling Rust to move ownership of `v` to the spawned\n"
"thread, we‚Äôre guaranteeing Rust that the main thread won‚Äôt use `v` anymore. "
"If\n"
"we change Listing 16-4 in the same way, we‚Äôre then violating the ownership\n"
"rules when we try to use `v` in the main thread. The `move` keyword "
"overrides\n"
"Rust‚Äôs conservative default of borrowing; it doesn‚Äôt let us violate the\n"
"ownership rules."
msgstr ""

#: src/ch16-01-threads.md:400
msgid ""
"With a basic understanding of threads and the thread API, let‚Äôs look at what "
"we\n"
"can *do* with threads."
msgstr ""

#: src/ch16-02-message-passing.md:1
msgid "## Using Message Passing to Transfer Data Between Threads"
msgstr ""

#: src/ch16-02-message-passing.md:3
msgid ""
"One increasingly popular approach to ensuring safe concurrency is *message\n"
"passing*, where threads or actors communicate by sending each other "
"messages\n"
"containing data. Here‚Äôs the idea in a slogan from [the Go language\n"
"documentation](https://golang.org/doc/effective_go.html#concurrency):\n"
"‚ÄúDo not communicate by sharing memory; instead, share memory by "
"communicating.‚Äù"
msgstr ""

#: src/ch16-02-message-passing.md:9
msgid ""
"To accomplish message-sending concurrency, Rust's standard library provides "
"an\n"
"implementation of *channels*. A channel is a general programming concept by\n"
"which data is sent from one thread to another."
msgstr ""

#: src/ch16-02-message-passing.md:13
msgid ""
"You can imagine a channel in programming as being like a directional channel "
"of\n"
"water, such as a stream or a river. If you put something like a rubber duck\n"
"into a river, it will travel downstream to the end of the waterway."
msgstr ""

#: src/ch16-02-message-passing.md:17
msgid ""
"A channel has two halves: a transmitter and a receiver. The transmitter half "
"is\n"
"the upstream location where you put rubber ducks into the river, and the\n"
"receiver half is where the rubber duck ends up downstream. One part of your\n"
"code calls methods on the transmitter with the data you want to send, and\n"
"another part checks the receiving end for arriving messages. A channel is "
"said\n"
"to be *closed* if either the transmitter or receiver half is dropped."
msgstr ""

#: src/ch16-02-message-passing.md:24
msgid ""
"Here, we‚Äôll work up to a program that has one thread to generate values and\n"
"send them down a channel, and another thread that will receive the values "
"and\n"
"print them out. We‚Äôll be sending simple values between threads using a "
"channel\n"
"to illustrate the feature. Once you‚Äôre familiar with the technique, you "
"could\n"
"use channels for any threads that need to communicate between each other, "
"such\n"
"as a chat system or a system where many threads perform parts of a "
"calculation\n"
"and send the parts to one thread that aggregates the results."
msgstr ""

#: src/ch16-02-message-passing.md:32
msgid ""
"First, in Listing 16-6, we‚Äôll create a channel but not do anything with it.\n"
"Note that this won‚Äôt compile yet because Rust can‚Äôt tell what type of values "
"we\n"
"want to send over the channel."
msgstr ""

#: src/ch16-02-message-passing.md:38
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::sync::mpsc;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"}\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:46
msgid ""
"<span class=\"caption\">Listing 16-6: Creating a channel and assigning the "
"two\n"
"halves to `tx` and `rx`</span>"
msgstr ""

#: src/ch16-02-message-passing.md:49
msgid ""
"We create a new channel using the `mpsc::channel` function; `mpsc` stands "
"for\n"
"*multiple producer, single consumer*. In short, the way Rust‚Äôs standard "
"library\n"
"implements channels means a channel can have multiple *sending* ends that\n"
"produce values but only one *receiving* end that consumes those values. "
"Imagine\n"
"multiple streams flowing together into one big river: everything sent down "
"any\n"
"of the streams will end up in one river at the end. We‚Äôll start with a "
"single\n"
"producer for now, but we‚Äôll add multiple producers when we get this example\n"
"working."
msgstr ""

#: src/ch16-02-message-passing.md:58
msgid ""
"The `mpsc::channel` function returns a tuple, the first element of which is "
"the\n"
"sending end--the transmitter--and the second element is the receiving end--"
"the\n"
"receiver. The abbreviations `tx` and `rx` are traditionally used in many "
"fields\n"
"for *transmitter* and *receiver* respectively, so we name our variables as "
"such\n"
"to indicate each end. We‚Äôre using a `let` statement with a pattern that\n"
"destructures the tuples; we‚Äôll discuss the use of patterns in `let` "
"statements\n"
"and destructuring in Chapter 18. For now, know that using a `let` statement\n"
"this way is a convenient approach to extract the pieces of the tuple "
"returned\n"
"by `mpsc::channel`."
msgstr ""

#: src/ch16-02-message-passing.md:68
msgid ""
"Let‚Äôs move the transmitting end into a spawned thread and have it send one\n"
"string so the spawned thread is communicating with the main thread, as shown "
"in\n"
"Listing 16-7. This is like putting a rubber duck in the river upstream or\n"
"sending a chat message from one thread to another."
msgstr ""

#: src/ch16-02-message-passing.md:75
msgid ""
"```rust\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let val = String::from(\"hi\");\n"
"        tx.send(val).unwrap();\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:89
msgid ""
"<span class=\"caption\">Listing 16-7: Moving `tx` to a spawned thread and "
"sending\n"
"‚Äúhi‚Äù</span>"
msgstr ""

#: src/ch16-02-message-passing.md:92
msgid ""
"Again, we‚Äôre using `thread::spawn` to create a new thread and then using "
"`move`\n"
"to move `tx` into the closure so the spawned thread owns `tx`. The spawned\n"
"thread needs to own the transmitter to be able to send messages through the\n"
"channel. The transmitter has a `send` method that takes the value we want "
"to\n"
"send. The `send` method returns a `Result<T, E>` type, so if the receiver "
"has\n"
"already been dropped and there‚Äôs nowhere to send a value, the send "
"operation\n"
"will return an error. In this example, we‚Äôre calling `unwrap` to panic in "
"case\n"
"of an error. But in a real application, we would handle it properly: return "
"to\n"
"Chapter 9 to review strategies for proper error handling."
msgstr ""

#: src/ch16-02-message-passing.md:102
msgid ""
"In Listing 16-8, we‚Äôll get the value from the receiver in the main thread. "
"This\n"
"is like retrieving the rubber duck from the water at the end of the river "
"or\n"
"receiving a chat message."
msgstr ""

#: src/ch16-02-message-passing.md:108
msgid ""
"```rust\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let val = String::from(\"hi\");\n"
"        tx.send(val).unwrap();\n"
"    });\n"
"\n"
"    let received = rx.recv().unwrap();\n"
"    println!(\"Got: {}\", received);\n"
"}\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:125
msgid ""
"<span class=\"caption\">Listing 16-8: Receiving the value ‚Äúhi‚Äù in the main "
"thread\n"
"and printing it</span>"
msgstr ""

#: src/ch16-02-message-passing.md:128
msgid ""
"The receiver has two useful methods: `recv` and `try_recv`. We‚Äôre using "
"`recv`,\n"
"short for *receive*, which will block the main thread‚Äôs execution and wait\n"
"until a value is sent down the channel. Once a value is sent, `recv` will\n"
"return it in a `Result<T, E>`. When the transmitter closes, `recv` will "
"return\n"
"an error to signal that no more values will be coming."
msgstr ""

#: src/ch16-02-message-passing.md:134
msgid ""
"The `try_recv` method doesn‚Äôt block, but will instead return a `Result<T, "
"E>`\n"
"immediately: an `Ok` value holding a message if one is available and an "
"`Err`\n"
"value if there aren‚Äôt any messages this time. Using `try_recv` is useful if\n"
"this thread has other work to do while waiting for messages: we could write "
"a\n"
"loop that calls `try_recv` every so often, handles a message if one is\n"
"available, and otherwise does other work for a little while until checking\n"
"again."
msgstr ""

#: src/ch16-02-message-passing.md:142
msgid ""
"We‚Äôve used `recv` in this example for simplicity; we don‚Äôt have any other "
"work\n"
"for the main thread to do other than wait for messages, so blocking the "
"main\n"
"thread is appropriate."
msgstr ""

#: src/ch16-02-message-passing.md:146
msgid ""
"When we run the code in Listing 16-8, we‚Äôll see the value printed from the "
"main\n"
"thread:"
msgstr ""

#: src/ch16-02-message-passing.md:153
msgid ""
"```text\n"
"Got: hi\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:157
msgid "Perfect!"
msgstr ""

#: src/ch16-02-message-passing.md:159
msgid "### Channels and Ownership Transference"
msgstr ""

#: src/ch16-02-message-passing.md:161
msgid ""
"The ownership rules play a vital role in message sending because they help "
"you\n"
"write safe, concurrent code. Preventing errors in concurrent programming is "
"the\n"
"advantage of thinking about ownership throughout your Rust programs. Let‚Äôs "
"do\n"
"an experiment to show how channels and ownership work together to prevent\n"
"problems: we‚Äôll try to use a `val` value in the spawned thread *after* "
"we‚Äôve\n"
"sent it down the channel. Try compiling the code in Listing 16-9 to see why\n"
"this code isn‚Äôt allowed:"
msgstr ""

#: src/ch16-02-message-passing.md:171
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let val = String::from(\"hi\");\n"
"        tx.send(val).unwrap();\n"
"        println!(\"val is {}\", val);\n"
"    });\n"
"\n"
"    let received = rx.recv().unwrap();\n"
"    println!(\"Got: {}\", received);\n"
"}\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:189
msgid ""
"<span class=\"caption\">Listing 16-9: Attempting to use `val` after we‚Äôve "
"sent it\n"
"down the channel</span>"
msgstr ""

#: src/ch16-02-message-passing.md:192
msgid ""
"Here, we try to print `val` after we‚Äôve sent it down the channel via `tx."
"send`.\n"
"Allowing this would be a bad idea: once the value has been sent to another\n"
"thread, that thread could modify or drop it before we try to use the value\n"
"again. Potentially, the other thread‚Äôs modifications could cause errors or\n"
"unexpected results due to inconsistent or nonexistent data. However, Rust "
"gives\n"
"us an error if we try to compile the code in Listing 16-9:"
msgstr ""

#: src/ch16-02-message-passing.md:199
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling message-passing v0.1.0 (file:///projects/message-passing)\n"
"error[E0382]: borrow of moved value: `val`\n"
"  --> src/main.rs:10:31\n"
"   |\n"
"8  |         let val = String::from(\"hi\");\n"
"   |             --- move occurs because `val` has type `String`, which does "
"not implement the `Copy` trait\n"
"9  |         tx.send(val).unwrap();\n"
"   |                 --- value moved here\n"
"10 |         println!(\"val is {}\", val);\n"
"   |                               ^^^ value borrowed here after move\n"
"   |\n"
"   = note: this error originates in the macro `$crate::format_args_nl` which "
"comes from the expansion of the macro `println` (in Nightly builds, run with "
"-Z macro-backtrace for more info)\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `message-passing` due to previous error\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:218
msgid ""
"Our concurrency mistake has caused a compile time error. The `send` "
"function\n"
"takes ownership of its parameter, and when the value is moved, the receiver\n"
"takes ownership of it. This stops us from accidentally using the value "
"again\n"
"after sending it; the ownership system checks that everything is okay."
msgstr ""

#: src/ch16-02-message-passing.md:223
msgid "### Sending Multiple Values and Seeing the Receiver Waiting"
msgstr ""

#: src/ch16-02-message-passing.md:225
msgid ""
"The code in Listing 16-8 compiled and ran, but it didn‚Äôt clearly show us "
"that\n"
"two separate threads were talking to each other over the channel. In "
"Listing\n"
"16-10 we‚Äôve made some modifications that will prove the code in Listing 16-8 "
"is\n"
"running concurrently: the spawned thread will now send multiple messages "
"and\n"
"pause for a second between each message."
msgstr ""

#: src/ch16-02-message-passing.md:233
msgid ""
"```rust,noplayground\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let vals = vec![\n"
"            String::from(\"hi\"),\n"
"            String::from(\"from\"),\n"
"            String::from(\"the\"),\n"
"            String::from(\"thread\"),\n"
"        ];\n"
"\n"
"        for val in vals {\n"
"            tx.send(val).unwrap();\n"
"            thread::sleep(Duration::from_secs(1));\n"
"        }\n"
"    });\n"
"\n"
"    for received in rx {\n"
"        println!(\"Got: {}\", received);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:261
msgid ""
"<span class=\"caption\">Listing 16-10: Sending multiple messages and "
"pausing\n"
"between each</span>"
msgstr ""

#: src/ch16-02-message-passing.md:264
msgid ""
"This time, the spawned thread has a vector of strings that we want to send "
"to\n"
"the main thread. We iterate over them, sending each individually, and pause\n"
"between each by calling the `thread::sleep` function with a `Duration` value "
"of\n"
"1 second."
msgstr ""

#: src/ch16-02-message-passing.md:269
msgid ""
"In the main thread, we‚Äôre not calling the `recv` function explicitly "
"anymore:\n"
"instead, we‚Äôre treating `rx` as an iterator. For each value received, we‚Äôre\n"
"printing it. When the channel is closed, iteration will end."
msgstr ""

#: src/ch16-02-message-passing.md:273
msgid ""
"When running the code in Listing 16-10, you should see the following output\n"
"with a 1-second pause in between each line:"
msgstr ""

#: src/ch16-02-message-passing.md:280
msgid ""
"```text\n"
"Got: hi\n"
"Got: from\n"
"Got: the\n"
"Got: thread\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:287
msgid ""
"Because we don‚Äôt have any code that pauses or delays in the `for` loop in "
"the\n"
"main thread, we can tell that the main thread is waiting to receive values "
"from\n"
"the spawned thread."
msgstr ""

#: src/ch16-02-message-passing.md:291
msgid "### Creating Multiple Producers by Cloning the Transmitter"
msgstr ""

#: src/ch16-02-message-passing.md:293
msgid ""
"Earlier we mentioned that `mpsc` was an acronym for *multiple producer,\n"
"single consumer*. Let‚Äôs put `mpsc` to use and expand the code in Listing "
"16-10\n"
"to create multiple threads that all send values to the same receiver. We can "
"do\n"
"so by cloning the transmitter, as shown in Listing 16-11:"
msgstr ""

#: src/ch16-02-message-passing.md:300
msgid ""
"```rust,noplayground\n"
"# use std::sync::mpsc;\n"
"# use std::thread;\n"
"# use std::time::Duration;\n"
"# \n"
"# fn main() {\n"
"    // --snip--\n"
"\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    let tx1 = tx.clone();\n"
"    thread::spawn(move || {\n"
"        let vals = vec![\n"
"            String::from(\"hi\"),\n"
"            String::from(\"from\"),\n"
"            String::from(\"the\"),\n"
"            String::from(\"thread\"),\n"
"        ];\n"
"\n"
"        for val in vals {\n"
"            tx1.send(val).unwrap();\n"
"            thread::sleep(Duration::from_secs(1));\n"
"        }\n"
"    });\n"
"\n"
"    thread::spawn(move || {\n"
"        let vals = vec![\n"
"            String::from(\"more\"),\n"
"            String::from(\"messages\"),\n"
"            String::from(\"for\"),\n"
"            String::from(\"you\"),\n"
"        ];\n"
"\n"
"        for val in vals {\n"
"            tx.send(val).unwrap();\n"
"            thread::sleep(Duration::from_secs(1));\n"
"        }\n"
"    });\n"
"\n"
"    for received in rx {\n"
"        println!(\"Got: {}\", received);\n"
"    }\n"
"\n"
"    // --snip--\n"
"# }\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:347
msgid ""
"<span class=\"caption\">Listing 16-11: Sending multiple messages from "
"multiple\n"
"producers</span>"
msgstr ""

#: src/ch16-02-message-passing.md:350
msgid ""
"This time, before we create the first spawned thread, we call `clone` on "
"the\n"
"transmitter. This will give us a new transmitter we can pass to the first\n"
"spawned thread. We pass the original transmitter to a second spawned "
"thread.\n"
"This gives us two threads, each sending different messages to the one "
"receiver."
msgstr ""

#: src/ch16-02-message-passing.md:355
msgid "When you run the code, your output should look something like this:"
msgstr ""

#: src/ch16-02-message-passing.md:361
msgid ""
"```text\n"
"Got: hi\n"
"Got: more\n"
"Got: from\n"
"Got: messages\n"
"Got: for\n"
"Got: the\n"
"Got: thread\n"
"Got: you\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:372
msgid ""
"You might see the values in another order, depending on your system. This "
"is\n"
"what makes concurrency interesting as well as difficult. If you experiment "
"with\n"
"`thread::sleep`, giving it various values in the different threads, each "
"run\n"
"will be more nondeterministic and create different output each time."
msgstr ""

#: src/ch16-02-message-passing.md:377
msgid ""
"Now that we‚Äôve looked at how channels work, let‚Äôs look at a different method "
"of\n"
"concurrency."
msgstr ""

#: src/ch16-03-shared-state.md:1
msgid "## Shared-State Concurrency"
msgstr ""

#: src/ch16-03-shared-state.md:3
msgid ""
"Message passing is a fine way of handling concurrency, but it‚Äôs not the "
"only\n"
"one. Another method would be for multiple threads to access the same shared\n"
"data. Consider this part of the slogan from the Go language documentation\n"
"again: ‚Äúdo not communicate by sharing memory.‚Äù"
msgstr ""

#: src/ch16-03-shared-state.md:8
msgid ""
"What would communicating by sharing memory look like? In addition, why "
"would\n"
"message-passing enthusiasts caution not to use memory sharing?"
msgstr ""

#: src/ch16-03-shared-state.md:11
msgid ""
"In a way, channels in any programming language are similar to single "
"ownership,\n"
"because once you transfer a value down a channel, you should no longer use "
"that\n"
"value. Shared memory concurrency is like multiple ownership: multiple "
"threads\n"
"can access the same memory location at the same time. As you saw in Chapter "
"15,\n"
"where smart pointers made multiple ownership possible, multiple ownership "
"can\n"
"add complexity because these different owners need managing. Rust‚Äôs type "
"system\n"
"and ownership rules greatly assist in getting this management correct. For "
"an\n"
"example, let‚Äôs look at mutexes, one of the more common concurrency "
"primitives\n"
"for shared memory."
msgstr ""

#: src/ch16-03-shared-state.md:21
msgid "### Using Mutexes to Allow Access to Data from One Thread at a Time"
msgstr ""

#: src/ch16-03-shared-state.md:23
msgid ""
"*Mutex* is an abbreviation for *mutual exclusion*, as in, a mutex allows "
"only\n"
"one thread to access some data at any given time. To access the data in a\n"
"mutex, a thread must first signal that it wants access by asking to acquire "
"the\n"
"mutex‚Äôs *lock*. The lock is a data structure that is part of the mutex that\n"
"keeps track of who currently has exclusive access to the data. Therefore, "
"the\n"
"mutex is described as *guarding* the data it holds via the locking system."
msgstr ""

#: src/ch16-03-shared-state.md:30
msgid ""
"Mutexes have a reputation for being difficult to use because you have to\n"
"remember two rules:"
msgstr ""

#: src/ch16-03-shared-state.md:33
msgid ""
"* You must attempt to acquire the lock before using the data.\n"
"* When you‚Äôre done with the data that the mutex guards, you must unlock the\n"
"  data so other threads can acquire the lock."
msgstr ""

#: src/ch16-03-shared-state.md:37
msgid ""
"For a real-world metaphor for a mutex, imagine a panel discussion at a\n"
"conference with only one microphone. Before a panelist can speak, they have "
"to\n"
"ask or signal that they want to use the microphone. When they get the\n"
"microphone, they can talk for as long as they want to and then hand the\n"
"microphone to the next panelist who requests to speak. If a panelist forgets "
"to\n"
"hand the microphone off when they‚Äôre finished with it, no one else is able "
"to\n"
"speak. If management of the shared microphone goes wrong, the panel won‚Äôt "
"work\n"
"as planned!"
msgstr ""

#: src/ch16-03-shared-state.md:46
msgid ""
"Management of mutexes can be incredibly tricky to get right, which is why "
"so\n"
"many people are enthusiastic about channels. However, thanks to Rust‚Äôs type\n"
"system and ownership rules, you can‚Äôt get locking and unlocking wrong."
msgstr ""

#: src/ch16-03-shared-state.md:50
msgid "#### The API of `Mutex<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:52
msgid ""
"As an example of how to use a mutex, let‚Äôs start by using a mutex in a\n"
"single-threaded context, as shown in Listing 16-12:"
msgstr ""

#: src/ch16-03-shared-state.md:57
msgid ""
"```rust\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let m = Mutex::new(5);\n"
"\n"
"    {\n"
"        let mut num = m.lock().unwrap();\n"
"        *num = 6;\n"
"    }\n"
"\n"
"    println!(\"m = {:?}\", m);\n"
"}\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:72
msgid ""
"<span class=\"caption\">Listing 16-12: Exploring the API of `Mutex<T>` in a\n"
"single-threaded context for simplicity</span>"
msgstr ""

#: src/ch16-03-shared-state.md:75
msgid ""
"As with many types, we create a `Mutex<T>` using the associated function "
"`new`.\n"
"To access the data inside the mutex, we use the `lock` method to acquire "
"the\n"
"lock. This call will block the current thread so it can‚Äôt do any work until\n"
"it‚Äôs our turn to have the lock."
msgstr ""

#: src/ch16-03-shared-state.md:80
msgid ""
"The call to `lock` would fail if another thread holding the lock panicked. "
"In\n"
"that case, no one would ever be able to get the lock, so we‚Äôve chosen to\n"
"`unwrap` and have this thread panic if we‚Äôre in that situation."
msgstr ""

#: src/ch16-03-shared-state.md:84
msgid ""
"After we‚Äôve acquired the lock, we can treat the return value, named `num` "
"in\n"
"this case, as a mutable reference to the data inside. The type system "
"ensures\n"
"that we acquire a lock before using the value in `m`. The type of `m` is\n"
"`Mutex<i32>`, not `i32`, so we *must* call `lock` to be able to use the "
"`i32`\n"
"value. We can‚Äôt forget; the type system won‚Äôt let us access the inner `i32`\n"
"otherwise."
msgstr ""

#: src/ch16-03-shared-state.md:91
msgid ""
"As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the "
"call\n"
"to `lock` *returns* a smart pointer called `MutexGuard`, wrapped in a\n"
"`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` "
"smart\n"
"pointer implements `Deref` to point at our inner data; the smart pointer "
"also\n"
"has a `Drop` implementation that releases the lock automatically when a\n"
"`MutexGuard` goes out of scope, which happens at the end of the inner scope. "
"As\n"
"a result, we don‚Äôt risk forgetting to release the lock and blocking the "
"mutex\n"
"from being used by other threads, because the lock release happens\n"
"automatically."
msgstr ""

#: src/ch16-03-shared-state.md:101
msgid ""
"After dropping the lock, we can print the mutex value and see that we were "
"able\n"
"to change the inner `i32` to 6."
msgstr ""

#: src/ch16-03-shared-state.md:104
msgid "#### Sharing a `Mutex<T>` Between Multiple Threads"
msgstr ""

#: src/ch16-03-shared-state.md:106
msgid ""
"Now, let‚Äôs try to share a value between multiple threads using `Mutex<T>`.\n"
"We‚Äôll spin up 10 threads and have them each increment a counter value by 1, "
"so\n"
"the counter goes from 0 to 10. The next example in Listing 16-13 will have\n"
"a compiler error, and we‚Äôll use that error to learn more about using\n"
"`Mutex<T>` and how Rust helps us use it correctly."
msgstr ""

#: src/ch16-03-shared-state.md:114
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::sync::Mutex;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let counter = Mutex::new(0);\n"
"    let mut handles = vec![];\n"
"\n"
"    for _ in 0..10 {\n"
"        let handle = thread::spawn(move || {\n"
"            let mut num = counter.lock().unwrap();\n"
"\n"
"            *num += 1;\n"
"        });\n"
"        handles.push(handle);\n"
"    }\n"
"\n"
"    for handle in handles {\n"
"        handle.join().unwrap();\n"
"    }\n"
"\n"
"    println!(\"Result: {}\", *counter.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:139
msgid ""
"<span class=\"caption\">Listing 16-13: Ten threads each increment a counter\n"
"guarded by a `Mutex<T>`</span>"
msgstr ""

#: src/ch16-03-shared-state.md:142
msgid ""
"We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we "
"did\n"
"in Listing 16-12. Next, we create 10 threads by iterating over a range of\n"
"numbers. We use `thread::spawn` and give all the threads the same closure: "
"one\n"
"that moves the counter into the thread, acquires a lock on the `Mutex<T>` "
"by\n"
"calling the `lock` method, and then adds 1 to the value in the mutex. When "
"a\n"
"thread finishes running its closure, `num` will go out of scope and release "
"the\n"
"lock so another thread can acquire it."
msgstr ""

#: src/ch16-03-shared-state.md:150
msgid ""
"In the main thread, we collect all the join handles. Then, as we did in "
"Listing\n"
"16-2, we call `join` on each handle to make sure all the threads finish. At\n"
"that point, the main thread will acquire the lock and print the result of "
"this\n"
"program."
msgstr ""

#: src/ch16-03-shared-state.md:155
msgid "We hinted that this example wouldn‚Äôt compile. Now let‚Äôs find out why!"
msgstr ""

#: src/ch16-03-shared-state.md:157
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0382]: use of moved value: `counter`\n"
"  --> src/main.rs:9:36\n"
"   |\n"
"5  |     let counter = Mutex::new(0);\n"
"   |         ------- move occurs because `counter` has type `Mutex<i32>`, "
"which does not implement the `Copy` trait\n"
"...\n"
"9  |         let handle = thread::spawn(move || {\n"
"   |                                    ^^^^^^^ value moved into closure "
"here, in previous iteration of loop\n"
"10 |             let mut num = counter.lock().unwrap();\n"
"   |                           ------- use occurs due to use in closure\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `shared-state` due to previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:175
msgid ""
"The error message states that the `counter` value was moved in the previous\n"
"iteration of the loop. Rust is telling us that we can‚Äôt move the ownership\n"
"of lock `counter` into multiple threads. Let‚Äôs fix the compiler error with "
"a\n"
"multiple-ownership method we discussed in Chapter 15."
msgstr ""

#: src/ch16-03-shared-state.md:180
msgid "#### Multiple Ownership with Multiple Threads"
msgstr ""

#: src/ch16-03-shared-state.md:182
msgid ""
"In Chapter 15, we gave a value multiple owners by using the smart pointer\n"
"`Rc<T>` to create a reference counted value. Let‚Äôs do the same here and see\n"
"what happens. We‚Äôll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and "
"clone\n"
"the `Rc<T>` before moving ownership to the thread."
msgstr ""

#: src/ch16-03-shared-state.md:189
msgid ""
"```rust,ignore,does_not_compile\n"
"use std::rc::Rc;\n"
"use std::sync::Mutex;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let counter = Rc::new(Mutex::new(0));\n"
"    let mut handles = vec![];\n"
"\n"
"    for _ in 0..10 {\n"
"        let counter = Rc::clone(&counter);\n"
"        let handle = thread::spawn(move || {\n"
"            let mut num = counter.lock().unwrap();\n"
"\n"
"            *num += 1;\n"
"        });\n"
"        handles.push(handle);\n"
"    }\n"
"\n"
"    for handle in handles {\n"
"        handle.join().unwrap();\n"
"    }\n"
"\n"
"    println!(\"Result: {}\", *counter.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:216
msgid ""
"<span class=\"caption\">Listing 16-14: Attempting to use `Rc<T>` to allow\n"
"multiple threads to own the `Mutex<T>`</span>"
msgstr ""

#: src/ch16-03-shared-state.md:219
msgid ""
"Once again, we compile and get... different errors! The compiler is teaching "
"us\n"
"a lot."
msgstr ""

#: src/ch16-03-shared-state.md:222
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely\n"
"  --> src/main.rs:11:36\n"
"   |\n"
"11 |           let handle = thread::spawn(move || {\n"
"   |                        ------------- ^------\n"
"   |                        |             |\n"
"   |  ______________________|_____________within this `[closure@src/main."
"rs:11:36: 11:43]`\n"
"   | |                      |\n"
"   | |                      required by a bound introduced by this call\n"
"12 | |             let mut num = counter.lock().unwrap();\n"
"13 | |\n"
"14 | |             *num += 1;\n"
"15 | |         });\n"
"   | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely\n"
"   |\n"
"   = help: within `[closure@src/main.rs:11:36: 11:43]`, the trait `Send` is "
"not implemented for `Rc<Mutex<i32>>`\n"
"note: required because it's used within this closure\n"
"  --> src/main.rs:11:36\n"
"   |\n"
"11 |         let handle = thread::spawn(move || {\n"
"   |                                    ^^^^^^^\n"
"note: required by a bound in `spawn`\n"
"  --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/"
"mod.rs:704:8\n"
"   |\n"
"   = note: required by this bound in `spawn`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `shared-state` due to previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:255
msgid ""
"Wow, that error message is very wordy! Here‚Äôs the important part to focus "
"on:\n"
"`` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The compiler "
"is\n"
"also telling us the reason why: ``the trait `Send` is not implemented for\n"
"`Rc<Mutex<i32>>` ``. We‚Äôll talk about `Send` in the next section: it‚Äôs one "
"of\n"
"the traits that ensures the types we use with threads are meant for use in\n"
"concurrent situations."
msgstr ""

#: src/ch16-03-shared-state.md:262
msgid ""
"Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>`\n"
"manages the reference count, it adds to the count for each call to `clone` "
"and\n"
"subtracts from the count when each clone is dropped. But it doesn‚Äôt use any\n"
"concurrency primitives to make sure that changes to the count can‚Äôt be\n"
"interrupted by another thread. This could lead to wrong counts‚Äîsubtle bugs "
"that\n"
"could in turn lead to memory leaks or a value being dropped before we‚Äôre "
"done\n"
"with it. What we need is a type exactly like `Rc<T>` but one that makes "
"changes\n"
"to the reference count in a thread-safe way."
msgstr ""

#: src/ch16-03-shared-state.md:271
msgid "#### Atomic Reference Counting with `Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:273
msgid ""
"Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in\n"
"concurrent situations. The *a* stands for *atomic*, meaning it‚Äôs an "
"*atomically\n"
"reference counted* type. Atomics are an additional kind of concurrency\n"
"primitive that we won‚Äôt cover in detail here: see the standard library\n"
"documentation for [`std::sync::atomic`][atomic]<!-- ignore --> for more\n"
"details. At this point, you just need to know that atomics work like "
"primitive\n"
"types but are safe to share across threads."
msgstr ""

#: src/ch16-03-shared-state.md:281
msgid ""
"You might then wonder why all primitive types aren‚Äôt atomic and why "
"standard\n"
"library types aren‚Äôt implemented to use `Arc<T>` by default. The reason is "
"that\n"
"thread safety comes with a performance penalty that you only want to pay "
"when\n"
"you really need to. If you‚Äôre just performing operations on values within a\n"
"single thread, your code can run faster if it doesn‚Äôt have to enforce the\n"
"guarantees atomics provide."
msgstr ""

#: src/ch16-03-shared-state.md:288
msgid ""
"Let‚Äôs return to our example: `Arc<T>` and `Rc<T>` have the same API, so we "
"fix\n"
"our program by changing the `use` line, the call to `new`, and the call to\n"
"`clone`. The code in Listing 16-15 will finally compile and run:"
msgstr ""

#: src/ch16-03-shared-state.md:294
msgid ""
"```rust\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let counter = Arc::new(Mutex::new(0));\n"
"    let mut handles = vec![];\n"
"\n"
"    for _ in 0..10 {\n"
"        let counter = Arc::clone(&counter);\n"
"        let handle = thread::spawn(move || {\n"
"            let mut num = counter.lock().unwrap();\n"
"\n"
"            *num += 1;\n"
"        });\n"
"        handles.push(handle);\n"
"    }\n"
"\n"
"    for handle in handles {\n"
"        handle.join().unwrap();\n"
"    }\n"
"\n"
"    println!(\"Result: {}\", *counter.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:320
msgid ""
"<span class=\"caption\">Listing 16-15: Using an `Arc<T>` to wrap the "
"`Mutex<T>`\n"
"to be able to share ownership across multiple threads</span>"
msgstr ""

#: src/ch16-03-shared-state.md:329
msgid ""
"```text\n"
"Result: 10\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:333
msgid ""
"We did it! We counted from 0 to 10, which may not seem very impressive, but "
"it\n"
"did teach us a lot about `Mutex<T>` and thread safety. You could also use "
"this\n"
"program‚Äôs structure to do more complicated operations than just incrementing "
"a\n"
"counter. Using this strategy, you can divide a calculation into independent\n"
"parts, split those parts across threads, and then use a `Mutex<T>` to have "
"each\n"
"thread update the final result with its part."
msgstr ""

#: src/ch16-03-shared-state.md:340
msgid ""
"Note that if you are doing simple numerical operations, there are types "
"simpler\n"
"than `Mutex<T>` types provided by the [`std::sync::atomic` module of the\n"
"standard library][atomic]<!-- ignore -->. These types provide safe, "
"concurrent,\n"
"atomic access to primitive types. We chose to use `Mutex<T>` with a "
"primitive\n"
"type for this example so we could concentrate on how `Mutex<T>` works."
msgstr ""

#: src/ch16-03-shared-state.md:346
msgid "### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:348
msgid ""
"You might have noticed that `counter` is immutable but we could get a "
"mutable\n"
"reference to the value inside it; this means `Mutex<T>` provides interior\n"
"mutability, as the `Cell` family does. In the same way we used `RefCell<T>` "
"in\n"
"Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use "
"`Mutex<T>`\n"
"to mutate contents inside an `Arc<T>`."
msgstr ""

#: src/ch16-03-shared-state.md:354
msgid ""
"Another detail to note is that Rust can‚Äôt protect you from all kinds of "
"logic\n"
"errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` "
"came\n"
"with the risk of creating reference cycles, where two `Rc<T>` values refer "
"to\n"
"each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk "
"of\n"
"creating *deadlocks*. These occur when an operation needs to lock two "
"resources\n"
"and two threads have each acquired one of the locks, causing them to wait "
"for\n"
"each other forever. If you‚Äôre interested in deadlocks, try creating a Rust\n"
"program that has a deadlock; then research deadlock mitigation strategies "
"for\n"
"mutexes in any language and have a go at implementing them in Rust. The\n"
"standard library API documentation for `Mutex<T>` and `MutexGuard` offers\n"
"useful information."
msgstr ""

#: src/ch16-03-shared-state.md:366
msgid ""
"We‚Äôll round out this chapter by talking about the `Send` and `Sync` traits "
"and\n"
"how we can use them with custom types."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:1
msgid "## Extensible Concurrency with the `Sync` and `Send` Traits"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:3
msgid ""
"Interestingly, the Rust language has *very* few concurrency features. "
"Almost\n"
"every concurrency feature we‚Äôve talked about so far in this chapter has "
"been\n"
"part of the standard library, not the language. Your options for handling\n"
"concurrency are not limited to the language or the standard library; you "
"can\n"
"write your own concurrency features or use those written by others."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:9
msgid ""
"However, two concurrency concepts are embedded in the language: the\n"
"`std::marker` traits `Sync` and `Send`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:12
msgid "### Allowing Transference of Ownership Between Threads with `Send`"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:14
msgid ""
"The `Send` marker trait indicates that ownership of values of the type\n"
"implementing `Send` can be transferred between threads. Almost every Rust "
"type\n"
"is `Send`, but there are some exceptions, including `Rc<T>`: this cannot be\n"
"`Send` because if you cloned an `Rc<T>` value and tried to transfer "
"ownership\n"
"of the clone to another thread, both threads might update the reference "
"count\n"
"at the same time. For this reason, `Rc<T>` is implemented for use in\n"
"single-threaded situations where you don‚Äôt want to pay the thread-safe\n"
"performance penalty."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:23
msgid ""
"Therefore, Rust‚Äôs type system and trait bounds ensure that you can never\n"
"accidentally send an `Rc<T>` value across threads unsafely. When we tried to "
"do\n"
"this in Listing 16-14, we got the error `the trait Send is not implemented "
"for\n"
"Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code\n"
"compiled."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:29
msgid ""
"Any type composed entirely of `Send` types is automatically marked as `Send` "
"as\n"
"well. Almost all primitive types are `Send`, aside from raw pointers, which\n"
"we‚Äôll discuss in Chapter 19."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:33
msgid "### Allowing Access from Multiple Threads with `Sync`"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:35
msgid ""
"The `Sync` marker trait indicates that it is safe for the type implementing\n"
"`Sync` to be referenced from multiple threads. In other words, any type `T` "
"is\n"
"`Sync` if `&T` (an immutable reference to `T`) is `Send`, meaning the "
"reference\n"
"can be sent safely to another thread. Similar to `Send`, primitive types "
"are\n"
"`Sync`, and types composed entirely of types that are `Sync` are also `Sync`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:41
msgid ""
"The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it‚Äôs "
"not\n"
"`Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the\n"
"family of related `Cell<T>` types are not `Sync`. The implementation of "
"borrow\n"
"checking that `RefCell<T>` does at runtime is not thread-safe. The smart\n"
"pointer `Mutex<T>` is `Sync` and can be used to share access with multiple\n"
"threads as you saw in the [‚ÄúSharing a `Mutex<T>` Between Multiple\n"
"Threads‚Äù][sharing-a-mutext-between-multiple-threads]<!-- ignore --> section."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:49
msgid "### Implementing `Send` and `Sync` Manually Is Unsafe"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:51
msgid ""
"Because types that are made up of `Send` and `Sync` traits are "
"automatically\n"
"also `Send` and `Sync`, we don‚Äôt have to implement those traits manually. "
"As\n"
"marker traits, they don‚Äôt even have any methods to implement. They‚Äôre just\n"
"useful for enforcing invariants related to concurrency."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:56
msgid ""
"Manually implementing these traits involves implementing unsafe Rust code.\n"
"We‚Äôll talk about using unsafe Rust code in Chapter 19; for now, the "
"important\n"
"information is that building new concurrent types not made up of `Send` and\n"
"`Sync` parts requires careful thought to uphold the safety guarantees. "
"[‚ÄúThe\n"
"Rustonomicon‚Äù][nomicon] has more information about these guarantees and how "
"to\n"
"uphold them."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:65
msgid ""
"This isn‚Äôt the last you‚Äôll see of concurrency in this book: the project in\n"
"Chapter 20 will use the concepts in this chapter in a more realistic "
"situation\n"
"than the smaller examples discussed here."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:69
msgid ""
"As mentioned earlier, because very little of how Rust handles concurrency "
"is\n"
"part of the language, many concurrency solutions are implemented as crates.\n"
"These evolve more quickly than the standard library, so be sure to search\n"
"online for the current, state-of-the-art crates to use in multithreaded\n"
"situations."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:75
msgid ""
"The Rust standard library provides channels for message passing and smart\n"
"pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in\n"
"concurrent contexts. The type system and the borrow checker ensure that the\n"
"code using these solutions won‚Äôt end up with data races or invalid "
"references.\n"
"Once you get your code to compile, you can rest assured that it will "
"happily\n"
"run on multiple threads without the kinds of hard-to-track-down bugs common "
"in\n"
"other languages. Concurrent programming is no longer a concept to be afraid "
"of:\n"
"go forth and make your programs concurrent, fearlessly!"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:84
msgid ""
"Next, we‚Äôll talk about idiomatic ways to model problems and structure "
"solutions\n"
"as your Rust programs get bigger. In addition, we‚Äôll discuss how Rust‚Äôs "
"idioms\n"
"relate to those you might be familiar with from object-oriented programming."
msgstr ""

#: src/ch17-00-oop.md:1
msgid "# Object-Oriented Programming Features of Rust"
msgstr ""

#: src/ch17-00-oop.md:3
msgid ""
"Object-oriented programming (OOP) is a way of modeling programs. Objects as "
"a\n"
"programmatic concept were introduced in the programming language Simula in "
"the\n"
"1960s. Those objects influenced Alan Kay‚Äôs programming architecture in "
"which\n"
"objects pass messages to each other. To describe this architecture, he "
"coined\n"
"the term *object-oriented programming* in 1967. Many competing definitions\n"
"describe what OOP is, and by some of these definitions Rust is object-"
"oriented,\n"
"but by others it is not. In this chapter, we‚Äôll explore certain "
"characteristics\n"
"that are commonly considered object-oriented and how those characteristics\n"
"translate to idiomatic Rust. We‚Äôll then show you how to implement an\n"
"object-oriented design pattern in Rust and discuss the trade-offs of doing "
"so\n"
"versus implementing a solution using some of Rust‚Äôs strengths instead."
msgstr ""

#: src/ch17-01-what-is-oo.md:1
msgid "## Characteristics of Object-Oriented Languages"
msgstr ""

#: src/ch17-01-what-is-oo.md:3
msgid ""
"There is no consensus in the programming community about what features a\n"
"language must have to be considered object-oriented. Rust is influenced by "
"many\n"
"programming paradigms, including OOP; for example, we explored the features\n"
"that came from functional programming in Chapter 13. Arguably, OOP "
"languages\n"
"share certain common characteristics, namely objects, encapsulation, and\n"
"inheritance. Let‚Äôs look at what each of those characteristics means and "
"whether\n"
"Rust supports it."
msgstr ""

#: src/ch17-01-what-is-oo.md:11
msgid "### Objects Contain Data and Behavior"
msgstr ""

#: src/ch17-01-what-is-oo.md:13
msgid ""
"The book *Design Patterns: Elements of Reusable Object-Oriented Software* "
"by\n"
"Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-"
"Wesley\n"
"Professional, 1994), colloquially referred to as *The Gang of Four* book, is "
"a\n"
"catalog of object-oriented design patterns. It defines OOP this way:"
msgstr ""

#: src/ch17-01-what-is-oo.md:18
msgid ""
"> Object-oriented programs are made up of objects. An *object* packages "
"both\n"
"> data and the procedures that operate on that data. The procedures are\n"
"> typically called *methods* or *operations*."
msgstr ""

#: src/ch17-01-what-is-oo.md:22
msgid ""
"Using this definition, Rust is object-oriented: structs and enums have "
"data,\n"
"and `impl` blocks provide methods on structs and enums. Even though structs "
"and\n"
"enums with methods aren‚Äôt *called* objects, they provide the same\n"
"functionality, according to the Gang of Four‚Äôs definition of objects."
msgstr ""

#: src/ch17-01-what-is-oo.md:27
msgid "### Encapsulation that Hides Implementation Details"
msgstr ""

#: src/ch17-01-what-is-oo.md:29
msgid ""
"Another aspect commonly associated with OOP is the idea of *encapsulation*,\n"
"which means that the implementation details of an object aren‚Äôt accessible "
"to\n"
"code using that object. Therefore, the only way to interact with an object "
"is\n"
"through its public API; code using the object shouldn‚Äôt be able to reach "
"into\n"
"the object‚Äôs internals and change data or behavior directly. This enables "
"the\n"
"programmer to change and refactor an object‚Äôs internals without needing to\n"
"change the code that uses the object."
msgstr ""

#: src/ch17-01-what-is-oo.md:37
msgid ""
"We discussed how to control encapsulation in Chapter 7: we can use the "
"`pub`\n"
"keyword to decide which modules, types, functions, and methods in our code\n"
"should be public, and by default everything else is private. For example, "
"we\n"
"can define a struct `AveragedCollection` that has a field containing a "
"vector\n"
"of `i32` values. The struct can also have a field that contains the average "
"of\n"
"the values in the vector, meaning the average doesn‚Äôt have to be computed\n"
"on demand whenever anyone needs it. In other words, `AveragedCollection` "
"will\n"
"cache the calculated average for us. Listing 17-1 has the definition of the\n"
"`AveragedCollection` struct:"
msgstr ""

#: src/ch17-01-what-is-oo.md:49
msgid ""
"```rust,noplayground\n"
"pub struct AveragedCollection {\n"
"    list: Vec<i32>,\n"
"    average: f64,\n"
"}\n"
"```"
msgstr ""

#: src/ch17-01-what-is-oo.md:56
msgid ""
"<span class=\"caption\">Listing 17-1: An `AveragedCollection` struct that\n"
"maintains a list of integers and the average of the items in the\n"
"collection</span>"
msgstr ""

#: src/ch17-01-what-is-oo.md:60
msgid ""
"The struct is marked `pub` so that other code can use it, but the fields "
"within\n"
"the struct remain private. This is important in this case because we want "
"to\n"
"ensure that whenever a value is added or removed from the list, the average "
"is\n"
"also updated. We do this by implementing `add`, `remove`, and `average` "
"methods\n"
"on the struct, as shown in Listing 17-2:"
msgstr ""

#: src/ch17-01-what-is-oo.md:68
msgid ""
"```rust,noplayground\n"
"# pub struct AveragedCollection {\n"
"#     list: Vec<i32>,\n"
"#     average: f64,\n"
"# }\n"
"# \n"
"impl AveragedCollection {\n"
"    pub fn add(&mut self, value: i32) {\n"
"        self.list.push(value);\n"
"        self.update_average();\n"
"    }\n"
"\n"
"    pub fn remove(&mut self) -> Option<i32> {\n"
"        let result = self.list.pop();\n"
"        match result {\n"
"            Some(value) => {\n"
"                self.update_average();\n"
"                Some(value)\n"
"            }\n"
"            None => None,\n"
"        }\n"
"    }\n"
"\n"
"    pub fn average(&self) -> f64 {\n"
"        self.average\n"
"    }\n"
"\n"
"    fn update_average(&mut self) {\n"
"        let total: i32 = self.list.iter().sum();\n"
"        self.average = total as f64 / self.list.len() as f64;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-01-what-is-oo.md:102
msgid ""
"<span class=\"caption\">Listing 17-2: Implementations of the public methods\n"
"`add`, `remove`, and `average` on `AveragedCollection`</span>"
msgstr ""

#: src/ch17-01-what-is-oo.md:105
msgid ""
"The public methods `add`, `remove`, and `average` are the only ways to "
"access\n"
"or modify data in an instance of `AveragedCollection`. When an item is "
"added\n"
"to `list` using the `add` method or removed using the `remove` method, the\n"
"implementations of each call the private `update_average` method that "
"handles\n"
"updating the `average` field as well."
msgstr ""

#: src/ch17-01-what-is-oo.md:111
msgid ""
"We leave the `list` and `average` fields private so there is no way for\n"
"external code to add or remove items to or from the `list` field directly;\n"
"otherwise, the `average` field might become out of sync when the `list`\n"
"changes. The `average` method returns the value in the `average` field,\n"
"allowing external code to read the `average` but not modify it."
msgstr ""

#: src/ch17-01-what-is-oo.md:117
msgid ""
"Because we‚Äôve encapsulated the implementation details of the struct\n"
"`AveragedCollection`, we can easily change aspects, such as the data "
"structure,\n"
"in the future. For instance, we could use a `HashSet<i32>` instead of a\n"
"`Vec<i32>` for the `list` field. As long as the signatures of the `add`,\n"
"`remove`, and `average` public methods stay the same, code using\n"
"`AveragedCollection` wouldn‚Äôt need to change. If we made `list` public "
"instead,\n"
"this wouldn‚Äôt necessarily be the case: `HashSet<i32>` and `Vec<i32>` have\n"
"different methods for adding and removing items, so the external code would\n"
"likely have to change if it were modifying `list` directly."
msgstr ""

#: src/ch17-01-what-is-oo.md:127
msgid ""
"If encapsulation is a required aspect for a language to be considered\n"
"object-oriented, then Rust meets that requirement. The option to use `pub` "
"or\n"
"not for different parts of code enables encapsulation of implementation "
"details."
msgstr ""

#: src/ch17-01-what-is-oo.md:131
msgid "### Inheritance as a Type System and as Code Sharing"
msgstr ""

#: src/ch17-01-what-is-oo.md:133
msgid ""
"*Inheritance* is a mechanism whereby an object can inherit elements from\n"
"another object‚Äôs definition, thus gaining the parent object‚Äôs data and "
"behavior\n"
"without you having to define them again."
msgstr ""

#: src/ch17-01-what-is-oo.md:137
msgid ""
"If a language must have inheritance to be an object-oriented language, then\n"
"Rust is not one. There is no way to define a struct that inherits the "
"parent\n"
"struct‚Äôs fields and method implementations without using a macro."
msgstr ""

#: src/ch17-01-what-is-oo.md:141
msgid ""
"However, if you‚Äôre used to having inheritance in your programming toolbox, "
"you\n"
"can use other solutions in Rust, depending on your reason for reaching for\n"
"inheritance in the first place."
msgstr ""

#: src/ch17-01-what-is-oo.md:145
msgid ""
"You would choose inheritance for two main reasons. One is for reuse of "
"code:\n"
"you can implement particular behavior for one type, and inheritance enables "
"you\n"
"to reuse that implementation for a different type. You can do this in a "
"limited\n"
"way in Rust code using default trait method implementations, which you saw "
"in\n"
"Listing 10-14 when we added a default implementation of the `summarize` "
"method\n"
"on the `Summary` trait. Any type implementing the `Summary` trait would "
"have\n"
"the `summarize` method available on it without any further code. This is\n"
"similar to a parent class having an implementation of a method and an\n"
"inheriting child class also having the implementation of the method. We can\n"
"also override the default implementation of the `summarize` method when we\n"
"implement the `Summary` trait, which is similar to a child class overriding "
"the\n"
"implementation of a method inherited from a parent class."
msgstr ""

#: src/ch17-01-what-is-oo.md:158
msgid ""
"The other reason to use inheritance relates to the type system: to enable a\n"
"child type to be used in the same places as the parent type. This is also\n"
"called *polymorphism*, which means that you can substitute multiple objects "
"for\n"
"each other at runtime if they share certain characteristics."
msgstr ""

#: src/ch17-01-what-is-oo.md:163
msgid ""
"> ### Polymorphism\n"
">\n"
"> To many people, polymorphism is synonymous with inheritance. But it‚Äôs\n"
"> actually a more general concept that refers to code that can work with "
"data\n"
"> of multiple types. For inheritance, those types are generally subclasses.\n"
">\n"
"> Rust instead uses generics to abstract over different possible types and\n"
"> trait bounds to impose constraints on what those types must provide. This "
"is\n"
"> sometimes called *bounded parametric polymorphism*."
msgstr ""

#: src/ch17-01-what-is-oo.md:173
msgid ""
"Inheritance has recently fallen out of favor as a programming design "
"solution\n"
"in many programming languages because it‚Äôs often at risk of sharing more "
"code\n"
"than necessary. Subclasses shouldn‚Äôt always share all characteristics of "
"their\n"
"parent class but will do so with inheritance. This can make a program‚Äôs "
"design\n"
"less flexible. It also introduces the possibility of calling methods on\n"
"subclasses that don‚Äôt make sense or that cause errors because the methods "
"don‚Äôt\n"
"apply to the subclass. In addition, some languages will only allow single\n"
"inheritance (meaning a subclass can only inherit from one class), further\n"
"restricting the flexibility of a program‚Äôs design."
msgstr ""

#: src/ch17-01-what-is-oo.md:183
msgid ""
"For these reasons, Rust takes the different approach of using trait objects\n"
"instead of inheritance. Let‚Äôs look at how trait objects enable polymorphism "
"in\n"
"Rust."
msgstr ""

#: src/ch17-02-trait-objects.md:1
msgid "## Using Trait Objects That Allow for Values of Different Types"
msgstr ""

#: src/ch17-02-trait-objects.md:3
msgid ""
"In Chapter 8, we mentioned that one limitation of vectors is that they can\n"
"store elements of only one type. We created a workaround in Listing 8-9 "
"where\n"
"we defined a `SpreadsheetCell` enum that had variants to hold integers, "
"floats,\n"
"and text. This meant we could store different types of data in each cell "
"and\n"
"still have a vector that represented a row of cells. This is a perfectly "
"good\n"
"solution when our interchangeable items are a fixed set of types that we "
"know\n"
"when our code is compiled."
msgstr ""

#: src/ch17-02-trait-objects.md:11
msgid ""
"However, sometimes we want our library user to be able to extend the set of\n"
"types that are valid in a particular situation. To show how we might "
"achieve\n"
"this, we‚Äôll create an example graphical user interface (GUI) tool that "
"iterates\n"
"through a list of items, calling a `draw` method on each one to draw it to "
"the\n"
"screen‚Äîa common technique for GUI tools. We‚Äôll create a library crate "
"called\n"
"`gui` that contains the structure of a GUI library. This crate might "
"include\n"
"some types for people to use, such as `Button` or `TextField`. In addition,\n"
"`gui` users will want to create their own types that can be drawn: for\n"
"instance, one programmer might add an `Image` and another might add a\n"
"`SelectBox`."
msgstr ""

#: src/ch17-02-trait-objects.md:22
msgid ""
"We won‚Äôt implement a fully fledged GUI library for this example but will "
"show\n"
"how the pieces would fit together. At the time of writing the library, we "
"can‚Äôt\n"
"know and define all the types other programmers might want to create. But we "
"do\n"
"know that `gui` needs to keep track of many values of different types, and "
"it\n"
"needs to call a `draw` method on each of these differently typed values. It\n"
"doesn‚Äôt need to know exactly what will happen when we call the `draw` "
"method,\n"
"just that the value will have that method available for us to call."
msgstr ""

#: src/ch17-02-trait-objects.md:30
msgid ""
"To do this in a language with inheritance, we might define a class named\n"
"`Component` that has a method named `draw` on it. The other classes, such "
"as\n"
"`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus\n"
"inherit the `draw` method. They could each override the `draw` method to "
"define\n"
"their custom behavior, but the framework could treat all of the types as if\n"
"they were `Component` instances and call `draw` on them. But because Rust\n"
"doesn‚Äôt have inheritance, we need another way to structure the `gui` library "
"to\n"
"allow users to extend it with new types."
msgstr ""

#: src/ch17-02-trait-objects.md:39
msgid "### Defining a Trait for Common Behavior"
msgstr ""

#: src/ch17-02-trait-objects.md:41
msgid ""
"To implement the behavior we want `gui` to have, we‚Äôll define a trait named\n"
"`Draw` that will have one method named `draw`. Then we can define a vector "
"that\n"
"takes a *trait object*. A trait object points to both an instance of a type\n"
"implementing our specified trait and a table used to look up trait methods "
"on\n"
"that type at runtime. We create a trait object by specifying some sort of\n"
"pointer, such as a `&` reference or a `Box<T>` smart pointer, then the "
"`dyn`\n"
"keyword, and then specifying the relevant trait. (We‚Äôll talk about the "
"reason\n"
"trait objects must use a pointer in Chapter 19 in the section [‚ÄúDynamically\n"
"Sized Types and the `Sized` Trait.‚Äù][dynamically-sized]<!-- ignore -->) We "
"can\n"
"use trait objects in place of a generic or concrete type. Wherever we use a\n"
"trait object, Rust‚Äôs type system will ensure at compile time that any value\n"
"used in that context will implement the trait object‚Äôs trait. Consequently, "
"we\n"
"don‚Äôt need to know all the possible types at compile time."
msgstr ""

#: src/ch17-02-trait-objects.md:55
msgid ""
"We‚Äôve mentioned that, in Rust, we refrain from calling structs and enums\n"
"‚Äúobjects‚Äù to distinguish them from other languages‚Äô objects. In a struct or\n"
"enum, the data in the struct fields and the behavior in `impl` blocks are\n"
"separated, whereas in other languages, the data and behavior combined into "
"one\n"
"concept is often labeled an object. However, trait objects *are* more like\n"
"objects in other languages in the sense that they combine data and "
"behavior.\n"
"But trait objects differ from traditional objects in that we can‚Äôt add data "
"to\n"
"a trait object. Trait objects aren‚Äôt as generally useful as objects in "
"other\n"
"languages: their specific purpose is to allow abstraction across common\n"
"behavior."
msgstr ""

#: src/ch17-02-trait-objects.md:66
msgid ""
"Listing 17-3 shows how to define a trait named `Draw` with one method named\n"
"`draw`:"
msgstr ""

#: src/ch17-02-trait-objects.md:71
msgid ""
"```rust,noplayground\n"
"pub trait Draw {\n"
"    fn draw(&self);\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:77
msgid ""
"<span class=\"caption\">Listing 17-3: Definition of the `Draw` trait</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:79
msgid ""
"This syntax should look familiar from our discussions on how to define "
"traits\n"
"in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct "
"named\n"
"`Screen` that holds a vector named `components`. This vector is of type\n"
"`Box<dyn Draw>`, which is a trait object; it‚Äôs a stand-in for any type "
"inside\n"
"a `Box` that implements the `Draw` trait."
msgstr ""

#: src/ch17-02-trait-objects.md:87
msgid ""
"```rust,noplayground\n"
"# pub trait Draw {\n"
"#     fn draw(&self);\n"
"# }\n"
"# \n"
"pub struct Screen {\n"
"    pub components: Vec<Box<dyn Draw>>,\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:97
msgid ""
"<span class=\"caption\">Listing 17-4: Definition of the `Screen` struct with "
"a\n"
"`components` field holding a vector of trait objects that implement the "
"`Draw`\n"
"trait</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:101
msgid ""
"On the `Screen` struct, we‚Äôll define a method named `run` that will call "
"the\n"
"`draw` method on each of its `components`, as shown in Listing 17-5:"
msgstr ""

#: src/ch17-02-trait-objects.md:106
msgid ""
"```rust,noplayground\n"
"# pub trait Draw {\n"
"#     fn draw(&self);\n"
"# }\n"
"# \n"
"# pub struct Screen {\n"
"#     pub components: Vec<Box<dyn Draw>>,\n"
"# }\n"
"# \n"
"impl Screen {\n"
"    pub fn run(&self) {\n"
"        for component in self.components.iter() {\n"
"            component.draw();\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:124
msgid ""
"<span class=\"caption\">Listing 17-5: A `run` method on `Screen` that calls "
"the\n"
"`draw` method on each component</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:127
msgid ""
"This works differently from defining a struct that uses a generic type\n"
"parameter with trait bounds. A generic type parameter can only be "
"substituted\n"
"with one concrete type at a time, whereas trait objects allow for multiple\n"
"concrete types to fill in for the trait object at runtime. For example, we\n"
"could have defined the `Screen` struct using a generic type and a trait "
"bound\n"
"as in Listing 17-6:"
msgstr ""

#: src/ch17-02-trait-objects.md:136
msgid ""
"```rust,noplayground\n"
"# pub trait Draw {\n"
"#     fn draw(&self);\n"
"# }\n"
"# \n"
"pub struct Screen<T: Draw> {\n"
"    pub components: Vec<T>,\n"
"}\n"
"\n"
"impl<T> Screen<T>\n"
"where\n"
"    T: Draw,\n"
"{\n"
"    pub fn run(&self) {\n"
"        for component in self.components.iter() {\n"
"            component.draw();\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:157
msgid ""
"<span class=\"caption\">Listing 17-6: An alternate implementation of the "
"`Screen`\n"
"struct and its `run` method using generics and trait bounds</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:160
msgid ""
"This restricts us to a `Screen` instance that has a list of components all "
"of\n"
"type `Button` or all of type `TextField`. If you‚Äôll only ever have "
"homogeneous\n"
"collections, using generics and trait bounds is preferable because the\n"
"definitions will be monomorphized at compile time to use the concrete types."
msgstr ""

#: src/ch17-02-trait-objects.md:165
msgid ""
"On the other hand, with the method using trait objects, one `Screen` "
"instance\n"
"can hold a `Vec<T>` that contains a `Box<Button>` as well as a\n"
"`Box<TextField>`. Let‚Äôs look at how this works, and then we‚Äôll talk about "
"the\n"
"runtime performance implications."
msgstr ""

#: src/ch17-02-trait-objects.md:170
msgid "### Implementing the Trait"
msgstr ""

#: src/ch17-02-trait-objects.md:172
msgid ""
"Now we‚Äôll add some types that implement the `Draw` trait. We‚Äôll provide the\n"
"`Button` type. Again, actually implementing a GUI library is beyond the "
"scope\n"
"of this book, so the `draw` method won‚Äôt have any useful implementation in "
"its\n"
"body. To imagine what the implementation might look like, a `Button` struct\n"
"might have fields for `width`, `height`, and `label`, as shown in Listing "
"17-7:"
msgstr ""

#: src/ch17-02-trait-objects.md:180
msgid ""
"```rust,noplayground\n"
"# pub trait Draw {\n"
"#     fn draw(&self);\n"
"# }\n"
"# \n"
"# pub struct Screen {\n"
"#     pub components: Vec<Box<dyn Draw>>,\n"
"# }\n"
"# \n"
"# impl Screen {\n"
"#     pub fn run(&self) {\n"
"#         for component in self.components.iter() {\n"
"#             component.draw();\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"pub struct Button {\n"
"    pub width: u32,\n"
"    pub height: u32,\n"
"    pub label: String,\n"
"}\n"
"\n"
"impl Draw for Button {\n"
"    fn draw(&self) {\n"
"        // code to actually draw a button\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:210
msgid ""
"<span class=\"caption\">Listing 17-7: A `Button` struct that implements the\n"
"`Draw` trait</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:213
msgid ""
"The `width`, `height`, and `label` fields on `Button` will differ from the\n"
"fields on other components; for example, a `TextField` type might have "
"those\n"
"same fields plus a `placeholder` field. Each of the types we want to draw "
"on\n"
"the screen will implement the `Draw` trait but will use different code in "
"the\n"
"`draw` method to define how to draw that particular type, as `Button` has "
"here\n"
"(without the actual GUI code, as mentioned). The `Button` type, for "
"instance,\n"
"might have an additional `impl` block containing methods related to what\n"
"happens when a user clicks the button. These kinds of methods won‚Äôt apply "
"to\n"
"types like `TextField`."
msgstr ""

#: src/ch17-02-trait-objects.md:223
msgid ""
"If someone using our library decides to implement a `SelectBox` struct that "
"has\n"
"`width`, `height`, and `options` fields, they implement the `Draw` trait on "
"the\n"
"`SelectBox` type as well, as shown in Listing 17-8:"
msgstr ""

#: src/ch17-02-trait-objects.md:229
msgid ""
"```rust,ignore\n"
"use gui::Draw;\n"
"\n"
"struct SelectBox {\n"
"    width: u32,\n"
"    height: u32,\n"
"    options: Vec<String>,\n"
"}\n"
"\n"
"impl Draw for SelectBox {\n"
"    fn draw(&self) {\n"
"        // code to actually draw a select box\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:247
msgid ""
"<span class=\"caption\">Listing 17-8: Another crate using `gui` and "
"implementing\n"
"the `Draw` trait on a `SelectBox` struct</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:250
msgid ""
"Our library‚Äôs user can now write their `main` function to create a `Screen`\n"
"instance. To the `Screen` instance, they can add a `SelectBox` and a "
"`Button`\n"
"by putting each in a `Box<T>` to become a trait object. They can then call "
"the\n"
"`run` method on the `Screen` instance, which will call `draw` on each of "
"the\n"
"components. Listing 17-9 shows this implementation:"
msgstr ""

#: src/ch17-02-trait-objects.md:258
msgid ""
"```rust,ignore\n"
"# use gui::Draw;\n"
"# \n"
"# struct SelectBox {\n"
"#     width: u32,\n"
"#     height: u32,\n"
"#     options: Vec<String>,\n"
"# }\n"
"# \n"
"# impl Draw for SelectBox {\n"
"#     fn draw(&self) {\n"
"#         // code to actually draw a select box\n"
"#     }\n"
"# }\n"
"# \n"
"use gui::{Button, Screen};\n"
"\n"
"fn main() {\n"
"    let screen = Screen {\n"
"        components: vec![\n"
"            Box::new(SelectBox {\n"
"                width: 75,\n"
"                height: 10,\n"
"                options: vec![\n"
"                    String::from(\"Yes\"),\n"
"                    String::from(\"Maybe\"),\n"
"                    String::from(\"No\"),\n"
"                ],\n"
"            }),\n"
"            Box::new(Button {\n"
"                width: 50,\n"
"                height: 10,\n"
"                label: String::from(\"OK\"),\n"
"            }),\n"
"        ],\n"
"    };\n"
"\n"
"    screen.run();\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:299
msgid ""
"<span class=\"caption\">Listing 17-9: Using trait objects to store values "
"of\n"
"different types that implement the same trait</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:302
msgid ""
"When we wrote the library, we didn‚Äôt know that someone might add the\n"
"`SelectBox` type, but our `Screen` implementation was able to operate on "
"the\n"
"new type and draw it because `SelectBox` implements the `Draw` trait, which\n"
"means it implements the `draw` method."
msgstr ""

#: src/ch17-02-trait-objects.md:307
msgid ""
"This concept‚Äîof being concerned only with the messages a value responds to\n"
"rather than the value‚Äôs concrete type‚Äîis similar to the concept of *duck\n"
"typing* in dynamically typed languages: if it walks like a duck and quacks\n"
"like a duck, then it must be a duck! In the implementation of `run` on "
"`Screen`\n"
"in Listing 17-5, `run` doesn‚Äôt need to know what the concrete type of each\n"
"component is. It doesn‚Äôt check whether a component is an instance of a "
"`Button`\n"
"or a `SelectBox`, it just calls the `draw` method on the component. By\n"
"specifying `Box<dyn Draw>` as the type of the values in the `components`\n"
"vector, we‚Äôve defined `Screen` to need values that we can call the `draw`\n"
"method on."
msgstr ""

#: src/ch17-02-trait-objects.md:318
msgid ""
"The advantage of using trait objects and Rust‚Äôs type system to write code\n"
"similar to code using duck typing is that we never have to check whether a\n"
"value implements a particular method at runtime or worry about getting "
"errors\n"
"if a value doesn‚Äôt implement a method but we call it anyway. Rust won‚Äôt "
"compile\n"
"our code if the values don‚Äôt implement the traits that the trait objects "
"need."
msgstr ""

#: src/ch17-02-trait-objects.md:324
msgid ""
"For example, Listing 17-10 shows what happens if we try to create a "
"`Screen`\n"
"with a `String` as a component:"
msgstr ""

#: src/ch17-02-trait-objects.md:329
msgid ""
"```rust,ignore,does_not_compile\n"
"use gui::Screen;\n"
"\n"
"fn main() {\n"
"    let screen = Screen {\n"
"        components: vec![Box::new(String::from(\"Hi\"))],\n"
"    };\n"
"\n"
"    screen.run();\n"
"}\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:341
msgid ""
"<span class=\"caption\">Listing 17-10: Attempting to use a type that "
"doesn‚Äôt\n"
"implement the trait object‚Äôs trait</span>"
msgstr ""

#: src/ch17-02-trait-objects.md:344
msgid ""
"We‚Äôll get this error because `String` doesn‚Äôt implement the `Draw` trait:"
msgstr ""

#: src/ch17-02-trait-objects.md:346
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling gui v0.1.0 (file:///projects/gui)\n"
"error[E0277]: the trait bound `String: Draw` is not satisfied\n"
" --> src/main.rs:5:26\n"
"  |\n"
"5 |         components: vec![Box::new(String::from(\"Hi\"))],\n"
"  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` "
"is not implemented for `String`\n"
"  |\n"
"  = help: the trait `Draw` is implemented for `Button`\n"
"  = note: required for the cast from `String` to the object type `dyn Draw`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `gui` due to previous error\n"
"```"
msgstr ""

#: src/ch17-02-trait-objects.md:362
msgid ""
"This error lets us know that either we‚Äôre passing something to `Screen` we\n"
"didn‚Äôt mean to pass and so should pass a different type or we should "
"implement\n"
"`Draw` on `String` so that `Screen` is able to call `draw` on it."
msgstr ""

#: src/ch17-02-trait-objects.md:366
msgid "### Trait Objects Perform Dynamic Dispatch"
msgstr ""

#: src/ch17-02-trait-objects.md:368
msgid ""
"Recall in the [‚ÄúPerformance of Code Using\n"
"Generics‚Äù][performance-of-code-using-generics]<!-- ignore --> section in\n"
"Chapter 10 our discussion on the monomorphization process performed by the\n"
"compiler when we use trait bounds on generics: the compiler generates\n"
"nongeneric implementations of functions and methods for each concrete type "
"that\n"
"we use in place of a generic type parameter. The code that results from\n"
"monomorphization is doing *static dispatch*, which is when the compiler "
"knows\n"
"what method you‚Äôre calling at compile time. This is opposed to *dynamic\n"
"dispatch*, which is when the compiler can‚Äôt tell at compile time which "
"method\n"
"you‚Äôre calling. In dynamic dispatch cases, the compiler emits code that at\n"
"runtime will figure out which method to call."
msgstr ""

#: src/ch17-02-trait-objects.md:380
msgid ""
"When we use trait objects, Rust must use dynamic dispatch. The compiler "
"doesn‚Äôt\n"
"know all the types that might be used with the code that‚Äôs using trait "
"objects,\n"
"so it doesn‚Äôt know which method implemented on which type to call. Instead, "
"at\n"
"runtime, Rust uses the pointers inside the trait object to know which method "
"to\n"
"call. This lookup incurs a runtime cost that doesn‚Äôt occur with static\n"
"dispatch. Dynamic dispatch also prevents the compiler from choosing to "
"inline a\n"
"method‚Äôs code, which in turn prevents some optimizations. However, we did "
"get\n"
"extra flexibility in the code that we wrote in Listing 17-5 and were able "
"to\n"
"support in Listing 17-9, so it‚Äôs a trade-off to consider."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:1
msgid "## Implementing an Object-Oriented Design Pattern"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:3
msgid ""
"The *state pattern* is an object-oriented design pattern. The crux of the\n"
"pattern is that we define a set of states a value can have internally. The\n"
"states are represented by a set of *state objects*, and the value‚Äôs "
"behavior\n"
"changes based on its state. We‚Äôre going to work through an example of a "
"blog\n"
"post struct that has a field to hold its state, which will be a state "
"object\n"
"from the set \"draft\", \"review\", or \"published\"."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:10
msgid ""
"The state objects share functionality: in Rust, of course, we use structs "
"and\n"
"traits rather than objects and inheritance. Each state object is "
"responsible\n"
"for its own behavior and for governing when it should change into another\n"
"state. The value that holds a state object knows nothing about the "
"different\n"
"behavior of the states or when to transition between states."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:16
msgid ""
"The advantage of using the state pattern is that, when the business\n"
"requirements of the program change, we won‚Äôt need to change the code of the\n"
"value holding the state or the code that uses the value. We‚Äôll only need to\n"
"update the code inside one of the state objects to change its rules or "
"perhaps\n"
"add more state objects."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:22
msgid ""
"First, we‚Äôre going to implement the state pattern in a more traditional\n"
"object-oriented way, then we‚Äôll use an approach that‚Äôs a bit more natural "
"in\n"
"Rust. Let‚Äôs dig in to incrementally implementing a blog post workflow using "
"the\n"
"state pattern."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:27
msgid "The final functionality will look like this:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:29
msgid ""
"1. A blog post starts as an empty draft.\n"
"2. When the draft is done, a review of the post is requested.\n"
"3. When the post is approved, it gets published.\n"
"4. Only published blog posts return content to print, so unapproved posts "
"can‚Äôt\n"
"   accidentally be published."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:35
msgid ""
"Any other changes attempted on a post should have no effect. For example, if "
"we\n"
"try to approve a draft blog post before we‚Äôve requested a review, the post\n"
"should remain an unpublished draft."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:39
msgid ""
"Listing 17-11 shows this workflow in code form: this is an example usage of "
"the\n"
"API we‚Äôll implement in a library crate named `blog`. This won‚Äôt compile yet\n"
"because we haven‚Äôt implemented the `blog` crate."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:45
msgid ""
"```rust,ignore,does_not_compile\n"
"use blog::Post;\n"
"\n"
"fn main() {\n"
"    let mut post = Post::new();\n"
"\n"
"    post.add_text(\"I ate a salad for lunch today\");\n"
"    assert_eq!(\"\", post.content());\n"
"\n"
"    post.request_review();\n"
"    assert_eq!(\"\", post.content());\n"
"\n"
"    post.approve();\n"
"    assert_eq!(\"I ate a salad for lunch today\", post.content());\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:62
msgid ""
"<span class=\"caption\">Listing 17-11: Code that demonstrates the desired\n"
"behavior we want our `blog` crate to have</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:65
msgid ""
"We want to allow the user to create a new draft blog post with `Post::new`. "
"We\n"
"want to allow text to be added to the blog post. If we try to get the "
"post‚Äôs\n"
"content immediately, before approval, we shouldn‚Äôt get any text because the\n"
"post is still a draft. We‚Äôve added `assert_eq!` in the code for "
"demonstration\n"
"purposes. An excellent unit test for this would be to assert that a draft "
"blog\n"
"post returns an empty string from the `content` method, but we‚Äôre not going "
"to\n"
"write tests for this example."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:73
msgid ""
"Next, we want to enable a request for a review of the post, and we want\n"
"`content` to return an empty string while waiting for the review. When the "
"post\n"
"receives approval, it should get published, meaning the text of the post "
"will\n"
"be returned when `content` is called."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:78
msgid ""
"Notice that the only type we‚Äôre interacting with from the crate is the "
"`Post`\n"
"type. This type will use the state pattern and will hold a value that will "
"be\n"
"one of three state objects representing the various states a post can be\n"
"in‚Äîdraft, waiting for review, or published. Changing from one state to "
"another\n"
"will be managed internally within the `Post` type. The states change in\n"
"response to the methods called by our library‚Äôs users on the `Post` "
"instance,\n"
"but they don‚Äôt have to manage the state changes directly. Also, users can‚Äôt\n"
"make a mistake with the states, like publishing a post before it‚Äôs reviewed."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:87
msgid "### Defining `Post` and Creating a New Instance in the Draft State"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:89
msgid ""
"Let‚Äôs get started on the implementation of the library! We know we need a\n"
"public `Post` struct that holds some content, so we‚Äôll start with the\n"
"definition of the struct and an associated public `new` function to create "
"an\n"
"instance of `Post`, as shown in Listing 17-12. We‚Äôll also make a private\n"
"`State` trait that will define the behavior that all state objects for a "
"`Post`\n"
"must have."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:96
msgid ""
"Then `Post` will hold a trait object of `Box<dyn State>` inside an "
"`Option<T>`\n"
"in a private field named `state` to hold the state object. You‚Äôll see why "
"the\n"
"`Option<T>` is necessary in a bit."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:102
msgid ""
"```rust,noplayground\n"
"pub struct Post {\n"
"    state: Option<Box<dyn State>>,\n"
"    content: String,\n"
"}\n"
"\n"
"impl Post {\n"
"    pub fn new() -> Post {\n"
"        Post {\n"
"            state: Some(Box::new(Draft {})),\n"
"            content: String::new(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"trait State {}\n"
"\n"
"struct Draft {}\n"
"\n"
"impl State for Draft {}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:124
msgid ""
"<span class=\"caption\">Listing 17-12: Definition of a `Post` struct and a "
"`new`\n"
"function that creates a new `Post` instance, a `State` trait, and a `Draft`\n"
"struct</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:128
msgid ""
"The `State` trait defines the behavior shared by different post states. The\n"
"state objects are `Draft`, `PendingReview`, and `Published`, and they will "
"all\n"
"implement the `State` trait. For now, the trait doesn‚Äôt have any methods, "
"and\n"
"we‚Äôll start by defining just the `Draft` state because that is the state we\n"
"want a post to start in."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:134
msgid ""
"When we create a new `Post`, we set its `state` field to a `Some` value "
"that\n"
"holds a `Box`. This `Box` points to a new instance of the `Draft` struct.\n"
"This ensures whenever we create a new instance of `Post`, it will start out "
"as\n"
"a draft. Because the `state` field of `Post` is private, there is no way to\n"
"create a `Post` in any other state! In the `Post::new` function, we set the\n"
"`content` field to a new, empty `String`."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:141
msgid "### Storing the Text of the Post Content"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:143
msgid ""
"We saw in Listing 17-11 that we want to be able to call a method named\n"
"`add_text` and pass it a `&str` that is then added as the text content of "
"the\n"
"blog post. We implement this as a method, rather than exposing the "
"`content`\n"
"field as `pub`, so that later we can implement a method that will control "
"how\n"
"the `content` field‚Äôs data is read. The `add_text` method is pretty\n"
"straightforward, so let‚Äôs add the implementation in Listing 17-13 to the "
"`impl\n"
"Post` block:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:153
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"impl Post {\n"
"    // --snip--\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"    pub fn add_text(&mut self, text: &str) {\n"
"        self.content.push_str(text);\n"
"    }\n"
"}\n"
"# \n"
"# trait State {}\n"
"# \n"
"# struct Draft {}\n"
"# \n"
"# impl State for Draft {}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:180
msgid ""
"<span class=\"caption\">Listing 17-13: Implementing the `add_text` method to "
"add\n"
"text to a post‚Äôs `content`</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:183
msgid ""
"The `add_text` method takes a mutable reference to `self`, because we‚Äôre\n"
"changing the `Post` instance that we‚Äôre calling `add_text` on. We then call\n"
"`push_str` on the `String` in `content` and pass the `text` argument to add "
"to\n"
"the saved `content`. This behavior doesn‚Äôt depend on the state the post is "
"in,\n"
"so it‚Äôs not part of the state pattern. The `add_text` method doesn‚Äôt "
"interact\n"
"with the `state` field at all, but it is part of the behavior we want to\n"
"support."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:191
msgid "### Ensuring the Content of a Draft Post Is Empty"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:193
msgid ""
"Even after we‚Äôve called `add_text` and added some content to our post, we "
"still\n"
"want the `content` method to return an empty string slice because the post "
"is\n"
"still in the draft state, as shown on line 7 of Listing 17-11. For now, "
"let‚Äôs\n"
"implement the `content` method with the simplest thing that will fulfill "
"this\n"
"requirement: always returning an empty string slice. We‚Äôll change this "
"later\n"
"once we implement the ability to change a post‚Äôs state so it can be "
"published.\n"
"So far, posts can only be in the draft state, so the post content should "
"always\n"
"be empty. Listing 17-14 shows this placeholder implementation:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:204
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"impl Post {\n"
"    // --snip--\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"    pub fn content(&self) -> &str {\n"
"        \"\"\n"
"    }\n"
"}\n"
"# \n"
"# trait State {}\n"
"# \n"
"# struct Draft {}\n"
"# \n"
"# impl State for Draft {}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:235
msgid ""
"<span class=\"caption\">Listing 17-14: Adding a placeholder implementation "
"for\n"
"the `content` method on `Post` that always returns an empty string slice</"
"span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:238
msgid ""
"With this added `content` method, everything in Listing 17-11 up to line 7\n"
"works as intended."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:241
msgid "### Requesting a Review of the Post Changes Its State"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:243
msgid ""
"Next, we need to add functionality to request a review of a post, which "
"should\n"
"change its state from `Draft` to `PendingReview`. Listing 17-15 shows this "
"code:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:248
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"impl Post {\n"
"    // --snip--\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"#     pub fn content(&self) -> &str {\n"
"#         \"\"\n"
"#     }\n"
"# \n"
"    pub fn request_review(&mut self) {\n"
"        if let Some(s) = self.state.take() {\n"
"            self.state = Some(s.request_review())\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"trait State {\n"
"    fn request_review(self: Box<Self>) -> Box<dyn State>;\n"
"}\n"
"\n"
"struct Draft {}\n"
"\n"
"impl State for Draft {\n"
"    fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"        Box::new(PendingReview {})\n"
"    }\n"
"}\n"
"\n"
"struct PendingReview {}\n"
"\n"
"impl State for PendingReview {\n"
"    fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"        self\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:299
msgid ""
"<span class=\"caption\">Listing 17-15: Implementing `request_review` methods "
"on\n"
"`Post` and the `State` trait</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:302
msgid ""
"We give `Post` a public method named `request_review` that will take a "
"mutable\n"
"reference to `self`. Then we call an internal `request_review` method on "
"the\n"
"current state of `Post`, and this second `request_review` method consumes "
"the\n"
"current state and returns a new state."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:307
msgid ""
"We add the `request_review` method to the `State` trait; all types that\n"
"implement the trait will now need to implement the `request_review` method.\n"
"Note that rather than having `self`, `&self`, or `&mut self` as the first\n"
"parameter of the method, we have `self: Box<Self>`. This syntax means the\n"
"method is only valid when called on a `Box` holding the type. This syntax "
"takes\n"
"ownership of `Box<Self>`, invalidating the old state so the state value of "
"the\n"
"`Post` can transform into a new state."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:315
msgid ""
"To consume the old state, the `request_review` method needs to take "
"ownership\n"
"of the state value. This is where the `Option` in the `state` field of "
"`Post`\n"
"comes in: we call the `take` method to take the `Some` value out of the "
"`state`\n"
"field and leave a `None` in its place, because Rust doesn‚Äôt let us have\n"
"unpopulated fields in structs. This lets us move the `state` value out of\n"
"`Post` rather than borrowing it. Then we‚Äôll set the post‚Äôs `state` value to "
"the\n"
"result of this operation."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:323
msgid ""
"We need to set `state` to `None` temporarily rather than setting it "
"directly\n"
"with code like `self.state = self.state.request_review();` to get ownership "
"of\n"
"the `state` value. This ensures `Post` can‚Äôt use the old `state` value "
"after\n"
"we‚Äôve transformed it into a new state."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:328
msgid ""
"The `request_review` method on `Draft` returns a new, boxed instance of a "
"new\n"
"`PendingReview` struct, which represents the state when a post is waiting "
"for a\n"
"review. The `PendingReview` struct also implements the `request_review` "
"method\n"
"but doesn‚Äôt do any transformations. Rather, it returns itself, because when "
"we\n"
"request a review on a post already in the `PendingReview` state, it should "
"stay\n"
"in the `PendingReview` state."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:335
msgid ""
"Now we can start seeing the advantages of the state pattern: the\n"
"`request_review` method on `Post` is the same no matter its `state` value. "
"Each\n"
"state is responsible for its own rules."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:339
msgid ""
"We‚Äôll leave the `content` method on `Post` as is, returning an empty string\n"
"slice. We can now have a `Post` in the `PendingReview` state as well as in "
"the\n"
"`Draft` state, but we want the same behavior in the `PendingReview` state.\n"
"Listing 17-11 now works up to line 10!"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:345
msgid ""
"<a id=\"adding-the-approve-method-that-changes-the-behavior-of-content\"></a>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:347
msgid "### Adding `approve` to Change the Behavior of `content`"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:349
msgid ""
"The `approve` method will be similar to the `request_review` method: it "
"will\n"
"set `state` to the value that the current state says it should have when "
"that\n"
"state is approved, as shown in Listing 17-16:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:355
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"impl Post {\n"
"    // --snip--\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"#     pub fn content(&self) -> &str {\n"
"#         \"\"\n"
"#     }\n"
"# \n"
"#     pub fn request_review(&mut self) {\n"
"#         if let Some(s) = self.state.take() {\n"
"#             self.state = Some(s.request_review())\n"
"#         }\n"
"#     }\n"
"# \n"
"    pub fn approve(&mut self) {\n"
"        if let Some(s) = self.state.take() {\n"
"            self.state = Some(s.approve())\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"trait State {\n"
"    fn request_review(self: Box<Self>) -> Box<dyn State>;\n"
"    fn approve(self: Box<Self>) -> Box<dyn State>;\n"
"}\n"
"\n"
"struct Draft {}\n"
"\n"
"impl State for Draft {\n"
"    // --snip--\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         Box::new(PendingReview {})\n"
"#     }\n"
"# \n"
"    fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"        self\n"
"    }\n"
"}\n"
"\n"
"struct PendingReview {}\n"
"\n"
"impl State for PendingReview {\n"
"    // --snip--\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"    fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"        Box::new(Published {})\n"
"    }\n"
"}\n"
"\n"
"struct Published {}\n"
"\n"
"impl State for Published {\n"
"    fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"        self\n"
"    }\n"
"\n"
"    fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"        self\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:435
msgid ""
"<span class=\"caption\">Listing 17-16: Implementing the `approve` method on\n"
"`Post` and the `State` trait</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:438
msgid ""
"We add the `approve` method to the `State` trait and add a new struct that\n"
"implements `State`, the `Published` state."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:441
msgid ""
"Similar to the way `request_review` on `PendingReview` works, if we call "
"the\n"
"`approve` method on a `Draft`, it will have no effect because `approve` "
"will\n"
"return `self`. When we call `approve` on `PendingReview`, it returns a new,\n"
"boxed instance of the `Published` struct. The `Published` struct implements "
"the\n"
"`State` trait, and for both the `request_review` method and the `approve`\n"
"method, it returns itself, because the post should stay in the `Published`\n"
"state in those cases."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:449
msgid ""
"Now we need to update the `content` method on `Post`. We want the value\n"
"returned from `content` to depend on the current state of the `Post`, so "
"we‚Äôre\n"
"going to have the `Post` delegate to a `content` method defined on its "
"`state`,\n"
"as shown in Listing 17-17:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:456
msgid ""
"```rust,ignore,does_not_compile\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"impl Post {\n"
"    // --snip--\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"    pub fn content(&self) -> &str {\n"
"        self.state.as_ref().unwrap().content(self)\n"
"    }\n"
"    // --snip--\n"
"# \n"
"#     pub fn request_review(&mut self) {\n"
"#         if let Some(s) = self.state.take() {\n"
"#             self.state = Some(s.request_review())\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn approve(&mut self) {\n"
"#         if let Some(s) = self.state.take() {\n"
"#             self.state = Some(s.approve())\n"
"#         }\n"
"#     }\n"
"}\n"
"# \n"
"# trait State {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State>;\n"
"#     fn approve(self: Box<Self>) -> Box<dyn State>;\n"
"# }\n"
"# \n"
"# struct Draft {}\n"
"# \n"
"# impl State for Draft {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         Box::new(PendingReview {})\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# }\n"
"# \n"
"# struct PendingReview {}\n"
"# \n"
"# impl State for PendingReview {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         Box::new(Published {})\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Published {}\n"
"# \n"
"# impl State for Published {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:535
msgid ""
"<span class=\"caption\">Listing 17-17: Updating the `content` method on "
"`Post` to\n"
"delegate to a `content` method on `State`</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:538
msgid ""
"Because the goal is to keep all these rules inside the structs that "
"implement\n"
"`State`, we call a `content` method on the value in `state` and pass the "
"post\n"
"instance (that is, `self`) as an argument. Then we return the value that‚Äôs\n"
"returned from using the `content` method on the `state` value."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:543
msgid ""
"We call the `as_ref` method on the `Option` because we want a reference to "
"the\n"
"value inside the `Option` rather than ownership of the value. Because "
"`state`\n"
"is an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn\n"
"State>>` is returned. If we didn‚Äôt call `as_ref`, we would get an error "
"because\n"
"we can‚Äôt move `state` out of the borrowed `&self` of the function parameter."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:549
msgid ""
"We then call the `unwrap` method, which we know will never panic, because "
"we\n"
"know the methods on `Post` ensure that `state` will always contain a `Some`\n"
"value when those methods are done. This is one of the cases we talked about "
"in\n"
"the [‚ÄúCases In Which You Have More Information Than the\n"
"Compiler‚Äù][more-info-than-rustc]<!-- ignore --> section of Chapter 9 when "
"we\n"
"know that a `None` value is never possible, even though the compiler isn‚Äôt "
"able\n"
"to understand that."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:557
msgid ""
"At this point, when we call `content` on the `&Box<dyn State>`, deref "
"coercion\n"
"will take effect on the `&` and the `Box` so the `content` method will\n"
"ultimately be called on the type that implements the `State` trait. That "
"means\n"
"we need to add `content` to the `State` trait definition, and that is where\n"
"we‚Äôll put the logic for what content to return depending on which state we\n"
"have, as shown in Listing 17-18:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:566
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     state: Option<Box<dyn State>>,\n"
"#     content: String,\n"
"# }\n"
"# \n"
"# impl Post {\n"
"#     pub fn new() -> Post {\n"
"#         Post {\n"
"#             state: Some(Box::new(Draft {})),\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"#     pub fn content(&self) -> &str {\n"
"#         self.state.as_ref().unwrap().content(self)\n"
"#     }\n"
"# \n"
"#     pub fn request_review(&mut self) {\n"
"#         if let Some(s) = self.state.take() {\n"
"#             self.state = Some(s.request_review())\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn approve(&mut self) {\n"
"#         if let Some(s) = self.state.take() {\n"
"#             self.state = Some(s.approve())\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"trait State {\n"
"    // --snip--\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State>;\n"
"#     fn approve(self: Box<Self>) -> Box<dyn State>;\n"
"# \n"
"    fn content<'a>(&self, post: &'a Post) -> &'a str {\n"
"        \"\"\n"
"    }\n"
"}\n"
"\n"
"// --snip--\n"
"# \n"
"# struct Draft {}\n"
"# \n"
"# impl State for Draft {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         Box::new(PendingReview {})\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# }\n"
"# \n"
"# struct PendingReview {}\n"
"# \n"
"# impl State for PendingReview {\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         Box::new(Published {})\n"
"#     }\n"
"# }\n"
"# \n"
"struct Published {}\n"
"\n"
"impl State for Published {\n"
"    // --snip--\n"
"#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"#     fn approve(self: Box<Self>) -> Box<dyn State> {\n"
"#         self\n"
"#     }\n"
"# \n"
"    fn content<'a>(&self, post: &'a Post) -> &'a str {\n"
"        &post.content\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:655
msgid ""
"<span class=\"caption\">Listing 17-18: Adding the `content` method to the "
"`State`\n"
"trait</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:658
msgid ""
"We add a default implementation for the `content` method that returns an "
"empty\n"
"string slice. That means we don‚Äôt need to implement `content` on the "
"`Draft`\n"
"and `PendingReview` structs. The `Published` struct will override the "
"`content`\n"
"method and return the value in `post.content`."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:663
msgid ""
"Note that we need lifetime annotations on this method, as we discussed in\n"
"Chapter 10. We‚Äôre taking a reference to a `post` as an argument and "
"returning a\n"
"reference to part of that `post`, so the lifetime of the returned reference "
"is\n"
"related to the lifetime of the `post` argument."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:668
msgid ""
"And we‚Äôre done‚Äîall of Listing 17-11 now works! We‚Äôve implemented the state\n"
"pattern with the rules of the blog post workflow. The logic related to the\n"
"rules lives in the state objects rather than being scattered throughout "
"`Post`."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:672
msgid ""
"> #### Why Not An Enum?\n"
">\n"
"> You may have been wondering why we didn‚Äôt use an `enum` with the "
"different\n"
"> possible post states as variants. That‚Äôs certainly a possible solution, "
"try\n"
"> it and compare the end results to see which you prefer! One disadvantage "
"of\n"
"> using an enum is every place that checks the value of the enum will need "
"a\n"
"> `match` expression or similar to handle every possible variant. This "
"could\n"
"> get more repetitive than this trait object solution."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:681
msgid "### Trade-offs of the State Pattern"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:683
msgid ""
"We‚Äôve shown that Rust is capable of implementing the object-oriented state\n"
"pattern to encapsulate the different kinds of behavior a post should have "
"in\n"
"each state. The methods on `Post` know nothing about the various behaviors. "
"The\n"
"way we organized the code, we have to look in only one place to know the\n"
"different ways a published post can behave: the implementation of the "
"`State`\n"
"trait on the `Published` struct."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:690
msgid ""
"If we were to create an alternative implementation that didn‚Äôt use the "
"state\n"
"pattern, we might instead use `match` expressions in the methods on `Post` "
"or\n"
"even in the `main` code that checks the state of the post and changes "
"behavior\n"
"in those places. That would mean we would have to look in several places to\n"
"understand all the implications of a post being in the published state! "
"This\n"
"would only increase the more states we added: each of those `match` "
"expressions\n"
"would need another arm."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:698
msgid ""
"With the state pattern, the `Post` methods and the places we use `Post` "
"don‚Äôt\n"
"need `match` expressions, and to add a new state, we would only need to add "
"a\n"
"new struct and implement the trait methods on that one struct."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:702
msgid ""
"The implementation using the state pattern is easy to extend to add more\n"
"functionality. To see the simplicity of maintaining code that uses the "
"state\n"
"pattern, try a few of these suggestions:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:706
msgid ""
"* Add a `reject` method that changes the post‚Äôs state from `PendingReview` "
"back\n"
"  to `Draft`.\n"
"* Require two calls to `approve` before the state can be changed to "
"`Published`.\n"
"* Allow users to add text content only when a post is in the `Draft` state.\n"
"  Hint: have the state object responsible for what might change about the\n"
"  content but not responsible for modifying the `Post`."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:713
msgid ""
"One downside of the state pattern is that, because the states implement the\n"
"transitions between states, some of the states are coupled to each other. If "
"we\n"
"add another state between `PendingReview` and `Published`, such as "
"`Scheduled`,\n"
"we would have to change the code in `PendingReview` to transition to\n"
"`Scheduled` instead. It would be less work if `PendingReview` didn‚Äôt need "
"to\n"
"change with the addition of a new state, but that would mean switching to\n"
"another design pattern."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:721
msgid ""
"Another downside is that we‚Äôve duplicated some logic. To eliminate some of "
"the\n"
"duplication, we might try to make default implementations for the\n"
"`request_review` and `approve` methods on the `State` trait that return "
"`self`;\n"
"however, this would violate object safety, because the trait doesn‚Äôt know "
"what\n"
"the concrete `self` will be exactly. We want to be able to use `State` as a\n"
"trait object, so we need its methods to be object safe."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:728
msgid ""
"Other duplication includes the similar implementations of the "
"`request_review`\n"
"and `approve` methods on `Post`. Both methods delegate to the implementation "
"of\n"
"the same method on the value in the `state` field of `Option` and set the "
"new\n"
"value of the `state` field to the result. If we had a lot of methods on "
"`Post`\n"
"that followed this pattern, we might consider defining a macro to eliminate "
"the\n"
"repetition (see the [‚ÄúMacros‚Äù][macros]<!-- ignore --> section in Chapter 19)."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:735
msgid ""
"By implementing the state pattern exactly as it‚Äôs defined for object-"
"oriented\n"
"languages, we‚Äôre not taking as full advantage of Rust‚Äôs strengths as we "
"could.\n"
"Let‚Äôs look at some changes we can make to the `blog` crate that can make\n"
"invalid states and transitions into compile time errors."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:740
msgid "#### Encoding States and Behavior as Types"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:742
msgid ""
"We‚Äôll show you how to rethink the state pattern to get a different set of\n"
"trade-offs. Rather than encapsulating the states and transitions completely "
"so\n"
"outside code has no knowledge of them, we‚Äôll encode the states into "
"different\n"
"types. Consequently, Rust‚Äôs type checking system will prevent attempts to "
"use\n"
"draft posts where only published posts are allowed by issuing a compiler "
"error."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:748
msgid "Let‚Äôs consider the first part of `main` in Listing 17-11:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:752
msgid ""
"```rust,ignore\n"
"# use blog::Post;\n"
"# \n"
"fn main() {\n"
"    let mut post = Post::new();\n"
"\n"
"    post.add_text(\"I ate a salad for lunch today\");\n"
"    assert_eq!(\"\", post.content());\n"
"# \n"
"#     post.request_review();\n"
"#     assert_eq!(\"\", post.content());\n"
"# \n"
"#     post.approve();\n"
"#     assert_eq!(\"I ate a salad for lunch today\", post.content());\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:769
msgid ""
"We still enable the creation of new posts in the draft state using `Post::"
"new`\n"
"and the ability to add text to the post‚Äôs content. But instead of having a\n"
"`content` method on a draft post that returns an empty string, we‚Äôll make it "
"so\n"
"draft posts don‚Äôt have the `content` method at all. That way, if we try to "
"get\n"
"a draft post‚Äôs content, we‚Äôll get a compiler error telling us the method\n"
"doesn‚Äôt exist. As a result, it will be impossible for us to accidentally\n"
"display draft post content in production, because that code won‚Äôt even "
"compile.\n"
"Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` "
"struct,\n"
"as well as methods on each:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:781
msgid ""
"```rust,noplayground\n"
"pub struct Post {\n"
"    content: String,\n"
"}\n"
"\n"
"pub struct DraftPost {\n"
"    content: String,\n"
"}\n"
"\n"
"impl Post {\n"
"    pub fn new() -> DraftPost {\n"
"        DraftPost {\n"
"            content: String::new(),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn content(&self) -> &str {\n"
"        &self.content\n"
"    }\n"
"}\n"
"\n"
"impl DraftPost {\n"
"    pub fn add_text(&mut self, text: &str) {\n"
"        self.content.push_str(text);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:809
msgid ""
"<span class=\"caption\">Listing 17-19: A `Post` with a `content` method and "
"a\n"
"`DraftPost` without a `content` method</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:812
msgid ""
"Both the `Post` and `DraftPost` structs have a private `content` field that\n"
"stores the blog post text. The structs no longer have the `state` field "
"because\n"
"we‚Äôre moving the encoding of the state to the types of the structs. The "
"`Post`\n"
"struct will represent a published post, and it has a `content` method that\n"
"returns the `content`."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:818
msgid ""
"We still have a `Post::new` function, but instead of returning an instance "
"of\n"
"`Post`, it returns an instance of `DraftPost`. Because `content` is private\n"
"and there aren‚Äôt any functions that return `Post`, it‚Äôs not possible to "
"create\n"
"an instance of `Post` right now."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:823
msgid ""
"The `DraftPost` struct has an `add_text` method, so we can add text to\n"
"`content` as before, but note that `DraftPost` does not have a `content` "
"method\n"
"defined! So now the program ensures all posts start as draft posts, and "
"draft\n"
"posts don‚Äôt have their content available for display. Any attempt to get "
"around\n"
"these constraints will result in a compiler error."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:829
msgid "#### Implementing Transitions as Transformations into Different Types"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:831
msgid ""
"So how do we get a published post? We want to enforce the rule that a draft\n"
"post has to be reviewed and approved before it can be published. A post in "
"the\n"
"pending review state should still not display any content. Let‚Äôs implement\n"
"these constraints by adding another struct, `PendingReviewPost`, defining "
"the\n"
"`request_review` method on `DraftPost` to return a `PendingReviewPost`, and\n"
"defining an `approve` method on `PendingReviewPost` to return a `Post`, as\n"
"shown in Listing 17-20:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:841
msgid ""
"```rust,noplayground\n"
"# pub struct Post {\n"
"#     content: String,\n"
"# }\n"
"# \n"
"# pub struct DraftPost {\n"
"#     content: String,\n"
"# }\n"
"# \n"
"# impl Post {\n"
"#     pub fn new() -> DraftPost {\n"
"#         DraftPost {\n"
"#             content: String::new(),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn content(&self) -> &str {\n"
"#         &self.content\n"
"#     }\n"
"# }\n"
"# \n"
"impl DraftPost {\n"
"    // --snip--\n"
"#     pub fn add_text(&mut self, text: &str) {\n"
"#         self.content.push_str(text);\n"
"#     }\n"
"# \n"
"    pub fn request_review(self) -> PendingReviewPost {\n"
"        PendingReviewPost {\n"
"            content: self.content,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct PendingReviewPost {\n"
"    content: String,\n"
"}\n"
"\n"
"impl PendingReviewPost {\n"
"    pub fn approve(self) -> Post {\n"
"        Post {\n"
"            content: self.content,\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:888
msgid ""
"<span class=\"caption\">Listing 17-20: A `PendingReviewPost` that gets "
"created by\n"
"calling `request_review` on `DraftPost` and an `approve` method that turns "
"a\n"
"`PendingReviewPost` into a published `Post`</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:892
msgid ""
"The `request_review` and `approve` methods take ownership of `self`, thus\n"
"consuming the `DraftPost` and `PendingReviewPost` instances and "
"transforming\n"
"them into a `PendingReviewPost` and a published `Post`, respectively. This "
"way,\n"
"we won‚Äôt have any lingering `DraftPost` instances after we‚Äôve called\n"
"`request_review` on them, and so forth. The `PendingReviewPost` struct "
"doesn‚Äôt\n"
"have a `content` method defined on it, so attempting to read its content\n"
"results in a compiler error, as with `DraftPost`. Because the only way to "
"get a\n"
"published `Post` instance that does have a `content` method defined is to "
"call\n"
"the `approve` method on a `PendingReviewPost`, and the only way to get a\n"
"`PendingReviewPost` is to call the `request_review` method on a "
"`DraftPost`,\n"
"we‚Äôve now encoded the blog post workflow into the type system."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:904
msgid ""
"But we also have to make some small changes to `main`. The `request_review` "
"and\n"
"`approve` methods return new instances rather than modifying the struct "
"they‚Äôre\n"
"called on, so we need to add more `let post =` shadowing assignments to "
"save\n"
"the returned instances. We also can‚Äôt have the assertions about the draft "
"and\n"
"pending review posts‚Äô contents be empty strings, nor do we need them: we "
"can‚Äôt\n"
"compile code that tries to use the content of posts in those states any "
"longer.\n"
"The updated code in `main` is shown in Listing 17-21:"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:914
msgid ""
"```rust,ignore\n"
"use blog::Post;\n"
"\n"
"fn main() {\n"
"    let mut post = Post::new();\n"
"\n"
"    post.add_text(\"I ate a salad for lunch today\");\n"
"\n"
"    let post = post.request_review();\n"
"\n"
"    let post = post.approve();\n"
"\n"
"    assert_eq!(\"I ate a salad for lunch today\", post.content());\n"
"}\n"
"```"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:930
msgid ""
"<span class=\"caption\">Listing 17-21: Modifications to `main` to use the "
"new\n"
"implementation of the blog post workflow</span>"
msgstr ""

#: src/ch17-03-oo-design-patterns.md:933
msgid ""
"The changes we needed to make to `main` to reassign `post` mean that this\n"
"implementation doesn‚Äôt quite follow the object-oriented state pattern "
"anymore:\n"
"the transformations between the states are no longer encapsulated entirely\n"
"within the `Post` implementation. However, our gain is that invalid states "
"are\n"
"now impossible because of the type system and the type checking that happens "
"at\n"
"compile time! This ensures that certain bugs, such as display of the content "
"of\n"
"an unpublished post, will be discovered before they make it to production."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:941
msgid ""
"Try the tasks suggested at the start of this section on the `blog` crate as "
"it\n"
"is after Listing 17-21 to see what you think about the design of this "
"version\n"
"of the code. Note that some of the tasks might be completed already in this\n"
"design."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:946
msgid ""
"We‚Äôve seen that even though Rust is capable of implementing object-oriented\n"
"design patterns, other patterns, such as encoding state into the type "
"system,\n"
"are also available in Rust. These patterns have different trade-offs. "
"Although\n"
"you might be very familiar with object-oriented patterns, rethinking the\n"
"problem to take advantage of Rust‚Äôs features can provide benefits, such as\n"
"preventing some bugs at compile time. Object-oriented patterns won‚Äôt always "
"be\n"
"the best solution in Rust due to certain features, like ownership, that\n"
"object-oriented languages don‚Äôt have."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:957
msgid ""
"No matter whether or not you think Rust is an object-oriented language "
"after\n"
"reading this chapter, you now know that you can use trait objects to get "
"some\n"
"object-oriented features in Rust. Dynamic dispatch can give your code some\n"
"flexibility in exchange for a bit of runtime performance. You can use this\n"
"flexibility to implement object-oriented patterns that can help your code‚Äôs\n"
"maintainability. Rust also has other features, like ownership, that\n"
"object-oriented languages don‚Äôt have. An object-oriented pattern won‚Äôt "
"always\n"
"be the best way to take advantage of Rust‚Äôs strengths, but is an available\n"
"option."
msgstr ""

#: src/ch17-03-oo-design-patterns.md:967
msgid ""
"Next, we‚Äôll look at patterns, which are another of Rust‚Äôs features that "
"enable\n"
"lots of flexibility. We‚Äôve looked at them briefly throughout the book but\n"
"haven‚Äôt seen their full capability yet. Let‚Äôs go!"
msgstr ""

#: src/ch18-00-patterns.md:1
msgid "# Patterns and Matching"
msgstr ""

#: src/ch18-00-patterns.md:3
msgid ""
"*Patterns* are a special syntax in Rust for matching against the structure "
"of\n"
"types, both complex and simple. Using patterns in conjunction with `match`\n"
"expressions and other constructs gives you more control over a program‚Äôs\n"
"control flow. A pattern consists of some combination of the following:"
msgstr ""

#: src/ch18-00-patterns.md:8
msgid ""
"* Literals\n"
"* Destructured arrays, enums, structs, or tuples\n"
"* Variables\n"
"* Wildcards\n"
"* Placeholders"
msgstr ""

#: src/ch18-00-patterns.md:14
msgid ""
"Some example patterns include `x`, `(a, 3)`, and `Some(Color::Red)`. In the\n"
"contexts in which patterns are valid, these components describe the shape "
"of\n"
"data. Our program then matches values against the patterns to determine "
"whether\n"
"it has the correct shape of data to continue running a particular piece of "
"code."
msgstr ""

#: src/ch18-00-patterns.md:19
msgid ""
"To use a pattern, we compare it to some value. If the pattern matches the\n"
"value, we use the value parts in our code. Recall the `match` expressions "
"in\n"
"Chapter 6 that used patterns, such as the coin-sorting machine example. If "
"the\n"
"value fits the shape of the pattern, we can use the named pieces. If it\n"
"doesn‚Äôt, the code associated with the pattern won‚Äôt run."
msgstr ""

#: src/ch18-00-patterns.md:25
msgid ""
"This chapter is a reference on all things related to patterns. We‚Äôll cover "
"the\n"
"valid places to use patterns, the difference between refutable and "
"irrefutable\n"
"patterns, and the different kinds of pattern syntax that you might see. By "
"the\n"
"end of the chapter, you‚Äôll know how to use patterns to express many concepts "
"in\n"
"a clear way."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:1
msgid "## All the Places Patterns Can Be Used"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:3
msgid ""
"Patterns pop up in a number of places in Rust, and you‚Äôve been using them a "
"lot\n"
"without realizing it! This section discusses all the places where patterns "
"are\n"
"valid."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:7
msgid "### `match` Arms"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:9
msgid ""
"As discussed in Chapter 6, we use patterns in the arms of `match` "
"expressions.\n"
"Formally, `match` expressions are defined as the keyword `match`, a value "
"to\n"
"match on, and one or more match arms that consist of a pattern and an\n"
"expression to run if the value matches that arm‚Äôs pattern, like this:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:14
msgid ""
"```text\n"
"match VALUE {\n"
"    PATTERN => EXPRESSION,\n"
"    PATTERN => EXPRESSION,\n"
"    PATTERN => EXPRESSION,\n"
"}\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:22
msgid ""
"For example, here's the `match` expression from Listing 6-5 that matches on "
"an\n"
"`Option<i32>` value in the variable `x`:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:25
msgid ""
"```rust,ignore\n"
"match x {\n"
"    None => None,\n"
"    Some(i) => Some(i + 1),\n"
"}\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:32
msgid ""
"The patterns in this `match` expression are the `None` and `Some(i)` on the\n"
"left of each arrow."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:35
msgid ""
"One requirement for `match` expressions is that they need to be *exhaustive* "
"in\n"
"the sense that all possibilities for the value in the `match` expression "
"must\n"
"be accounted for. One way to ensure you‚Äôve covered every possibility is to "
"have\n"
"a catchall pattern for the last arm: for example, a variable name matching "
"any\n"
"value can never fail and thus covers every remaining case."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:41
msgid ""
"The particular pattern `_` will match anything, but it never binds to a\n"
"variable, so it‚Äôs often used in the last match arm. The `_` pattern can be\n"
"useful when you want to ignore any value not specified, for example. We‚Äôll\n"
"cover the `_` pattern in more detail in the [‚ÄúIgnoring Values in a\n"
"Pattern‚Äù][ignoring-values-in-a-pattern]<!-- ignore --> section later in "
"this\n"
"chapter."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:48
msgid "### Conditional `if let` Expressions"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:50
msgid ""
"In Chapter 6 we discussed how to use `if let` expressions mainly as a "
"shorter\n"
"way to write the equivalent of a `match` that only matches one case.\n"
"Optionally, `if let` can have a corresponding `else` containing code to run "
"if\n"
"the pattern in the `if let` doesn‚Äôt match."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:55
msgid ""
"Listing 18-1 shows that it‚Äôs also possible to mix and match `if let`, `else\n"
"if`, and `else if let` expressions. Doing so gives us more flexibility than "
"a\n"
"`match` expression in which we can express only one value to compare with "
"the\n"
"patterns. Also, Rust doesn't require that the conditions in a series of `if\n"
"let`, `else if`, `else if let` arms relate to each other."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:61
msgid ""
"The code in Listing 18-1 determines what color to make your background based "
"on\n"
"a series of checks for several conditions. For this example, we‚Äôve created\n"
"variables with hardcoded values that a real program might receive from user\n"
"input."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:68
msgid ""
"```rust\n"
"fn main() {\n"
"    let favorite_color: Option<&str> = None;\n"
"    let is_tuesday = false;\n"
"    let age: Result<u8, _> = \"34\".parse();\n"
"\n"
"    if let Some(color) = favorite_color {\n"
"        println!(\"Using your favorite color, {color}, as the "
"background\");\n"
"    } else if is_tuesday {\n"
"        println!(\"Tuesday is green day!\");\n"
"    } else if let Ok(age) = age {\n"
"        if age > 30 {\n"
"            println!(\"Using purple as the background color\");\n"
"        } else {\n"
"            println!(\"Using orange as the background color\");\n"
"        }\n"
"    } else {\n"
"        println!(\"Using blue as the background color\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:90
msgid ""
"<span class=\"caption\">Listing 18-1: Mixing `if let`, `else if`, `else if "
"let`,\n"
"and `else`</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:93
msgid ""
"If the user specifies a favorite color, that color is used as the "
"background.\n"
"If no favorite color is specified and today is Tuesday, the background color "
"is\n"
"green. Otherwise, if the user specifies their age as a string and we can "
"parse\n"
"it as a number successfully, the color is either purple or orange depending "
"on\n"
"the value of the number. If none of these conditions apply, the background\n"
"color is blue."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:100
msgid ""
"This conditional structure lets us support complex requirements. With the\n"
"hardcoded values we have here, this example will print `Using purple as the\n"
"background color`."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:104
msgid ""
"You can see that `if let` can also introduce shadowed variables in the same "
"way\n"
"that `match` arms can: the line `if let Ok(age) = age` introduces a new\n"
"shadowed `age` variable that contains the value inside the `Ok` variant. "
"This\n"
"means we need to place the `if age > 30` condition within that block: we "
"can‚Äôt\n"
"combine these two conditions into `if let Ok(age) = age && age > 30`. The\n"
"shadowed `age` we want to compare to 30 isn‚Äôt valid until the new scope "
"starts\n"
"with the curly bracket."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:112
msgid ""
"The downside of using `if let` expressions is that the compiler doesn‚Äôt "
"check\n"
"for exhaustiveness, whereas with `match` expressions it does. If we omitted "
"the\n"
"last `else` block and therefore missed handling some cases, the compiler "
"would\n"
"not alert us to the possible logic bug."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:117
msgid "### `while let` Conditional Loops"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:119
msgid ""
"Similar in construction to `if let`, the `while let` conditional loop allows "
"a\n"
"`while` loop to run for as long as a pattern continues to match. In Listing\n"
"18-2 we code a `while let` loop that uses a vector as a stack and prints "
"the\n"
"values in the vector in the opposite order in which they were pushed."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:124
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut stack = Vec::new();\n"
"\n"
"    stack.push(1);\n"
"    stack.push(2);\n"
"    stack.push(3);\n"
"\n"
"    while let Some(top) = stack.pop() {\n"
"        println!(\"{}\", top);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:138
msgid ""
"<span class=\"caption\">Listing 18-2: Using a `while let` loop to print "
"values\n"
"for as long as `stack.pop()` returns `Some`</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:141
msgid ""
"This example prints 3, 2, and then 1. The `pop` method takes the last "
"element\n"
"out of the vector and returns `Some(value)`. If the vector is empty, `pop`\n"
"returns `None`. The `while` loop continues running the code in its block as\n"
"long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We "
"can\n"
"use `while let` to pop every element off our stack."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:147
msgid "### `for` Loops"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:149
msgid ""
"In a `for` loop, the value that directly follows the keyword `for` is a\n"
"pattern. For example, in `for x in y` the `x` is the pattern. Listing 18-3\n"
"demonstrates how to use a pattern in a `for` loop to destructure, or break\n"
"apart, a tuple as part of the `for` loop."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:154
msgid ""
"```rust\n"
"# fn main() {\n"
"    let v = vec!['a', 'b', 'c'];\n"
"\n"
"    for (index, value) in v.iter().enumerate() {\n"
"        println!(\"{} is at index {}\", value, index);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:164
msgid ""
"<span class=\"caption\">Listing 18-3: Using a pattern in a `for` loop to\n"
"destructure a tuple</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:167
msgid "The code in Listing 18-3 will print the following:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:169
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.52s\n"
"     Running `target/debug/patterns`\n"
"a is at index 0\n"
"b is at index 1\n"
"c is at index 2\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:179
msgid ""
"We adapt an iterator using the `enumerate` method so it produces a value "
"and\n"
"the index for that value, placed into a tuple. The first value produced is "
"the\n"
"tuple `(0, 'a')`. When this value is matched to the pattern `(index, "
"value)`,\n"
"`index` will be `0` and `value` will be `'a'`, printing the first line of "
"the\n"
"output."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:185
msgid "### `let` Statements"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:187
msgid ""
"Prior to this chapter, we had only explicitly discussed using patterns with\n"
"`match` and `if let`, but in fact, we‚Äôve used patterns in other places as "
"well,\n"
"including in `let` statements. For example, consider this straightforward\n"
"variable assignment with `let`:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:196
msgid ""
"Every time you've used a `let` statement like this you've been using "
"patterns,\n"
"although you might not have realized it! More formally, a `let` statement "
"looks\n"
"like this:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:200
msgid ""
"```text\n"
"let PATTERN = EXPRESSION;\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:204
msgid ""
"In statements like `let x = 5;` with a variable name in the `PATTERN` slot, "
"the\n"
"variable name is just a particularly simple form of a pattern. Rust "
"compares\n"
"the expression against the pattern and assigns any names it finds. So in "
"the\n"
"`let x = 5;` example, `x` is a pattern that means ‚Äúbind what matches here "
"to\n"
"the variable `x`.‚Äù Because the name `x` is the whole pattern, this pattern\n"
"effectively means ‚Äúbind everything to the variable `x`, whatever the value "
"is.‚Äù"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:211
msgid ""
"To see the pattern matching aspect of `let` more clearly, consider Listing\n"
"18-4, which uses a pattern with `let` to destructure a tuple."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:214
msgid ""
"```rust\n"
"# fn main() {\n"
"    let (x, y, z) = (1, 2, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:220
msgid ""
"<span class=\"caption\">Listing 18-4: Using a pattern to destructure a tuple "
"and\n"
"create three variables at once</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:223
msgid ""
"Here, we match a tuple against a pattern. Rust compares the value `(1, 2, "
"3)`\n"
"to the pattern `(x, y, z)` and sees that the value matches the pattern, so "
"Rust\n"
"binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple\n"
"pattern as nesting three individual variable patterns inside it."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:228
msgid ""
"If the number of elements in the pattern doesn‚Äôt match the number of "
"elements\n"
"in the tuple, the overall type won‚Äôt match and we‚Äôll get a compiler error. "
"For\n"
"example, Listing 18-5 shows an attempt to destructure a tuple with three\n"
"elements into two variables, which won‚Äôt work."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:233
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let (x, y) = (1, 2, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:239
msgid ""
"<span class=\"caption\">Listing 18-5: Incorrectly constructing a pattern "
"whose\n"
"variables don‚Äôt match the number of elements in the tuple</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:242
msgid "Attempting to compile this code results in this type error:"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:244
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:2:9\n"
"  |\n"
"2 |     let (x, y) = (1, 2, 3);\n"
"  |         ^^^^^^   --------- this expression has type `({integer}, "
"{integer}, {integer})`\n"
"  |         |\n"
"  |         expected a tuple with 3 elements, found one with 2 elements\n"
"  |\n"
"  = note: expected tuple `({integer}, {integer}, {integer})`\n"
"             found tuple `(_, _)`\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `patterns` due to previous error\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:262
msgid ""
"To fix the error, we could ignore one or more of the values in the tuple "
"using\n"
"`_` or `..`, as you‚Äôll see in the [‚ÄúIgnoring Values in a\n"
"Pattern‚Äù][ignoring-values-in-a-pattern]<!-- ignore --> section. If the "
"problem\n"
"is that we have too many variables in the pattern, the solution is to make "
"the\n"
"types match by removing variables so the number of variables equals the "
"number\n"
"of elements in the tuple."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:269
msgid "### Function Parameters"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:271
msgid ""
"Function parameters can also be patterns. The code in Listing 18-6, which\n"
"declares a function named `foo` that takes one parameter named `x` of type\n"
"`i32`, should by now look familiar."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:275
msgid ""
"```rust\n"
"fn foo(x: i32) {\n"
"    // code goes here\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:283
msgid ""
"<span class=\"caption\">Listing 18-6: A function signature uses patterns in "
"the\n"
"parameters</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:286
msgid ""
"The `x` part is a pattern! As we did with `let`, we could match a tuple in "
"a\n"
"function‚Äôs arguments to the pattern. Listing 18-7 splits the values in a "
"tuple\n"
"as we pass it to a function."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:292
msgid ""
"```rust\n"
"fn print_coordinates(&(x, y): &(i32, i32)) {\n"
"    println!(\"Current location: ({}, {})\", x, y);\n"
"}\n"
"\n"
"fn main() {\n"
"    let point = (3, 5);\n"
"    print_coordinates(&point);\n"
"}\n"
"```"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:303
msgid ""
"<span class=\"caption\">Listing 18-7: A function with parameters that "
"destructure\n"
"a tuple</span>"
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:306
msgid ""
"This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the\n"
"pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:309
msgid ""
"We can also use patterns in closure parameter lists in the same way as in\n"
"function parameter lists, because closures are similar to functions, as\n"
"discussed in Chapter 13."
msgstr ""

#: src/ch18-01-all-the-places-for-patterns.md:313
msgid ""
"At this point, you‚Äôve seen several ways of using patterns, but patterns "
"don‚Äôt\n"
"work the same in every place we can use them. In some places, the patterns "
"must\n"
"be irrefutable; in other circumstances, they can be refutable. We‚Äôll "
"discuss\n"
"these two concepts next."
msgstr ""

#: src/ch18-02-refutability.md:1
msgid "## Refutability: Whether a Pattern Might Fail to Match"
msgstr ""

#: src/ch18-02-refutability.md:3
msgid ""
"Patterns come in two forms: refutable and irrefutable. Patterns that will "
"match\n"
"for any possible value passed are *irrefutable*. An example would be `x` in "
"the\n"
"statement `let x = 5;` because `x` matches anything and therefore cannot "
"fail\n"
"to match. Patterns that can fail to match for some possible value are\n"
"*refutable*. An example would be `Some(x)` in the expression `if let Some(x) "
"=\n"
"a_value` because if the value in the `a_value` variable is `None` rather "
"than\n"
"`Some`, the `Some(x)` pattern will not match."
msgstr ""

#: src/ch18-02-refutability.md:11
msgid ""
"Function parameters, `let` statements, and `for` loops can only accept\n"
"irrefutable patterns, because the program cannot do anything meaningful "
"when\n"
"values don‚Äôt match. The `if let` and `while let` expressions accept\n"
"refutable and irrefutable patterns, but the compiler warns against\n"
"irrefutable patterns because by definition they‚Äôre intended to handle "
"possible\n"
"failure: the functionality of a conditional is in its ability to perform\n"
"differently depending on success or failure."
msgstr ""

#: src/ch18-02-refutability.md:19
msgid ""
"In general, you shouldn‚Äôt have to worry about the distinction between "
"refutable\n"
"and irrefutable patterns; however, you do need to be familiar with the "
"concept\n"
"of refutability so you can respond when you see it in an error message. In\n"
"those cases, you‚Äôll need to change either the pattern or the construct "
"you‚Äôre\n"
"using the pattern with, depending on the intended behavior of the code."
msgstr ""

#: src/ch18-02-refutability.md:25
msgid ""
"Let‚Äôs look at an example of what happens when we try to use a refutable "
"pattern\n"
"where Rust requires an irrefutable pattern and vice versa. Listing 18-8 "
"shows a\n"
"`let` statement, but for the pattern we‚Äôve specified `Some(x)`, a refutable\n"
"pattern. As you might expect, this code will not compile."
msgstr ""

#: src/ch18-02-refutability.md:30
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"#     let some_option_value: Option<i32> = None;\n"
"    let Some(x) = some_option_value;\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-02-refutability.md:37
msgid ""
"<span class=\"caption\">Listing 18-8: Attempting to use a refutable pattern "
"with\n"
"`let`</span>"
msgstr ""

#: src/ch18-02-refutability.md:40
msgid ""
"If `some_option_value` was a `None` value, it would fail to match the "
"pattern\n"
"`Some(x)`, meaning the pattern is refutable. However, the `let` statement "
"can\n"
"only accept an irrefutable pattern because there is nothing valid the code "
"can\n"
"do with a `None` value. At compile time, Rust will complain that we‚Äôve tried "
"to\n"
"use a refutable pattern where an irrefutable pattern is required:"
msgstr ""

#: src/ch18-02-refutability.md:46
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error[E0005]: refutable pattern in local binding: `None` not covered\n"
" --> src/main.rs:3:9\n"
"  |\n"
"3 |     let Some(x) = some_option_value;\n"
"  |         ^^^^^^^ pattern `None` not covered\n"
"  |\n"
"  = note: `let` bindings require an \"irrefutable pattern\", like a `struct` "
"or an `enum` with only one variant\n"
"  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-"
"refutability.html\n"
"note: `Option<i32>` defined here\n"
" --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option."
"rs:518:1\n"
"  |\n"
"  = note: \n"
"/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option."
"rs:522:5: not covered\n"
"  = note: the matched value is of type `Option<i32>`\n"
"help: you might want to use `if let` to ignore the variant that isn't "
"matched\n"
"  |\n"
"3 |     let x = if let Some(x) = some_option_value { x } else { todo!() };\n"
"  |     ++++++++++                                 ++++++++++++++++++++++\n"
"help: alternatively, you might want to use let else to handle the variant "
"that isn't matched\n"
"  |\n"
"3 |     let Some(x) = some_option_value else { todo!() };\n"
"  |                                     ++++++++++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0005`.\n"
"error: could not compile `patterns` due to previous error\n"
"```"
msgstr ""

#: src/ch18-02-refutability.md:76
msgid ""
"Because we didn‚Äôt cover (and couldn‚Äôt cover!) every valid value with the\n"
"pattern `Some(x)`, Rust rightfully produces a compiler error."
msgstr ""

#: src/ch18-02-refutability.md:79
msgid ""
"If we have a refutable pattern where an irrefutable pattern is needed, we "
"can\n"
"fix it by changing the code that uses the pattern: instead of using `let`, "
"we\n"
"can use `if let`. Then if the pattern doesn‚Äôt match, the code will just "
"skip\n"
"the code in the curly brackets, giving it a way to continue validly. "
"Listing\n"
"18-9 shows how to fix the code in Listing 18-8."
msgstr ""

#: src/ch18-02-refutability.md:85
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let some_option_value: Option<i32> = None;\n"
"    if let Some(x) = some_option_value {\n"
"        println!(\"{}\", x);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-02-refutability.md:94
msgid ""
"<span class=\"caption\">Listing 18-9: Using `if let` and a block with "
"refutable\n"
"patterns instead of `let`</span>"
msgstr ""

#: src/ch18-02-refutability.md:97
msgid ""
"We‚Äôve given the code an out! This code is perfectly valid, although it means "
"we\n"
"cannot use an irrefutable pattern without receiving an error. If we give "
"`if\n"
"let` a pattern that will always match, such as `x`, as shown in Listing "
"18-10,\n"
"the compiler will give a warning."
msgstr ""

#: src/ch18-02-refutability.md:102
msgid ""
"```rust\n"
"# fn main() {\n"
"    if let x = 5 {\n"
"        println!(\"{}\", x);\n"
"    };\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-02-refutability.md:110
msgid ""
"<span class=\"caption\">Listing 18-10: Attempting to use an irrefutable "
"pattern\n"
"with `if let`</span>"
msgstr ""

#: src/ch18-02-refutability.md:113
msgid ""
"Rust complains that it doesn‚Äôt make sense to use `if let` with an "
"irrefutable\n"
"pattern:"
msgstr ""

#: src/ch18-02-refutability.md:116
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"warning: irrefutable `if let` pattern\n"
" --> src/main.rs:2:8\n"
"  |\n"
"2 |     if let x = 5 {\n"
"  |        ^^^^^^^^^\n"
"  |\n"
"  = note: this pattern will always match, so the `if let` is useless\n"
"  = help: consider replacing the `if let` with a `let`\n"
"  = note: `#[warn(irrefutable_let_patterns)]` on by default\n"
"\n"
"warning: `patterns` (bin \"patterns\") generated 1 warning\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.39s\n"
"     Running `target/debug/patterns`\n"
"5\n"
"```"
msgstr ""

#: src/ch18-02-refutability.md:135
msgid ""
"For this reason, match arms must use refutable patterns, except for the "
"last\n"
"arm, which should match any remaining values with an irrefutable pattern. "
"Rust\n"
"allows us to use an irrefutable pattern in a `match` with only one arm, but\n"
"this syntax isn‚Äôt particularly useful and could be replaced with a simpler\n"
"`let` statement."
msgstr ""

#: src/ch18-02-refutability.md:141
msgid ""
"Now that you know where to use patterns and the difference between "
"refutable\n"
"and irrefutable patterns, let‚Äôs cover all the syntax we can use to create\n"
"patterns."
msgstr ""

#: src/ch18-03-pattern-syntax.md:1
msgid "## Pattern Syntax"
msgstr ""

#: src/ch18-03-pattern-syntax.md:3
msgid ""
"In this section, we gather all the syntax valid in patterns and discuss why "
"and\n"
"when you might want to use each one."
msgstr ""

#: src/ch18-03-pattern-syntax.md:6
msgid "### Matching Literals"
msgstr ""

#: src/ch18-03-pattern-syntax.md:8
msgid ""
"As you saw in Chapter 6, you can match patterns against literals directly. "
"The\n"
"following code gives some examples:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:11
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 1;\n"
"\n"
"    match x {\n"
"        1 => println!(\"one\"),\n"
"        2 => println!(\"two\"),\n"
"        3 => println!(\"three\"),\n"
"        _ => println!(\"anything\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:24
msgid ""
"This code prints `one` because the value in `x` is 1. This syntax is useful\n"
"when you want your code to take an action if it gets a particular concrete\n"
"value."
msgstr ""

#: src/ch18-03-pattern-syntax.md:28
msgid "### Matching Named Variables"
msgstr ""

#: src/ch18-03-pattern-syntax.md:30
msgid ""
"Named variables are irrefutable patterns that match any value, and we‚Äôve "
"used\n"
"them many times in the book. However, there is a complication when you use\n"
"named variables in `match` expressions. Because `match` starts a new scope,\n"
"variables declared as part of a pattern inside the `match` expression will\n"
"shadow those with the same name outside the `match` construct, as is the "
"case\n"
"with all variables. In Listing 18-11, we declare a variable named `x` with "
"the\n"
"value `Some(5)` and a variable `y` with the value `10`. We then create a\n"
"`match` expression on the value `x`. Look at the patterns in the match arms "
"and\n"
"`println!` at the end, and try to figure out what the code will print "
"before\n"
"running this code or reading further."
msgstr ""

#: src/ch18-03-pattern-syntax.md:43
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = Some(5);\n"
"    let y = 10;\n"
"\n"
"    match x {\n"
"        Some(50) => println!(\"Got 50\"),\n"
"        Some(y) => println!(\"Matched, y = {y}\"),\n"
"        _ => println!(\"Default case, x = {:?}\", x),\n"
"    }\n"
"\n"
"    println!(\"at the end: x = {:?}, y = {y}\", x);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:58
msgid ""
"<span class=\"caption\">Listing 18-11: A `match` expression with an arm "
"that\n"
"introduces a shadowed variable `y`</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:61
msgid ""
"Let‚Äôs walk through what happens when the `match` expression runs. The "
"pattern\n"
"in the first match arm doesn‚Äôt match the defined value of `x`, so the code\n"
"continues."
msgstr ""

#: src/ch18-03-pattern-syntax.md:65
msgid ""
"The pattern in the second match arm introduces a new variable named `y` "
"that\n"
"will match any value inside a `Some` value. Because we‚Äôre in a new scope "
"inside\n"
"the `match` expression, this is a new `y` variable, not the `y` we declared "
"at\n"
"the beginning with the value 10. This new `y` binding will match any value\n"
"inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds "
"to\n"
"the inner value of the `Some` in `x`. That value is `5`, so the expression "
"for\n"
"that arm executes and prints `Matched, y = 5`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:73
msgid ""
"If `x` had been a `None` value instead of `Some(5)`, the patterns in the "
"first\n"
"two arms wouldn‚Äôt have matched, so the value would have matched to the\n"
"underscore. We didn‚Äôt introduce the `x` variable in the pattern of the\n"
"underscore arm, so the `x` in the expression is still the outer `x` that "
"hasn‚Äôt\n"
"been shadowed. In this hypothetical case, the `match` would print `Default\n"
"case, x = None`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:80
msgid ""
"When the `match` expression is done, its scope ends, and so does the scope "
"of\n"
"the inner `y`. The last `println!` produces `at the end: x = Some(5), y = "
"10`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:83
msgid ""
"To create a `match` expression that compares the values of the outer `x` "
"and\n"
"`y`, rather than introducing a shadowed variable, we would need to use a "
"match\n"
"guard conditional instead. We‚Äôll talk about match guards later in the "
"[‚ÄúExtra\n"
"Conditionals with Match Guards‚Äù](#extra-conditionals-with-match-guards)<!--\n"
"ignore --> section."
msgstr ""

#: src/ch18-03-pattern-syntax.md:89
msgid "### Multiple Patterns"
msgstr ""

#: src/ch18-03-pattern-syntax.md:91
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax,\n"
"which is the pattern *or* operator. For example, in the following code we "
"match\n"
"the value of `x` against the match arms, the first of which has an *or* "
"option,\n"
"meaning if the value of `x` matches either of the values in that arm, that\n"
"arm‚Äôs code will run:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:97
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 1;\n"
"\n"
"    match x {\n"
"        1 | 2 => println!(\"one or two\"),\n"
"        3 => println!(\"three\"),\n"
"        _ => println!(\"anything\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:109
msgid "This code prints `one or two`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:111
msgid "### Matching Ranges of Values with `..=`"
msgstr ""

#: src/ch18-03-pattern-syntax.md:113
msgid ""
"The `..=` syntax allows us to match to an inclusive range of values. In the\n"
"following code, when a pattern matches any of the values within the given\n"
"range, that arm will execute:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:117
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 5;\n"
"\n"
"    match x {\n"
"        1..=5 => println!(\"one through five\"),\n"
"        _ => println!(\"something else\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:128
msgid ""
"If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more\n"
"convenient for multiple match values than using the `|` operator to express "
"the\n"
"same idea; if we were to use `|` we would have to specify `1 | 2 | 3 | 4 | "
"5`.\n"
"Specifying a range is much shorter, especially if we want to match, say, "
"any\n"
"number between 1 and 1,000!"
msgstr ""

#: src/ch18-03-pattern-syntax.md:134
msgid ""
"The compiler checks that the range isn‚Äôt empty at compile time, and because "
"the\n"
"only types for which Rust can tell if a range is empty or not are `char` "
"and\n"
"numeric values, ranges are only allowed with numeric or `char` values."
msgstr ""

#: src/ch18-03-pattern-syntax.md:138
msgid "Here is an example using ranges of `char` values:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:140
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 'c';\n"
"\n"
"    match x {\n"
"        'a'..='j' => println!(\"early ASCII letter\"),\n"
"        'k'..='z' => println!(\"late ASCII letter\"),\n"
"        _ => println!(\"something else\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:152
msgid ""
"Rust can tell that `'c'` is within the first pattern‚Äôs range and prints "
"`early\n"
"ASCII letter`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:155
msgid "### Destructuring to Break Apart Values"
msgstr ""

#: src/ch18-03-pattern-syntax.md:157
msgid ""
"We can also use patterns to destructure structs, enums, and tuples to use\n"
"different parts of these values. Let‚Äôs walk through each value."
msgstr ""

#: src/ch18-03-pattern-syntax.md:160
msgid "#### Destructuring Structs"
msgstr ""

#: src/ch18-03-pattern-syntax.md:162
msgid ""
"Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we "
"can\n"
"break apart using a pattern with a `let` statement."
msgstr ""

#: src/ch18-03-pattern-syntax.md:167
msgid ""
"```rust\n"
"struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point { x: 0, y: 7 };\n"
"\n"
"    let Point { x: a, y: b } = p;\n"
"    assert_eq!(0, a);\n"
"    assert_eq!(7, b);\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:182
msgid ""
"<span class=\"caption\">Listing 18-12: Destructuring a struct‚Äôs fields into\n"
"separate variables</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:185
msgid ""
"This code creates the variables `a` and `b` that match the values of the "
"`x`\n"
"and `y` fields of the `p` struct. This example shows that the names of the\n"
"variables in the pattern don‚Äôt have to match the field names of the struct.\n"
"However, it‚Äôs common to match the variable names to the field names to make "
"it\n"
"easier to remember which variables came from which fields. Because of this\n"
"common usage, and because writing `let Point { x: x, y: y } = p;` contains "
"a\n"
"lot of duplication, Rust has a shorthand for patterns that match struct "
"fields:\n"
"you only need to list the name of the struct field, and the variables "
"created\n"
"from the pattern will have the same names. Listing 18-13 behaves in the "
"same\n"
"way as the code in Listing 18-12, but the variables created in the `let`\n"
"pattern are `x` and `y` instead of `a` and `b`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:199
msgid ""
"```rust\n"
"struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point { x: 0, y: 7 };\n"
"\n"
"    let Point { x, y } = p;\n"
"    assert_eq!(0, x);\n"
"    assert_eq!(7, y);\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:214
msgid ""
"<span class=\"caption\">Listing 18-13: Destructuring struct fields using "
"struct\n"
"field shorthand</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:217
msgid ""
"This code creates the variables `x` and `y` that match the `x` and `y` "
"fields\n"
"of the `p` variable. The outcome is that the variables `x` and `y` contain "
"the\n"
"values from the `p` struct."
msgstr ""

#: src/ch18-03-pattern-syntax.md:221
msgid ""
"We can also destructure with literal values as part of the struct pattern\n"
"rather than creating variables for all the fields. Doing so allows us to "
"test\n"
"some of the fields for particular values while creating variables to\n"
"destructure the other fields."
msgstr ""

#: src/ch18-03-pattern-syntax.md:226
msgid ""
"In Listing 18-14, we have a `match` expression that separates `Point` "
"values\n"
"into three cases: points that lie directly on the `x` axis (which is true "
"when\n"
"`y = 0`), on the `y` axis (`x = 0`), or neither."
msgstr ""

#: src/ch18-03-pattern-syntax.md:232
msgid ""
"```rust\n"
"# struct Point {\n"
"#     x: i32,\n"
"#     y: i32,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let p = Point { x: 0, y: 7 };\n"
"\n"
"    match p {\n"
"        Point { x, y: 0 } => println!(\"On the x axis at {x}\"),\n"
"        Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n"
"        Point { x, y } => {\n"
"            println!(\"On neither axis: ({x}, {y})\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:251
msgid ""
"<span class=\"caption\">Listing 18-14: Destructuring and matching literal "
"values\n"
"in one pattern</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:254
msgid ""
"The first arm will match any point that lies on the `x` axis by specifying "
"that\n"
"the `y` field matches if its value matches the literal `0`. The pattern "
"still\n"
"creates an `x` variable that we can use in the code for this arm."
msgstr ""

#: src/ch18-03-pattern-syntax.md:258
msgid ""
"Similarly, the second arm matches any point on the `y` axis by specifying "
"that\n"
"the `x` field matches if its value is `0` and creates a variable `y` for "
"the\n"
"value of the `y` field. The third arm doesn‚Äôt specify any literals, so it\n"
"matches any other `Point` and creates variables for both the `x` and `y` "
"fields."
msgstr ""

#: src/ch18-03-pattern-syntax.md:263
msgid ""
"In this example, the value `p` matches the second arm by virtue of `x`\n"
"containing a 0, so this code will print `On the y axis at 7`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:266
msgid ""
"Remember that a `match` expression stops checking arms once it has found "
"the\n"
"first matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` "
"axis\n"
"and the `y` axis, this code would only print `On the x axis at 0`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:270
msgid "#### Destructuring Enums"
msgstr ""

#: src/ch18-03-pattern-syntax.md:272
msgid ""
"We've destructured enums in this book (for example, Listing 6-5 in Chapter "
"6),\n"
"but haven‚Äôt yet explicitly discussed that the pattern to destructure an "
"enum\n"
"corresponds to the way the data stored within the enum is defined. As an\n"
"example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and "
"write\n"
"a `match` with patterns that will destructure each inner value."
msgstr ""

#: src/ch18-03-pattern-syntax.md:280
msgid ""
"```rust\n"
"enum Message {\n"
"    Quit,\n"
"    Move { x: i32, y: i32 },\n"
"    Write(String),\n"
"    ChangeColor(i32, i32, i32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let msg = Message::ChangeColor(0, 160, 255);\n"
"\n"
"    match msg {\n"
"        Message::Quit => {\n"
"            println!(\"The Quit variant has no data to destructure.\");\n"
"        }\n"
"        Message::Move { x, y } => {\n"
"            println!(\"Move in the x direction {x} and in the y direction "
"{y}\");\n"
"        }\n"
"        Message::Write(text) => {\n"
"            println!(\"Text message: {text}\");\n"
"        }\n"
"        Message::ChangeColor(r, g, b) => {\n"
"            println!(\"Change the color to red {r}, green {g}, and blue "
"{b}\",)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:308
msgid ""
"<span class=\"caption\">Listing 18-15: Destructuring enum variants that "
"hold\n"
"different kinds of values</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:311
msgid ""
"This code will print `Change the color to red 0, green 160, and blue 255`. "
"Try\n"
"changing the value of `msg` to see the code from the other arms run."
msgstr ""

#: src/ch18-03-pattern-syntax.md:314
msgid ""
"For enum variants without any data, like `Message::Quit`, we can‚Äôt "
"destructure\n"
"the value any further. We can only match on the literal `Message::Quit` "
"value,\n"
"and no variables are in that pattern."
msgstr ""

#: src/ch18-03-pattern-syntax.md:318
msgid ""
"For struct-like enum variants, such as `Message::Move`, we can use a "
"pattern\n"
"similar to the pattern we specify to match structs. After the variant name, "
"we\n"
"place curly brackets and then list the fields with variables so we break "
"apart\n"
"the pieces to use in the code for this arm. Here we use the shorthand form "
"as\n"
"we did in Listing 18-13."
msgstr ""

#: src/ch18-03-pattern-syntax.md:324
msgid ""
"For tuple-like enum variants, like `Message::Write` that holds a tuple with "
"one\n"
"element and `Message::ChangeColor` that holds a tuple with three elements, "
"the\n"
"pattern is similar to the pattern we specify to match tuples. The number of\n"
"variables in the pattern must match the number of elements in the variant "
"we‚Äôre\n"
"matching."
msgstr ""

#: src/ch18-03-pattern-syntax.md:330
msgid "#### Destructuring Nested Structs and Enums"
msgstr ""

#: src/ch18-03-pattern-syntax.md:332
msgid ""
"So far, our examples have all been matching structs or enums one level "
"deep,\n"
"but matching can work on nested items too! For example, we can refactor the\n"
"code in Listing 18-15 to support RGB and HSV colors in the `ChangeColor`\n"
"message, as shown in Listing 18-16."
msgstr ""

#: src/ch18-03-pattern-syntax.md:337
msgid ""
"```rust\n"
"enum Color {\n"
"    Rgb(i32, i32, i32),\n"
"    Hsv(i32, i32, i32),\n"
"}\n"
"\n"
"enum Message {\n"
"    Quit,\n"
"    Move { x: i32, y: i32 },\n"
"    Write(String),\n"
"    ChangeColor(Color),\n"
"}\n"
"\n"
"fn main() {\n"
"    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n"
"\n"
"    match msg {\n"
"        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n"
"            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n"
"        }\n"
"        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n"
"            println!(\"Change color to hue {h}, saturation {s}, value "
"{v}\")\n"
"        }\n"
"        _ => (),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:365
msgid "<span class=\"caption\">Listing 18-16: Matching on nested enums</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:367
msgid ""
"The pattern of the first arm in the `match` expression matches a\n"
"`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; "
"then\n"
"the pattern binds to the three inner `i32` values. The pattern of the "
"second\n"
"arm also matches a `Message::ChangeColor` enum variant, but the inner enum\n"
"matches `Color::Hsv` instead. We can specify these complex conditions in "
"one\n"
"`match` expression, even though two enums are involved."
msgstr ""

#: src/ch18-03-pattern-syntax.md:374
msgid "#### Destructuring Structs and Tuples"
msgstr ""

#: src/ch18-03-pattern-syntax.md:376
msgid ""
"We can mix, match, and nest destructuring patterns in even more complex "
"ways.\n"
"The following example shows a complicated destructure where we nest structs "
"and\n"
"tuples inside a tuple and destructure all the primitive values out:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:380
msgid ""
"```rust\n"
"# fn main() {\n"
"#     struct Point {\n"
"#         x: i32,\n"
"#         y: i32,\n"
"#     }\n"
"# \n"
"    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: "
"-10 });\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:391
msgid ""
"This code lets us break complex types into their component parts so we can "
"use\n"
"the values we‚Äôre interested in separately."
msgstr ""

#: src/ch18-03-pattern-syntax.md:394
msgid ""
"Destructuring with patterns is a convenient way to use pieces of values, "
"such\n"
"as the value from each field in a struct, separately from each other."
msgstr ""

#: src/ch18-03-pattern-syntax.md:397
msgid "### Ignoring Values in a Pattern"
msgstr ""

#: src/ch18-03-pattern-syntax.md:399
msgid ""
"You‚Äôve seen that it‚Äôs sometimes useful to ignore values in a pattern, such "
"as\n"
"in the last arm of a `match`, to get a catchall that doesn‚Äôt actually do\n"
"anything but does account for all remaining possible values. There are a "
"few\n"
"ways to ignore entire values or parts of values in a pattern: using the `_`\n"
"pattern (which you‚Äôve seen), using the `_` pattern within another pattern,\n"
"using a name that starts with an underscore, or using `..` to ignore "
"remaining\n"
"parts of a value. Let‚Äôs explore how and why to use each of these patterns."
msgstr ""

#: src/ch18-03-pattern-syntax.md:407
msgid "#### Ignoring an Entire Value with `_`"
msgstr ""

#: src/ch18-03-pattern-syntax.md:409
msgid ""
"We‚Äôve used the underscore as a wildcard pattern that will match any value "
"but\n"
"not bind to the value. This is especially useful as the last arm in a "
"`match`\n"
"expression, but we can also use it in any pattern, including function\n"
"parameters, as shown in Listing 18-17."
msgstr ""

#: src/ch18-03-pattern-syntax.md:416
msgid ""
"```rust\n"
"fn foo(_: i32, y: i32) {\n"
"    println!(\"This code only uses the y parameter: {}\", y);\n"
"}\n"
"\n"
"fn main() {\n"
"    foo(3, 4);\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:426
msgid ""
"<span class=\"caption\">Listing 18-17: Using `_` in a function signature</"
"span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:428
msgid ""
"This code will completely ignore the value `3` passed as the first "
"argument,\n"
"and will print `This code only uses the y parameter: 4`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:431
msgid ""
"In most cases when you no longer need a particular function parameter, you\n"
"would change the signature so it doesn‚Äôt include the unused parameter. "
"Ignoring\n"
"a function parameter can be especially useful in cases when, for example,\n"
"you're implementing a trait when you need a certain type signature but the\n"
"function body in your implementation doesn‚Äôt need one of the parameters. "
"You\n"
"then avoid getting a compiler warning about unused function parameters, as "
"you\n"
"would if you used a name instead."
msgstr ""

#: src/ch18-03-pattern-syntax.md:439
msgid "#### Ignoring Parts of a Value with a Nested `_`"
msgstr ""

#: src/ch18-03-pattern-syntax.md:441
msgid ""
"We can also use `_` inside another pattern to ignore just part of a value, "
"for\n"
"example, when we want to test for only part of a value but have no use for "
"the\n"
"other parts in the corresponding code we want to run. Listing 18-18 shows "
"code\n"
"responsible for managing a setting‚Äôs value. The business requirements are "
"that\n"
"the user should not be allowed to overwrite an existing customization of a\n"
"setting but can unset the setting and give it a value if it is currently "
"unset."
msgstr ""

#: src/ch18-03-pattern-syntax.md:448
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut setting_value = Some(5);\n"
"    let new_setting_value = Some(10);\n"
"\n"
"    match (setting_value, new_setting_value) {\n"
"        (Some(_), Some(_)) => {\n"
"            println!(\"Can't overwrite an existing customized value\");\n"
"        }\n"
"        _ => {\n"
"            setting_value = new_setting_value;\n"
"        }\n"
"    }\n"
"\n"
"    println!(\"setting is {:?}\", setting_value);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:466
msgid ""
"<span class=\"caption\">Listing 18-18: Using an underscore within patterns "
"that\n"
"match `Some` variants when we don‚Äôt need to use the value inside the\n"
"`Some`</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:470
msgid ""
"This code will print `Can't overwrite an existing customized value` and "
"then\n"
"`setting is Some(5)`. In the first match arm, we don‚Äôt need to match on or "
"use\n"
"the values inside either `Some` variant, but we do need to test for the "
"case\n"
"when `setting_value` and `new_setting_value` are the `Some` variant. In "
"that\n"
"case, we print the reason for not changing `setting_value`, and it doesn‚Äôt "
"get\n"
"changed."
msgstr ""

#: src/ch18-03-pattern-syntax.md:477
msgid ""
"In all other cases (if either `setting_value` or `new_setting_value` are\n"
"`None`) expressed by the `_` pattern in the second arm, we want to allow\n"
"`new_setting_value` to become `setting_value`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:481
msgid ""
"We can also use underscores in multiple places within one pattern to ignore\n"
"particular values. Listing 18-19 shows an example of ignoring the second "
"and\n"
"fourth values in a tuple of five items."
msgstr ""

#: src/ch18-03-pattern-syntax.md:485
msgid ""
"```rust\n"
"# fn main() {\n"
"    let numbers = (2, 4, 8, 16, 32);\n"
"\n"
"    match numbers {\n"
"        (first, _, third, _, fifth) => {\n"
"            println!(\"Some numbers: {first}, {third}, {fifth}\")\n"
"        }\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:497
msgid ""
"<span class=\"caption\">Listing 18-19: Ignoring multiple parts of a tuple</"
"span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:499
msgid ""
"This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will "
"be\n"
"ignored."
msgstr ""

#: src/ch18-03-pattern-syntax.md:502
msgid "#### Ignoring an Unused Variable by Starting Its Name with `_`"
msgstr ""

#: src/ch18-03-pattern-syntax.md:504
msgid ""
"If you create a variable but don‚Äôt use it anywhere, Rust will usually issue "
"a\n"
"warning because an unused variable could be a bug. However, sometimes it‚Äôs\n"
"useful to be able to create a variable you won‚Äôt use yet, such as when "
"you‚Äôre\n"
"prototyping or just starting a project. In this situation, you can tell "
"Rust\n"
"not to warn you about the unused variable by starting the name of the "
"variable\n"
"with an underscore. In Listing 18-20, we create two unused variables, but "
"when\n"
"we compile this code, we should only get a warning about one of them."
msgstr ""

#: src/ch18-03-pattern-syntax.md:514
msgid ""
"```rust\n"
"fn main() {\n"
"    let _x = 5;\n"
"    let y = 10;\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:521
msgid ""
"<span class=\"caption\">Listing 18-20: Starting a variable name with an\n"
"underscore to avoid getting unused variable warnings</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:524
msgid ""
"Here we get a warning about not using the variable `y`, but we don‚Äôt get a\n"
"warning about not using `_x`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:527
msgid ""
"Note that there is a subtle difference between using only `_` and using a "
"name\n"
"that starts with an underscore. The syntax `_x` still binds the value to "
"the\n"
"variable, whereas `_` doesn‚Äôt bind at all. To show a case where this\n"
"distinction matters, Listing 18-21 will provide us with an error."
msgstr ""

#: src/ch18-03-pattern-syntax.md:532
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let s = Some(String::from(\"Hello!\"));\n"
"\n"
"    if let Some(_s) = s {\n"
"        println!(\"found a string\");\n"
"    }\n"
"\n"
"    println!(\"{:?}\", s);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:544
msgid ""
"<span class=\"caption\">Listing 18-21: An unused variable starting with an\n"
"underscore still binds the value, which might take ownership of the value</"
"span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:547
msgid ""
"We‚Äôll receive an error because the `s` value will still be moved into `_s`,\n"
"which prevents us from using `s` again. However, using the underscore by "
"itself\n"
"doesn‚Äôt ever bind to the value. Listing 18-22 will compile without any "
"errors\n"
"because `s` doesn‚Äôt get moved into `_`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:552
msgid ""
"```rust\n"
"# fn main() {\n"
"    let s = Some(String::from(\"Hello!\"));\n"
"\n"
"    if let Some(_) = s {\n"
"        println!(\"found a string\");\n"
"    }\n"
"\n"
"    println!(\"{:?}\", s);\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:564
msgid ""
"<span class=\"caption\">Listing 18-22: Using an underscore does not bind "
"the\n"
"value</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:567
msgid ""
"This code works just fine because we never bind `s` to anything; it isn‚Äôt "
"moved."
msgstr ""

#: src/ch18-03-pattern-syntax.md:569
msgid "#### Ignoring Remaining Parts of a Value with `..`"
msgstr ""

#: src/ch18-03-pattern-syntax.md:571
msgid ""
"With values that have many parts, we can use the `..` syntax to use "
"specific\n"
"parts and ignore the rest, avoiding the need to list underscores for each\n"
"ignored value. The `..` pattern ignores any parts of a value that we "
"haven‚Äôt\n"
"explicitly matched in the rest of the pattern. In Listing 18-23, we have a\n"
"`Point` struct that holds a coordinate in three-dimensional space. In the\n"
"`match` expression, we want to operate only on the `x` coordinate and "
"ignore\n"
"the values in the `y` and `z` fields."
msgstr ""

#: src/ch18-03-pattern-syntax.md:579
msgid ""
"```rust\n"
"# fn main() {\n"
"    struct Point {\n"
"        x: i32,\n"
"        y: i32,\n"
"        z: i32,\n"
"    }\n"
"\n"
"    let origin = Point { x: 0, y: 0, z: 0 };\n"
"\n"
"    match origin {\n"
"        Point { x, .. } => println!(\"x is {}\", x),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:595
msgid ""
"<span class=\"caption\">Listing 18-23: Ignoring all fields of a `Point` "
"except\n"
"for `x` by using `..`</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:598
msgid ""
"We list the `x` value and then just include the `..` pattern. This is "
"quicker\n"
"than having to list `y: _` and `z: _`, particularly when we‚Äôre working with\n"
"structs that have lots of fields in situations where only one or two fields "
"are\n"
"relevant."
msgstr ""

#: src/ch18-03-pattern-syntax.md:603
msgid ""
"The syntax `..` will expand to as many values as it needs to be. Listing "
"18-24\n"
"shows how to use `..` with a tuple."
msgstr ""

#: src/ch18-03-pattern-syntax.md:608
msgid ""
"```rust\n"
"fn main() {\n"
"    let numbers = (2, 4, 8, 16, 32);\n"
"\n"
"    match numbers {\n"
"        (first, .., last) => {\n"
"            println!(\"Some numbers: {first}, {last}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:620
msgid ""
"<span class=\"caption\">Listing 18-24: Matching only the first and last "
"values in\n"
"a tuple and ignoring all other values</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:623
msgid ""
"In this code, the first and last value are matched with `first` and `last`. "
"The\n"
"`..` will match and ignore everything in the middle."
msgstr ""

#: src/ch18-03-pattern-syntax.md:626
msgid ""
"However, using `..` must be unambiguous. If it is unclear which values are\n"
"intended for matching and which should be ignored, Rust will give us an "
"error.\n"
"Listing 18-25 shows an example of using `..` ambiguously, so it will not\n"
"compile."
msgstr ""

#: src/ch18-03-pattern-syntax.md:633
msgid ""
"```rust,ignore,does_not_compile\n"
"fn main() {\n"
"    let numbers = (2, 4, 8, 16, 32);\n"
"\n"
"    match numbers {\n"
"        (.., second, ..) => {\n"
"            println!(\"Some numbers: {}\", second)\n"
"        },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:645
msgid ""
"<span class=\"caption\">Listing 18-25: An attempt to use `..` in an "
"ambiguous\n"
"way</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:648
msgid "When we compile this example, we get this error:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:650
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error: `..` can only be used once per tuple pattern\n"
" --> src/main.rs:5:22\n"
"  |\n"
"5 |         (.., second, ..) => {\n"
"  |          --          ^^ can only be used once per tuple pattern\n"
"  |          |\n"
"  |          previously used here\n"
"\n"
"error: could not compile `patterns` due to previous error\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:664
msgid ""
"It‚Äôs impossible for Rust to determine how many values in the tuple to "
"ignore\n"
"before matching a value with `second` and then how many further values to\n"
"ignore thereafter. This code could mean that we want to ignore `2`, bind\n"
"`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to "
"ignore\n"
"`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so "
"forth.\n"
"The variable name `second` doesn‚Äôt mean anything special to Rust, so we get "
"a\n"
"compiler error because using `..` in two places like this is ambiguous."
msgstr ""

#: src/ch18-03-pattern-syntax.md:672
msgid "### Extra Conditionals with Match Guards"
msgstr ""

#: src/ch18-03-pattern-syntax.md:674
msgid ""
"A *match guard* is an additional `if` condition, specified after the pattern "
"in\n"
"a `match` arm, that must also match for that arm to be chosen. Match guards "
"are\n"
"useful for expressing more complex ideas than a pattern alone allows."
msgstr ""

#: src/ch18-03-pattern-syntax.md:678
msgid ""
"The condition can use variables created in the pattern. Listing 18-26 shows "
"a\n"
"`match` where the first arm has the pattern `Some(x)` and also has a match\n"
"guard of `if x % 2 == 0` (which will be true if the number is even)."
msgstr ""

#: src/ch18-03-pattern-syntax.md:682
msgid ""
"```rust\n"
"# fn main() {\n"
"    let num = Some(4);\n"
"\n"
"    match num {\n"
"        Some(x) if x % 2 == 0 => println!(\"The number {} is even\", x),\n"
"        Some(x) => println!(\"The number {} is odd\", x),\n"
"        None => (),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:694
msgid ""
"<span class=\"caption\">Listing 18-26: Adding a match guard to a pattern</"
"span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:696
msgid ""
"This example will print `The number 4 is even`. When `num` is compared to "
"the\n"
"pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. "
"Then\n"
"the match guard checks whether the remainder of dividing `x` by 2 is equal "
"to\n"
"0, and because it is, the first arm is selected."
msgstr ""

#: src/ch18-03-pattern-syntax.md:701
msgid ""
"If `num` had been `Some(5)` instead, the match guard in the first arm would\n"
"have been false because the remainder of 5 divided by 2 is 1, which is not\n"
"equal to 0. Rust would then go to the second arm, which would match because "
"the\n"
"second arm doesn‚Äôt have a match guard and therefore matches any `Some` "
"variant."
msgstr ""

#: src/ch18-03-pattern-syntax.md:706
msgid ""
"There is no way to express the `if x % 2 == 0` condition within a pattern, "
"so\n"
"the match guard gives us the ability to express this logic. The downside of\n"
"this additional expressiveness is that the compiler doesn't try to check "
"for\n"
"exhaustiveness when match guard expressions are involved."
msgstr ""

#: src/ch18-03-pattern-syntax.md:711
msgid ""
"In Listing 18-11, we mentioned that we could use match guards to solve our\n"
"pattern-shadowing problem. Recall that we created a new variable inside the\n"
"pattern in the `match` expression instead of using the variable outside the\n"
"`match`. That new variable meant we couldn‚Äôt test against the value of the\n"
"outer variable. Listing 18-27 shows how we can use a match guard to fix "
"this\n"
"problem."
msgstr ""

#: src/ch18-03-pattern-syntax.md:720
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = Some(5);\n"
"    let y = 10;\n"
"\n"
"    match x {\n"
"        Some(50) => println!(\"Got 50\"),\n"
"        Some(n) if n == y => println!(\"Matched, n = {n}\"),\n"
"        _ => println!(\"Default case, x = {:?}\", x),\n"
"    }\n"
"\n"
"    println!(\"at the end: x = {:?}, y = {y}\", x);\n"
"}\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:735
msgid ""
"<span class=\"caption\">Listing 18-27: Using a match guard to test for "
"equality\n"
"with an outer variable</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:738
msgid ""
"This code will now print `Default case, x = Some(5)`. The pattern in the "
"second\n"
"match arm doesn‚Äôt introduce a new variable `y` that would shadow the outer "
"`y`,\n"
"meaning we can use the outer `y` in the match guard. Instead of specifying "
"the\n"
"pattern as `Some(y)`, which would have shadowed the outer `y`, we specify\n"
"`Some(n)`. This creates a new variable `n` that doesn‚Äôt shadow anything "
"because\n"
"there is no `n` variable outside the `match`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:745
msgid ""
"The match guard `if n == y` is not a pattern and therefore doesn‚Äôt "
"introduce\n"
"new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, "
"and\n"
"we can look for a value that has the same value as the outer `y` by "
"comparing\n"
"`n` to `y`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:750
msgid ""
"You can also use the *or* operator `|` in a match guard to specify multiple\n"
"patterns; the match guard condition will apply to all the patterns. Listing\n"
"18-28 shows the precedence when combining a pattern that uses `|` with a "
"match\n"
"guard. The important part of this example is that the `if y` match guard\n"
"applies to `4`, `5`, *and* `6`, even though it might look like `if y` only\n"
"applies to `6`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:757
msgid ""
"```rust\n"
"# fn main() {\n"
"    let x = 4;\n"
"    let y = false;\n"
"\n"
"    match x {\n"
"        4 | 5 | 6 if y => println!(\"yes\"),\n"
"        _ => println!(\"no\"),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:769
msgid ""
"<span class=\"caption\">Listing 18-28: Combining multiple patterns with a "
"match\n"
"guard</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:772
msgid ""
"The match condition states that the arm only matches if the value of `x` is\n"
"equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the\n"
"pattern of the first arm matches because `x` is `4`, but the match guard `if "
"y`\n"
"is false, so the first arm is not chosen. The code moves on to the second "
"arm,\n"
"which does match, and this program prints `no`. The reason is that the `if`\n"
"condition applies to the whole pattern `4 | 5 | 6`, not only to the last "
"value\n"
"`6`. In other words, the precedence of a match guard in relation to a "
"pattern\n"
"behaves like this:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:781
msgid ""
"```text\n"
"(4 | 5 | 6) if y => ...\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:785
msgid "rather than this:"
msgstr ""

#: src/ch18-03-pattern-syntax.md:787
msgid ""
"```text\n"
"4 | 5 | (6 if y) => ...\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:791
msgid ""
"After running the code, the precedence behavior is evident: if the match "
"guard\n"
"were applied only to the final value in the list of values specified using "
"the\n"
"`|` operator, the arm would have matched and the program would have printed\n"
"`yes`."
msgstr ""

#: src/ch18-03-pattern-syntax.md:796
msgid "### `@` Bindings"
msgstr ""

#: src/ch18-03-pattern-syntax.md:798
msgid ""
"The *at* operator `@` lets us create a variable that holds a value at the "
"same\n"
"time as we‚Äôre testing that value for a pattern match. In Listing 18-29, we "
"want\n"
"to test that a `Message::Hello` `id` field is within the range `3..=7`. We "
"also\n"
"want to bind the value to the variable `id_variable` so we can use it in "
"the\n"
"code associated with the arm. We could name this variable `id`, the same as "
"the\n"
"field, but for this example we‚Äôll use a different name."
msgstr ""

#: src/ch18-03-pattern-syntax.md:805
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum Message {\n"
"        Hello { id: i32 },\n"
"    }\n"
"\n"
"    let msg = Message::Hello { id: 5 };\n"
"\n"
"    match msg {\n"
"        Message::Hello {\n"
"            id: id_variable @ 3..=7,\n"
"        } => println!(\"Found an id in range: {}\", id_variable),\n"
"        Message::Hello { id: 10..=12 } => {\n"
"            println!(\"Found an id in another range\")\n"
"        }\n"
"        Message::Hello { id } => println!(\"Found some other id: {}\", id),\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch18-03-pattern-syntax.md:825
msgid ""
"<span class=\"caption\">Listing 18-29: Using `@` to bind to a value in a "
"pattern\n"
"while also testing it</span>"
msgstr ""

#: src/ch18-03-pattern-syntax.md:828
msgid ""
"This example will print `Found an id in range: 5`. By specifying "
"`id_variable\n"
"@` before the range `3..=7`, we‚Äôre capturing whatever value matched the "
"range\n"
"while also testing that the value matched the range pattern."
msgstr ""

#: src/ch18-03-pattern-syntax.md:832
msgid ""
"In the second arm, where we only have a range specified in the pattern, the "
"code\n"
"associated with the arm doesn‚Äôt have a variable that contains the actual "
"value\n"
"of the `id` field. The `id` field‚Äôs value could have been 10, 11, or 12, "
"but\n"
"the code that goes with that pattern doesn‚Äôt know which it is. The pattern "
"code\n"
"isn‚Äôt able to use the value from the `id` field, because we haven‚Äôt saved "
"the\n"
"`id` value in a variable."
msgstr ""

#: src/ch18-03-pattern-syntax.md:839
msgid ""
"In the last arm, where we‚Äôve specified a variable without a range, we do "
"have\n"
"the value available to use in the arm‚Äôs code in a variable named `id`. The\n"
"reason is that we‚Äôve used the struct field shorthand syntax. But we haven‚Äôt\n"
"applied any test to the value in the `id` field in this arm, as we did with "
"the\n"
"first two arms: any value would match this pattern."
msgstr ""

#: src/ch18-03-pattern-syntax.md:845
msgid ""
"Using `@` lets us test a value and save it in a variable within one pattern."
msgstr ""

#: src/ch18-03-pattern-syntax.md:849
msgid ""
"Rust‚Äôs patterns are very useful in distinguishing between different kinds "
"of\n"
"data. When used in `match` expressions, Rust ensures your patterns cover "
"every\n"
"possible value, or your program won‚Äôt compile. Patterns in `let` statements "
"and\n"
"function parameters make those constructs more useful, enabling the\n"
"destructuring of values into smaller parts at the same time as assigning to\n"
"variables. We can create simple or complex patterns to suit our needs."
msgstr ""

#: src/ch18-03-pattern-syntax.md:856
msgid ""
"Next, for the penultimate chapter of the book, we‚Äôll look at some advanced\n"
"aspects of a variety of Rust‚Äôs features."
msgstr ""

#: src/ch19-00-advanced-features.md:1
msgid "# Advanced Features"
msgstr ""

#: src/ch19-00-advanced-features.md:3
msgid ""
"By now, you‚Äôve learned the most commonly used parts of the Rust programming\n"
"language. Before we do one more project in Chapter 20, we‚Äôll look at a few\n"
"aspects of the language you might run into every once in a while, but may "
"not\n"
"use every day. You can use this chapter as a reference for when you "
"encounter\n"
"any unknowns. The features covered here are useful in very specific "
"situations.\n"
"Although you might not reach for them often, we want to make sure you have "
"a\n"
"grasp of all the features Rust has to offer."
msgstr ""

#: src/ch19-00-advanced-features.md:11
msgid "In this chapter, we‚Äôll cover:"
msgstr ""

#: src/ch19-00-advanced-features.md:13
msgid ""
"* Unsafe Rust: how to opt out of some of Rust‚Äôs guarantees and take\n"
"  responsibility for manually upholding those guarantees\n"
"* Advanced traits: associated types, default type parameters, fully "
"qualified\n"
"  syntax, supertraits, and the newtype pattern in relation to traits\n"
"* Advanced types: more about the newtype pattern, type aliases, the never "
"type,\n"
"  and dynamically sized types\n"
"* Advanced functions and closures: function pointers and returning closures\n"
"* Macros: ways to define code that defines more code at compile time"
msgstr ""

#: src/ch19-00-advanced-features.md:22
msgid ""
"It‚Äôs a panoply of Rust features with something for everyone! Let‚Äôs dive in!"
msgstr ""

#: src/ch19-01-unsafe-rust.md:1
msgid "## Unsafe Rust"
msgstr ""

#: src/ch19-01-unsafe-rust.md:3
msgid ""
"All the code we‚Äôve discussed so far has had Rust‚Äôs memory safety guarantees\n"
"enforced at compile time. However, Rust has a second language hidden inside "
"it\n"
"that doesn‚Äôt enforce these memory safety guarantees: it‚Äôs called *unsafe "
"Rust*\n"
"and works just like regular Rust, but gives us extra superpowers."
msgstr ""

#: src/ch19-01-unsafe-rust.md:8
msgid ""
"Unsafe Rust exists because, by nature, static analysis is conservative. "
"When\n"
"the compiler tries to determine whether or not code upholds the guarantees,\n"
"it‚Äôs better for it to reject some valid programs than to accept some "
"invalid\n"
"programs. Although the code *might* be okay, if the Rust compiler doesn‚Äôt "
"have\n"
"enough information to be confident, it will reject the code. In these "
"cases,\n"
"you can use unsafe code to tell the compiler, ‚ÄúTrust me, I know what I‚Äôm\n"
"doing.‚Äù Be warned, however, that you use unsafe Rust at your own risk: if "
"you\n"
"use unsafe code incorrectly, problems can occur due to memory unsafety, such "
"as\n"
"null pointer dereferencing."
msgstr ""

#: src/ch19-01-unsafe-rust.md:18
msgid ""
"Another reason Rust has an unsafe alter ego is that the underlying computer\n"
"hardware is inherently unsafe. If Rust didn‚Äôt let you do unsafe operations, "
"you\n"
"couldn‚Äôt do certain tasks. Rust needs to allow you to do low-level systems\n"
"programming, such as directly interacting with the operating system or even\n"
"writing your own operating system. Working with low-level systems "
"programming\n"
"is one of the goals of the language. Let‚Äôs explore what we can do with "
"unsafe\n"
"Rust and how to do it."
msgstr ""

#: src/ch19-01-unsafe-rust.md:26
msgid "### Unsafe Superpowers"
msgstr ""

#: src/ch19-01-unsafe-rust.md:28
msgid ""
"To switch to unsafe Rust, use the `unsafe` keyword and then start a new "
"block\n"
"that holds the unsafe code. You can take five actions in unsafe Rust that "
"you\n"
"can‚Äôt in safe Rust, which we call *unsafe superpowers*. Those superpowers\n"
"include the ability to:"
msgstr ""

#: src/ch19-01-unsafe-rust.md:33
msgid ""
"* Dereference a raw pointer\n"
"* Call an unsafe function or method\n"
"* Access or modify a mutable static variable\n"
"* Implement an unsafe trait\n"
"* Access fields of `union`s"
msgstr ""

#: src/ch19-01-unsafe-rust.md:39
msgid ""
"It‚Äôs important to understand that `unsafe` doesn‚Äôt turn off the borrow "
"checker\n"
"or disable any other of Rust‚Äôs safety checks: if you use a reference in "
"unsafe\n"
"code, it will still be checked. The `unsafe` keyword only gives you access "
"to\n"
"these five features that are then not checked by the compiler for memory\n"
"safety. You‚Äôll still get some degree of safety inside of an unsafe block."
msgstr ""

#: src/ch19-01-unsafe-rust.md:45
msgid ""
"In addition, `unsafe` does not mean the code inside the block is "
"necessarily\n"
"dangerous or that it will definitely have memory safety problems: the intent "
"is\n"
"that as the programmer, you‚Äôll ensure the code inside an `unsafe` block "
"will\n"
"access memory in a valid way."
msgstr ""

#: src/ch19-01-unsafe-rust.md:50
msgid ""
"People are fallible, and mistakes will happen, but by requiring these five\n"
"unsafe operations to be inside blocks annotated with `unsafe` you‚Äôll know "
"that\n"
"any errors related to memory safety must be within an `unsafe` block. Keep\n"
"`unsafe` blocks small; you‚Äôll be thankful later when you investigate memory\n"
"bugs."
msgstr ""

#: src/ch19-01-unsafe-rust.md:56
msgid ""
"To isolate unsafe code as much as possible, it‚Äôs best to enclose unsafe "
"code\n"
"within a safe abstraction and provide a safe API, which we‚Äôll discuss later "
"in\n"
"the chapter when we examine unsafe functions and methods. Parts of the "
"standard\n"
"library are implemented as safe abstractions over unsafe code that has been\n"
"audited. Wrapping unsafe code in a safe abstraction prevents uses of "
"`unsafe`\n"
"from leaking out into all the places that you or your users might want to "
"use\n"
"the functionality implemented with `unsafe` code, because using a safe\n"
"abstraction is safe."
msgstr ""

#: src/ch19-01-unsafe-rust.md:65
msgid ""
"Let‚Äôs look at each of the five unsafe superpowers in turn. We‚Äôll also look "
"at\n"
"some abstractions that provide a safe interface to unsafe code."
msgstr ""

#: src/ch19-01-unsafe-rust.md:68
msgid "### Dereferencing a Raw Pointer"
msgstr ""

#: src/ch19-01-unsafe-rust.md:70
msgid ""
"In Chapter 4, in the [‚ÄúDangling References‚Äù][dangling-references]<!-- "
"ignore\n"
"--> section, we mentioned that the compiler ensures references are always\n"
"valid. Unsafe Rust has two new types called *raw pointers* that are similar "
"to\n"
"references. As with references, raw pointers can be immutable or mutable "
"and\n"
"are written as `*const T` and `*mut T`, respectively. The asterisk isn‚Äôt "
"the\n"
"dereference operator; it‚Äôs part of the type name. In the context of raw\n"
"pointers, *immutable* means that the pointer can‚Äôt be directly assigned to\n"
"after being dereferenced."
msgstr ""

#: src/ch19-01-unsafe-rust.md:79
msgid "Different from references and smart pointers, raw pointers:"
msgstr ""

#: src/ch19-01-unsafe-rust.md:81
msgid ""
"* Are allowed to ignore the borrowing rules by having both immutable and\n"
"  mutable pointers or multiple mutable pointers to the same location\n"
"* Aren‚Äôt guaranteed to point to valid memory\n"
"* Are allowed to be null\n"
"* Don‚Äôt implement any automatic cleanup"
msgstr ""

#: src/ch19-01-unsafe-rust.md:87
msgid ""
"By opting out of having Rust enforce these guarantees, you can give up\n"
"guaranteed safety in exchange for greater performance or the ability to\n"
"interface with another language or hardware where Rust‚Äôs guarantees don‚Äôt "
"apply."
msgstr ""

#: src/ch19-01-unsafe-rust.md:91
msgid ""
"Listing 19-1 shows how to create an immutable and a mutable raw pointer "
"from\n"
"references."
msgstr ""

#: src/ch19-01-unsafe-rust.md:94
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &num as *const i32;\n"
"    let r2 = &mut num as *mut i32;\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:103
msgid ""
"<span class=\"caption\">Listing 19-1: Creating raw pointers from references</"
"span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:105
msgid ""
"Notice that we don‚Äôt include the `unsafe` keyword in this code. We can "
"create\n"
"raw pointers in safe code; we just can‚Äôt dereference raw pointers outside "
"an\n"
"unsafe block, as you‚Äôll see in a bit."
msgstr ""

#: src/ch19-01-unsafe-rust.md:109
msgid ""
"We‚Äôve created raw pointers by using `as` to cast an immutable and a mutable\n"
"reference into their corresponding raw pointer types. Because we created "
"them\n"
"directly from references guaranteed to be valid, we know these particular "
"raw\n"
"pointers are valid, but we can‚Äôt make that assumption about just any raw\n"
"pointer."
msgstr ""

#: src/ch19-01-unsafe-rust.md:115
msgid ""
"To demonstrate this, next we‚Äôll create a raw pointer whose validity we can‚Äôt "
"be\n"
"so certain of. Listing 19-2 shows how to create a raw pointer to an "
"arbitrary\n"
"location in memory. Trying to use arbitrary memory is undefined: there might "
"be\n"
"data at that address or there might not, the compiler might optimize the "
"code\n"
"so there is no memory access, or the program might error with a "
"segmentation\n"
"fault. Usually, there is no good reason to write code like this, but it is\n"
"possible."
msgstr ""

#: src/ch19-01-unsafe-rust.md:123
msgid ""
"```rust\n"
"# fn main() {\n"
"    let address = 0x012345usize;\n"
"    let r = address as *const i32;\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:130
msgid ""
"<span class=\"caption\">Listing 19-2: Creating a raw pointer to an "
"arbitrary\n"
"memory address</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:133
msgid ""
"Recall that we can create raw pointers in safe code, but we can‚Äôt "
"*dereference*\n"
"raw pointers and read the data being pointed to. In Listing 19-3, we use "
"the\n"
"dereference operator `*` on a raw pointer that requires an `unsafe` block."
msgstr ""

#: src/ch19-01-unsafe-rust.md:137
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &num as *const i32;\n"
"    let r2 = &mut num as *mut i32;\n"
"\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:151
msgid ""
"<span class=\"caption\">Listing 19-3: Dereferencing raw pointers within an\n"
"`unsafe` block</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:154
msgid ""
"Creating a pointer does no harm; it‚Äôs only when we try to access the value "
"that\n"
"it points at that we might end up dealing with an invalid value."
msgstr ""

#: src/ch19-01-unsafe-rust.md:157
msgid ""
"Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut "
"i32`\n"
"raw pointers that both pointed to the same memory location, where `num` is\n"
"stored. If we instead tried to create an immutable and a mutable reference "
"to\n"
"`num`, the code would not have compiled because Rust‚Äôs ownership rules "
"don‚Äôt\n"
"allow a mutable reference at the same time as any immutable references. "
"With\n"
"raw pointers, we can create a mutable pointer and an immutable pointer to "
"the\n"
"same location and change data through the mutable pointer, potentially "
"creating\n"
"a data race. Be careful!"
msgstr ""

#: src/ch19-01-unsafe-rust.md:166
msgid ""
"With all of these dangers, why would you ever use raw pointers? One major "
"use\n"
"case is when interfacing with C code, as you‚Äôll see in the next section,\n"
"[‚ÄúCalling an Unsafe Function or\n"
"Method.‚Äù](#calling-an-unsafe-function-or-method)<!-- ignore --> Another case "
"is\n"
"when building up safe abstractions that the borrow checker doesn‚Äôt "
"understand.\n"
"We‚Äôll introduce unsafe functions and then look at an example of a safe\n"
"abstraction that uses unsafe code."
msgstr ""

#: src/ch19-01-unsafe-rust.md:174
msgid "### Calling an Unsafe Function or Method"
msgstr ""

#: src/ch19-01-unsafe-rust.md:176
msgid ""
"The second type of operation you can perform in an unsafe block is calling\n"
"unsafe functions. Unsafe functions and methods look exactly like regular\n"
"functions and methods, but they have an extra `unsafe` before the rest of "
"the\n"
"definition. The `unsafe` keyword in this context indicates the function has\n"
"requirements we need to uphold when we call this function, because Rust "
"can‚Äôt\n"
"guarantee we‚Äôve met these requirements. By calling an unsafe function within "
"an\n"
"`unsafe` block, we‚Äôre saying that we‚Äôve read this function‚Äôs documentation "
"and\n"
"take responsibility for upholding the function‚Äôs contracts."
msgstr ""

#: src/ch19-01-unsafe-rust.md:185
msgid ""
"Here is an unsafe function named `dangerous` that doesn‚Äôt do anything in "
"its\n"
"body:"
msgstr ""

#: src/ch19-01-unsafe-rust.md:188
msgid ""
"```rust\n"
"# fn main() {\n"
"    unsafe fn dangerous() {}\n"
"\n"
"    unsafe {\n"
"        dangerous();\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:198
msgid ""
"We must call the `dangerous` function within a separate `unsafe` block. If "
"we\n"
"try to call `dangerous` without the `unsafe` block, we‚Äôll get an error:"
msgstr ""

#: src/ch19-01-unsafe-rust.md:201
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n"
"error[E0133]: call to unsafe function is unsafe and requires unsafe function "
"or block\n"
" --> src/main.rs:4:5\n"
"  |\n"
"4 |     dangerous();\n"
"  |     ^^^^^^^^^^^ call to unsafe function\n"
"  |\n"
"  = note: consult the function's documentation for information on how to "
"avoid undefined behavior\n"
"\n"
"For more information about this error, try `rustc --explain E0133`.\n"
"error: could not compile `unsafe-example` due to previous error\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:216
msgid ""
"With the `unsafe` block, we‚Äôre asserting to Rust that we‚Äôve read the "
"function‚Äôs\n"
"documentation, we understand how to use it properly, and we‚Äôve verified "
"that\n"
"we‚Äôre fulfilling the contract of the function."
msgstr ""

#: src/ch19-01-unsafe-rust.md:220
msgid ""
"Bodies of unsafe functions are effectively `unsafe` blocks, so to perform "
"other\n"
"unsafe operations within an unsafe function, we don‚Äôt need to add another\n"
"`unsafe` block."
msgstr ""

#: src/ch19-01-unsafe-rust.md:224
msgid "#### Creating a Safe Abstraction over Unsafe Code"
msgstr ""

#: src/ch19-01-unsafe-rust.md:226
msgid ""
"Just because a function contains unsafe code doesn‚Äôt mean we need to mark "
"the\n"
"entire function as unsafe. In fact, wrapping unsafe code in a safe function "
"is\n"
"a common abstraction. As an example, let‚Äôs study the `split_at_mut` "
"function\n"
"from the standard library, which requires some unsafe code. We‚Äôll explore "
"how\n"
"we might implement it. This safe method is defined on mutable slices: it "
"takes\n"
"one slice and makes it two by splitting the slice at the index given as an\n"
"argument. Listing 19-4 shows how to use `split_at_mut`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:234
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut v = vec![1, 2, 3, 4, 5, 6];\n"
"\n"
"    let r = &mut v[..];\n"
"\n"
"    let (a, b) = r.split_at_mut(3);\n"
"\n"
"    assert_eq!(a, &mut [1, 2, 3]);\n"
"    assert_eq!(b, &mut [4, 5, 6]);\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:247
msgid ""
"<span class=\"caption\">Listing 19-4: Using the safe `split_at_mut`\n"
"function</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:250
msgid ""
"We can‚Äôt implement this function using only safe Rust. An attempt might "
"look\n"
"something like Listing 19-5, which won‚Äôt compile. For simplicity, we‚Äôll\n"
"implement `split_at_mut` as a function rather than a method and only for "
"slices\n"
"of `i32` values rather than for a generic type `T`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:255
msgid ""
"```rust,ignore,does_not_compile\n"
"fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) "
"{\n"
"    let len = values.len();\n"
"\n"
"    assert!(mid <= len);\n"
"\n"
"    (&mut values[..mid], &mut values[mid..])\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let mut vector = vec![1, 2, 3, 4, 5, 6];\n"
"#     let (left, right) = split_at_mut(&mut vector, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:270
msgid ""
"<span class=\"caption\">Listing 19-5: An attempted implementation of\n"
"`split_at_mut` using only safe Rust</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:273
msgid ""
"This function first gets the total length of the slice. Then it asserts "
"that\n"
"the index given as a parameter is within the slice by checking whether it‚Äôs\n"
"less than or equal to the length. The assertion means that if we pass an "
"index\n"
"that is greater than the length to split the slice at, the function will "
"panic\n"
"before it attempts to use that index."
msgstr ""

#: src/ch19-01-unsafe-rust.md:279
msgid ""
"Then we return two mutable slices in a tuple: one from the start of the\n"
"original slice to the `mid` index and another from `mid` to the end of the\n"
"slice."
msgstr ""

#: src/ch19-01-unsafe-rust.md:283
msgid "When we try to compile the code in Listing 19-5, we‚Äôll get an error."
msgstr ""

#: src/ch19-01-unsafe-rust.md:285
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n"
"error[E0499]: cannot borrow `*values` as mutable more than once at a time\n"
" --> src/main.rs:6:31\n"
"  |\n"
"1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut "
"[i32]) {\n"
"  |                         - let's call the lifetime of this reference "
"`'1`\n"
"...\n"
"6 |     (&mut values[..mid], &mut values[mid..])\n"
"  |     --------------------------^^^^^^--------\n"
"  |     |     |                   |\n"
"  |     |     |                   second mutable borrow occurs here\n"
"  |     |     first mutable borrow occurs here\n"
"  |     returning this value requires that `*values` is borrowed for `'1`\n"
"\n"
"For more information about this error, try `rustc --explain E0499`.\n"
"error: could not compile `unsafe-example` due to previous error\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:305
msgid ""
"Rust‚Äôs borrow checker can‚Äôt understand that we‚Äôre borrowing different parts "
"of\n"
"the slice; it only knows that we‚Äôre borrowing from the same slice twice.\n"
"Borrowing different parts of a slice is fundamentally okay because the two\n"
"slices aren‚Äôt overlapping, but Rust isn‚Äôt smart enough to know this. When "
"we\n"
"know code is okay, but Rust doesn‚Äôt, it‚Äôs time to reach for unsafe code."
msgstr ""

#: src/ch19-01-unsafe-rust.md:311
msgid ""
"Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some "
"calls\n"
"to unsafe functions to make the implementation of `split_at_mut` work."
msgstr ""

#: src/ch19-01-unsafe-rust.md:314
msgid ""
"```rust\n"
"use std::slice;\n"
"\n"
"fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) "
"{\n"
"    let len = values.len();\n"
"    let ptr = values.as_mut_ptr();\n"
"\n"
"    assert!(mid <= len);\n"
"\n"
"    unsafe {\n"
"        (\n"
"            slice::from_raw_parts_mut(ptr, mid),\n"
"            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n"
"        )\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let mut vector = vec![1, 2, 3, 4, 5, 6];\n"
"#     let (left, right) = split_at_mut(&mut vector, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:337
msgid ""
"<span class=\"caption\">Listing 19-6: Using unsafe code in the "
"implementation of\n"
"the `split_at_mut` function</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:340
msgid ""
"Recall from [‚ÄúThe Slice Type‚Äù][the-slice-type]<!-- ignore --> section in\n"
"Chapter 4 that slices are a pointer to some data and the length of the "
"slice.\n"
"We use the `len` method to get the length of a slice and the `as_mut_ptr`\n"
"method to access the raw pointer of a slice. In this case, because we have "
"a\n"
"mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the "
"type\n"
"`*mut i32`, which we‚Äôve stored in the variable `ptr`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:347
msgid ""
"We keep the assertion that the `mid` index is within the slice. Then we get "
"to\n"
"the unsafe code: the `slice::from_raw_parts_mut` function takes a raw "
"pointer\n"
"and a length, and it creates a slice. We use this function to create a "
"slice\n"
"that starts from `ptr` and is `mid` items long. Then we call the `add`\n"
"method on `ptr` with `mid` as an argument to get a raw pointer that starts "
"at\n"
"`mid`, and we create a slice using that pointer and the remaining number of\n"
"items after `mid` as the length."
msgstr ""

#: src/ch19-01-unsafe-rust.md:355
msgid ""
"The function `slice::from_raw_parts_mut` is unsafe because it takes a raw\n"
"pointer and must trust that this pointer is valid. The `add` method on raw\n"
"pointers is also unsafe, because it must trust that the offset location is "
"also\n"
"a valid pointer. Therefore, we had to put an `unsafe` block around our calls "
"to\n"
"`slice::from_raw_parts_mut` and `add` so we could call them. By looking at\n"
"the code and by adding the assertion that `mid` must be less than or equal "
"to\n"
"`len`, we can tell that all the raw pointers used within the `unsafe` block\n"
"will be valid pointers to data within the slice. This is an acceptable and\n"
"appropriate use of `unsafe`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:365
msgid ""
"Note that we don‚Äôt need to mark the resulting `split_at_mut` function as\n"
"`unsafe`, and we can call this function from safe Rust. We‚Äôve created a "
"safe\n"
"abstraction to the unsafe code with an implementation of the function that "
"uses\n"
"`unsafe` code in a safe way, because it creates only valid pointers from "
"the\n"
"data this function has access to."
msgstr ""

#: src/ch19-01-unsafe-rust.md:371
msgid ""
"In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would\n"
"likely crash when the slice is used. This code takes an arbitrary memory\n"
"location and creates a slice 10,000 items long."
msgstr ""

#: src/ch19-01-unsafe-rust.md:375
msgid ""
"```rust\n"
"# fn main() {\n"
"    use std::slice;\n"
"\n"
"    let address = 0x01234usize;\n"
"    let r = address as *mut i32;\n"
"\n"
"    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:386
msgid ""
"<span class=\"caption\">Listing 19-7: Creating a slice from an arbitrary "
"memory\n"
"location</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:389
msgid ""
"We don‚Äôt own the memory at this arbitrary location, and there is no "
"guarantee\n"
"that the slice this code creates contains valid `i32` values. Attempting to "
"use\n"
"`values` as though it‚Äôs a valid slice results in undefined behavior."
msgstr ""

#: src/ch19-01-unsafe-rust.md:393
msgid "#### Using `extern` Functions to Call External Code"
msgstr ""

#: src/ch19-01-unsafe-rust.md:395
msgid ""
"Sometimes, your Rust code might need to interact with code written in "
"another\n"
"language. For this, Rust has the keyword `extern` that facilitates the "
"creation\n"
"and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a\n"
"programming language to define functions and enable a different (foreign)\n"
"programming language to call those functions."
msgstr ""

#: src/ch19-01-unsafe-rust.md:401
msgid ""
"Listing 19-8 demonstrates how to set up an integration with the `abs` "
"function\n"
"from the C standard library. Functions declared within `extern` blocks are\n"
"always unsafe to call from Rust code. The reason is that other languages "
"don‚Äôt\n"
"enforce Rust‚Äôs rules and guarantees, and Rust can‚Äôt check them, so\n"
"responsibility falls on the programmer to ensure safety."
msgstr ""

#: src/ch19-01-unsafe-rust.md:409
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:421
msgid ""
"<span class=\"caption\">Listing 19-8: Declaring and calling an `extern` "
"function\n"
"defined in another language</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:424
msgid ""
"Within the `extern \"C\"` block, we list the names and signatures of "
"external\n"
"functions from another language we want to call. The `\"C\"` part defines "
"which\n"
"*application binary interface (ABI)* the external function uses: the ABI\n"
"defines how to call the function at the assembly level. The `\"C\"` ABI is "
"the\n"
"most common and follows the C programming language‚Äôs ABI."
msgstr ""

#: src/ch19-01-unsafe-rust.md:430
msgid ""
"> #### Calling Rust Functions from Other Languages\n"
">\n"
"> We can also use `extern` to create an interface that allows other "
"languages\n"
"> to call Rust functions. Instead of creating a whole `extern` block, we "
"add\n"
"> the `extern` keyword and specify the ABI to use just before the `fn` "
"keyword\n"
"> for the relevant function. We also need to add a `#[no_mangle]` annotation "
"to\n"
"> tell the Rust compiler not to mangle the name of this function. *Mangling* "
"is\n"
"> when a compiler changes the name we‚Äôve given a function to a different "
"name\n"
"> that contains more information for other parts of the compilation process "
"to\n"
"> consume but is less human readable. Every programming language compiler\n"
"> mangles names slightly differently, so for a Rust function to be nameable "
"by\n"
"> other languages, we must disable the Rust compiler‚Äôs name mangling.\n"
">\n"
"> In the following example, we make the `call_from_c` function accessible "
"from\n"
"> C code, after it‚Äôs compiled to a shared library and linked from C:\n"
">\n"
"> ```rust\n"
"> #[no_mangle]\n"
"> pub extern \"C\" fn call_from_c() {\n"
">     println!(\"Just called a Rust function from C!\");\n"
"> }\n"
"> ```\n"
">\n"
"> This usage of `extern` does not require `unsafe`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:455
msgid "### Accessing or Modifying a Mutable Static Variable"
msgstr ""

#: src/ch19-01-unsafe-rust.md:457
msgid ""
"In this book, we‚Äôve not yet talked about *global variables*, which Rust "
"does\n"
"support but can be problematic with Rust‚Äôs ownership rules. If two threads "
"are\n"
"accessing the same mutable global variable, it can cause a data race."
msgstr ""

#: src/ch19-01-unsafe-rust.md:461
msgid ""
"In Rust, global variables are called *static* variables. Listing 19-9 shows "
"an\n"
"example declaration and use of a static variable with a string slice as a\n"
"value."
msgstr ""

#: src/ch19-01-unsafe-rust.md:467
msgid ""
"```rust\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"name is: {}\", HELLO_WORLD);\n"
"}\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:475
msgid ""
"<span class=\"caption\">Listing 19-9: Defining and using an immutable "
"static\n"
"variable</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:478
msgid ""
"Static variables are similar to constants, which we discussed in the\n"
"[‚ÄúDifferences Between Variables and\n"
"Constants‚Äù][differences-between-variables-and-constants]<!-- ignore --> "
"section\n"
"in Chapter 3. The names of static variables are in `SCREAMING_SNAKE_CASE` "
"by\n"
"convention. Static variables can only store references with the `'static`\n"
"lifetime, which means the Rust compiler can figure out the lifetime and we\n"
"aren‚Äôt required to annotate it explicitly. Accessing an immutable static\n"
"variable is safe."
msgstr ""

#: src/ch19-01-unsafe-rust.md:487
msgid ""
"A subtle difference between constants and immutable static variables is "
"that\n"
"values in a static variable have a fixed address in memory. Using the value\n"
"will always access the same data. Constants, on the other hand, are allowed "
"to\n"
"duplicate their data whenever they‚Äôre used. Another difference is that "
"static\n"
"variables can be mutable. Accessing and modifying mutable static variables "
"is\n"
"*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable\n"
"static variable named `COUNTER`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:497
msgid ""
"```rust\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_count(inc: u32) {\n"
"    unsafe {\n"
"        COUNTER += inc;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_count(3);\n"
"\n"
"    unsafe {\n"
"        println!(\"COUNTER: {}\", COUNTER);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:515
msgid ""
"<span class=\"caption\">Listing 19-10: Reading from or writing to a mutable\n"
"static variable is unsafe</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:518
msgid ""
"As with regular variables, we specify mutability using the `mut` keyword. "
"Any\n"
"code that reads or writes from `COUNTER` must be within an `unsafe` block. "
"This\n"
"code compiles and prints `COUNTER: 3` as we would expect because it‚Äôs "
"single\n"
"threaded. Having multiple threads access `COUNTER` would likely result in "
"data\n"
"races."
msgstr ""

#: src/ch19-01-unsafe-rust.md:524
msgid ""
"With mutable data that is globally accessible, it‚Äôs difficult to ensure "
"there\n"
"are no data races, which is why Rust considers mutable static variables to "
"be\n"
"unsafe. Where possible, it‚Äôs preferable to use the concurrency techniques "
"and\n"
"thread-safe smart pointers we discussed in Chapter 16 so the compiler "
"checks\n"
"that data accessed from different threads is done safely."
msgstr ""

#: src/ch19-01-unsafe-rust.md:530
msgid "### Implementing an Unsafe Trait"
msgstr ""

#: src/ch19-01-unsafe-rust.md:532
msgid ""
"We can use `unsafe` to implement an unsafe trait. A trait is unsafe when at\n"
"least one of its methods has some invariant that the compiler can‚Äôt verify. "
"We\n"
"declare that a trait is `unsafe` by adding the `unsafe` keyword before "
"`trait`\n"
"and marking the implementation of the trait as `unsafe` too, as shown in\n"
"Listing 19-11."
msgstr ""

#: src/ch19-01-unsafe-rust.md:538
msgid ""
"```rust\n"
"unsafe trait Foo {\n"
"    // methods go here\n"
"}\n"
"\n"
"unsafe impl Foo for i32 {\n"
"    // method implementations go here\n"
"}\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/ch19-01-unsafe-rust.md:550
msgid ""
"<span class=\"caption\">Listing 19-11: Defining and implementing an unsafe\n"
"trait</span>"
msgstr ""

#: src/ch19-01-unsafe-rust.md:553
msgid ""
"By using `unsafe impl`, we‚Äôre promising that we‚Äôll uphold the invariants "
"that\n"
"the compiler can‚Äôt verify."
msgstr ""

#: src/ch19-01-unsafe-rust.md:556
msgid ""
"As an example, recall the `Sync` and `Send` marker traits we discussed in "
"the\n"
"[‚ÄúExtensible Concurrency with the `Sync` and `Send`\n"
"Traits‚Äù][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore --"
">\n"
"section in Chapter 16: the compiler implements these traits automatically "
"if\n"
"our types are composed entirely of `Send` and `Sync` types. If we implement "
"a\n"
"type that contains a type that is not `Send` or `Sync`, such as raw "
"pointers,\n"
"and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. "
"Rust\n"
"can‚Äôt verify that our type upholds the guarantees that it can be safely "
"sent\n"
"across threads or accessed from multiple threads; therefore, we need to do\n"
"those checks manually and indicate as such with `unsafe`."
msgstr ""

#: src/ch19-01-unsafe-rust.md:567
msgid "### Accessing Fields of a Union"
msgstr ""

#: src/ch19-01-unsafe-rust.md:569
msgid ""
"The final action that works only with `unsafe` is accessing fields of a\n"
"*union*. A `union` is similar to a `struct`, but only one declared field is\n"
"used in a particular instance at one time. Unions are primarily used to\n"
"interface with unions in C code. Accessing union fields is unsafe because "
"Rust\n"
"can‚Äôt guarantee the type of the data currently being stored in the union\n"
"instance. You can learn more about unions in [the Rust Reference][reference]."
msgstr ""

#: src/ch19-01-unsafe-rust.md:576
msgid "### When to Use Unsafe Code"
msgstr ""

#: src/ch19-01-unsafe-rust.md:578
msgid ""
"Using `unsafe` to take one of the five actions (superpowers) just discussed\n"
"isn‚Äôt wrong or even frowned upon. But it is trickier to get `unsafe` code\n"
"correct because the compiler can‚Äôt help uphold memory safety. When you have "
"a\n"
"reason to use `unsafe` code, you can do so, and having the explicit "
"`unsafe`\n"
"annotation makes it easier to track down the source of problems when they "
"occur."
msgstr ""

#: src/ch19-03-advanced-traits.md:1
msgid "## Advanced Traits"
msgstr ""

#: src/ch19-03-advanced-traits.md:3
msgid ""
"We first covered traits in the [‚ÄúTraits: Defining Shared\n"
"Behavior‚Äù][traits-defining-shared-behavior]<!-- ignore --> section of "
"Chapter\n"
"10, but we didn‚Äôt discuss the more advanced details. Now that you know more\n"
"about Rust, we can get into the nitty-gritty."
msgstr ""

#: src/ch19-03-advanced-traits.md:8
msgid ""
"### Specifying Placeholder Types in Trait Definitions with Associated Types"
msgstr ""

#: src/ch19-03-advanced-traits.md:10
msgid ""
"*Associated types* connect a type placeholder with a trait such that the "
"trait\n"
"method definitions can use these placeholder types in their signatures. The\n"
"implementor of a trait will specify the concrete type to be used instead of "
"the\n"
"placeholder type for the particular implementation. That way, we can define "
"a\n"
"trait that uses some types without needing to know exactly what those types "
"are\n"
"until the trait is implemented."
msgstr ""

#: src/ch19-03-advanced-traits.md:17
msgid ""
"We‚Äôve described most of the advanced features in this chapter as being "
"rarely\n"
"needed. Associated types are somewhere in the middle: they‚Äôre used more "
"rarely\n"
"than features explained in the rest of the book but more commonly than many "
"of\n"
"the other features discussed in this chapter."
msgstr ""

#: src/ch19-03-advanced-traits.md:22
msgid ""
"One example of a trait with an associated type is the `Iterator` trait that "
"the\n"
"standard library provides. The associated type is named `Item` and stands "
"in\n"
"for the type of the values the type implementing the `Iterator` trait is\n"
"iterating over. The definition of the `Iterator` trait is as shown in "
"Listing\n"
"19-12."
msgstr ""

#: src/ch19-03-advanced-traits.md:28
msgid ""
"```rust,noplayground\n"
"pub trait Iterator {\n"
"    type Item;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:36
msgid ""
"<span class=\"caption\">Listing 19-12: The definition of the `Iterator` "
"trait\n"
"that has an associated type `Item`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:39
msgid ""
"The type `Item` is a placeholder, and the `next` method‚Äôs definition shows "
"that\n"
"it will return values of type `Option<Self::Item>`. Implementors of the\n"
"`Iterator` trait will specify the concrete type for `Item`, and the `next`\n"
"method will return an `Option` containing a value of that concrete type."
msgstr ""

#: src/ch19-03-advanced-traits.md:44
msgid ""
"Associated types might seem like a similar concept to generics, in that the\n"
"latter allow us to define a function without specifying what types it can\n"
"handle. To examine the difference between the two concepts, we‚Äôll look at "
"an\n"
"implementation of the `Iterator` trait on a type named `Counter` that "
"specifies\n"
"the `Item` type is `u32`:"
msgstr ""

#: src/ch19-03-advanced-traits.md:52
msgid ""
"```rust,ignore\n"
"# struct Counter {\n"
"#     count: u32,\n"
"# }\n"
"# \n"
"# impl Counter {\n"
"#     fn new() -> Counter {\n"
"#         Counter { count: 0 }\n"
"#     }\n"
"# }\n"
"# \n"
"impl Iterator for Counter {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        // --snip--\n"
"#         if self.count < 5 {\n"
"#             self.count += 1;\n"
"#             Some(self.count)\n"
"#         } else {\n"
"#             None\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:78
msgid ""
"This syntax seems comparable to that of generics. So why not just define "
"the\n"
"`Iterator` trait with generics, as shown in Listing 19-13?"
msgstr ""

#: src/ch19-03-advanced-traits.md:81
msgid ""
"```rust,noplayground\n"
"pub trait Iterator<T> {\n"
"    fn next(&mut self) -> Option<T>;\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:87
msgid ""
"<span class=\"caption\">Listing 19-13: A hypothetical definition of the\n"
"`Iterator` trait using generics</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:90
msgid ""
"The difference is that when using generics, as in Listing 19-13, we must\n"
"annotate the types in each implementation; because we can also implement\n"
"`Iterator<String> for Counter` or any other type, we could have multiple\n"
"implementations of `Iterator` for `Counter`. In other words, when a trait "
"has a\n"
"generic parameter, it can be implemented for a type multiple times, "
"changing\n"
"the concrete types of the generic type parameters each time. When we use "
"the\n"
"`next` method on `Counter`, we would have to provide type annotations to\n"
"indicate which implementation of `Iterator` we want to use."
msgstr ""

#: src/ch19-03-advanced-traits.md:99
msgid ""
"With associated types, we don‚Äôt need to annotate types because we can‚Äôt\n"
"implement a trait on a type multiple times. In Listing 19-12 with the\n"
"definition that uses associated types, we can only choose what the type of\n"
"`Item` will be once, because there can only be one `impl Iterator for "
"Counter`.\n"
"We don‚Äôt have to specify that we want an iterator of `u32` values "
"everywhere\n"
"that we call `next` on `Counter`."
msgstr ""

#: src/ch19-03-advanced-traits.md:106
msgid ""
"Associated types also become part of the trait‚Äôs contract: implementors of "
"the\n"
"trait must provide a type to stand in for the associated type placeholder.\n"
"Associated types often have a name that describes how the type will be "
"used,\n"
"and documenting the associated type in the API documentation is good "
"practice."
msgstr ""

#: src/ch19-03-advanced-traits.md:111
msgid "### Default Generic Type Parameters and Operator Overloading"
msgstr ""

#: src/ch19-03-advanced-traits.md:113
msgid ""
"When we use generic type parameters, we can specify a default concrete type "
"for\n"
"the generic type. This eliminates the need for implementors of the trait to\n"
"specify a concrete type if the default type works. You specify a default "
"type\n"
"when declaring a generic type with the `<PlaceholderType=ConcreteType>` "
"syntax."
msgstr ""

#: src/ch19-03-advanced-traits.md:118
msgid ""
"A great example of a situation where this technique is useful is with "
"*operator\n"
"overloading*, in which you customize the behavior of an operator (such as "
"`+`)\n"
"in particular situations."
msgstr ""

#: src/ch19-03-advanced-traits.md:122
msgid ""
"Rust doesn‚Äôt allow you to create your own operators or overload arbitrary\n"
"operators. But you can overload the operations and corresponding traits "
"listed\n"
"in `std::ops` by implementing the traits associated with the operator. For\n"
"example, in Listing 19-14 we overload the `+` operator to add two `Point`\n"
"instances together. We do this by implementing the `Add` trait on a `Point`\n"
"struct:"
msgstr ""

#: src/ch19-03-advanced-traits.md:131
msgid ""
"```rust\n"
"use std::ops::Add;\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq)]\n"
"struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"impl Add for Point {\n"
"    type Output = Point;\n"
"\n"
"    fn add(self, other: Point) -> Point {\n"
"        Point {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(\n"
"        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n"
"        Point { x: 3, y: 3 }\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:159
msgid ""
"<span class=\"caption\">Listing 19-14: Implementing the `Add` trait to "
"overload\n"
"the `+` operator for `Point` instances</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:162
msgid ""
"The `add` method adds the `x` values of two `Point` instances and the `y`\n"
"values of two `Point` instances to create a new `Point`. The `Add` trait has "
"an\n"
"associated type named `Output` that determines the type returned from the "
"`add`\n"
"method."
msgstr ""

#: src/ch19-03-advanced-traits.md:167
msgid ""
"The default generic type in this code is within the `Add` trait. Here is "
"its\n"
"definition:"
msgstr ""

#: src/ch19-03-advanced-traits.md:170
msgid ""
"```rust\n"
"trait Add<Rhs=Self> {\n"
"    type Output;\n"
"\n"
"    fn add(self, rhs: Rhs) -> Self::Output;\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:178
msgid ""
"This code should look generally familiar: a trait with one method and an\n"
"associated type. The new part is `Rhs=Self`: this syntax is called *default\n"
"type parameters*. The `Rhs` generic type parameter (short for ‚Äúright hand\n"
"side‚Äù) defines the type of the `rhs` parameter in the `add` method. If we "
"don‚Äôt\n"
"specify a concrete type for `Rhs` when we implement the `Add` trait, the "
"type\n"
"of `Rhs` will default to `Self`, which will be the type we‚Äôre implementing\n"
"`Add` on."
msgstr ""

#: src/ch19-03-advanced-traits.md:186
msgid ""
"When we implemented `Add` for `Point`, we used the default for `Rhs` because "
"we\n"
"wanted to add two `Point` instances. Let‚Äôs look at an example of "
"implementing\n"
"the `Add` trait where we want to customize the `Rhs` type rather than using "
"the\n"
"default."
msgstr ""

#: src/ch19-03-advanced-traits.md:191
msgid ""
"We have two structs, `Millimeters` and `Meters`, holding values in "
"different\n"
"units. This thin wrapping of an existing type in another struct is known as "
"the\n"
"*newtype pattern*, which we describe in more detail in the [‚ÄúUsing the "
"Newtype\n"
"Pattern to Implement External Traits on External Types‚Äù][newtype]<!-- "
"ignore\n"
"--> section. We want to add values in millimeters to values in meters and "
"have\n"
"the implementation of `Add` do the conversion correctly. We can implement "
"`Add`\n"
"for `Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15."
msgstr ""

#: src/ch19-03-advanced-traits.md:201
msgid ""
"```rust,noplayground\n"
"use std::ops::Add;\n"
"\n"
"struct Millimeters(u32);\n"
"struct Meters(u32);\n"
"\n"
"impl Add<Meters> for Millimeters {\n"
"    type Output = Millimeters;\n"
"\n"
"    fn add(self, other: Meters) -> Millimeters {\n"
"        Millimeters(self.0 + (other.0 * 1000))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:216
msgid ""
"<span class=\"caption\">Listing 19-15: Implementing the `Add` trait on\n"
"`Millimeters` to add `Millimeters` to `Meters`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:219
msgid ""
"To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the\n"
"value of the `Rhs` type parameter instead of using the default of `Self`."
msgstr ""

#: src/ch19-03-advanced-traits.md:222
msgid "You‚Äôll use default type parameters in two main ways:"
msgstr ""

#: src/ch19-03-advanced-traits.md:224
msgid ""
"* To extend a type without breaking existing code\n"
"* To allow customization in specific cases most users won‚Äôt need"
msgstr ""

#: src/ch19-03-advanced-traits.md:227
msgid ""
"The standard library‚Äôs `Add` trait is an example of the second purpose:\n"
"usually, you‚Äôll add two like types, but the `Add` trait provides the ability "
"to\n"
"customize beyond that. Using a default type parameter in the `Add` trait\n"
"definition means you don‚Äôt have to specify the extra parameter most of the\n"
"time. In other words, a bit of implementation boilerplate isn‚Äôt needed, "
"making\n"
"it easier to use the trait."
msgstr ""

#: src/ch19-03-advanced-traits.md:234
msgid ""
"The first purpose is similar to the second but in reverse: if you want to "
"add a\n"
"type parameter to an existing trait, you can give it a default to allow\n"
"extension of the functionality of the trait without breaking the existing\n"
"implementation code."
msgstr ""

#: src/ch19-03-advanced-traits.md:239
msgid ""
"### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same "
"Name"
msgstr ""

#: src/ch19-03-advanced-traits.md:241
msgid ""
"Nothing in Rust prevents a trait from having a method with the same name as\n"
"another trait‚Äôs method, nor does Rust prevent you from implementing both "
"traits\n"
"on one type. It‚Äôs also possible to implement a method directly on the type "
"with\n"
"the same name as methods from traits."
msgstr ""

#: src/ch19-03-advanced-traits.md:246
msgid ""
"When calling methods with the same name, you‚Äôll need to tell Rust which one "
"you\n"
"want to use. Consider the code in Listing 19-16 where we‚Äôve defined two "
"traits,\n"
"`Pilot` and `Wizard`, that both have a method called `fly`. We then "
"implement\n"
"both traits on a type `Human` that already has a method named `fly` "
"implemented\n"
"on it. Each `fly` method does something different."
msgstr ""

#: src/ch19-03-advanced-traits.md:254
msgid ""
"```rust\n"
"trait Pilot {\n"
"    fn fly(&self);\n"
"}\n"
"\n"
"trait Wizard {\n"
"    fn fly(&self);\n"
"}\n"
"\n"
"struct Human;\n"
"\n"
"impl Pilot for Human {\n"
"    fn fly(&self) {\n"
"        println!(\"This is your captain speaking.\");\n"
"    }\n"
"}\n"
"\n"
"impl Wizard for Human {\n"
"    fn fly(&self) {\n"
"        println!(\"Up!\");\n"
"    }\n"
"}\n"
"\n"
"impl Human {\n"
"    fn fly(&self) {\n"
"        println!(\"*waving arms furiously*\");\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:286
msgid ""
"<span class=\"caption\">Listing 19-16: Two traits are defined to have a "
"`fly`\n"
"method and are implemented on the `Human` type, and a `fly` method is\n"
"implemented on `Human` directly</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:290
msgid ""
"When we call `fly` on an instance of `Human`, the compiler defaults to "
"calling\n"
"the method that is directly implemented on the type, as shown in Listing "
"19-17."
msgstr ""

#: src/ch19-03-advanced-traits.md:295
msgid ""
"```rust\n"
"# trait Pilot {\n"
"#     fn fly(&self);\n"
"# }\n"
"# \n"
"# trait Wizard {\n"
"#     fn fly(&self);\n"
"# }\n"
"# \n"
"# struct Human;\n"
"# \n"
"# impl Pilot for Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"This is your captain speaking.\");\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Wizard for Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"Up!\");\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"*waving arms furiously*\");\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let person = Human;\n"
"    person.fly();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:330
msgid ""
"<span class=\"caption\">Listing 19-17: Calling `fly` on an instance of\n"
"`Human`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:333
msgid ""
"Running this code will print `*waving arms furiously*`, showing that Rust\n"
"called the `fly` method implemented on `Human` directly."
msgstr ""

#: src/ch19-03-advanced-traits.md:336
msgid ""
"To call the `fly` methods from either the `Pilot` trait or the `Wizard` "
"trait,\n"
"we need to use more explicit syntax to specify which `fly` method we mean.\n"
"Listing 19-18 demonstrates this syntax."
msgstr ""

#: src/ch19-03-advanced-traits.md:342
msgid ""
"```rust\n"
"# trait Pilot {\n"
"#     fn fly(&self);\n"
"# }\n"
"# \n"
"# trait Wizard {\n"
"#     fn fly(&self);\n"
"# }\n"
"# \n"
"# struct Human;\n"
"# \n"
"# impl Pilot for Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"This is your captain speaking.\");\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Wizard for Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"Up!\");\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Human {\n"
"#     fn fly(&self) {\n"
"#         println!(\"*waving arms furiously*\");\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let person = Human;\n"
"    Pilot::fly(&person);\n"
"    Wizard::fly(&person);\n"
"    person.fly();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:379
msgid ""
"<span class=\"caption\">Listing 19-18: Specifying which trait‚Äôs `fly` method "
"we\n"
"want to call</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:382
msgid ""
"Specifying the trait name before the method name clarifies to Rust which\n"
"implementation of `fly` we want to call. We could also write\n"
"`Human::fly(&person)`, which is equivalent to the `person.fly()` that we "
"used\n"
"in Listing 19-18, but this is a bit longer to write if we don‚Äôt need to\n"
"disambiguate."
msgstr ""

#: src/ch19-03-advanced-traits.md:388
msgid "Running this code prints the following:"
msgstr ""

#: src/ch19-03-advanced-traits.md:390
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.46s\n"
"     Running `target/debug/traits-example`\n"
"This is your captain speaking.\n"
"Up!\n"
"*waving arms furiously*\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:400
msgid ""
"Because the `fly` method takes a `self` parameter, if we had two *types* "
"that\n"
"both implement one *trait*, Rust could figure out which implementation of a\n"
"trait to use based on the type of `self`."
msgstr ""

#: src/ch19-03-advanced-traits.md:404
msgid ""
"However, associated functions that are not methods don‚Äôt have a `self`\n"
"parameter. When there are multiple types or traits that define non-method\n"
"functions with the same function name, Rust doesn't always know which type "
"you\n"
"mean unless you use *fully qualified syntax*. For example, in Listing 19-19 "
"we\n"
"create a trait for an animal shelter that wants to name all baby dogs "
"*Spot*.\n"
"We make an `Animal` trait with an associated non-method function "
"`baby_name`.\n"
"The `Animal` trait is implemented for the struct `Dog`, on which we also\n"
"provide an associated non-method function `baby_name` directly."
msgstr ""

#: src/ch19-03-advanced-traits.md:415
msgid ""
"```rust\n"
"trait Animal {\n"
"    fn baby_name() -> String;\n"
"}\n"
"\n"
"struct Dog;\n"
"\n"
"impl Dog {\n"
"    fn baby_name() -> String {\n"
"        String::from(\"Spot\")\n"
"    }\n"
"}\n"
"\n"
"impl Animal for Dog {\n"
"    fn baby_name() -> String {\n"
"        String::from(\"puppy\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"A baby dog is called a {}\", Dog::baby_name());\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:439
msgid ""
"<span class=\"caption\">Listing 19-19: A trait with an associated function "
"and a\n"
"type with an associated function of the same name that also implements the\n"
"trait</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:443
msgid ""
"We implement the code for naming all puppies Spot in the `baby_name` "
"associated\n"
"function that is defined on `Dog`. The `Dog` type also implements the trait\n"
"`Animal`, which describes characteristics that all animals have. Baby dogs "
"are\n"
"called puppies, and that is expressed in the implementation of the `Animal`\n"
"trait on `Dog` in the `baby_name` function associated with the `Animal` "
"trait."
msgstr ""

#: src/ch19-03-advanced-traits.md:449
msgid ""
"In `main`, we call the `Dog::baby_name` function, which calls the "
"associated\n"
"function defined on `Dog` directly. This code prints the following:"
msgstr ""

#: src/ch19-03-advanced-traits.md:452
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.54s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a Spot\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:460
msgid ""
"This output isn‚Äôt what we wanted. We want to call the `baby_name` function "
"that\n"
"is part of the `Animal` trait that we implemented on `Dog` so the code "
"prints\n"
"`A baby dog is called a puppy`. The technique of specifying the trait name "
"that\n"
"we used in Listing 19-18 doesn‚Äôt help here; if we change `main` to the code "
"in\n"
"Listing 19-20, we‚Äôll get a compilation error."
msgstr ""

#: src/ch19-03-advanced-traits.md:468
msgid ""
"```rust,ignore,does_not_compile\n"
"# trait Animal {\n"
"#     fn baby_name() -> String;\n"
"# }\n"
"# \n"
"# struct Dog;\n"
"# \n"
"# impl Dog {\n"
"#     fn baby_name() -> String {\n"
"#         String::from(\"Spot\")\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Animal for Dog {\n"
"#     fn baby_name() -> String {\n"
"#         String::from(\"puppy\")\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    println!(\"A baby dog is called a {}\", Animal::baby_name());\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:492
msgid ""
"<span class=\"caption\">Listing 19-20: Attempting to call the `baby_name`\n"
"function from the `Animal` trait, but Rust doesn‚Äôt know which implementation "
"to\n"
"use</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:496
msgid ""
"Because `Animal::baby_name` doesn‚Äôt have a `self` parameter, and there could "
"be\n"
"other types that implement the `Animal` trait, Rust can‚Äôt figure out which\n"
"implementation of `Animal::baby_name` we want. We‚Äôll get this compiler error:"
msgstr ""

#: src/ch19-03-advanced-traits.md:500
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0790]: cannot call associated function on trait without specifying "
"the corresponding `impl` type\n"
"  --> src/main.rs:20:43\n"
"   |\n"
"2  |     fn baby_name() -> String;\n"
"   |     ------------------------- `Animal::baby_name` defined here\n"
"...\n"
"20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n"
"   |                                           ^^^^^^^^^^^^^^^^^ cannot call "
"associated function of trait\n"
"   |\n"
"help: use the fully-qualified path to the only available implementation\n"
"   |\n"
"20 |     println!(\"A baby dog is called a {}\", <Dog as Animal>::"
"baby_name());\n"
"   |                                           +++++++       +\n"
"\n"
"For more information about this error, try `rustc --explain E0790`.\n"
"error: could not compile `traits-example` due to previous error\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:521
msgid ""
"To disambiguate and tell Rust that we want to use the implementation of\n"
"`Animal` for `Dog` as opposed to the implementation of `Animal` for some "
"other\n"
"type, we need to use fully qualified syntax. Listing 19-21 demonstrates how "
"to\n"
"use fully qualified syntax."
msgstr ""

#: src/ch19-03-advanced-traits.md:528
msgid ""
"```rust\n"
"# trait Animal {\n"
"#     fn baby_name() -> String;\n"
"# }\n"
"# \n"
"# struct Dog;\n"
"# \n"
"# impl Dog {\n"
"#     fn baby_name() -> String {\n"
"#         String::from(\"Spot\")\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Animal for Dog {\n"
"#     fn baby_name() -> String {\n"
"#         String::from(\"puppy\")\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:552
msgid ""
"<span class=\"caption\">Listing 19-21: Using fully qualified syntax to "
"specify\n"
"that we want to call the `baby_name` function from the `Animal` trait as\n"
"implemented on `Dog`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:556
msgid ""
"We‚Äôre providing Rust with a type annotation within the angle brackets, "
"which\n"
"indicates we want to call the `baby_name` method from the `Animal` trait as\n"
"implemented on `Dog` by saying that we want to treat the `Dog` type as an\n"
"`Animal` for this function call. This code will now print what we want:"
msgstr ""

#: src/ch19-03-advanced-traits.md:561
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a puppy\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:569
msgid "In general, fully qualified syntax is defined as follows:"
msgstr ""

#: src/ch19-03-advanced-traits.md:571
msgid ""
"```rust,ignore\n"
"<Type as Trait>::function(receiver_if_method, next_arg, ...);\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:575
msgid ""
"For associated functions that aren‚Äôt methods, there would not be a "
"`receiver`:\n"
"there would only be the list of other arguments. You could use fully "
"qualified\n"
"syntax everywhere that you call functions or methods. However, you‚Äôre "
"allowed\n"
"to omit any part of this syntax that Rust can figure out from other "
"information\n"
"in the program. You only need to use this more verbose syntax in cases "
"where\n"
"there are multiple implementations that use the same name and Rust needs "
"help\n"
"to identify which implementation you want to call."
msgstr ""

#: src/ch19-03-advanced-traits.md:583
msgid ""
"### Using Supertraits to Require One Trait‚Äôs Functionality Within Another "
"Trait"
msgstr ""

#: src/ch19-03-advanced-traits.md:585
msgid ""
"Sometimes, you might write a trait definition that depends on another "
"trait:\n"
"for a type to implement the first trait, you want to require that type to "
"also\n"
"implement the second trait. You would do this so that your trait definition "
"can\n"
"make use of the associated items of the second trait. The trait your trait\n"
"definition is relying on is called a *supertrait* of your trait."
msgstr ""

#: src/ch19-03-advanced-traits.md:591
msgid ""
"For example, let‚Äôs say we want to make an `OutlinePrint` trait with an\n"
"`outline_print` method that will print a given value formatted so that it's\n"
"framed in asterisks. That is, given a `Point` struct that implements the\n"
"standard library trait `Display` to result in `(x, y)`, when we call\n"
"`outline_print` on a `Point` instance that has `1` for `x` and `3` for `y`, "
"it\n"
"should print the following:"
msgstr ""

#: src/ch19-03-advanced-traits.md:598
msgid ""
"```text\n"
"**********\n"
"*        *\n"
"* (1, 3) *\n"
"*        *\n"
"**********\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:606
msgid ""
"In the implementation of the `outline_print` method, we want to use the\n"
"`Display` trait‚Äôs functionality. Therefore, we need to specify that the\n"
"`OutlinePrint` trait will work only for types that also implement `Display` "
"and\n"
"provide the functionality that `OutlinePrint` needs. We can do that in the\n"
"trait definition by specifying `OutlinePrint: Display`. This technique is\n"
"similar to adding a trait bound to the trait. Listing 19-22 shows an\n"
"implementation of the `OutlinePrint` trait."
msgstr ""

#: src/ch19-03-advanced-traits.md:616
msgid ""
"```rust\n"
"use std::fmt;\n"
"\n"
"trait OutlinePrint: fmt::Display {\n"
"    fn outline_print(&self) {\n"
"        let output = self.to_string();\n"
"        let len = output.len();\n"
"        println!(\"{}\", \"*\".repeat(len + 4));\n"
"        println!(\"*{}*\", \" \".repeat(len + 2));\n"
"        println!(\"* {} *\", output);\n"
"        println!(\"*{}*\", \" \".repeat(len + 2));\n"
"        println!(\"{}\", \"*\".repeat(len + 4));\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:634
msgid ""
"<span class=\"caption\">Listing 19-22: Implementing the `OutlinePrint` trait "
"that\n"
"requires the functionality from `Display`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:637
msgid ""
"Because we‚Äôve specified that `OutlinePrint` requires the `Display` trait, "
"we\n"
"can use the `to_string` function that is automatically implemented for any "
"type\n"
"that implements `Display`. If we tried to use `to_string` without adding a\n"
"colon and specifying the `Display` trait after the trait name, we‚Äôd get an\n"
"error saying that no method named `to_string` was found for the type `&Self` "
"in\n"
"the current scope."
msgstr ""

#: src/ch19-03-advanced-traits.md:644
msgid ""
"Let‚Äôs see what happens when we try to implement `OutlinePrint` on a type "
"that\n"
"doesn‚Äôt implement `Display`, such as the `Point` struct:"
msgstr ""

#: src/ch19-03-advanced-traits.md:649
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::fmt;\n"
"# \n"
"# trait OutlinePrint: fmt::Display {\n"
"#     fn outline_print(&self) {\n"
"#         let output = self.to_string();\n"
"#         let len = output.len();\n"
"#         println!(\"{}\", \"*\".repeat(len + 4));\n"
"#         println!(\"*{}*\", \" \".repeat(len + 2));\n"
"#         println!(\"* {} *\", output);\n"
"#         println!(\"*{}*\", \" \".repeat(len + 2));\n"
"#         println!(\"{}\", \"*\".repeat(len + 4));\n"
"#     }\n"
"# }\n"
"# \n"
"struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"impl OutlinePrint for Point {}\n"
"# \n"
"# fn main() {\n"
"#     let p = Point { x: 1, y: 3 };\n"
"#     p.outline_print();\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:677
msgid "We get an error saying that `Display` is required but not implemented:"
msgstr ""

#: src/ch19-03-advanced-traits.md:679
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0277]: `Point` doesn't implement `std::fmt::Display`\n"
"  --> src/main.rs:20:6\n"
"   |\n"
"20 | impl OutlinePrint for Point {}\n"
"   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default "
"formatter\n"
"   |\n"
"   = help: the trait `std::fmt::Display` is not implemented for `Point`\n"
"   = note: in format strings you may be able to use `{:?}` (or {:#?} for "
"pretty-print) instead\n"
"note: required by a bound in `OutlinePrint`\n"
"  --> src/main.rs:3:21\n"
"   |\n"
"3  | trait OutlinePrint: fmt::Display {\n"
"   |                     ^^^^^^^^^^^^ required by this bound in "
"`OutlinePrint`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `traits-example` due to previous error\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:700
msgid ""
"To fix this, we implement `Display` on `Point` and satisfy the constraint "
"that\n"
"`OutlinePrint` requires, like so:"
msgstr ""

#: src/ch19-03-advanced-traits.md:705
msgid ""
"```rust\n"
"# trait OutlinePrint: fmt::Display {\n"
"#     fn outline_print(&self) {\n"
"#         let output = self.to_string();\n"
"#         let len = output.len();\n"
"#         println!(\"{}\", \"*\".repeat(len + 4));\n"
"#         println!(\"*{}*\", \" \".repeat(len + 2));\n"
"#         println!(\"* {} *\", output);\n"
"#         println!(\"*{}*\", \" \".repeat(len + 2));\n"
"#         println!(\"{}\", \"*\".repeat(len + 4));\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Point {\n"
"#     x: i32,\n"
"#     y: i32,\n"
"# }\n"
"# \n"
"# impl OutlinePrint for Point {}\n"
"# \n"
"use std::fmt;\n"
"\n"
"impl fmt::Display for Point {\n"
"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n"
"        write!(f, \"({}, {})\", self.x, self.y)\n"
"    }\n"
"}\n"
"# \n"
"# fn main() {\n"
"#     let p = Point { x: 1, y: 3 };\n"
"#     p.outline_print();\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:739
msgid ""
"Then implementing the `OutlinePrint` trait on `Point` will compile\n"
"successfully, and we can call `outline_print` on a `Point` instance to "
"display\n"
"it within an outline of asterisks."
msgstr ""

#: src/ch19-03-advanced-traits.md:743
msgid ""
"### Using the Newtype Pattern to Implement External Traits on External Types"
msgstr ""

#: src/ch19-03-advanced-traits.md:745
msgid ""
"In Chapter 10 in the [‚ÄúImplementing a Trait on a\n"
"Type‚Äù][implementing-a-trait-on-a-type]<!-- ignore --> section, we mentioned "
"the\n"
"orphan rule that states we‚Äôre only allowed to implement a trait on a type "
"if\n"
"either the trait or the type are local to our crate. It‚Äôs possible to get\n"
"around this restriction using the *newtype pattern*, which involves creating "
"a\n"
"new type in a tuple struct. (We covered tuple structs in the [‚ÄúUsing Tuple\n"
"Structs without Named Fields to Create Different Types‚Äù][tuple-structs]<!--\n"
"ignore --> section of Chapter 5.) The tuple struct will have one field and "
"be a\n"
"thin wrapper around the type we want to implement a trait for. Then the "
"wrapper\n"
"type is local to our crate, and we can implement the trait on the wrapper.\n"
"*Newtype* is a term that originates from the Haskell programming language.\n"
"There is no runtime performance penalty for using this pattern, and the "
"wrapper\n"
"type is elided at compile time."
msgstr ""

#: src/ch19-03-advanced-traits.md:759
msgid ""
"As an example, let‚Äôs say we want to implement `Display` on `Vec<T>`, which "
"the\n"
"orphan rule prevents us from doing directly because the `Display` trait and "
"the\n"
"`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct\n"
"that holds an instance of `Vec<T>`; then we can implement `Display` on\n"
"`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23."
msgstr ""

#: src/ch19-03-advanced-traits.md:767
msgid ""
"```rust\n"
"use std::fmt;\n"
"\n"
"struct Wrapper(Vec<String>);\n"
"\n"
"impl fmt::Display for Wrapper {\n"
"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n"
"        write!(f, \"[{}]\", self.0.join(\", \"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wrapper(vec![String::from(\"hello\"), String::"
"from(\"world\")]);\n"
"    println!(\"w = {}\", w);\n"
"}\n"
"```"
msgstr ""

#: src/ch19-03-advanced-traits.md:784
msgid ""
"<span class=\"caption\">Listing 19-23: Creating a `Wrapper` type around\n"
"`Vec<String>` to implement `Display`</span>"
msgstr ""

#: src/ch19-03-advanced-traits.md:787
msgid ""
"The implementation of `Display` uses `self.0` to access the inner `Vec<T>`,\n"
"because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in "
"the\n"
"tuple. Then we can use the functionality of the `Display` type on `Wrapper`."
msgstr ""

#: src/ch19-03-advanced-traits.md:791
msgid ""
"The downside of using this technique is that `Wrapper` is a new type, so it\n"
"doesn‚Äôt have the methods of the value it‚Äôs holding. We would have to "
"implement\n"
"all the methods of `Vec<T>` directly on `Wrapper` such that the methods\n"
"delegate to `self.0`, which would allow us to treat `Wrapper` exactly like "
"a\n"
"`Vec<T>`. If we wanted the new type to have every method the inner type "
"has,\n"
"implementing the `Deref` trait (discussed in Chapter 15 in the [‚ÄúTreating "
"Smart\n"
"Pointers Like Regular References with the `Deref`\n"
"Trait‚Äù][smart-pointer-deref]<!-- ignore --> section) on the `Wrapper` to "
"return\n"
"the inner type would be a solution. If we don‚Äôt want the `Wrapper` type to "
"have\n"
"all the methods of the inner type‚Äîfor example, to restrict the `Wrapper` "
"type‚Äôs\n"
"behavior‚Äîwe would have to implement just the methods we do want manually."
msgstr ""

#: src/ch19-03-advanced-traits.md:803
msgid ""
"This newtype pattern is also useful even when traits are not involved. "
"Let‚Äôs\n"
"switch focus and look at some advanced ways to interact with Rust‚Äôs type "
"system."
msgstr ""

#: src/ch19-04-advanced-types.md:1
msgid "## Advanced Types"
msgstr ""

#: src/ch19-04-advanced-types.md:3
msgid ""
"The Rust type system has some features that we‚Äôve so far mentioned but "
"haven‚Äôt\n"
"yet discussed. We‚Äôll start by discussing newtypes in general as we examine "
"why\n"
"newtypes are useful as types. Then we‚Äôll move on to type aliases, a feature\n"
"similar to newtypes but with slightly different semantics. We‚Äôll also "
"discuss\n"
"the `!` type and dynamically sized types."
msgstr ""

#: src/ch19-04-advanced-types.md:9
msgid "### Using the Newtype Pattern for Type Safety and Abstraction"
msgstr ""

#: src/ch19-04-advanced-types.md:11
msgid ""
"> Note: This section assumes you‚Äôve read the earlier section [‚ÄúUsing the\n"
"> Newtype Pattern to Implement External Traits on External\n"
"> Types.‚Äù][using-the-newtype-pattern]<!-- ignore -->"
msgstr ""

#: src/ch19-04-advanced-types.md:15
msgid ""
"The newtype pattern is also useful for tasks beyond those we‚Äôve discussed "
"so\n"
"far, including statically enforcing that values are never confused and\n"
"indicating the units of a value. You saw an example of using newtypes to\n"
"indicate units in Listing 19-15: recall that the `Millimeters` and `Meters`\n"
"structs wrapped `u32` values in a newtype. If we wrote a function with a\n"
"parameter of type `Millimeters`, we couldn‚Äôt compile a program that\n"
"accidentally tried to call that function with a value of type `Meters` or a\n"
"plain `u32`."
msgstr ""

#: src/ch19-04-advanced-types.md:24
msgid ""
"We can also use the newtype pattern to abstract away some implementation\n"
"details of a type: the new type can expose a public API that is different "
"from\n"
"the API of the private inner type."
msgstr ""

#: src/ch19-04-advanced-types.md:28
msgid ""
"Newtypes can also hide internal implementation. For example, we could "
"provide a\n"
"`People` type to wrap a `HashMap<i32, String>` that stores a person‚Äôs ID\n"
"associated with their name. Code using `People` would only interact with "
"the\n"
"public API we provide, such as a method to add a name string to the "
"`People`\n"
"collection; that code wouldn‚Äôt need to know that we assign an `i32` ID to "
"names\n"
"internally. The newtype pattern is a lightweight way to achieve "
"encapsulation\n"
"to hide implementation details, which we discussed in the [‚ÄúEncapsulation "
"that\n"
"Hides Implementation\n"
"Details‚Äù][encapsulation-that-hides-implementation-details]<!-- ignore -->\n"
"section of Chapter 17."
msgstr ""

#: src/ch19-04-advanced-types.md:39
msgid "### Creating Type Synonyms with Type Aliases"
msgstr ""

#: src/ch19-04-advanced-types.md:41
msgid ""
"Rust provides the ability to declare a *type alias* to give an existing "
"type\n"
"another name. For this we use the `type` keyword. For example, we can "
"create\n"
"the alias `Kilometers` to `i32` like so:"
msgstr ""

#: src/ch19-04-advanced-types.md:45
msgid ""
"```rust\n"
"# fn main() {\n"
"    type Kilometers = i32;\n"
"# \n"
"#     let x: i32 = 5;\n"
"#     let y: Kilometers = 5;\n"
"# \n"
"#     println!(\"x + y = {}\", x + y);\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:56
msgid ""
"Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the "
"`Millimeters`\n"
"and `Meters` types we created in Listing 19-15, `Kilometers` is not a "
"separate,\n"
"new type. Values that have the type `Kilometers` will be treated the same "
"as\n"
"values of type `i32`:"
msgstr ""

#: src/ch19-04-advanced-types.md:61
msgid ""
"```rust\n"
"# fn main() {\n"
"    type Kilometers = i32;\n"
"\n"
"    let x: i32 = 5;\n"
"    let y: Kilometers = 5;\n"
"\n"
"    println!(\"x + y = {}\", x + y);\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:72
msgid ""
"Because `Kilometers` and `i32` are the same type, we can add values of both\n"
"types and we can pass `Kilometers` values to functions that take `i32`\n"
"parameters. However, using this method, we don‚Äôt get the type checking "
"benefits\n"
"that we get from the newtype pattern discussed earlier. In other words, if "
"we\n"
"mix up `Kilometers` and `i32` values somewhere, the compiler will not give "
"us\n"
"an error."
msgstr ""

#: src/ch19-04-advanced-types.md:79
msgid ""
"The main use case for type synonyms is to reduce repetition. For example, "
"we\n"
"might have a lengthy type like this:"
msgstr ""

#: src/ch19-04-advanced-types.md:82
msgid ""
"```rust,ignore\n"
"Box<dyn Fn() + Send + 'static>\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:86
msgid ""
"Writing this lengthy type in function signatures and as type annotations "
"all\n"
"over the code can be tiresome and error prone. Imagine having a project full "
"of\n"
"code like that in Listing 19-24."
msgstr ""

#: src/ch19-04-advanced-types.md:90
msgid ""
"```rust\n"
"# fn main() {\n"
"    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!(\"hi\"));\n"
"\n"
"    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {\n"
"        // --snip--\n"
"    }\n"
"\n"
"    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {\n"
"        // --snip--\n"
"#         Box::new(|| ())\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:105
msgid ""
"<span class=\"caption\">Listing 19-24: Using a long type in many places</"
"span>"
msgstr ""

#: src/ch19-04-advanced-types.md:107
msgid ""
"A type alias makes this code more manageable by reducing the repetition. In\n"
"Listing 19-25, we‚Äôve introduced an alias named `Thunk` for the verbose type "
"and\n"
"can replace all uses of the type with the shorter alias `Thunk`."
msgstr ""

#: src/ch19-04-advanced-types.md:111
msgid ""
"```rust\n"
"# fn main() {\n"
"    type Thunk = Box<dyn Fn() + Send + 'static>;\n"
"\n"
"    let f: Thunk = Box::new(|| println!(\"hi\"));\n"
"\n"
"    fn takes_long_type(f: Thunk) {\n"
"        // --snip--\n"
"    }\n"
"\n"
"    fn returns_long_type() -> Thunk {\n"
"        // --snip--\n"
"#         Box::new(|| ())\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:128
msgid ""
"<span class=\"caption\">Listing 19-25: Introducing a type alias `Thunk` to "
"reduce\n"
"repetition</span>"
msgstr ""

#: src/ch19-04-advanced-types.md:131
msgid ""
"This code is much easier to read and write! Choosing a meaningful name for "
"a\n"
"type alias can help communicate your intent as well (*thunk* is a word for "
"code\n"
"to be evaluated at a later time, so it‚Äôs an appropriate name for a closure "
"that\n"
"gets stored)."
msgstr ""

#: src/ch19-04-advanced-types.md:136
msgid ""
"Type aliases are also commonly used with the `Result<T, E>` type for "
"reducing\n"
"repetition. Consider the `std::io` module in the standard library. I/O\n"
"operations often return a `Result<T, E>` to handle situations when "
"operations\n"
"fail to work. This library has a `std::io::Error` struct that represents "
"all\n"
"possible I/O errors. Many of the functions in `std::io` will be returning\n"
"`Result<T, E>` where the `E` is `std::io::Error`, such as these functions "
"in\n"
"the `Write` trait:"
msgstr ""

#: src/ch19-04-advanced-types.md:144
msgid ""
"```rust,noplayground\n"
"use std::fmt;\n"
"use std::io::Error;\n"
"\n"
"pub trait Write {\n"
"    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;\n"
"    fn flush(&mut self) -> Result<(), Error>;\n"
"\n"
"    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;\n"
"    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:157
msgid ""
"The `Result<..., Error>` is repeated a lot. As such, `std::io` has this "
"type\n"
"alias declaration:"
msgstr ""

#: src/ch19-04-advanced-types.md:160
msgid ""
"```rust,noplayground\n"
"# use std::fmt;\n"
"# \n"
"type Result<T> = std::result::Result<T, std::io::Error>;\n"
"# \n"
"# pub trait Write {\n"
"#     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n"
"#     fn flush(&mut self) -> Result<()>;\n"
"# \n"
"#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n"
"#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:174
msgid ""
"Because this declaration is in the `std::io` module, we can use the fully\n"
"qualified alias `std::io::Result<T>`; that is, a `Result<T, E>` with the "
"`E`\n"
"filled in as `std::io::Error`. The `Write` trait function signatures end up\n"
"looking like this:"
msgstr ""

#: src/ch19-04-advanced-types.md:179
msgid ""
"```rust,noplayground\n"
"# use std::fmt;\n"
"# \n"
"# type Result<T> = std::result::Result<T, std::io::Error>;\n"
"# \n"
"pub trait Write {\n"
"    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n"
"    fn flush(&mut self) -> Result<()>;\n"
"\n"
"    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n"
"    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:193
msgid ""
"The type alias helps in two ways: it makes code easier to write *and* it "
"gives\n"
"us a consistent interface across all of `std::io`. Because it‚Äôs an alias, "
"it‚Äôs\n"
"just another `Result<T, E>`, which means we can use any methods that work "
"on\n"
"`Result<T, E>` with it, as well as special syntax like the `?` operator."
msgstr ""

#: src/ch19-04-advanced-types.md:198
msgid "### The Never Type that Never Returns"
msgstr ""

#: src/ch19-04-advanced-types.md:200
msgid ""
"Rust has a special type named `!` that‚Äôs known in type theory lingo as the\n"
"*empty type* because it has no values. We prefer to call it the *never "
"type*\n"
"because it stands in the place of the return type when a function will "
"never\n"
"return. Here is an example:"
msgstr ""

#: src/ch19-04-advanced-types.md:205
msgid ""
"```rust,noplayground\n"
"fn bar() -> ! {\n"
"    // --snip--\n"
"#     panic!();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:212
msgid ""
"This code is read as ‚Äúthe function `bar` returns never.‚Äù Functions that "
"return\n"
"never are called *diverging functions*. We can‚Äôt create values of the type `!"
"`\n"
"so `bar` can never possibly return."
msgstr ""

#: src/ch19-04-advanced-types.md:216
msgid ""
"But what use is a type you can never create values for? Recall the code "
"from\n"
"Listing 2-5, part of the number guessing game; we‚Äôve reproduced a bit of it\n"
"here in Listing 19-26."
msgstr ""

#: src/ch19-04-advanced-types.md:220
msgid ""
"```rust,ignore\n"
"# use rand::Rng;\n"
"# use std::cmp::Ordering;\n"
"# use std::io;\n"
"# \n"
"# fn main() {\n"
"#     println!(\"Guess the number!\");\n"
"# \n"
"#     let secret_number = rand::thread_rng().gen_range(1..=100);\n"
"# \n"
"#     println!(\"The secret number is: {secret_number}\");\n"
"# \n"
"#     loop {\n"
"#         println!(\"Please input your guess.\");\n"
"# \n"
"#         let mut guess = String::new();\n"
"# \n"
"#         // --snip--\n"
"# \n"
"#         io::stdin()\n"
"#             .read_line(&mut guess)\n"
"#             .expect(\"Failed to read line\");\n"
"# \n"
"        let guess: u32 = match guess.trim().parse() {\n"
"            Ok(num) => num,\n"
"            Err(_) => continue,\n"
"        };\n"
"# \n"
"#         println!(\"You guessed: {guess}\");\n"
"# \n"
"#         // --snip--\n"
"# \n"
"#         match guess.cmp(&secret_number) {\n"
"#             Ordering::Less => println!(\"Too small!\"),\n"
"#             Ordering::Greater => println!(\"Too big!\"),\n"
"#             Ordering::Equal => {\n"
"#                 println!(\"You win!\");\n"
"#                 break;\n"
"#             }\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:264
msgid ""
"<span class=\"caption\">Listing 19-26: A `match` with an arm that ends in\n"
"`continue`</span>"
msgstr ""

#: src/ch19-04-advanced-types.md:267
msgid ""
"At the time, we skipped over some details in this code. In Chapter 6 in "
"[‚ÄúThe\n"
"`match` Control Flow Operator‚Äù][the-match-control-flow-operator]<!-- ignore "
"-->\n"
"section, we discussed that `match` arms must all return the same type. So, "
"for\n"
"example, the following code doesn‚Äôt work:"
msgstr ""

#: src/ch19-04-advanced-types.md:272
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"#     let guess = \"3\";\n"
"    let guess = match guess.trim().parse() {\n"
"        Ok(_) => 5,\n"
"        Err(_) => \"hello\",\n"
"    };\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:282
msgid ""
"The type of `guess` in this code would have to be an integer *and* a "
"string,\n"
"and Rust requires that `guess` have only one type. So what does `continue`\n"
"return? How were we allowed to return a `u32` from one arm and have another "
"arm\n"
"that ends with `continue` in Listing 19-26?"
msgstr ""

#: src/ch19-04-advanced-types.md:287
msgid ""
"As you might have guessed, `continue` has a `!` value. That is, when Rust\n"
"computes the type of `guess`, it looks at both match arms, the former with "
"a\n"
"value of `u32` and the latter with a `!` value. Because `!` can never have "
"a\n"
"value, Rust decides that the type of `guess` is `u32`."
msgstr ""

#: src/ch19-04-advanced-types.md:292
msgid ""
"The formal way of describing this behavior is that expressions of type `!` "
"can\n"
"be coerced into any other type. We‚Äôre allowed to end this `match` arm with\n"
"`continue` because `continue` doesn‚Äôt return a value; instead, it moves "
"control\n"
"back to the top of the loop, so in the `Err` case, we never assign a value "
"to\n"
"`guess`."
msgstr ""

#: src/ch19-04-advanced-types.md:298
msgid ""
"The never type is useful with the `panic!` macro as well. Recall the "
"`unwrap`\n"
"function that we call on `Option<T>` values to produce a value or panic "
"with\n"
"this definition:"
msgstr ""

#: src/ch19-04-advanced-types.md:302
msgid ""
"```rust,ignore\n"
"# enum Option<T> {\n"
"#     Some(T),\n"
"#     None,\n"
"# }\n"
"# \n"
"# use crate::Option::*;\n"
"# \n"
"impl<T> Option<T> {\n"
"    pub fn unwrap(self) -> T {\n"
"        match self {\n"
"            Some(val) => val,\n"
"            None => panic!(\"called `Option::unwrap()` on a `None` "
"value\"),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:320
msgid ""
"In this code, the same thing happens as in the `match` in Listing 19-26: "
"Rust\n"
"sees that `val` has the type `T` and `panic!` has the type `!`, so the "
"result\n"
"of the overall `match` expression is `T`. This code works because `panic!`\n"
"doesn‚Äôt produce a value; it ends the program. In the `None` case, we won‚Äôt "
"be\n"
"returning a value from `unwrap`, so this code is valid."
msgstr ""

#: src/ch19-04-advanced-types.md:326
msgid "One final expression that has the type `!` is a `loop`:"
msgstr ""

#: src/ch19-04-advanced-types.md:328
msgid ""
"```rust,ignore\n"
"# fn main() {\n"
"    print!(\"forever \");\n"
"\n"
"    loop {\n"
"        print!(\"and ever \");\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:338
msgid ""
"Here, the loop never ends, so `!` is the value of the expression. However, "
"this\n"
"wouldn‚Äôt be true if we included a `break`, because the loop would terminate\n"
"when it got to the `break`."
msgstr ""

#: src/ch19-04-advanced-types.md:342
msgid "### Dynamically Sized Types and the `Sized` Trait"
msgstr ""

#: src/ch19-04-advanced-types.md:344
msgid ""
"Rust needs to know certain details about its types, such as how much space "
"to\n"
"allocate for a value of a particular type. This leaves one corner of its "
"type\n"
"system a little confusing at first: the concept of *dynamically sized "
"types*.\n"
"Sometimes referred to as *DSTs* or *unsized types*, these types let us "
"write\n"
"code using values whose size we can know only at runtime."
msgstr ""

#: src/ch19-04-advanced-types.md:350
msgid ""
"Let‚Äôs dig into the details of a dynamically sized type called `str`, which\n"
"we‚Äôve been using throughout the book. That‚Äôs right, not `&str`, but `str` "
"on\n"
"its own, is a DST. We can‚Äôt know how long the string is until runtime, "
"meaning\n"
"we can‚Äôt create a variable of type `str`, nor can we take an argument of "
"type\n"
"`str`. Consider the following code, which does not work:"
msgstr ""

#: src/ch19-04-advanced-types.md:356
msgid ""
"```rust,ignore,does_not_compile\n"
"# fn main() {\n"
"    let s1: str = \"Hello there!\";\n"
"    let s2: str = \"How's it going?\";\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:363
msgid ""
"Rust needs to know how much memory to allocate for any value of a "
"particular\n"
"type, and all values of a type must use the same amount of memory. If Rust\n"
"allowed us to write this code, these two `str` values would need to take up "
"the\n"
"same amount of space. But they have different lengths: `s1` needs 12 bytes "
"of\n"
"storage and `s2` needs 15. This is why it‚Äôs not possible to create a "
"variable\n"
"holding a dynamically sized type."
msgstr ""

#: src/ch19-04-advanced-types.md:370
msgid ""
"So what do we do? In this case, you already know the answer: we make the "
"types\n"
"of `s1` and `s2` a `&str` rather than a `str`. Recall from the [‚ÄúString\n"
"Slices‚Äù][string-slices]<!-- ignore --> section of Chapter 4 that the slice "
"data\n"
"structure just stores the starting position and the length of the slice. So\n"
"although a `&T` is a single value that stores the memory address of where "
"the\n"
"`T` is located, a `&str` is *two* values: the address of the `str` and its\n"
"length. As such, we can know the size of a `&str` value at compile time: "
"it‚Äôs\n"
"twice the length of a `usize`. That is, we always know the size of a `&str`, "
"no\n"
"matter how long the string it refers to is. In general, this is the way in\n"
"which dynamically sized types are used in Rust: they have an extra bit of\n"
"metadata that stores the size of the dynamic information. The golden rule "
"of\n"
"dynamically sized types is that we must always put values of dynamically "
"sized\n"
"types behind a pointer of some kind."
msgstr ""

#: src/ch19-04-advanced-types.md:384
msgid ""
"We can combine `str` with all kinds of pointers: for example, `Box<str>` or\n"
"`Rc<str>`. In fact, you‚Äôve seen this before but with a different "
"dynamically\n"
"sized type: traits. Every trait is a dynamically sized type we can refer to "
"by\n"
"using the name of the trait. In Chapter 17 in the [‚ÄúUsing Trait Objects "
"That\n"
"Allow for Values of Different\n"
"Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--\n"
"ignore --> section, we mentioned that to use traits as trait objects, we "
"must\n"
"put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` "
"(`Rc<dyn\n"
"Trait>` would work too)."
msgstr ""

#: src/ch19-04-advanced-types.md:394
msgid ""
"To work with DSTs, Rust provides the `Sized` trait to determine whether or "
"not\n"
"a type‚Äôs size is known at compile time. This trait is automatically "
"implemented\n"
"for everything whose size is known at compile time. In addition, Rust\n"
"implicitly adds a bound on `Sized` to every generic function. That is, a\n"
"generic function definition like this:"
msgstr ""

#: src/ch19-04-advanced-types.md:400
msgid ""
"```rust,ignore\n"
"fn generic<T>(t: T) {\n"
"    // --snip--\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:406
msgid "is actually treated as though we had written this:"
msgstr ""

#: src/ch19-04-advanced-types.md:408
msgid ""
"```rust,ignore\n"
"fn generic<T: Sized>(t: T) {\n"
"    // --snip--\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:414
msgid ""
"By default, generic functions will work only on types that have a known size "
"at\n"
"compile time. However, you can use the following special syntax to relax "
"this\n"
"restriction:"
msgstr ""

#: src/ch19-04-advanced-types.md:418
msgid ""
"```rust,ignore\n"
"fn generic<T: ?Sized>(t: &T) {\n"
"    // --snip--\n"
"}\n"
"```"
msgstr ""

#: src/ch19-04-advanced-types.md:424
msgid ""
"A trait bound on `?Sized` means ‚Äú`T` may or may not be `Sized`‚Äù and this\n"
"notation overrides the default that generic types must have a known size at\n"
"compile time. The `?Trait` syntax with this meaning is only available for\n"
"`Sized`, not any other traits."
msgstr ""

#: src/ch19-04-advanced-types.md:429
msgid ""
"Also note that we switched the type of the `t` parameter from `T` to `&T`.\n"
"Because the type might not be `Sized`, we need to use it behind some kind "
"of\n"
"pointer. In this case, we‚Äôve chosen a reference."
msgstr ""

#: src/ch19-04-advanced-types.md:433
msgid "Next, we‚Äôll talk about functions and closures!"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:1
msgid "## Advanced Functions and Closures"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:3
msgid ""
"This section explores some advanced features related to functions and "
"closures,\n"
"including function pointers and returning closures."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:6
msgid "### Function Pointers"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:8
msgid ""
"We‚Äôve talked about how to pass closures to functions; you can also pass "
"regular\n"
"functions to functions! This technique is useful when you want to pass a\n"
"function you‚Äôve already defined rather than defining a new closure. "
"Functions\n"
"coerce to the type `fn` (with a lowercase f), not to be confused with the "
"`Fn`\n"
"closure trait. The `fn` type is called a *function pointer*. Passing "
"functions\n"
"with function pointers will allow you to use functions as arguments to "
"other\n"
"functions."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:16
msgid ""
"The syntax for specifying that a parameter is a function pointer is similar "
"to\n"
"that of closures, as shown in Listing 19-27, where we‚Äôve defined a function\n"
"`add_one` that adds one to its parameter. The function `do_twice` takes two\n"
"parameters: a function pointer to any function that takes an `i32` "
"parameter\n"
"and returns an `i32`, and one `i32` value. The `do_twice` function calls "
"the\n"
"function `f` twice, passing it the `arg` value, then adds the two function "
"call\n"
"results together. The `main` function calls `do_twice` with the arguments\n"
"`add_one` and `5`."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:27
msgid ""
"```rust\n"
"fn add_one(x: i32) -> i32 {\n"
"    x + 1\n"
"}\n"
"\n"
"fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n"
"    f(arg) + f(arg)\n"
"}\n"
"\n"
"fn main() {\n"
"    let answer = do_twice(add_one, 5);\n"
"\n"
"    println!(\"The answer is: {}\", answer);\n"
"}\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:43
msgid ""
"<span class=\"caption\">Listing 19-27: Using the `fn` type to accept a "
"function\n"
"pointer as an argument</span>"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:46
msgid ""
"This code prints `The answer is: 12`. We specify that the parameter `f` in\n"
"`do_twice` is an `fn` that takes one parameter of type `i32` and returns an\n"
"`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can "
"pass\n"
"the function name `add_one` as the first argument to `do_twice`."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:51
msgid ""
"Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as "
"the\n"
"parameter type directly rather than declaring a generic type parameter with "
"one\n"
"of the `Fn` traits as a trait bound."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:55
msgid ""
"Function pointers implement all three of the closure traits (`Fn`, `FnMut`, "
"and\n"
"`FnOnce`), meaning you can always pass a function pointer as an argument for "
"a\n"
"function that expects a closure. It‚Äôs best to write functions using a "
"generic\n"
"type and one of the closure traits so your functions can accept either\n"
"functions or closures."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:61
msgid ""
"That said, one example of where you would want to only accept `fn` and not\n"
"closures is when interfacing with external code that doesn‚Äôt have closures: "
"C\n"
"functions can accept functions as arguments, but C doesn‚Äôt have closures."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:65
msgid ""
"As an example of where you could use either a closure defined inline or a "
"named\n"
"function, let‚Äôs look at a use of the `map` method provided by the "
"`Iterator`\n"
"trait in the standard library. To use the `map` function to turn a vector "
"of\n"
"numbers into a vector of strings, we could use a closure, like this:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:70
msgid ""
"```rust\n"
"# fn main() {\n"
"    let list_of_numbers = vec![1, 2, 3];\n"
"    let list_of_strings: Vec<String> =\n"
"        list_of_numbers.iter().map(|i| i.to_string()).collect();\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:78
msgid ""
"Or we could name a function as the argument to `map` instead of the "
"closure,\n"
"like this:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:81
msgid ""
"```rust\n"
"# fn main() {\n"
"    let list_of_numbers = vec![1, 2, 3];\n"
"    let list_of_strings: Vec<String> =\n"
"        list_of_numbers.iter().map(ToString::to_string).collect();\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:89
msgid ""
"Note that we must use the fully qualified syntax that we talked about "
"earlier\n"
"in the [‚ÄúAdvanced Traits‚Äù][advanced-traits]<!-- ignore --> section because\n"
"there are multiple functions available named `to_string`. Here, we‚Äôre using "
"the\n"
"`to_string` function defined in the `ToString` trait, which the standard\n"
"library has implemented for any type that implements `Display`."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:95
msgid ""
"Recall from the [‚ÄúEnum values‚Äù][enum-values]<!-- ignore --> section of "
"Chapter\n"
"6 that the name of each enum variant that we define also becomes an "
"initializer\n"
"function. We can use these initializer functions as function pointers that\n"
"implement the closure traits, which means we can specify the initializer\n"
"functions as arguments for methods that take closures, like so:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:101
msgid ""
"```rust\n"
"# fn main() {\n"
"    enum Status {\n"
"        Value(u32),\n"
"        Stop,\n"
"    }\n"
"\n"
"    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value)."
"collect();\n"
"# }\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:112
msgid ""
"Here we create `Status::Value` instances using each `u32` value in the "
"range\n"
"that `map` is called on by using the initializer function of `Status::"
"Value`.\n"
"Some people prefer this style, and some people prefer to use closures. They\n"
"compile to the same code, so use whichever style is clearer to you."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:117
msgid "### Returning Closures"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:119
msgid ""
"Closures are represented by traits, which means you can‚Äôt return closures\n"
"directly. In most cases where you might want to return a trait, you can "
"instead\n"
"use the concrete type that implements the trait as the return value of the\n"
"function. However, you can‚Äôt do that with closures because they don‚Äôt have "
"a\n"
"concrete type that is returnable; you‚Äôre not allowed to use the function\n"
"pointer `fn` as a return type, for example."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:126
msgid ""
"The following code tries to return a closure directly, but it won‚Äôt compile:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:128
msgid ""
"```rust,ignore,does_not_compile\n"
"fn returns_closure() -> dyn Fn(i32) -> i32 {\n"
"    |x| x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:134
msgid "The compiler error is as follows:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:136
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling functions-example v0.1.0 (file:///projects/functions-example)\n"
"error[E0746]: return type cannot have an unboxed trait object\n"
" --> src/lib.rs:1:25\n"
"  |\n"
"1 | fn returns_closure() -> dyn Fn(i32) -> i32 {\n"
"  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at "
"compile-time\n"
"  |\n"
"  = note: for information on `impl Trait`, see <https://doc.rust-lang.org/"
"book/ch10-02-traits.html#returning-types-that-implement-traits>\n"
"help: use `impl Fn(i32) -> i32` as the return type, as all return paths are "
"of type `[closure@src/lib.rs:2:5: 2:8]`, which implements `Fn(i32) -> i32`\n"
"  |\n"
"1 | fn returns_closure() -> impl Fn(i32) -> i32 {\n"
"  |                         ~~~~~~~~~~~~~~~~~~~\n"
"\n"
"For more information about this error, try `rustc --explain E0746`.\n"
"error: could not compile `functions-example` due to previous error\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:155
msgid ""
"The error references the `Sized` trait again! Rust doesn‚Äôt know how much "
"space\n"
"it will need to store the closure. We saw a solution to this problem "
"earlier.\n"
"We can use a trait object:"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:159
msgid ""
"```rust,noplayground\n"
"fn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n"
"    Box::new(|x| x + 1)\n"
"}\n"
"```"
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:165
msgid ""
"This code will compile just fine. For more about trait objects, refer to "
"the\n"
"section [‚ÄúUsing Trait Objects That Allow for Values of Different\n"
"Types‚Äù][using-trait-objects-that-allow-for-values-of-different-types]<!--\n"
"ignore --> in Chapter 17."
msgstr ""

#: src/ch19-05-advanced-functions-and-closures.md:170
msgid "Next, let‚Äôs look at macros!"
msgstr ""

#: src/ch19-06-macros.md:1
msgid "## Macros"
msgstr ""

#: src/ch19-06-macros.md:3
msgid ""
"We‚Äôve used macros like `println!` throughout this book, but we haven‚Äôt "
"fully\n"
"explored what a macro is and how it works. The term *macro* refers to a "
"family\n"
"of features in Rust: *declarative* macros with `macro_rules!` and three "
"kinds\n"
"of *procedural* macros:"
msgstr ""

#: src/ch19-06-macros.md:8
msgid ""
"* Custom `#[derive]` macros that specify code added with the `derive` "
"attribute\n"
"  used on structs and enums\n"
"* Attribute-like macros that define custom attributes usable on any item\n"
"* Function-like macros that look like function calls but operate on the "
"tokens\n"
"  specified as their argument"
msgstr ""

#: src/ch19-06-macros.md:14
msgid ""
"We‚Äôll talk about each of these in turn, but first, let‚Äôs look at why we "
"even\n"
"need macros when we already have functions."
msgstr ""

#: src/ch19-06-macros.md:17
msgid "### The Difference Between Macros and Functions"
msgstr ""

#: src/ch19-06-macros.md:19
msgid ""
"Fundamentally, macros are a way of writing code that writes other code, "
"which\n"
"is known as *metaprogramming*. In Appendix C, we discuss the `derive`\n"
"attribute, which generates an implementation of various traits for you. "
"We‚Äôve\n"
"also used the `println!` and `vec!` macros throughout the book. All of "
"these\n"
"macros *expand* to produce more code than the code you‚Äôve written manually."
msgstr ""

#: src/ch19-06-macros.md:25
msgid ""
"Metaprogramming is useful for reducing the amount of code you have to write "
"and\n"
"maintain, which is also one of the roles of functions. However, macros have\n"
"some additional powers that functions don‚Äôt."
msgstr ""

#: src/ch19-06-macros.md:29
msgid ""
"A function signature must declare the number and type of parameters the\n"
"function has. Macros, on the other hand, can take a variable number of\n"
"parameters: we can call `println!(\"hello\")` with one argument or\n"
"`println!(\"hello {}\", name)` with two arguments. Also, macros are "
"expanded\n"
"before the compiler interprets the meaning of the code, so a macro can, for\n"
"example, implement a trait on a given type. A function can‚Äôt, because it "
"gets\n"
"called at runtime and a trait needs to be implemented at compile time."
msgstr ""

#: src/ch19-06-macros.md:37
msgid ""
"The downside to implementing a macro instead of a function is that macro\n"
"definitions are more complex than function definitions because you‚Äôre "
"writing\n"
"Rust code that writes Rust code. Due to this indirection, macro definitions "
"are\n"
"generally more difficult to read, understand, and maintain than function\n"
"definitions."
msgstr ""

#: src/ch19-06-macros.md:43
msgid ""
"Another important difference between macros and functions is that you must\n"
"define macros or bring them into scope *before* you call them in a file, as\n"
"opposed to functions you can define anywhere and call anywhere."
msgstr ""

#: src/ch19-06-macros.md:47
msgid "### Declarative Macros with `macro_rules!` for General Metaprogramming"
msgstr ""

#: src/ch19-06-macros.md:49
msgid ""
"The most widely used form of macros in Rust is the *declarative macro*. "
"These\n"
"are also sometimes referred to as ‚Äúmacros by example,‚Äù ‚Äú`macro_rules!` "
"macros,‚Äù\n"
"or just plain ‚Äúmacros.‚Äù At their core, declarative macros allow you to "
"write\n"
"something similar to a Rust `match` expression. As discussed in Chapter 6,\n"
"`match` expressions are control structures that take an expression, compare "
"the\n"
"resulting value of the expression to patterns, and then run the code "
"associated\n"
"with the matching pattern. Macros also compare a value to patterns that are\n"
"associated with particular code: in this situation, the value is the "
"literal\n"
"Rust source code passed to the macro; the patterns are compared with the\n"
"structure of that source code; and the code associated with each pattern, "
"when\n"
"matched, replaces the code passed to the macro. This all happens during\n"
"compilation."
msgstr ""

#: src/ch19-06-macros.md:62
msgid ""
"To define a macro, you use the `macro_rules!` construct. Let‚Äôs explore how "
"to\n"
"use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8\n"
"covered how we can use the `vec!` macro to create a new vector with "
"particular\n"
"values. For example, the following macro creates a new vector containing "
"three\n"
"integers:"
msgstr ""

#: src/ch19-06-macros.md:68
msgid ""
"```rust\n"
"let v: Vec<u32> = vec![1, 2, 3];\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:72
msgid ""
"We could also use the `vec!` macro to make a vector of two integers or a "
"vector\n"
"of five string slices. We wouldn‚Äôt be able to use a function to do the same\n"
"because we wouldn‚Äôt know the number or type of values up front."
msgstr ""

#: src/ch19-06-macros.md:76
msgid ""
"Listing 19-28 shows a slightly simplified definition of the `vec!` macro."
msgstr ""

#: src/ch19-06-macros.md:80
msgid ""
"```rust,noplayground\n"
"#[macro_export]\n"
"macro_rules! vec {\n"
"    ( $( $x:expr ),* ) => {\n"
"        {\n"
"            let mut temp_vec = Vec::new();\n"
"            $(\n"
"                temp_vec.push($x);\n"
"            )*\n"
"            temp_vec\n"
"        }\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:95
msgid ""
"<span class=\"caption\">Listing 19-28: A simplified version of the `vec!` "
"macro\n"
"definition</span>"
msgstr ""

#: src/ch19-06-macros.md:98
msgid ""
"> Note: The actual definition of the `vec!` macro in the standard library\n"
"> includes code to preallocate the correct amount of memory up front. That "
"code\n"
"> is an optimization that we don‚Äôt include here to make the example simpler."
msgstr ""

#: src/ch19-06-macros.md:102
msgid ""
"The `#[macro_export]` annotation indicates that this macro should be made\n"
"available whenever the crate in which the macro is defined is brought into\n"
"scope. Without this annotation, the macro can‚Äôt be brought into scope."
msgstr ""

#: src/ch19-06-macros.md:106
msgid ""
"We then start the macro definition with `macro_rules!` and the name of the\n"
"macro we‚Äôre defining *without* the exclamation mark. The name, in this case\n"
"`vec`, is followed by curly brackets denoting the body of the macro "
"definition."
msgstr ""

#: src/ch19-06-macros.md:110
msgid ""
"The structure in the `vec!` body is similar to the structure of a `match`\n"
"expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,\n"
"followed by `=>` and the block of code associated with this pattern. If the\n"
"pattern matches, the associated block of code will be emitted. Given that "
"this\n"
"is the only pattern in this macro, there is only one valid way to match; "
"any\n"
"other pattern will result in an error. More complex macros will have more "
"than\n"
"one arm."
msgstr ""

#: src/ch19-06-macros.md:118
msgid ""
"Valid pattern syntax in macro definitions is different than the pattern "
"syntax\n"
"covered in Chapter 18 because macro patterns are matched against Rust code\n"
"structure rather than values. Let‚Äôs walk through what the pattern pieces in\n"
"Listing 19-28 mean; for the full macro pattern syntax, see the [Rust\n"
"Reference][ref]."
msgstr ""

#: src/ch19-06-macros.md:124
msgid ""
"First, we use a set of parentheses to encompass the whole pattern. We use a\n"
"dollar sign (`$`) to declare a variable in the macro system that will "
"contain\n"
"the Rust code matching the pattern. The dollar sign makes it clear this is "
"a\n"
"macro variable as opposed to a regular Rust variable. Next comes a set of\n"
"parentheses that captures values that match the pattern within the "
"parentheses\n"
"for use in the replacement code. Within `$()` is `$x:expr`, which matches "
"any\n"
"Rust expression and gives the expression the name `$x`."
msgstr ""

#: src/ch19-06-macros.md:132
msgid ""
"The comma following `$()` indicates that a literal comma separator "
"character\n"
"could optionally appear after the code that matches the code in `$()`. The "
"`*`\n"
"specifies that the pattern matches zero or more of whatever precedes the `*`."
msgstr ""

#: src/ch19-06-macros.md:136
msgid ""
"When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches "
"three\n"
"times with the three expressions `1`, `2`, and `3`."
msgstr ""

#: src/ch19-06-macros.md:139
msgid ""
"Now let‚Äôs look at the pattern in the body of the code associated with this "
"arm:\n"
"`temp_vec.push()` within `$()*` is generated for each part that matches "
"`$()`\n"
"in the pattern zero or more times depending on how many times the pattern\n"
"matches. The `$x` is replaced with each expression matched. When we call "
"this\n"
"macro with `vec![1, 2, 3];`, the code generated that replaces this macro "
"call\n"
"will be the following:"
msgstr ""

#: src/ch19-06-macros.md:146
msgid ""
"```rust,ignore\n"
"{\n"
"    let mut temp_vec = Vec::new();\n"
"    temp_vec.push(1);\n"
"    temp_vec.push(2);\n"
"    temp_vec.push(3);\n"
"    temp_vec\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:156
msgid ""
"We‚Äôve defined a macro that can take any number of arguments of any type and "
"can\n"
"generate code to create a vector containing the specified elements."
msgstr ""

#: src/ch19-06-macros.md:159
msgid ""
"To learn more about how to write macros, consult the online documentation "
"or\n"
"other resources, such as [‚ÄúThe Little Book of Rust Macros‚Äù][tlborm] started "
"by\n"
"Daniel Keep and continued by Lukas Wirth."
msgstr ""

#: src/ch19-06-macros.md:163
msgid "### Procedural Macros for Generating Code from Attributes"
msgstr ""

#: src/ch19-06-macros.md:165
msgid ""
"The second form of macros is the *procedural macro*, which acts more like a\n"
"function (and is a type of procedure). Procedural macros accept some code as "
"an\n"
"input, operate on that code, and produce some code as an output rather than\n"
"matching against patterns and replacing the code with other code as "
"declarative\n"
"macros do. The three kinds of procedural macros are custom derive,\n"
"attribute-like, and function-like, and all work in a similar fashion."
msgstr ""

#: src/ch19-06-macros.md:172
msgid ""
"When creating procedural macros, the definitions must reside in their own "
"crate\n"
"with a special crate type. This is for complex technical reasons that we "
"hope\n"
"to eliminate in the future. In Listing 19-29, we show how to define a\n"
"procedural macro, where `some_attribute` is a placeholder for using a "
"specific\n"
"macro variety."
msgstr ""

#: src/ch19-06-macros.md:180
msgid ""
"```rust,ignore\n"
"use proc_macro;\n"
"\n"
"#[some_attribute]\n"
"pub fn some_name(input: TokenStream) -> TokenStream {\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:188
msgid ""
"<span class=\"caption\">Listing 19-29: An example of defining a procedural\n"
"macro</span>"
msgstr ""

#: src/ch19-06-macros.md:191
msgid ""
"The function that defines a procedural macro takes a `TokenStream` as an "
"input\n"
"and produces a `TokenStream` as an output. The `TokenStream` type is defined "
"by\n"
"the `proc_macro` crate that is included with Rust and represents a sequence "
"of\n"
"tokens. This is the core of the macro: the source code that the macro is\n"
"operating on makes up the input `TokenStream`, and the code the macro "
"produces\n"
"is the output `TokenStream`. The function also has an attribute attached to "
"it\n"
"that specifies which kind of procedural macro we‚Äôre creating. We can have\n"
"multiple kinds of procedural macros in the same crate."
msgstr ""

#: src/ch19-06-macros.md:200
msgid ""
"Let‚Äôs look at the different kinds of procedural macros. We‚Äôll start with a\n"
"custom derive macro and then explain the small dissimilarities that make "
"the\n"
"other forms different."
msgstr ""

#: src/ch19-06-macros.md:204
msgid "### How to Write a Custom `derive` Macro"
msgstr ""

#: src/ch19-06-macros.md:206
msgid ""
"Let‚Äôs create a crate named `hello_macro` that defines a trait named\n"
"`HelloMacro` with one associated function named `hello_macro`. Rather than\n"
"making our users implement the `HelloMacro` trait for each of their types,\n"
"we‚Äôll provide a procedural macro so users can annotate their type with\n"
"`#[derive(HelloMacro)]` to get a default implementation of the "
"`hello_macro`\n"
"function. The default implementation will print `Hello, Macro! My name is\n"
"TypeName!` where `TypeName` is the name of the type on which this trait has\n"
"been defined. In other words, we‚Äôll write a crate that enables another\n"
"programmer to write code like Listing 19-30 using our crate."
msgstr ""

#: src/ch19-06-macros.md:218
msgid ""
"```rust,ignore,does_not_compile\n"
"use hello_macro::HelloMacro;\n"
"use hello_macro_derive::HelloMacro;\n"
"\n"
"#[derive(HelloMacro)]\n"
"struct Pancakes;\n"
"\n"
"fn main() {\n"
"    Pancakes::hello_macro();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:230
msgid ""
"<span class=\"caption\">Listing 19-30: The code a user of our crate will be "
"able\n"
"to write when using our procedural macro</span>"
msgstr ""

#: src/ch19-06-macros.md:233
msgid ""
"This code will print `Hello, Macro! My name is Pancakes!` when we‚Äôre done. "
"The\n"
"first step is to make a new library crate, like this:"
msgstr ""

#: src/ch19-06-macros.md:236
msgid ""
"```console\n"
"$ cargo new hello_macro --lib\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:240
msgid "Next, we‚Äôll define the `HelloMacro` trait and its associated function:"
msgstr ""

#: src/ch19-06-macros.md:244
msgid ""
"```rust,noplayground\n"
"pub trait HelloMacro {\n"
"    fn hello_macro();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:250
msgid ""
"We have a trait and its function. At this point, our crate user could "
"implement\n"
"the trait to achieve the desired functionality, like so:"
msgstr ""

#: src/ch19-06-macros.md:253
msgid ""
"```rust,ignore\n"
"use hello_macro::HelloMacro;\n"
"\n"
"struct Pancakes;\n"
"\n"
"impl HelloMacro for Pancakes {\n"
"    fn hello_macro() {\n"
"        println!(\"Hello, Macro! My name is Pancakes!\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    Pancakes::hello_macro();\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:269
msgid ""
"However, they would need to write the implementation block for each type "
"they\n"
"wanted to use with `hello_macro`; we want to spare them from having to do "
"this\n"
"work."
msgstr ""

#: src/ch19-06-macros.md:273
msgid ""
"Additionally, we can‚Äôt yet provide the `hello_macro` function with default\n"
"implementation that will print the name of the type the trait is "
"implemented\n"
"on: Rust doesn‚Äôt have reflection capabilities, so it can‚Äôt look up the "
"type‚Äôs\n"
"name at runtime. We need a macro to generate code at compile time."
msgstr ""

#: src/ch19-06-macros.md:278
msgid ""
"The next step is to define the procedural macro. At the time of this "
"writing,\n"
"procedural macros need to be in their own crate. Eventually, this "
"restriction\n"
"might be lifted. The convention for structuring crates and macro crates is "
"as\n"
"follows: for a crate named `foo`, a custom derive procedural macro crate is\n"
"called `foo_derive`. Let‚Äôs start a new crate called `hello_macro_derive` "
"inside\n"
"our `hello_macro` project:"
msgstr ""

#: src/ch19-06-macros.md:285
msgid ""
"```console\n"
"$ cargo new hello_macro_derive --lib\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:289
msgid ""
"Our two crates are tightly related, so we create the procedural macro crate\n"
"within the directory of our `hello_macro` crate. If we change the trait\n"
"definition in `hello_macro`, we‚Äôll have to change the implementation of the\n"
"procedural macro in `hello_macro_derive` as well. The two crates will need "
"to\n"
"be published separately, and programmers using these crates will need to "
"add\n"
"both as dependencies and bring them both into scope. We could instead have "
"the\n"
"`hello_macro` crate use `hello_macro_derive` as a dependency and re-export "
"the\n"
"procedural macro code. However, the way we‚Äôve structured the project makes "
"it\n"
"possible for programmers to use `hello_macro` even if they don‚Äôt want the\n"
"`derive` functionality."
msgstr ""

#: src/ch19-06-macros.md:300
msgid ""
"We need to declare the `hello_macro_derive` crate as a procedural macro "
"crate.\n"
"We‚Äôll also need functionality from the `syn` and `quote` crates, as you‚Äôll "
"see\n"
"in a moment, so we need to add them as dependencies. Add the following to "
"the\n"
"*Cargo.toml* file for `hello_macro_derive`:"
msgstr ""

#: src/ch19-06-macros.md:305
msgid "<span class=\"filename\">Filename: hello_macro_derive/Cargo.toml</span>"
msgstr ""

#: src/ch19-06-macros.md:307
msgid ""
"```toml\n"
"[lib]\n"
"proc-macro = true\n"
"\n"
"[dependencies]\n"
"syn = \"1.0\"\n"
"quote = \"1.0\"\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:316
msgid ""
"To start defining the procedural macro, place the code in Listing 19-31 "
"into\n"
"your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this "
"code\n"
"won‚Äôt compile until we add a definition for the `impl_hello_macro` function."
msgstr ""

#: src/ch19-06-macros.md:320 src/ch19-06-macros.md:421
msgid "<span class=\"filename\">Filename: hello_macro_derive/src/lib.rs</span>"
msgstr ""

#: src/ch19-06-macros.md:322
msgid ""
"```rust,ignore,does_not_compile\n"
"use proc_macro::TokenStream;\n"
"use quote::quote;\n"
"use syn;\n"
"\n"
"#[proc_macro_derive(HelloMacro)]\n"
"pub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n"
"    // Construct a representation of Rust code as a syntax tree\n"
"    // that we can manipulate\n"
"    let ast = syn::parse(input).unwrap();\n"
"\n"
"    // Build the trait implementation\n"
"    impl_hello_macro(&ast)\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:338
msgid ""
"<span class=\"caption\">Listing 19-31: Code that most procedural macro "
"crates\n"
"will require in order to process Rust code</span>"
msgstr ""

#: src/ch19-06-macros.md:341
msgid ""
"Notice that we‚Äôve split the code into the `hello_macro_derive` function, "
"which\n"
"is responsible for parsing the `TokenStream`, and the `impl_hello_macro`\n"
"function, which is responsible for transforming the syntax tree: this makes\n"
"writing a procedural macro more convenient. The code in the outer function\n"
"(`hello_macro_derive` in this case) will be the same for almost every\n"
"procedural macro crate you see or create. The code you specify in the body "
"of\n"
"the inner function (`impl_hello_macro` in this case) will be different\n"
"depending on your procedural macro‚Äôs purpose."
msgstr ""

#: src/ch19-06-macros.md:350
msgid ""
"We‚Äôve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. "
"The\n"
"`proc_macro` crate comes with Rust, so we didn‚Äôt need to add that to the\n"
"dependencies in *Cargo.toml*. The `proc_macro` crate is the compiler‚Äôs API "
"that\n"
"allows us to read and manipulate Rust code from our code."
msgstr ""

#: src/ch19-06-macros.md:355
msgid ""
"The `syn` crate parses Rust code from a string into a data structure that "
"we\n"
"can perform operations on. The `quote` crate turns `syn` data structures "
"back\n"
"into Rust code. These crates make it much simpler to parse any sort of Rust\n"
"code we might want to handle: writing a full parser for Rust code is no "
"simple\n"
"task."
msgstr ""

#: src/ch19-06-macros.md:361
msgid ""
"The `hello_macro_derive` function will be called when a user of our library\n"
"specifies `#[derive(HelloMacro)]` on a type. This is possible because we‚Äôve\n"
"annotated the `hello_macro_derive` function here with `proc_macro_derive` "
"and\n"
"specified the name `HelloMacro`, which matches our trait name; this is the\n"
"convention most procedural macros follow."
msgstr ""

#: src/ch19-06-macros.md:367
msgid ""
"The `hello_macro_derive` function first converts the `input` from a\n"
"`TokenStream` to a data structure that we can then interpret and perform\n"
"operations on. This is where `syn` comes into play. The `parse` function in\n"
"`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing "
"the\n"
"parsed Rust code. Listing 19-32 shows the relevant parts of the "
"`DeriveInput`\n"
"struct we get from parsing the `struct Pancakes;` string:"
msgstr ""

#: src/ch19-06-macros.md:374
msgid ""
"```rust,ignore\n"
"DeriveInput {\n"
"    // --snip--\n"
"\n"
"    ident: Ident {\n"
"        ident: \"Pancakes\",\n"
"        span: #0 bytes(95..103)\n"
"    },\n"
"    data: Struct(\n"
"        DataStruct {\n"
"            struct_token: Struct,\n"
"            fields: Unit,\n"
"            semi_token: Some(\n"
"                Semi\n"
"            )\n"
"        }\n"
"    )\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:394
msgid ""
"<span class=\"caption\">Listing 19-32: The `DeriveInput` instance we get "
"when\n"
"parsing the code that has the macro‚Äôs attribute in Listing 19-30</span>"
msgstr ""

#: src/ch19-06-macros.md:397
msgid ""
"The fields of this struct show that the Rust code we‚Äôve parsed is a unit "
"struct\n"
"with the `ident` (identifier, meaning the name) of `Pancakes`. There are "
"more\n"
"fields on this struct for describing all sorts of Rust code; check the "
"[`syn`\n"
"documentation for `DeriveInput`][syn-docs] for more information."
msgstr ""

#: src/ch19-06-macros.md:402
msgid ""
"Soon we‚Äôll define the `impl_hello_macro` function, which is where we‚Äôll "
"build\n"
"the new Rust code we want to include. But before we do, note that the "
"output\n"
"for our derive macro is also a `TokenStream`. The returned `TokenStream` is\n"
"added to the code that our crate users write, so when they compile their "
"crate,\n"
"they‚Äôll get the extra functionality that we provide in the modified\n"
"`TokenStream`."
msgstr ""

#: src/ch19-06-macros.md:409
msgid ""
"You might have noticed that we‚Äôre calling `unwrap` to cause the\n"
"`hello_macro_derive` function to panic if the call to the `syn::parse` "
"function\n"
"fails here. It‚Äôs necessary for our procedural macro to panic on errors "
"because\n"
"`proc_macro_derive` functions must return `TokenStream` rather than `Result` "
"to\n"
"conform to the procedural macro API. We‚Äôve simplified this example by using\n"
"`unwrap`; in production code, you should provide more specific error "
"messages\n"
"about what went wrong by using `panic!` or `expect`."
msgstr ""

#: src/ch19-06-macros.md:417
msgid ""
"Now that we have the code to turn the annotated Rust code from a "
"`TokenStream`\n"
"into a `DeriveInput` instance, let‚Äôs generate the code that implements the\n"
"`HelloMacro` trait on the annotated type, as shown in Listing 19-33."
msgstr ""

#: src/ch19-06-macros.md:423
msgid ""
"```rust,ignore\n"
"# use proc_macro::TokenStream;\n"
"# use quote::quote;\n"
"# use syn;\n"
"# \n"
"# #[proc_macro_derive(HelloMacro)]\n"
"# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n"
"#     // Construct a representation of Rust code as a syntax tree\n"
"#     // that we can manipulate\n"
"#     let ast = syn::parse(input).unwrap();\n"
"# \n"
"#     // Build the trait implementation\n"
"#     impl_hello_macro(&ast)\n"
"# }\n"
"# \n"
"fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n"
"    let name = &ast.ident;\n"
"    let gen = quote! {\n"
"        impl HelloMacro for #name {\n"
"            fn hello_macro() {\n"
"                println!(\"Hello, Macro! My name is {}!\", stringify!"
"(#name));\n"
"            }\n"
"        }\n"
"    };\n"
"    gen.into()\n"
"}\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:451
msgid ""
"<span class=\"caption\">Listing 19-33: Implementing the `HelloMacro` trait "
"using\n"
"the parsed Rust code</span>"
msgstr ""

#: src/ch19-06-macros.md:454
msgid ""
"We get an `Ident` struct instance containing the name (identifier) of the\n"
"annotated type using `ast.ident`. The struct in Listing 19-32 shows that "
"when\n"
"we run the `impl_hello_macro` function on the code in Listing 19-30, the\n"
"`ident` we get will have the `ident` field with a value of `\"Pancakes\"`. "
"Thus,\n"
"the `name` variable in Listing 19-33 will contain an `Ident` struct "
"instance\n"
"that, when printed, will be the string `\"Pancakes\"`, the name of the "
"struct in\n"
"Listing 19-30."
msgstr ""

#: src/ch19-06-macros.md:462
msgid ""
"The `quote!` macro lets us define the Rust code that we want to return. The\n"
"compiler expects something different to the direct result of the `quote!`\n"
"macro‚Äôs execution, so we need to convert it to a `TokenStream`. We do this "
"by\n"
"calling the `into` method, which consumes this intermediate representation "
"and\n"
"returns a value of the required `TokenStream` type."
msgstr ""

#: src/ch19-06-macros.md:468
msgid ""
"The `quote!` macro also provides some very cool templating mechanics: we "
"can\n"
"enter `#name`, and `quote!` will replace it with the value in the variable\n"
"`name`. You can even do some repetition similar to the way regular macros "
"work.\n"
"Check out [the `quote` crate‚Äôs docs][quote-docs] for a thorough introduction."
msgstr ""

#: src/ch19-06-macros.md:473
msgid ""
"We want our procedural macro to generate an implementation of our "
"`HelloMacro`\n"
"trait for the type the user annotated, which we can get by using `#name`. "
"The\n"
"trait implementation has the one function `hello_macro`, whose body contains "
"the\n"
"functionality we want to provide: printing `Hello, Macro! My name is` and "
"then\n"
"the name of the annotated type."
msgstr ""

#: src/ch19-06-macros.md:479
msgid ""
"The `stringify!` macro used here is built into Rust. It takes a Rust\n"
"expression, such as `1 + 2`, and at compile time turns the expression into "
"a\n"
"string literal, such as `\"1 + 2\"`. This is different than `format!` or\n"
"`println!`, macros which evaluate the expression and then turn the result "
"into\n"
"a `String`. There is a possibility that the `#name` input might be an\n"
"expression to print literally, so we use `stringify!`. Using `stringify!` "
"also\n"
"saves an allocation by converting `#name` to a string literal at compile "
"time."
msgstr ""

#: src/ch19-06-macros.md:487
msgid ""
"At this point, `cargo build` should complete successfully in both "
"`hello_macro`\n"
"and `hello_macro_derive`. Let‚Äôs hook up these crates to the code in Listing\n"
"19-30 to see the procedural macro in action! Create a new binary project in\n"
"your *projects* directory using `cargo new pancakes`. We need to add\n"
"`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`\n"
"crate‚Äôs *Cargo.toml*. If you‚Äôre publishing your versions of `hello_macro` "
"and\n"
"`hello_macro_derive` to [crates.io](https://crates.io/), they would be "
"regular\n"
"dependencies; if not, you can specify them as `path` dependencies as follows:"
msgstr ""

#: src/ch19-06-macros.md:496
msgid ""
"```toml\n"
"hello_macro = { path = \"../hello_macro\" }\n"
"hello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:501
msgid ""
"Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it\n"
"should print `Hello, Macro! My name is Pancakes!` The implementation of the\n"
"`HelloMacro` trait from the procedural macro was included without the\n"
"`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added "
"the\n"
"trait implementation."
msgstr ""

#: src/ch19-06-macros.md:507
msgid ""
"Next, let‚Äôs explore how the other kinds of procedural macros differ from "
"custom\n"
"derive macros."
msgstr ""

#: src/ch19-06-macros.md:510
msgid "### Attribute-like macros"
msgstr ""

#: src/ch19-06-macros.md:512
msgid ""
"Attribute-like macros are similar to custom derive macros, but instead of\n"
"generating code for the `derive` attribute, they allow you to create new\n"
"attributes. They‚Äôre also more flexible: `derive` only works for structs and\n"
"enums; attributes can be applied to other items as well, such as functions.\n"
"Here‚Äôs an example of using an attribute-like macro: say you have an "
"attribute\n"
"named `route` that annotates functions when using a web application "
"framework:"
msgstr ""

#: src/ch19-06-macros.md:519
msgid ""
"```rust,ignore\n"
"#[route(GET, \"/\")]\n"
"fn index() {\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:524
msgid ""
"This `#[route]` attribute would be defined by the framework as a procedural\n"
"macro. The signature of the macro definition function would look like this:"
msgstr ""

#: src/ch19-06-macros.md:527
msgid ""
"```rust,ignore\n"
"#[proc_macro_attribute]\n"
"pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:532
msgid ""
"Here, we have two parameters of type `TokenStream`. The first is for the\n"
"contents of the attribute: the `GET, \"/\"` part. The second is the body of "
"the\n"
"item the attribute is attached to: in this case, `fn index() {}` and the "
"rest\n"
"of the function‚Äôs body."
msgstr ""

#: src/ch19-06-macros.md:537
msgid ""
"Other than that, attribute-like macros work the same way as custom derive\n"
"macros: you create a crate with the `proc-macro` crate type and implement a\n"
"function that generates the code you want!"
msgstr ""

#: src/ch19-06-macros.md:541
msgid "### Function-like macros"
msgstr ""

#: src/ch19-06-macros.md:543
msgid ""
"Function-like macros define macros that look like function calls. Similarly "
"to\n"
"`macro_rules!` macros, they‚Äôre more flexible than functions; for example, "
"they\n"
"can take an unknown number of arguments. However, `macro_rules!` macros can "
"be\n"
"defined only using the match-like syntax we discussed in the section\n"
"[‚ÄúDeclarative Macros with `macro_rules!` for General\n"
"Metaprogramming‚Äù][decl]<!-- ignore --> earlier. Function-like macros take a\n"
"`TokenStream` parameter and their definition manipulates that `TokenStream`\n"
"using Rust code as the other two types of procedural macros do. An example "
"of a\n"
"function-like macro is an `sql!` macro that might be called like so:"
msgstr ""

#: src/ch19-06-macros.md:553
msgid ""
"```rust,ignore\n"
"let sql = sql!(SELECT * FROM posts WHERE id=1);\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:557
msgid ""
"This macro would parse the SQL statement inside it and check that it‚Äôs\n"
"syntactically correct, which is much more complex processing than a\n"
"`macro_rules!` macro can do. The `sql!` macro would be defined like this:"
msgstr ""

#: src/ch19-06-macros.md:561
msgid ""
"```rust,ignore\n"
"#[proc_macro]\n"
"pub fn sql(input: TokenStream) -> TokenStream {\n"
"```"
msgstr ""

#: src/ch19-06-macros.md:566
msgid ""
"This definition is similar to the custom derive macro‚Äôs signature: we "
"receive\n"
"the tokens that are inside the parentheses and return the code we wanted to\n"
"generate."
msgstr ""

#: src/ch19-06-macros.md:572
msgid ""
"Whew! Now you have some Rust features in your toolbox that you likely won‚Äôt "
"use\n"
"often, but you‚Äôll know they‚Äôre available in very particular circumstances.\n"
"We‚Äôve introduced several complex topics so that when you encounter them in\n"
"error message suggestions or in other peoples‚Äô code, you‚Äôll be able to\n"
"recognize these concepts and syntax. Use this chapter as a reference to "
"guide\n"
"you to solutions."
msgstr ""

#: src/ch19-06-macros.md:579
msgid ""
"Next, we‚Äôll put everything we‚Äôve discussed throughout the book into "
"practice\n"
"and do one more project!"
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:1
msgid "# Final Project: Building a Multithreaded Web Server"
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:3
msgid ""
"It‚Äôs been a long journey, but we‚Äôve reached the end of the book. In this\n"
"chapter, we‚Äôll build one more project together to demonstrate some of the\n"
"concepts we covered in the final chapters, as well as recap some earlier\n"
"lessons."
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:8
msgid ""
"For our final project, we‚Äôll make a web server that says ‚Äúhello‚Äù and looks "
"like\n"
"Figure 20-1 in a web browser."
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:11
msgid "hello from rust"
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:13
msgid "<span class=\"caption\">Figure 20-1: Our final shared project</span>"
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:15
msgid "Here is our plan for building the web server:"
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:17
msgid ""
"1. Learn a bit about TCP and HTTP.\n"
"2. Listen for TCP connections on a socket.\n"
"3. Parse a small number of HTTP requests.\n"
"4. Create a proper HTTP response.\n"
"5. Improve the throughput of our server with a thread pool."
msgstr ""

#: src/ch20-00-final-project-a-web-server.md:23
msgid ""
"Before we get started, we should mention one detail: the method we‚Äôll use "
"won‚Äôt\n"
"be the best way to build a web server with Rust. Community members have\n"
"published a number of production-ready crates available on\n"
"[crates.io](https://crates.io/) that provide more complete web server and\n"
"thread pool implementations than we‚Äôll build. However, our intention in "
"this\n"
"chapter is to help you learn, not to take the easy route. Because Rust is a\n"
"systems programming language, we can choose the level of abstraction we want "
"to\n"
"work with and can go to a lower level than is possible or practical in "
"other\n"
"languages. We‚Äôll therefore write the basic HTTP server and thread pool "
"manually\n"
"so you can learn the general ideas and techniques behind the crates you "
"might\n"
"use in the future."
msgstr ""

#: src/ch20-01-single-threaded.md:1
msgid "## Building a Single-Threaded Web Server"
msgstr ""

#: src/ch20-01-single-threaded.md:3
msgid ""
"We‚Äôll start by getting a single-threaded web server working. Before we "
"begin,\n"
"let‚Äôs look at a quick overview of the protocols involved in building web\n"
"servers. The details of these protocols are beyond the scope of this book, "
"but\n"
"a brief overview will give you the information you need."
msgstr ""

#: src/ch20-01-single-threaded.md:8
msgid ""
"The two main protocols involved in web servers are *Hypertext Transfer\n"
"Protocol* *(HTTP)* and *Transmission Control Protocol* *(TCP)*. Both "
"protocols\n"
"are *request-response* protocols, meaning a *client* initiates requests and "
"a\n"
"*server* listens to the requests and provides a response to the client. The\n"
"contents of those requests and responses are defined by the protocols."
msgstr ""

#: src/ch20-01-single-threaded.md:14
msgid ""
"TCP is the lower-level protocol that describes the details of how "
"information\n"
"gets from one server to another but doesn‚Äôt specify what that information "
"is.\n"
"HTTP builds on top of TCP by defining the contents of the requests and\n"
"responses. It‚Äôs technically possible to use HTTP with other protocols, but "
"in\n"
"the vast majority of cases, HTTP sends its data over TCP. We‚Äôll work with "
"the\n"
"raw bytes of TCP and HTTP requests and responses."
msgstr ""

#: src/ch20-01-single-threaded.md:21
msgid "### Listening to the TCP Connection"
msgstr ""

#: src/ch20-01-single-threaded.md:23
msgid ""
"Our web server needs to listen to a TCP connection, so that‚Äôs the first "
"part\n"
"we‚Äôll work on. The standard library offers a `std::net` module that lets us "
"do\n"
"this. Let‚Äôs make a new project in the usual fashion:"
msgstr ""

#: src/ch20-01-single-threaded.md:27
msgid ""
"```console\n"
"$ cargo new hello\n"
"     Created binary (application) `hello` project\n"
"$ cd hello\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:33
msgid ""
"Now enter the code in Listing 20-1 in *src/main.rs* to start. This code "
"will\n"
"listen at the local address `127.0.0.1:7878` for incoming TCP streams. When "
"it\n"
"gets an incoming stream, it will print `Connection established!`."
msgstr ""

#: src/ch20-01-single-threaded.md:39
msgid ""
"```rust,no_run\n"
"use std::net::TcpListener;\n"
"\n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"\n"
"    for stream in listener.incoming() {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        println!(\"Connection established!\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:53
msgid ""
"<span class=\"caption\">Listing 20-1: Listening for incoming streams and "
"printing\n"
"a message when we receive a stream</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:56
msgid ""
"Using `TcpListener`, we can listen for TCP connections at the address\n"
"`127.0.0.1:7878`. In the address, the section before the colon is an IP "
"address\n"
"representing your computer (this is the same on every computer and doesn‚Äôt\n"
"represent the authors‚Äô computer specifically), and `7878` is the port. "
"We‚Äôve\n"
"chosen this port for two reasons: HTTP isn‚Äôt normally accepted on this port "
"so\n"
"our server is unlikely to conflict with any other web server you might have\n"
"running on your machine, and 7878 is *rust* typed on a telephone."
msgstr ""

#: src/ch20-01-single-threaded.md:64
msgid ""
"The `bind` function in this scenario works like the `new` function in that "
"it\n"
"will return a new `TcpListener` instance. The function is called `bind`\n"
"because, in networking, connecting to a port to listen to is known as "
"‚Äúbinding\n"
"to a port.‚Äù"
msgstr ""

#: src/ch20-01-single-threaded.md:69
msgid ""
"The `bind` function returns a `Result<T, E>`, which indicates that it‚Äôs\n"
"possible for binding to fail. For example, connecting to port 80 requires\n"
"administrator privileges (nonadministrators can listen only on ports higher\n"
"than 1023), so if we tried to connect to port 80 without being an\n"
"administrator, binding wouldn‚Äôt work. Binding also wouldn‚Äôt work, for "
"example,\n"
"if we ran two instances of our program and so had two programs listening to "
"the\n"
"same port. Because we‚Äôre writing a basic server just for learning purposes, "
"we\n"
"won‚Äôt worry about handling these kinds of errors; instead, we use `unwrap` "
"to\n"
"stop the program if errors happen."
msgstr ""

#: src/ch20-01-single-threaded.md:79
msgid ""
"The `incoming` method on `TcpListener` returns an iterator that gives us a\n"
"sequence of streams (more specifically, streams of type `TcpStream`). A "
"single\n"
"*stream* represents an open connection between the client and the server. A\n"
"*connection* is the name for the full request and response process in which "
"a\n"
"client connects to the server, the server generates a response, and the "
"server\n"
"closes the connection. As such, we will read from the `TcpStream` to see "
"what\n"
"the client sent and then write our response to the stream to send data back "
"to\n"
"the client. Overall, this `for` loop will process each connection in turn "
"and\n"
"produce a series of streams for us to handle."
msgstr ""

#: src/ch20-01-single-threaded.md:89
msgid ""
"For now, our handling of the stream consists of calling `unwrap` to "
"terminate\n"
"our program if the stream has any errors; if there aren‚Äôt any errors, the\n"
"program prints a message. We‚Äôll add more functionality for the success case "
"in\n"
"the next listing. The reason we might receive errors from the `incoming` "
"method\n"
"when a client connects to the server is that we‚Äôre not actually iterating "
"over\n"
"connections. Instead, we‚Äôre iterating over *connection attempts*. The\n"
"connection might not be successful for a number of reasons, many of them\n"
"operating system specific. For example, many operating systems have a limit "
"to\n"
"the number of simultaneous open connections they can support; new "
"connection\n"
"attempts beyond that number will produce an error until some of the open\n"
"connections are closed."
msgstr ""

#: src/ch20-01-single-threaded.md:101
msgid ""
"Let‚Äôs try running this code! Invoke `cargo run` in the terminal and then "
"load\n"
"*127.0.0.1:7878* in a web browser. The browser should show an error message\n"
"like ‚ÄúConnection reset,‚Äù because the server isn‚Äôt currently sending back "
"any\n"
"data. But when you look at your terminal, you should see several messages "
"that\n"
"were printed when the browser connected to the server!"
msgstr ""

#: src/ch20-01-single-threaded.md:107
msgid ""
"```text\n"
"     Running `target/debug/hello`\n"
"Connection established!\n"
"Connection established!\n"
"Connection established!\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:114
msgid ""
"Sometimes, you‚Äôll see multiple messages printed for one browser request; "
"the\n"
"reason might be that the browser is making a request for the page as well as "
"a\n"
"request for other resources, like the *favicon.ico* icon that appears in "
"the\n"
"browser tab."
msgstr ""

#: src/ch20-01-single-threaded.md:119
msgid ""
"It could also be that the browser is trying to connect to the server "
"multiple\n"
"times because the server isn‚Äôt responding with any data. When `stream` goes "
"out\n"
"of scope and is dropped at the end of the loop, the connection is closed as\n"
"part of the `drop` implementation. Browsers sometimes deal with closed\n"
"connections by retrying, because the problem might be temporary. The "
"important\n"
"factor is that we‚Äôve successfully gotten a handle to a TCP connection!"
msgstr ""

#: src/ch20-01-single-threaded.md:126
msgid ""
"Remember to stop the program by pressing <span class=\"keystroke\">ctrl-c</"
"span>\n"
"when you‚Äôre done running a particular version of the code. Then restart the\n"
"program by invoking the `cargo run` command after you‚Äôve made each set of "
"code\n"
"changes to make sure you‚Äôre running the newest code."
msgstr ""

#: src/ch20-01-single-threaded.md:131
msgid "### Reading the Request"
msgstr ""

#: src/ch20-01-single-threaded.md:133
msgid ""
"Let‚Äôs implement the functionality to read the request from the browser! To\n"
"separate the concerns of first getting a connection and then taking some "
"action\n"
"with the connection, we‚Äôll start a new function for processing connections. "
"In\n"
"this new `handle_connection` function, we‚Äôll read data from the TCP stream "
"and\n"
"print it so we can see the data being sent from the browser. Change the code "
"to\n"
"look like Listing 20-2."
msgstr ""

#: src/ch20-01-single-threaded.md:142
msgid ""
"```rust,no_run\n"
"use std::{\n"
"    io::{prelude::*, BufReader},\n"
"    net::{TcpListener, TcpStream},\n"
"};\n"
"\n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"\n"
"    for stream in listener.incoming() {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        handle_connection(stream);\n"
"    }\n"
"}\n"
"\n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    let buf_reader = BufReader::new(&mut stream);\n"
"    let http_request: Vec<_> = buf_reader\n"
"        .lines()\n"
"        .map(|result| result.unwrap())\n"
"        .take_while(|line| !line.is_empty())\n"
"        .collect();\n"
"\n"
"    println!(\"Request: {:#?}\", http_request);\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:170
msgid ""
"<span class=\"caption\">Listing 20-2: Reading from the `TcpStream` and "
"printing\n"
"the data</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:173
msgid ""
"We bring `std::io::prelude` and `std::io::BufReader` into scope to get "
"access\n"
"to traits and types that let us read from and write to the stream. In the "
"`for`\n"
"loop in the `main` function, instead of printing a message that says we made "
"a\n"
"connection, we now call the new `handle_connection` function and pass the\n"
"`stream` to it."
msgstr ""

#: src/ch20-01-single-threaded.md:179
msgid ""
"In the `handle_connection` function, we create a new `BufReader` instance "
"that\n"
"wraps a mutable reference to the `stream`. `BufReader` adds buffering by\n"
"managing calls to the `std::io::Read` trait methods for us."
msgstr ""

#: src/ch20-01-single-threaded.md:183
msgid ""
"We create a variable named `http_request` to collect the lines of the "
"request\n"
"the browser sends to our server. We indicate that we want to collect these\n"
"lines in a vector by adding the `Vec<_>` type annotation."
msgstr ""

#: src/ch20-01-single-threaded.md:187
msgid ""
"`BufReader` implements the `std::io::BufRead` trait, which provides the "
"`lines`\n"
"method. The `lines` method returns an iterator of `Result<String,\n"
"std::io::Error>` by splitting the stream of data whenever it sees a newline\n"
"byte. To get each `String`, we map and `unwrap` each `Result`. The `Result`\n"
"might be an error if the data isn‚Äôt valid UTF-8 or if there was a problem\n"
"reading from the stream. Again, a production program should handle these "
"errors\n"
"more gracefully, but we‚Äôre choosing to stop the program in the error case "
"for\n"
"simplicity."
msgstr ""

#: src/ch20-01-single-threaded.md:196
msgid ""
"The browser signals the end of an HTTP request by sending two newline\n"
"characters in a row, so to get one request from the stream, we take lines "
"until\n"
"we get a line that is the empty string. Once we‚Äôve collected the lines into "
"the\n"
"vector, we‚Äôre printing them out using pretty debug formatting so we can take "
"a\n"
"look at the instructions the web browser is sending to our server."
msgstr ""

#: src/ch20-01-single-threaded.md:202
msgid ""
"Let‚Äôs try this code! Start the program and make a request in a web browser\n"
"again. Note that we‚Äôll still get an error page in the browser, but our\n"
"program‚Äôs output in the terminal will now look similar to this:"
msgstr ""

#: src/ch20-01-single-threaded.md:206
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n"
"     Running `target/debug/hello`\n"
"Request: [\n"
"    \"GET / HTTP/1.1\",\n"
"    \"Host: 127.0.0.1:7878\",\n"
"    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) "
"Gecko/20100101 Firefox/99.0\",\n"
"    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/"
"avif,image/webp,*/*;q=0.8\",\n"
"    \"Accept-Language: en-US,en;q=0.5\",\n"
"    \"Accept-Encoding: gzip, deflate, br\",\n"
"    \"DNT: 1\",\n"
"    \"Connection: keep-alive\",\n"
"    \"Upgrade-Insecure-Requests: 1\",\n"
"    \"Sec-Fetch-Dest: document\",\n"
"    \"Sec-Fetch-Mode: navigate\",\n"
"    \"Sec-Fetch-Site: none\",\n"
"    \"Sec-Fetch-User: ?1\",\n"
"    \"Cache-Control: max-age=0\",\n"
"]\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:229
msgid ""
"Depending on your browser, you might get slightly different output. Now "
"that\n"
"we‚Äôre printing the request data, we can see why we get multiple connections\n"
"from one browser request by looking at the path after `GET` in the first "
"line\n"
"of the request. If the repeated connections are all requesting */*, we know "
"the\n"
"browser is trying to fetch */* repeatedly because it‚Äôs not getting a "
"response\n"
"from our program."
msgstr ""

#: src/ch20-01-single-threaded.md:236
msgid ""
"Let‚Äôs break down this request data to understand what the browser is asking "
"of\n"
"our program."
msgstr ""

#: src/ch20-01-single-threaded.md:239
msgid "### A Closer Look at an HTTP Request"
msgstr ""

#: src/ch20-01-single-threaded.md:241
msgid "HTTP is a text-based protocol, and a request takes this format:"
msgstr ""

#: src/ch20-01-single-threaded.md:243
msgid ""
"```text\n"
"Method Request-URI HTTP-Version CRLF\n"
"headers CRLF\n"
"message-body\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:249
msgid ""
"The first line is the *request line* that holds information about what the\n"
"client is requesting. The first part of the request line indicates the "
"*method*\n"
"being used, such as `GET` or `POST`, which describes how the client is "
"making\n"
"this request. Our client used a `GET` request, which means it is asking for\n"
"information."
msgstr ""

#: src/ch20-01-single-threaded.md:255
msgid ""
"The next part of the request line is */*, which indicates the *Uniform "
"Resource\n"
"Identifier* *(URI)* the client is requesting: a URI is almost, but not "
"quite,\n"
"the same as a *Uniform Resource Locator* *(URL)*. The difference between "
"URIs\n"
"and URLs isn‚Äôt important for our purposes in this chapter, but the HTTP "
"spec\n"
"uses the term URI, so we can just mentally substitute URL for URI here."
msgstr ""

#: src/ch20-01-single-threaded.md:261
msgid ""
"The last part is the HTTP version the client uses, and then the request "
"line\n"
"ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line "
"feed*,\n"
"which are terms from the typewriter days!) The CRLF sequence can also be\n"
"written as `\\r\\n`, where `\\r` is a carriage return and `\\n` is a line "
"feed. The\n"
"CRLF sequence separates the request line from the rest of the request data.\n"
"Note that when the CRLF is printed, we see a new line start rather than "
"`\\r\\n`."
msgstr ""

#: src/ch20-01-single-threaded.md:268
msgid ""
"Looking at the request line data we received from running our program so "
"far,\n"
"we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is "
"the\n"
"version."
msgstr ""

#: src/ch20-01-single-threaded.md:272
msgid ""
"After the request line, the remaining lines starting from `Host:` onward "
"are\n"
"headers. `GET` requests have no body."
msgstr ""

#: src/ch20-01-single-threaded.md:275
msgid ""
"Try making a request from a different browser or asking for a different\n"
"address, such as *127.0.0.1:7878/test*, to see how the request data changes."
msgstr ""

#: src/ch20-01-single-threaded.md:278
msgid ""
"Now that we know what the browser is asking for, let‚Äôs send back some data!"
msgstr ""

#: src/ch20-01-single-threaded.md:280
msgid "### Writing a Response"
msgstr ""

#: src/ch20-01-single-threaded.md:282
msgid ""
"We‚Äôre going to implement sending data in response to a client request.\n"
"Responses have the following format:"
msgstr ""

#: src/ch20-01-single-threaded.md:285
msgid ""
"```text\n"
"HTTP-Version Status-Code Reason-Phrase CRLF\n"
"headers CRLF\n"
"message-body\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:291
msgid ""
"The first line is a *status line* that contains the HTTP version used in "
"the\n"
"response, a numeric status code that summarizes the result of the request, "
"and\n"
"a reason phrase that provides a text description of the status code. After "
"the\n"
"CRLF sequence are any headers, another CRLF sequence, and the body of the\n"
"response."
msgstr ""

#: src/ch20-01-single-threaded.md:297
msgid ""
"Here is an example response that uses HTTP version 1.1, has a status code "
"of\n"
"200, an OK reason phrase, no headers, and no body:"
msgstr ""

#: src/ch20-01-single-threaded.md:300
msgid ""
"```text\n"
"HTTP/1.1 200 OK\\r\\n\\r\\n\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:304
msgid ""
"The status code 200 is the standard success response. The text is a tiny\n"
"successful HTTP response. Let‚Äôs write this to the stream as our response to "
"a\n"
"successful request! From the `handle_connection` function, remove the\n"
"`println!` that was printing the request data and replace it with the code "
"in\n"
"Listing 20-3."
msgstr ""

#: src/ch20-01-single-threaded.md:312
msgid ""
"```rust,no_run\n"
"# use std::{\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"# };\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"# \n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    let buf_reader = BufReader::new(&mut stream);\n"
"    let http_request: Vec<_> = buf_reader\n"
"        .lines()\n"
"        .map(|result| result.unwrap())\n"
"        .take_while(|line| !line.is_empty())\n"
"        .collect();\n"
"\n"
"    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n"
"\n"
"    stream.write_all(response.as_bytes()).unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:342
msgid ""
"<span class=\"caption\">Listing 20-3: Writing a tiny successful HTTP "
"response to\n"
"the stream</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:345
msgid ""
"The first new line defines the `response` variable that holds the success\n"
"message‚Äôs data. Then we call `as_bytes` on our `response` to convert the "
"string\n"
"data to bytes. The `write_all` method on `stream` takes a `&[u8]` and sends\n"
"those bytes directly down the connection. Because the `write_all` operation\n"
"could fail, we use `unwrap` on any error result as before. Again, in a real\n"
"application you would add error handling here."
msgstr ""

#: src/ch20-01-single-threaded.md:352
msgid ""
"With these changes, let‚Äôs run our code and make a request. We‚Äôre no longer\n"
"printing any data to the terminal, so we won‚Äôt see any output other than "
"the\n"
"output from Cargo. When you load *127.0.0.1:7878* in a web browser, you "
"should\n"
"get a blank page instead of an error. You‚Äôve just hand-coded receiving an "
"HTTP\n"
"request and sending a response!"
msgstr ""

#: src/ch20-01-single-threaded.md:358
msgid "### Returning Real HTML"
msgstr ""

#: src/ch20-01-single-threaded.md:360
msgid ""
"Let‚Äôs implement the functionality for returning more than a blank page. "
"Create\n"
"the new file *hello.html* in the root of your project directory, not in the\n"
"*src* directory. You can input any HTML you want; Listing 20-4 shows one\n"
"possibility."
msgstr ""

#: src/ch20-01-single-threaded.md:365
msgid "<span class=\"filename\">Filename: hello.html</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:367
msgid ""
"```html\n"
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"  <head>\n"
"    <meta charset=\"utf-8\">\n"
"    <title>Hello!</title>\n"
"  </head>\n"
"  <body>\n"
"    <h1>Hello!</h1>\n"
"    <p>Hi from Rust</p>\n"
"  </body>\n"
"</html>\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:381
msgid ""
"<span class=\"caption\">Listing 20-4: A sample HTML file to return in a\n"
"response</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:384
msgid ""
"This is a minimal HTML5 document with a heading and some text. To return "
"this\n"
"from the server when a request is received, we‚Äôll modify `handle_connection` "
"as\n"
"shown in Listing 20-5 to read the HTML file, add it to the response as a "
"body,\n"
"and send it."
msgstr ""

#: src/ch20-01-single-threaded.md:391
msgid ""
"```rust,no_run\n"
"use std::{\n"
"    fs,\n"
"    io::{prelude::*, BufReader},\n"
"    net::{TcpListener, TcpStream},\n"
"};\n"
"// --snip--\n"
"\n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"# \n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    let buf_reader = BufReader::new(&mut stream);\n"
"    let http_request: Vec<_> = buf_reader\n"
"        .lines()\n"
"        .map(|result| result.unwrap())\n"
"        .take_while(|line| !line.is_empty())\n"
"        .collect();\n"
"\n"
"    let status_line = \"HTTP/1.1 200 OK\";\n"
"    let contents = fs::read_to_string(\"hello.html\").unwrap();\n"
"    let length = contents.len();\n"
"\n"
"    let response =\n"
"        format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"\n"
"    stream.write_all(response.as_bytes()).unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:428
msgid ""
"<span class=\"caption\">Listing 20-5: Sending the contents of *hello.html* "
"as the\n"
"body of the response</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:431
msgid ""
"We‚Äôve added `fs` to the `use` statement to bring the standard library‚Äôs\n"
"filesystem module into scope. The code for reading the contents of a file to "
"a\n"
"string should look familiar; we used it in Chapter 12 when we read the "
"contents\n"
"of a file for our I/O project in Listing 12-4."
msgstr ""

#: src/ch20-01-single-threaded.md:436
msgid ""
"Next, we use `format!` to add the file‚Äôs contents as the body of the "
"success\n"
"response. To ensure a valid HTTP response, we add the `Content-Length` "
"header\n"
"which is set to the size of our response body, in this case the size of\n"
"`hello.html`."
msgstr ""

#: src/ch20-01-single-threaded.md:441
msgid ""
"Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; "
"you\n"
"should see your HTML rendered!"
msgstr ""

#: src/ch20-01-single-threaded.md:444
msgid ""
"Currently, we‚Äôre ignoring the request data in `http_request` and just "
"sending\n"
"back the contents of the HTML file unconditionally. That means if you try\n"
"requesting *127.0.0.1:7878/something-else* in your browser, you‚Äôll still "
"get\n"
"back this same HTML response. At the moment, our server is very limited and\n"
"does not do what most web servers do. We want to customize our responses\n"
"depending on the request and only send back the HTML file for a well-formed\n"
"request to */*."
msgstr ""

#: src/ch20-01-single-threaded.md:452
msgid "### Validating the Request and Selectively Responding"
msgstr ""

#: src/ch20-01-single-threaded.md:454
msgid ""
"Right now, our web server will return the HTML in the file no matter what "
"the\n"
"client requested. Let‚Äôs add functionality to check that the browser is\n"
"requesting */* before returning the HTML file and return an error if the\n"
"browser requests anything else. For this we need to modify "
"`handle_connection`,\n"
"as shown in Listing 20-6. This new code checks the content of the request\n"
"received against what we know a request for */* looks like and adds `if` "
"and\n"
"`else` blocks to treat requests differently."
msgstr ""

#: src/ch20-01-single-threaded.md:464
msgid ""
"```rust,no_run\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"# };\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"// --snip--\n"
"\n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    let buf_reader = BufReader::new(&mut stream);\n"
"    let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"\n"
"    if request_line == \"GET / HTTP/1.1\" {\n"
"        let status_line = \"HTTP/1.1 200 OK\";\n"
"        let contents = fs::read_to_string(\"hello.html\").unwrap();\n"
"        let length = contents.len();\n"
"\n"
"        let response = format!(\n"
"            \"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\"\n"
"        );\n"
"\n"
"        stream.write_all(response.as_bytes()).unwrap();\n"
"    } else {\n"
"        // some other request\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:502
msgid ""
"<span class=\"caption\">Listing 20-6: Handling requests to */* differently "
"from\n"
"other requests</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:505
msgid ""
"We‚Äôre only going to be looking at the first line of the HTTP request, so "
"rather\n"
"than reading the entire request into a vector, we‚Äôre calling `next` to get "
"the\n"
"first item from the iterator. The first `unwrap` takes care of the `Option` "
"and\n"
"stops the program if the iterator has no items. The second `unwrap` handles "
"the\n"
"`Result` and has the same effect as the `unwrap` that was in the `map` added "
"in\n"
"Listing 20-2."
msgstr ""

#: src/ch20-01-single-threaded.md:512
msgid ""
"Next, we check the `request_line` to see if it equals the request line of a "
"GET\n"
"request to the */* path. If it does, the `if` block returns the contents of "
"our\n"
"HTML file."
msgstr ""

#: src/ch20-01-single-threaded.md:516
msgid ""
"If the `request_line` does *not* equal the GET request to the */* path, it\n"
"means we‚Äôve received some other request. We‚Äôll add code to the `else` block "
"in\n"
"a moment to respond to all other requests."
msgstr ""

#: src/ch20-01-single-threaded.md:520
msgid ""
"Run this code now and request *127.0.0.1:7878*; you should get the HTML in\n"
"*hello.html*. If you make any other request, such as\n"
"*127.0.0.1:7878/something-else*, you‚Äôll get a connection error like those "
"you\n"
"saw when running the code in Listing 20-1 and Listing 20-2."
msgstr ""

#: src/ch20-01-single-threaded.md:525
msgid ""
"Now let‚Äôs add the code in Listing 20-7 to the `else` block to return a "
"response\n"
"with the status code 404, which signals that the content for the request "
"was\n"
"not found. We‚Äôll also return some HTML for a page to render in the browser\n"
"indicating the response to the end user."
msgstr ""

#: src/ch20-01-single-threaded.md:532
msgid ""
"```rust,no_run\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"# };\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"# \n"
"# fn handle_connection(mut stream: TcpStream) {\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"# \n"
"#     if request_line == \"GET / HTTP/1.1\" {\n"
"#         let status_line = \"HTTP/1.1 200 OK\";\n"
"#         let contents = fs::read_to_string(\"hello.html\").unwrap();\n"
"#         let length = contents.len();\n"
"# \n"
"#         let response = format!(\n"
"#             \"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\"\n"
"#         );\n"
"# \n"
"#         stream.write_all(response.as_bytes()).unwrap();\n"
"    // --snip--\n"
"    } else {\n"
"        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n"
"        let contents = fs::read_to_string(\"404.html\").unwrap();\n"
"        let length = contents.len();\n"
"\n"
"        let response = format!(\n"
"            \"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\"\n"
"        );\n"
"\n"
"        stream.write_all(response.as_bytes()).unwrap();\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:578
msgid ""
"<span class=\"caption\">Listing 20-7: Responding with status code 404 and "
"an\n"
"error page if anything other than */* was requested</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:581
msgid ""
"Here, our response has a status line with status code 404 and the reason "
"phrase\n"
"`NOT FOUND`. The body of the response will be the HTML in the file *404."
"html*.\n"
"You‚Äôll need to create a *404.html* file next to *hello.html* for the error\n"
"page; again feel free to use any HTML you want or use the example HTML in\n"
"Listing 20-8."
msgstr ""

#: src/ch20-01-single-threaded.md:587
msgid "<span class=\"filename\">Filename: 404.html</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:589
msgid ""
"```html\n"
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"  <head>\n"
"    <meta charset=\"utf-8\">\n"
"    <title>Hello!</title>\n"
"  </head>\n"
"  <body>\n"
"    <h1>Oops!</h1>\n"
"    <p>Sorry, I don't know what you're asking for.</p>\n"
"  </body>\n"
"</html>\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:603
msgid ""
"<span class=\"caption\">Listing 20-8: Sample content for the page to send "
"back\n"
"with any 404 response</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:606
msgid ""
"With these changes, run your server again. Requesting *127.0.0.1:7878* "
"should\n"
"return the contents of *hello.html*, and any other request, like\n"
"*127.0.0.1:7878/foo*, should return the error HTML from *404.html*."
msgstr ""

#: src/ch20-01-single-threaded.md:610
msgid "### A Touch of Refactoring"
msgstr ""

#: src/ch20-01-single-threaded.md:612
msgid ""
"At the moment the `if` and `else` blocks have a lot of repetition: they‚Äôre "
"both\n"
"reading files and writing the contents of the files to the stream. The only\n"
"differences are the status line and the filename. Let‚Äôs make the code more\n"
"concise by pulling out those differences into separate `if` and `else` "
"lines\n"
"that will assign the values of the status line and the filename to "
"variables;\n"
"we can then use those variables unconditionally in the code to read the "
"file\n"
"and write the response. Listing 20-9 shows the resulting code after "
"replacing\n"
"the large `if` and `else` blocks."
msgstr ""

#: src/ch20-01-single-threaded.md:623
msgid ""
"```rust,no_run\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"# };\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"// --snip--\n"
"\n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    // --snip--\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"\n"
"    let (status_line, filename) = if request_line == \"GET / HTTP/1.1\" {\n"
"        (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"    } else {\n"
"        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n"
"    };\n"
"\n"
"    let contents = fs::read_to_string(filename).unwrap();\n"
"    let length = contents.len();\n"
"\n"
"    let response =\n"
"        format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"\n"
"    stream.write_all(response.as_bytes()).unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch20-01-single-threaded.md:662
msgid ""
"<span class=\"caption\">Listing 20-9: Refactoring the `if` and `else` blocks "
"to\n"
"contain only the code that differs between the two cases</span>"
msgstr ""

#: src/ch20-01-single-threaded.md:665
msgid ""
"Now the `if` and `else` blocks only return the appropriate values for the\n"
"status line and filename in a tuple; we then use destructuring to assign "
"these\n"
"two values to `status_line` and `filename` using a pattern in the `let`\n"
"statement, as discussed in Chapter 18."
msgstr ""

#: src/ch20-01-single-threaded.md:670
msgid ""
"The previously duplicated code is now outside the `if` and `else` blocks "
"and\n"
"uses the `status_line` and `filename` variables. This makes it easier to "
"see\n"
"the difference between the two cases, and it means we have only one place "
"to\n"
"update the code if we want to change how the file reading and response "
"writing\n"
"work. The behavior of the code in Listing 20-9 will be the same as that in\n"
"Listing 20-8."
msgstr ""

#: src/ch20-01-single-threaded.md:677
msgid ""
"Awesome! We now have a simple web server in approximately 40 lines of Rust "
"code\n"
"that responds to one request with a page of content and responds to all "
"other\n"
"requests with a 404 response."
msgstr ""

#: src/ch20-01-single-threaded.md:681
msgid ""
"Currently, our server runs in a single thread, meaning it can only serve "
"one\n"
"request at a time. Let‚Äôs examine how that can be a problem by simulating "
"some\n"
"slow requests. Then we‚Äôll fix it so our server can handle multiple requests "
"at\n"
"once."
msgstr ""

#: src/ch20-02-multithreaded.md:1
msgid "## Turning Our Single-Threaded Server into a Multithreaded Server"
msgstr ""

#: src/ch20-02-multithreaded.md:3
msgid ""
"Right now, the server will process each request in turn, meaning it won‚Äôt\n"
"process a second connection until the first is finished processing. If the\n"
"server received more and more requests, this serial execution would be less "
"and\n"
"less optimal. If the server receives a request that takes a long time to\n"
"process, subsequent requests will have to wait until the long request is\n"
"finished, even if the new requests can be processed quickly. We‚Äôll need to "
"fix\n"
"this, but first, we‚Äôll look at the problem in action."
msgstr ""

#: src/ch20-02-multithreaded.md:11
msgid "### Simulating a Slow Request in the Current Server Implementation"
msgstr ""

#: src/ch20-02-multithreaded.md:13
msgid ""
"We‚Äôll look at how a slow-processing request can affect other requests made "
"to\n"
"our current server implementation. Listing 20-10 implements handling a "
"request\n"
"to */sleep* with a simulated slow response that will cause the server to "
"sleep\n"
"for 5 seconds before responding."
msgstr ""

#: src/ch20-02-multithreaded.md:20
msgid ""
"```rust,no_run\n"
"use std::{\n"
"    fs,\n"
"    io::{prelude::*, BufReader},\n"
"    net::{TcpListener, TcpStream},\n"
"    thread,\n"
"    time::Duration,\n"
"};\n"
"// --snip--\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         handle_connection(stream);\n"
"#     }\n"
"# }\n"
"\n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    // --snip--\n"
"\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"# \n"
"    let (status_line, filename) = match &request_line[..] {\n"
"        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n"
"        \"GET /sleep HTTP/1.1\" => {\n"
"            thread::sleep(Duration::from_secs(5));\n"
"            (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"        }\n"
"        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n"
"    };\n"
"\n"
"    // --snip--\n"
"# \n"
"#     let contents = fs::read_to_string(filename).unwrap();\n"
"#     let length = contents.len();\n"
"# \n"
"#     let response =\n"
"#         format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"# \n"
"#     stream.write_all(response.as_bytes()).unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:67
msgid ""
"<span class=\"caption\">Listing 20-10: Simulating a slow request by sleeping "
"for\n"
"5 seconds</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:70
msgid ""
"We switched from `if` to `match` now that we have three cases. We need to\n"
"explicitly match on a slice of `request_line` to pattern match against the\n"
"string literal values; `match` doesn‚Äôt do automatic referencing and\n"
"dereferencing like the equality method does."
msgstr ""

#: src/ch20-02-multithreaded.md:75
msgid ""
"The first arm is the same as the `if` block from Listing 20-9. The second "
"arm\n"
"matches a request to */sleep*. When that request is received, the server "
"will\n"
"sleep for 5 seconds before rendering the successful HTML page. The third arm "
"is\n"
"the same as the `else` block from Listing 20-9."
msgstr ""

#: src/ch20-02-multithreaded.md:80
msgid ""
"You can see how primitive our server is: real libraries would handle the\n"
"recognition of multiple requests in a much less verbose way!"
msgstr ""

#: src/ch20-02-multithreaded.md:83
msgid ""
"Start the server using `cargo run`. Then open two browser windows: one for\n"
"*http://127.0.0.1:7878/* and the other for *http://127.0.0.1:7878/sleep*. "
"If\n"
"you enter the */* URI a few times, as before, you‚Äôll see it respond "
"quickly.\n"
"But if you enter */sleep* and then load */*, you‚Äôll see that */* waits "
"until\n"
"`sleep` has slept for its full 5 seconds before loading."
msgstr ""

#: src/ch20-02-multithreaded.md:89
msgid ""
"There are multiple techniques we could use to avoid requests backing up "
"behind\n"
"a slow request; the one we‚Äôll implement is a thread pool."
msgstr ""

#: src/ch20-02-multithreaded.md:92
msgid "### Improving Throughput with a Thread Pool"
msgstr ""

#: src/ch20-02-multithreaded.md:94
msgid ""
"A *thread pool* is a group of spawned threads that are waiting and ready to\n"
"handle a task. When the program receives a new task, it assigns one of the\n"
"threads in the pool to the task, and that thread will process the task. The\n"
"remaining threads in the pool are available to handle any other tasks that "
"come\n"
"in while the first thread is processing. When the first thread is done\n"
"processing its task, it‚Äôs returned to the pool of idle threads, ready to "
"handle\n"
"a new task. A thread pool allows you to process connections concurrently,\n"
"increasing the throughput of your server."
msgstr ""

#: src/ch20-02-multithreaded.md:103
msgid ""
"We‚Äôll limit the number of threads in the pool to a small number to protect "
"us\n"
"from Denial of Service (DoS) attacks; if we had our program create a new "
"thread\n"
"for each request as it came in, someone making 10 million requests to our\n"
"server could create havoc by using up all our server‚Äôs resources and "
"grinding\n"
"the processing of requests to a halt."
msgstr ""

#: src/ch20-02-multithreaded.md:109
msgid ""
"Rather than spawning unlimited threads, then, we‚Äôll have a fixed number of\n"
"threads waiting in the pool. Requests that come in are sent to the pool for\n"
"processing. The pool will maintain a queue of incoming requests. Each of "
"the\n"
"threads in the pool will pop off a request from this queue, handle the "
"request,\n"
"and then ask the queue for another request. With this design, we can process "
"up\n"
"to `N` requests concurrently, where `N` is the number of threads. If each\n"
"thread is responding to a long-running request, subsequent requests can "
"still\n"
"back up in the queue, but we‚Äôve increased the number of long-running "
"requests\n"
"we can handle before reaching that point."
msgstr ""

#: src/ch20-02-multithreaded.md:119
msgid ""
"This technique is just one of many ways to improve the throughput of a web\n"
"server. Other options you might explore are the *fork/join model*, the\n"
"*single-threaded async I/O model*, or the *multi-threaded async I/O model*. "
"If\n"
"you‚Äôre interested in this topic, you can read more about other solutions "
"and\n"
"try to implement them; with a low-level language like Rust, all of these\n"
"options are possible."
msgstr ""

#: src/ch20-02-multithreaded.md:126
msgid ""
"Before we begin implementing a thread pool, let‚Äôs talk about what using the\n"
"pool should look like. When you‚Äôre trying to design code, writing the "
"client\n"
"interface first can help guide your design. Write the API of the code so "
"it‚Äôs\n"
"structured in the way you want to call it; then implement the functionality\n"
"within that structure rather than implementing the functionality and then\n"
"designing the public API."
msgstr ""

#: src/ch20-02-multithreaded.md:133
msgid ""
"Similar to how we used test-driven development in the project in Chapter "
"12,\n"
"we‚Äôll use compiler-driven development here. We‚Äôll write the code that calls "
"the\n"
"functions we want, and then we‚Äôll look at errors from the compiler to "
"determine\n"
"what we should change next to get the code to work. Before we do that, "
"however,\n"
"we‚Äôll explore the technique we‚Äôre not going to use as a starting point."
msgstr ""

#: src/ch20-02-multithreaded.md:140
msgid ""
"<a id=\"code-structure-if-we-could-spawn-a-thread-for-each-request\"></a>"
msgstr ""

#: src/ch20-02-multithreaded.md:142
msgid "#### Spawning a Thread for Each Request"
msgstr ""

#: src/ch20-02-multithreaded.md:144
msgid ""
"First, let‚Äôs explore how our code might look if it did create a new thread "
"for\n"
"every connection. As mentioned earlier, this isn‚Äôt our final plan due to "
"the\n"
"problems with potentially spawning an unlimited number of threads, but it is "
"a\n"
"starting point to get a working multithreaded server first. Then we‚Äôll add "
"the\n"
"thread pool as an improvement, and contrasting the two solutions will be\n"
"easier. Listing 20-11 shows the changes to make to `main` to spawn a new "
"thread\n"
"to handle each stream within the `for` loop."
msgstr ""

#: src/ch20-02-multithreaded.md:154
msgid ""
"```rust,no_run\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"#     thread,\n"
"#     time::Duration,\n"
"# };\n"
"# \n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"\n"
"    for stream in listener.incoming() {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        thread::spawn(|| {\n"
"            handle_connection(stream);\n"
"        });\n"
"    }\n"
"}\n"
"# \n"
"# fn handle_connection(mut stream: TcpStream) {\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"# \n"
"#     let (status_line, filename) = match &request_line[..] {\n"
"#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n"
"#         \"GET /sleep HTTP/1.1\" => {\n"
"#             thread::sleep(Duration::from_secs(5));\n"
"#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"#         }\n"
"#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n"
"#     };\n"
"# \n"
"#     let contents = fs::read_to_string(filename).unwrap();\n"
"#     let length = contents.len();\n"
"# \n"
"#     let response =\n"
"#         format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"# \n"
"#     stream.write_all(response.as_bytes()).unwrap();\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:198
msgid ""
"<span class=\"caption\">Listing 20-11: Spawning a new thread for each\n"
"stream</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:201
msgid ""
"As you learned in Chapter 16, `thread::spawn` will create a new thread and "
"then\n"
"run the code in the closure in the new thread. If you run this code and "
"load\n"
"*/sleep* in your browser, then */* in two more browser tabs, you‚Äôll indeed "
"see\n"
"that the requests to */* don‚Äôt have to wait for */sleep* to finish. However, "
"as\n"
"we mentioned, this will eventually overwhelm the system because you‚Äôd be "
"making\n"
"new threads without any limit."
msgstr ""

#: src/ch20-02-multithreaded.md:209
msgid ""
"<a id=\"creating-a-similar-interface-for-a-finite-number-of-threads\"></a>"
msgstr ""

#: src/ch20-02-multithreaded.md:211
msgid "#### Creating a Finite Number of Threads"
msgstr ""

#: src/ch20-02-multithreaded.md:213
msgid ""
"We want our thread pool to work in a similar, familiar way so switching "
"from\n"
"threads to a thread pool doesn‚Äôt require large changes to the code that "
"uses\n"
"our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`\n"
"struct we want to use instead of `thread::spawn`."
msgstr ""

#: src/ch20-02-multithreaded.md:220
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"#     thread,\n"
"#     time::Duration,\n"
"# };\n"
"# \n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"    let pool = ThreadPool::new(4);\n"
"\n"
"    for stream in listener.incoming() {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        pool.execute(|| {\n"
"            handle_connection(stream);\n"
"        });\n"
"    }\n"
"}\n"
"# \n"
"# fn handle_connection(mut stream: TcpStream) {\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"# \n"
"#     let (status_line, filename) = match &request_line[..] {\n"
"#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n"
"#         \"GET /sleep HTTP/1.1\" => {\n"
"#             thread::sleep(Duration::from_secs(5));\n"
"#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"#         }\n"
"#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n"
"#     };\n"
"# \n"
"#     let contents = fs::read_to_string(filename).unwrap();\n"
"#     let length = contents.len();\n"
"# \n"
"#     let response =\n"
"#         format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"# \n"
"#     stream.write_all(response.as_bytes()).unwrap();\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:265
msgid ""
"<span class=\"caption\">Listing 20-12: Our ideal `ThreadPool` interface</"
"span>"
msgstr ""

#: src/ch20-02-multithreaded.md:267
msgid ""
"We use `ThreadPool::new` to create a new thread pool with a configurable "
"number\n"
"of threads, in this case four. Then, in the `for` loop, `pool.execute` has "
"a\n"
"similar interface as `thread::spawn` in that it takes a closure the pool "
"should\n"
"run for each stream. We need to implement `pool.execute` so it takes the\n"
"closure and gives it to a thread in the pool to run. This code won‚Äôt yet\n"
"compile, but we‚Äôll try so the compiler can guide us in how to fix it."
msgstr ""

#: src/ch20-02-multithreaded.md:275
msgid ""
"<a id=\"building-the-threadpool-struct-using-compiler-driven-development\"></"
"a>"
msgstr ""

#: src/ch20-02-multithreaded.md:277
msgid "#### Building `ThreadPool` Using Compiler Driven Development"
msgstr ""

#: src/ch20-02-multithreaded.md:279
msgid ""
"Make the changes in Listing 20-12 to *src/main.rs*, and then let‚Äôs use the\n"
"compiler errors from `cargo check` to drive our development. Here is the "
"first\n"
"error we get:"
msgstr ""

#: src/ch20-02-multithreaded.md:283
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0433]: failed to resolve: use of undeclared type `ThreadPool`\n"
"  --> src/main.rs:11:16\n"
"   |\n"
"11 |     let pool = ThreadPool::new(4);\n"
"   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0433`.\n"
"error: could not compile `hello` due to previous error\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:296
msgid ""
"Great! This error tells us we need a `ThreadPool` type or module, so we‚Äôll\n"
"build one now. Our `ThreadPool` implementation will be independent of the "
"kind\n"
"of work our web server is doing. So, let‚Äôs switch the `hello` crate from a\n"
"binary crate to a library crate to hold our `ThreadPool` implementation. "
"After\n"
"we change to a library crate, we could also use the separate thread pool\n"
"library for any work we want to do using a thread pool, not just for "
"serving\n"
"web requests."
msgstr ""

#: src/ch20-02-multithreaded.md:304
msgid ""
"Create a *src/lib.rs* that contains the following, which is the simplest\n"
"definition of a `ThreadPool` struct that we can have for now:"
msgstr ""

#: src/ch20-02-multithreaded.md:309
msgid ""
"```rust,noplayground\n"
"pub struct ThreadPool;\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:313
msgid ""
"Then edit *main.rs* file to bring `ThreadPool` into scope from the library\n"
"crate by adding the following code to the top of *src/main.rs*:"
msgstr ""

#: src/ch20-02-multithreaded.md:318
msgid ""
"```rust,ignore\n"
"use hello::ThreadPool;\n"
"# use std::{\n"
"#     fs,\n"
"#     io::{prelude::*, BufReader},\n"
"#     net::{TcpListener, TcpStream},\n"
"#     thread,\n"
"#     time::Duration,\n"
"# };\n"
"# \n"
"# fn main() {\n"
"#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"#     let pool = ThreadPool::new(4);\n"
"# \n"
"#     for stream in listener.incoming() {\n"
"#         let stream = stream.unwrap();\n"
"# \n"
"#         pool.execute(|| {\n"
"#             handle_connection(stream);\n"
"#         });\n"
"#     }\n"
"# }\n"
"# \n"
"# fn handle_connection(mut stream: TcpStream) {\n"
"#     let buf_reader = BufReader::new(&mut stream);\n"
"#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n"
"# \n"
"#     let (status_line, filename) = match &request_line[..] {\n"
"#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n"
"#         \"GET /sleep HTTP/1.1\" => {\n"
"#             thread::sleep(Duration::from_secs(5));\n"
"#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"#         }\n"
"#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n"
"#     };\n"
"# \n"
"#     let contents = fs::read_to_string(filename).unwrap();\n"
"#     let length = contents.len();\n"
"# \n"
"#     let response =\n"
"#         format!(\"{status_line}\\r\\nContent-Length: "
"{length}\\r\\n\\r\\n{contents}\");\n"
"# \n"
"#     stream.write_all(response.as_bytes()).unwrap();\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:364
msgid ""
"This code still won‚Äôt work, but let‚Äôs check it again to get the next error "
"that\n"
"we need to address:"
msgstr ""

#: src/ch20-02-multithreaded.md:367
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0599]: no function or associated item named `new` found for struct "
"`ThreadPool` in the current scope\n"
"  --> src/main.rs:12:28\n"
"   |\n"
"12 |     let pool = ThreadPool::new(4);\n"
"   |                            ^^^ function or associated item not found in "
"`ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0599`.\n"
"error: could not compile `hello` due to previous error\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:380
msgid ""
"This error indicates that next we need to create an associated function "
"named\n"
"`new` for `ThreadPool`. We also know that `new` needs to have one parameter\n"
"that can accept `4` as an argument and should return a `ThreadPool` "
"instance.\n"
"Let‚Äôs implement the simplest `new` function that will have those\n"
"characteristics:"
msgstr ""

#: src/ch20-02-multithreaded.md:388
msgid ""
"```rust,noplayground\n"
"pub struct ThreadPool;\n"
"\n"
"impl ThreadPool {\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        ThreadPool\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:398
msgid ""
"We chose `usize` as the type of the `size` parameter, because we know that "
"a\n"
"negative number of threads doesn‚Äôt make any sense. We also know we‚Äôll use "
"this\n"
"4 as the number of elements in a collection of threads, which is what the\n"
"`usize` type is for, as discussed in the [‚ÄúInteger Types‚Äù][integer-"
"types]<!--\n"
"ignore --> section of Chapter 3."
msgstr ""

#: src/ch20-02-multithreaded.md:404
msgid "Let‚Äôs check the code again:"
msgstr ""

#: src/ch20-02-multithreaded.md:406
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0599]: no method named `execute` found for struct `ThreadPool` in the "
"current scope\n"
"  --> src/main.rs:17:14\n"
"   |\n"
"17 |         pool.execute(|| {\n"
"   |              ^^^^^^^ method not found in `ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0599`.\n"
"error: could not compile `hello` due to previous error\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:419
msgid ""
"Now the error occurs because we don‚Äôt have an `execute` method on "
"`ThreadPool`.\n"
"Recall from the [‚ÄúCreating a Finite Number of\n"
"Threads‚Äù](#creating-a-finite-number-of-threads)<!-- ignore --> section that "
"we\n"
"decided our thread pool should have an interface similar to `thread::spawn`. "
"In\n"
"addition, we‚Äôll implement the `execute` function so it takes the closure "
"it‚Äôs\n"
"given and gives it to an idle thread in the pool to run."
msgstr ""

#: src/ch20-02-multithreaded.md:426
msgid ""
"We‚Äôll define the `execute` method on `ThreadPool` to take a closure as a\n"
"parameter. Recall from the [‚ÄúMoving Captured Values Out of the Closure and "
"the\n"
"`Fn` Traits‚Äù][fn-traits]<!-- ignore --> section in Chapter 13 that we can "
"take\n"
"closures as parameters with three different traits: `Fn`, `FnMut`, and\n"
"`FnOnce`. We need to decide which kind of closure to use here. We know "
"we‚Äôll\n"
"end up doing something similar to the standard library `thread::spawn`\n"
"implementation, so we can look at what bounds the signature of `thread::"
"spawn`\n"
"has on its parameter. The documentation shows us the following:"
msgstr ""

#: src/ch20-02-multithreaded.md:435 src/ch20-02-multithreaded.md:568
msgid ""
"```rust,ignore\n"
"pub fn spawn<F, T>(f: F) -> JoinHandle<T>\n"
"    where\n"
"        F: FnOnce() -> T,\n"
"        F: Send + 'static,\n"
"        T: Send + 'static,\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:443
msgid ""
"The `F` type parameter is the one we‚Äôre concerned with here; the `T` type\n"
"parameter is related to the return value, and we‚Äôre not concerned with that. "
"We\n"
"can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is "
"probably\n"
"what we want as well, because we‚Äôll eventually pass the argument we get in\n"
"`execute` to `spawn`. We can be further confident that `FnOnce` is the trait "
"we\n"
"want to use because the thread for running a request will only execute that\n"
"request‚Äôs closure one time, which matches the `Once` in `FnOnce`."
msgstr ""

#: src/ch20-02-multithreaded.md:451
msgid ""
"The `F` type parameter also has the trait bound `Send` and the lifetime "
"bound\n"
"`'static`, which are useful in our situation: we need `Send` to transfer "
"the\n"
"closure from one thread to another and `'static` because we don‚Äôt know how "
"long\n"
"the thread will take to execute. Let‚Äôs create an `execute` method on\n"
"`ThreadPool` that will take a generic parameter of type `F` with these "
"bounds:"
msgstr ""

#: src/ch20-02-multithreaded.md:459
msgid ""
"```rust,noplayground\n"
"# pub struct ThreadPool;\n"
"# \n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         ThreadPool\n"
"#     }\n"
"# \n"
"    pub fn execute<F>(&self, f: F)\n"
"    where\n"
"        F: FnOnce() + Send + 'static,\n"
"    {\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:476
msgid ""
"We still use the `()` after `FnOnce` because this `FnOnce` represents a "
"closure\n"
"that takes no parameters and returns the unit type `()`. Just like function\n"
"definitions, the return type can be omitted from the signature, but even if "
"we\n"
"have no parameters, we still need the parentheses."
msgstr ""

#: src/ch20-02-multithreaded.md:481
msgid ""
"Again, this is the simplest implementation of the `execute` method: it does\n"
"nothing, but we‚Äôre trying only to make our code compile. Let‚Äôs check it "
"again:"
msgstr ""

#: src/ch20-02-multithreaded.md:484
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:490
msgid ""
"It compiles! But note that if you try `cargo run` and make a request in the\n"
"browser, you‚Äôll see the errors in the browser that we saw at the beginning "
"of\n"
"the chapter. Our library isn‚Äôt actually calling the closure passed to "
"`execute`\n"
"yet!"
msgstr ""

#: src/ch20-02-multithreaded.md:495
msgid ""
"> Note: A saying you might hear about languages with strict compilers, such "
"as\n"
"> Haskell and Rust, is ‚Äúif the code compiles, it works.‚Äù But this saying is "
"not\n"
"> universally true. Our project compiles, but it does absolutely nothing! If "
"we\n"
"> were building a real, complete project, this would be a good time to "
"start\n"
"> writing unit tests to check that the code compiles *and* has the behavior "
"we\n"
"> want."
msgstr ""

#: src/ch20-02-multithreaded.md:502
msgid "#### Validating the Number of Threads in `new`"
msgstr ""

#: src/ch20-02-multithreaded.md:504
msgid ""
"We aren‚Äôt doing anything with the parameters to `new` and `execute`. Let‚Äôs\n"
"implement the bodies of these functions with the behavior we want. To "
"start,\n"
"let‚Äôs think about `new`. Earlier we chose an unsigned type for the `size`\n"
"parameter, because a pool with a negative number of threads makes no sense.\n"
"However, a pool with zero threads also makes no sense, yet zero is a "
"perfectly\n"
"valid `usize`. We‚Äôll add code to check that `size` is greater than zero "
"before\n"
"we return a `ThreadPool` instance and have the program panic if it receives "
"a\n"
"zero by using the `assert!` macro, as shown in Listing 20-13."
msgstr ""

#: src/ch20-02-multithreaded.md:515
msgid ""
"```rust,noplayground\n"
"# pub struct ThreadPool;\n"
"# \n"
"impl ThreadPool {\n"
"    /// Create a new ThreadPool.\n"
"    ///\n"
"    /// The size is the number of threads in the pool.\n"
"    ///\n"
"    /// # Panics\n"
"    ///\n"
"    /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        ThreadPool\n"
"    }\n"
"\n"
"    // --snip--\n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:541
msgid ""
"<span class=\"caption\">Listing 20-13: Implementing `ThreadPool::new` to "
"panic if\n"
"`size` is zero</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:544
msgid ""
"We‚Äôve also added some documentation for our `ThreadPool` with doc comments.\n"
"Note that we followed good documentation practices by adding a section that\n"
"calls out the situations in which our function can panic, as discussed in\n"
"Chapter 14. Try running `cargo doc --open` and clicking the `ThreadPool` "
"struct\n"
"to see what the generated docs for `new` look like!"
msgstr ""

#: src/ch20-02-multithreaded.md:550
msgid ""
"Instead of adding the `assert!` macro as we‚Äôve done here, we could change "
"`new`\n"
"into `build` and return a `Result` like we did with `Config::build` in the I/"
"O\n"
"project in Listing 12-9. But we‚Äôve decided in this case that trying to "
"create a\n"
"thread pool without any threads should be an unrecoverable error. If you‚Äôre\n"
"feeling ambitious, try to write a function named `build` with the following\n"
"signature to compare with the `new` function:"
msgstr ""

#: src/ch20-02-multithreaded.md:557
msgid ""
"```rust,ignore\n"
"pub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:561
msgid "#### Creating Space to Store the Threads"
msgstr ""

#: src/ch20-02-multithreaded.md:563
msgid ""
"Now that we have a way to know we have a valid number of threads to store "
"in\n"
"the pool, we can create those threads and store them in the `ThreadPool` "
"struct\n"
"before returning the struct. But how do we ‚Äústore‚Äù a thread? Let‚Äôs take "
"another\n"
"look at the `thread::spawn` signature:"
msgstr ""

#: src/ch20-02-multithreaded.md:576
msgid ""
"The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that "
"the\n"
"closure returns. Let‚Äôs try using `JoinHandle` too and see what happens. In "
"our\n"
"case, the closures we‚Äôre passing to the thread pool will handle the "
"connection\n"
"and not return anything, so `T` will be the unit type `()`."
msgstr ""

#: src/ch20-02-multithreaded.md:581
msgid ""
"The code in Listing 20-14 will compile but doesn‚Äôt create any threads yet.\n"
"We‚Äôve changed the definition of `ThreadPool` to hold a vector of\n"
"`thread::JoinHandle<()>` instances, initialized the vector with a capacity "
"of\n"
"`size`, set up a `for` loop that will run some code to create the threads, "
"and\n"
"returned a `ThreadPool` instance containing them."
msgstr ""

#: src/ch20-02-multithreaded.md:589
msgid ""
"```rust,ignore,not_desired_behavior\n"
"use std::thread;\n"
"\n"
"pub struct ThreadPool {\n"
"    threads: Vec<thread::JoinHandle<()>>,\n"
"}\n"
"\n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let mut threads = Vec::with_capacity(size);\n"
"\n"
"        for _ in 0..size {\n"
"            // create some threads and store them in the vector\n"
"        }\n"
"\n"
"        ThreadPool { threads }\n"
"    }\n"
"    // --snip--\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:626
msgid ""
"<span class=\"caption\">Listing 20-14: Creating a vector for `ThreadPool` to "
"hold\n"
"the threads</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:629
msgid ""
"We‚Äôve brought `std::thread` into scope in the library crate, because we‚Äôre\n"
"using `thread::JoinHandle` as the type of the items in the vector in\n"
"`ThreadPool`."
msgstr ""

#: src/ch20-02-multithreaded.md:633
msgid ""
"Once a valid size is received, our `ThreadPool` creates a new vector that "
"can\n"
"hold `size` items. The `with_capacity` function performs the same task as\n"
"`Vec::new` but with an important difference: it preallocates space in the\n"
"vector. Because we know we need to store `size` elements in the vector, "
"doing\n"
"this allocation up front is slightly more efficient than using `Vec::new`,\n"
"which resizes itself as elements are inserted."
msgstr ""

#: src/ch20-02-multithreaded.md:640
msgid "When you run `cargo check` again, it should succeed."
msgstr ""

#: src/ch20-02-multithreaded.md:642
msgid ""
"#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to "
"a Thread"
msgstr ""

#: src/ch20-02-multithreaded.md:644
msgid ""
"We left a comment in the `for` loop in Listing 20-14 regarding the creation "
"of\n"
"threads. Here, we‚Äôll look at how we actually create threads. The standard\n"
"library provides `thread::spawn` as a way to create threads, and\n"
"`thread::spawn` expects to get some code the thread should run as soon as "
"the\n"
"thread is created. However, in our case, we want to create the threads and "
"have\n"
"them *wait* for code that we‚Äôll send later. The standard library‚Äôs\n"
"implementation of threads doesn‚Äôt include any way to do that; we have to\n"
"implement it manually."
msgstr ""

#: src/ch20-02-multithreaded.md:653
msgid ""
"We‚Äôll implement this behavior by introducing a new data structure between "
"the\n"
"`ThreadPool` and the threads that will manage this new behavior. We‚Äôll call\n"
"this data structure *Worker*, which is a common term in pooling\n"
"implementations. The Worker picks up code that needs to be run and runs the\n"
"code in the Worker‚Äôs thread. Think of people working in the kitchen at a\n"
"restaurant: the workers wait until orders come in from customers, and then\n"
"they‚Äôre responsible for taking those orders and fulfilling them."
msgstr ""

#: src/ch20-02-multithreaded.md:661
msgid ""
"Instead of storing a vector of `JoinHandle<()>` instances in the thread "
"pool,\n"
"we‚Äôll store instances of the `Worker` struct. Each `Worker` will store a "
"single\n"
"`JoinHandle<()>` instance. Then we‚Äôll implement a method on `Worker` that "
"will\n"
"take a closure of code to run and send it to the already running thread for\n"
"execution. We‚Äôll also give each worker an `id` so we can distinguish "
"between\n"
"the different workers in the pool when logging or debugging."
msgstr ""

#: src/ch20-02-multithreaded.md:668
msgid ""
"Here is the new process that will happen when we create a `ThreadPool`. "
"We‚Äôll\n"
"implement the code that sends the closure to the thread after we have "
"`Worker`\n"
"set up in this way:"
msgstr ""

#: src/ch20-02-multithreaded.md:672
msgid ""
"1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.\n"
"2. Change `ThreadPool` to hold a vector of `Worker` instances.\n"
"3. Define a `Worker::new` function that takes an `id` number and returns a\n"
"   `Worker` instance that holds the `id` and a thread spawned with an empty\n"
"   closure.\n"
"4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, "
"create\n"
"   a new `Worker` with that `id`, and store the worker in the vector."
msgstr ""

#: src/ch20-02-multithreaded.md:680
msgid ""
"If you‚Äôre up for a challenge, try implementing these changes on your own "
"before\n"
"looking at the code in Listing 20-15."
msgstr ""

#: src/ch20-02-multithreaded.md:683
msgid ""
"Ready? Here is Listing 20-15 with one way to make the preceding "
"modifications."
msgstr ""

#: src/ch20-02-multithreaded.md:687
msgid ""
"```rust,noplayground\n"
"use std::thread;\n"
"\n"
"pub struct ThreadPool {\n"
"    workers: Vec<Worker>,\n"
"}\n"
"\n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let mut workers = Vec::with_capacity(size);\n"
"\n"
"        for id in 0..size {\n"
"            workers.push(Worker::new(id));\n"
"        }\n"
"\n"
"        ThreadPool { workers }\n"
"    }\n"
"    // --snip--\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"\n"
"struct Worker {\n"
"    id: usize,\n"
"    thread: thread::JoinHandle<()>,\n"
"}\n"
"\n"
"impl Worker {\n"
"    fn new(id: usize) -> Worker {\n"
"        let thread = thread::spawn(|| {});\n"
"\n"
"        Worker { id, thread }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:737
msgid ""
"<span class=\"caption\">Listing 20-15: Modifying `ThreadPool` to hold "
"`Worker`\n"
"instances instead of holding threads directly</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:740
msgid ""
"We‚Äôve changed the name of the field on `ThreadPool` from `threads` to "
"`workers`\n"
"because it‚Äôs now holding `Worker` instances instead of `JoinHandle<()>`\n"
"instances. We use the counter in the `for` loop as an argument to\n"
"`Worker::new`, and we store each new `Worker` in the vector named `workers`."
msgstr ""

#: src/ch20-02-multithreaded.md:745
msgid ""
"External code (like our server in *src/main.rs*) doesn‚Äôt need to know the\n"
"implementation details regarding using a `Worker` struct within "
"`ThreadPool`,\n"
"so we make the `Worker` struct and its `new` function private. The\n"
"`Worker::new` function uses the `id` we give it and stores a "
"`JoinHandle<()>`\n"
"instance that is created by spawning a new thread using an empty closure."
msgstr ""

#: src/ch20-02-multithreaded.md:751
msgid ""
"> Note: If the operating system can‚Äôt create a thread because there aren‚Äôt\n"
"> enough system resources, `thread::spawn` will panic. That will cause our\n"
"> whole server to panic, even though the creation of some threads might\n"
"> succeed. For simplicity‚Äôs sake, this behavior is fine, but in a "
"production\n"
"> thread pool implementation, you‚Äôd likely want to use\n"
"> [`std::thread::Builder`][builder]<!-- ignore --> and its\n"
"> [`spawn`][builder-spawn]<!-- ignore --> method that returns `Result` "
"instead."
msgstr ""

#: src/ch20-02-multithreaded.md:759
msgid ""
"This code will compile and will store the number of `Worker` instances we\n"
"specified as an argument to `ThreadPool::new`. But we‚Äôre *still* not "
"processing\n"
"the closure that we get in `execute`. Let‚Äôs look at how to do that next."
msgstr ""

#: src/ch20-02-multithreaded.md:763
msgid "#### Sending Requests to Threads via Channels"
msgstr ""

#: src/ch20-02-multithreaded.md:765
msgid ""
"The next problem we‚Äôll tackle is that the closures given to `thread::spawn` "
"do\n"
"absolutely nothing. Currently, we get the closure we want to execute in the\n"
"`execute` method. But we need to give `thread::spawn` a closure to run when "
"we\n"
"create each `Worker` during the creation of the `ThreadPool`."
msgstr ""

#: src/ch20-02-multithreaded.md:770
msgid ""
"We want the `Worker` structs that we just created to fetch the code to run "
"from\n"
"a queue held in the `ThreadPool` and send that code to its thread to run."
msgstr ""

#: src/ch20-02-multithreaded.md:773
msgid ""
"The channels we learned about in Chapter 16‚Äîa simple way to communicate "
"between\n"
"two threads‚Äîwould be perfect for this use case. We‚Äôll use a channel to "
"function\n"
"as the queue of jobs, and `execute` will send a job from the `ThreadPool` "
"to\n"
"the `Worker` instances, which will send the job to its thread. Here is the "
"plan:"
msgstr ""

#: src/ch20-02-multithreaded.md:778
msgid ""
"1. The `ThreadPool` will create a channel and hold on to the sender.\n"
"2. Each `Worker` will hold on to the receiver.\n"
"3. We‚Äôll create a new `Job` struct that will hold the closures we want to "
"send\n"
"   down the channel.\n"
"4. The `execute` method will send the job it wants to execute through the\n"
"   sender.\n"
"5. In its thread, the `Worker` will loop over its receiver and execute the\n"
"   closures of any jobs it receives."
msgstr ""

#: src/ch20-02-multithreaded.md:787
msgid ""
"Let‚Äôs start by creating a channel in `ThreadPool::new` and holding the "
"sender\n"
"in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct\n"
"doesn‚Äôt hold anything for now but will be the type of item we‚Äôre sending "
"down\n"
"the channel."
msgstr ""

#: src/ch20-02-multithreaded.md:794
msgid ""
"```rust,noplayground\n"
"use std::{sync::mpsc, thread};\n"
"\n"
"pub struct ThreadPool {\n"
"    workers: Vec<Worker>,\n"
"    sender: mpsc::Sender<Job>,\n"
"}\n"
"\n"
"struct Job;\n"
"\n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let (sender, receiver) = mpsc::channel();\n"
"\n"
"        let mut workers = Vec::with_capacity(size);\n"
"\n"
"        for id in 0..size {\n"
"            workers.push(Worker::new(id));\n"
"        }\n"
"\n"
"        ThreadPool { workers, sender }\n"
"    }\n"
"    // --snip--\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize) -> Worker {\n"
"#         let thread = thread::spawn(|| {});\n"
"# \n"
"#         Worker { id, thread }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:849
msgid ""
"<span class=\"caption\">Listing 20-16: Modifying `ThreadPool` to store the\n"
"sender of a channel that transmits `Job` instances</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:852
msgid ""
"In `ThreadPool::new`, we create our new channel and have the pool hold the\n"
"sender. This will successfully compile."
msgstr ""

#: src/ch20-02-multithreaded.md:855
msgid ""
"Let‚Äôs try passing a receiver of the channel into each worker as the thread "
"pool\n"
"creates the channel. We know we want to use the receiver in the thread that "
"the\n"
"workers spawn, so we‚Äôll reference the `receiver` parameter in the closure. "
"The\n"
"code in Listing 20-17 won‚Äôt quite compile yet."
msgstr ""

#: src/ch20-02-multithreaded.md:862
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::{sync::mpsc, thread};\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# struct Job;\n"
"# \n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let (sender, receiver) = mpsc::channel();\n"
"\n"
"        let mut workers = Vec::with_capacity(size);\n"
"\n"
"        for id in 0..size {\n"
"            workers.push(Worker::new(id, receiver));\n"
"        }\n"
"\n"
"        ThreadPool { workers, sender }\n"
"    }\n"
"    // --snip--\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"\n"
"// --snip--\n"
"\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"impl Worker {\n"
"    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n"
"        let thread = thread::spawn(|| {\n"
"            receiver;\n"
"        });\n"
"\n"
"        Worker { id, thread }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:922
msgid ""
"<span class=\"caption\">Listing 20-17: Passing the receiver to the workers</"
"span>"
msgstr ""

#: src/ch20-02-multithreaded.md:924
msgid ""
"We‚Äôve made some small and straightforward changes: we pass the receiver "
"into\n"
"`Worker::new`, and then we use it inside the closure."
msgstr ""

#: src/ch20-02-multithreaded.md:927
msgid "When we try to check this code, we get this error:"
msgstr ""

#: src/ch20-02-multithreaded.md:929
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0382]: use of moved value: `receiver`\n"
"  --> src/lib.rs:26:42\n"
"   |\n"
"21 |         let (sender, receiver) = mpsc::channel();\n"
"   |                      -------- move occurs because `receiver` has type "
"`std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait\n"
"...\n"
"26 |             workers.push(Worker::new(id, receiver));\n"
"   |                                          ^^^^^^^^ value moved here, in "
"previous iteration of loop\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `hello` due to previous error\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:945
msgid ""
"The code is trying to pass `receiver` to multiple `Worker` instances. This\n"
"won‚Äôt work, as you‚Äôll recall from Chapter 16: the channel implementation "
"that\n"
"Rust provides is multiple *producer*, single *consumer*. This means we "
"can‚Äôt\n"
"just clone the consuming end of the channel to fix this code. We also don‚Äôt\n"
"want to send a message multiple times to multiple consumers; we want one "
"list\n"
"of messages with multiple workers such that each message gets processed once."
msgstr ""

#: src/ch20-02-multithreaded.md:952
msgid ""
"Additionally, taking a job off the channel queue involves mutating the\n"
"`receiver`, so the threads need a safe way to share and modify `receiver`;\n"
"otherwise, we might get race conditions (as covered in Chapter 16)."
msgstr ""

#: src/ch20-02-multithreaded.md:956
msgid ""
"Recall the thread-safe smart pointers discussed in Chapter 16: to share\n"
"ownership across multiple threads and allow the threads to mutate the value, "
"we\n"
"need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own "
"the\n"
"receiver, and `Mutex` will ensure that only one worker gets a job from the\n"
"receiver at a time. Listing 20-18 shows the changes we need to make."
msgstr ""

#: src/ch20-02-multithreaded.md:964
msgid ""
"```rust,noplayground\n"
"use std::{\n"
"    sync::{mpsc, Arc, Mutex},\n"
"    thread,\n"
"};\n"
"// --snip--\n"
"\n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# struct Job;\n"
"# \n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let (sender, receiver) = mpsc::channel();\n"
"\n"
"        let receiver = Arc::new(Mutex::new(receiver));\n"
"\n"
"        let mut workers = Vec::with_capacity(size);\n"
"\n"
"        for id in 0..size {\n"
"            workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"        }\n"
"\n"
"        ThreadPool { workers, sender }\n"
"    }\n"
"\n"
"    // --snip--\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#     }\n"
"}\n"
"\n"
"// --snip--\n"
"\n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        // --snip--\n"
"#         let thread = thread::spawn(|| {\n"
"#             receiver;\n"
"#         });\n"
"# \n"
"#         Worker { id, thread }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:1031
msgid ""
"<span class=\"caption\">Listing 20-18: Sharing the receiver among the "
"workers\n"
"using `Arc` and `Mutex`</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:1034
msgid ""
"In `ThreadPool::new`, we put the receiver in an `Arc` and a `Mutex`. For "
"each\n"
"new worker, we clone the `Arc` to bump the reference count so the workers "
"can\n"
"share ownership of the receiver."
msgstr ""

#: src/ch20-02-multithreaded.md:1038
msgid "With these changes, the code compiles! We‚Äôre getting there!"
msgstr ""

#: src/ch20-02-multithreaded.md:1040
msgid "#### Implementing the `execute` Method"
msgstr ""

#: src/ch20-02-multithreaded.md:1042
msgid ""
"Let‚Äôs finally implement the `execute` method on `ThreadPool`. We‚Äôll also "
"change\n"
"`Job` from a struct to a type alias for a trait object that holds the type "
"of\n"
"closure that `execute` receives. As discussed in the [‚ÄúCreating Type "
"Synonyms\n"
"with Type Aliases‚Äù][creating-type-synonyms-with-type-aliases]<!-- ignore --"
">\n"
"section of Chapter 19, type aliases allow us to make long types shorter for\n"
"ease of use. Look at Listing 20-19."
msgstr ""

#: src/ch20-02-multithreaded.md:1051
msgid ""
"```rust,noplayground\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"// --snip--\n"
"\n"
"type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"\n"
"impl ThreadPool {\n"
"    // --snip--\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"\n"
"    pub fn execute<F>(&self, f: F)\n"
"    where\n"
"        F: FnOnce() + Send + 'static,\n"
"    {\n"
"        let job = Box::new(f);\n"
"\n"
"        self.sender.send(job).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// --snip--\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"#         let thread = thread::spawn(|| {\n"
"#             receiver;\n"
"#         });\n"
"# \n"
"#         Worker { id, thread }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:1119
msgid ""
"<span class=\"caption\">Listing 20-19: Creating a `Job` type alias for a "
"`Box`\n"
"that holds each closure and then sending the job down the channel</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:1122
msgid ""
"After creating a new `Job` instance using the closure we get in `execute`, "
"we\n"
"send that job down the sending end of the channel. We‚Äôre calling `unwrap` "
"on\n"
"`send` for the case that sending fails. This might happen if, for example, "
"we\n"
"stop all our threads from executing, meaning the receiving end has stopped\n"
"receiving new messages. At the moment, we can‚Äôt stop our threads from\n"
"executing: our threads continue executing as long as the pool exists. The\n"
"reason we use `unwrap` is that we know the failure case won‚Äôt happen, but "
"the\n"
"compiler doesn‚Äôt know that."
msgstr ""

#: src/ch20-02-multithreaded.md:1131
msgid ""
"But we‚Äôre not quite done yet! In the worker, our closure being passed to\n"
"`thread::spawn` still only *references* the receiving end of the channel.\n"
"Instead, we need the closure to loop forever, asking the receiving end of "
"the\n"
"channel for a job and running the job when it gets one. Let‚Äôs make the "
"change\n"
"shown in Listing 20-20 to `Worker::new`."
msgstr ""

#: src/ch20-02-multithreaded.md:1139
msgid ""
"```rust,noplayground\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"// --snip--\n"
"\n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        let thread = thread::spawn(move || loop {\n"
"            let job = receiver.lock().unwrap().recv().unwrap();\n"
"\n"
"            println!(\"Worker {id} got a job; executing.\");\n"
"\n"
"            job();\n"
"        });\n"
"\n"
"        Worker { id, thread }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:1208
msgid ""
"<span class=\"caption\">Listing 20-20: Receiving and executing the jobs in "
"the\n"
"worker‚Äôs thread</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:1211
msgid ""
"Here, we first call `lock` on the `receiver` to acquire the mutex, and then "
"we\n"
"call `unwrap` to panic on any errors. Acquiring a lock might fail if the "
"mutex\n"
"is in a *poisoned* state, which can happen if some other thread panicked "
"while\n"
"holding the lock rather than releasing the lock. In this situation, calling\n"
"`unwrap` to have this thread panic is the correct action to take. Feel free "
"to\n"
"change this `unwrap` to an `expect` with an error message that is meaningful "
"to\n"
"you."
msgstr ""

#: src/ch20-02-multithreaded.md:1219
msgid ""
"If we get the lock on the mutex, we call `recv` to receive a `Job` from the\n"
"channel. A final `unwrap` moves past any errors here as well, which might "
"occur\n"
"if the thread holding the sender has shut down, similar to how the `send`\n"
"method returns `Err` if the receiver shuts down."
msgstr ""

#: src/ch20-02-multithreaded.md:1224
msgid ""
"The call to `recv` blocks, so if there is no job yet, the current thread "
"will\n"
"wait until a job becomes available. The `Mutex<T>` ensures that only one\n"
"`Worker` thread at a time is trying to request a job."
msgstr ""

#: src/ch20-02-multithreaded.md:1228
msgid ""
"Our thread pool is now in a working state! Give it a `cargo run` and make "
"some\n"
"requests:"
msgstr ""

#: src/ch20-02-multithreaded.md:1231
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch20-web-server/listing-20-20\n"
"cargo run\n"
"make some requests to 127.0.0.1:7878\n"
"Can't automate because the output depends on making requests\n"
"-->"
msgstr ""

#: src/ch20-02-multithreaded.md:1238
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"warning: field is never read: `workers`\n"
" --> src/lib.rs:7:5\n"
"  |\n"
"7 |     workers: Vec<Worker>,\n"
"  |     ^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: `#[warn(dead_code)]` on by default\n"
"\n"
"warning: field is never read: `id`\n"
"  --> src/lib.rs:48:5\n"
"   |\n"
"48 |     id: usize,\n"
"   |     ^^^^^^^^^\n"
"\n"
"warning: field is never read: `thread`\n"
"  --> src/lib.rs:49:5\n"
"   |\n"
"49 |     thread: thread::JoinHandle<()>,\n"
"   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"\n"
"warning: `hello` (lib) generated 3 warnings\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n"
"     Running `target/debug/hello`\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"Worker 1 got a job; executing.\n"
"Worker 3 got a job; executing.\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"Worker 1 got a job; executing.\n"
"Worker 3 got a job; executing.\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:1276
msgid ""
"Success! We now have a thread pool that executes connections "
"asynchronously.\n"
"There are never more than four threads created, so our system won‚Äôt get\n"
"overloaded if the server receives a lot of requests. If we make a request "
"to\n"
"*/sleep*, the server will be able to serve other requests by having another\n"
"thread run them."
msgstr ""

#: src/ch20-02-multithreaded.md:1282
msgid ""
"> Note: if you open */sleep* in multiple browser windows simultaneously, "
"they\n"
"> might load one at a time in 5 second intervals. Some web browsers execute\n"
"> multiple instances of the same request sequentially for caching reasons. "
"This\n"
"> limitation is not caused by our web server."
msgstr ""

#: src/ch20-02-multithreaded.md:1287
msgid ""
"After learning about the `while let` loop in Chapter 18, you might be "
"wondering\n"
"why we didn‚Äôt write the worker thread code as shown in Listing 20-21."
msgstr ""

#: src/ch20-02-multithreaded.md:1292
msgid ""
"```rust,ignore,not_desired_behavior\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"// --snip--\n"
"\n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        let thread = thread::spawn(move || {\n"
"            while let Ok(job) = receiver.lock().unwrap().recv() {\n"
"                println!(\"Worker {id} got a job; executing.\");\n"
"\n"
"                job();\n"
"            }\n"
"        });\n"
"\n"
"        Worker { id, thread }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-02-multithreaded.md:1360
msgid ""
"<span class=\"caption\">Listing 20-21: An alternative implementation of\n"
"`Worker::new` using `while let`</span>"
msgstr ""

#: src/ch20-02-multithreaded.md:1363
msgid ""
"This code compiles and runs but doesn‚Äôt result in the desired threading\n"
"behavior: a slow request will still cause other requests to wait to be\n"
"processed. The reason is somewhat subtle: the `Mutex` struct has no public\n"
"`unlock` method because the ownership of the lock is based on the lifetime "
"of\n"
"the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`\n"
"method returns. At compile time, the borrow checker can then enforce the "
"rule\n"
"that a resource guarded by a `Mutex` cannot be accessed unless we hold the\n"
"lock. However, this implementation can also result in the lock being held\n"
"longer than intended if we aren‚Äôt mindful of the lifetime of the\n"
"`MutexGuard<T>`."
msgstr ""

#: src/ch20-02-multithreaded.md:1374
msgid ""
"The code in Listing 20-20 that uses `let job =\n"
"receiver.lock().unwrap().recv().unwrap();` works because with `let`, any\n"
"temporary values used in the expression on the right hand side of the "
"equals\n"
"sign are immediately dropped when the `let` statement ends. However, `while\n"
"let` (and `if let` and `match`) does not drop temporary values until the end "
"of\n"
"the associated block. In Listing 20-21, the lock remains held for the "
"duration\n"
"of the call to `job()`, meaning other workers cannot receive jobs."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:1
msgid "## Graceful Shutdown and Cleanup"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:3
msgid ""
"The code in Listing 20-20 is responding to requests asynchronously through "
"the\n"
"use of a thread pool, as we intended. We get some warnings about the "
"`workers`,\n"
"`id`, and `thread` fields that we‚Äôre not using in a direct way that reminds "
"us\n"
"we‚Äôre not cleaning up anything. When we use the less elegant <span\n"
"class=\"keystroke\">ctrl-c</span> method to halt the main thread, all other\n"
"threads are stopped immediately as well, even if they‚Äôre in the middle of\n"
"serving a request."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:11
msgid ""
"Next, then, we‚Äôll implement the `Drop` trait to call `join` on each of the\n"
"threads in the pool so they can finish the requests they‚Äôre working on "
"before\n"
"closing. Then we‚Äôll implement a way to tell the threads they should stop\n"
"accepting new requests and shut down. To see this code in action, we‚Äôll "
"modify\n"
"our server to accept only two requests before gracefully shutting down its\n"
"thread pool."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:18
msgid "### Implementing the `Drop` Trait on `ThreadPool`"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:20
msgid ""
"Let‚Äôs start with implementing `Drop` on our thread pool. When the pool is\n"
"dropped, our threads should all join to make sure they finish their work.\n"
"Listing 20-22 shows a first attempt at a `Drop` implementation; this code "
"won‚Äôt\n"
"quite work yet."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:27
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"impl Drop for ThreadPool {\n"
"    fn drop(&mut self) {\n"
"        for worker in &mut self.workers {\n"
"            println!(\"Shutting down worker {}\", worker.id);\n"
"\n"
"            worker.thread.join().unwrap();\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: thread::JoinHandle<()>,\n"
"# }\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"#         let thread = thread::spawn(move || loop {\n"
"#             let job = receiver.lock().unwrap().recv().unwrap();\n"
"# \n"
"#             println!(\"Worker {id} got a job; executing.\");\n"
"# \n"
"#             job();\n"
"#         });\n"
"# \n"
"#         Worker { id, thread }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:104
msgid ""
"<span class=\"caption\">Listing 20-22: Joining each thread when the thread "
"pool\n"
"goes out of scope</span>"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:107
msgid ""
"First, we loop through each of the thread pool `workers`. We use `&mut` for\n"
"this because `self` is a mutable reference, and we also need to be able to\n"
"mutate `worker`. For each worker, we print a message saying that this\n"
"particular worker is shutting down, and then we call `join` on that "
"worker‚Äôs\n"
"thread. If the call to `join` fails, we use `unwrap` to make Rust panic and "
"go\n"
"into an ungraceful shutdown."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:114
msgid "Here is the error we get when we compile this code:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:116
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0507]: cannot move out of `worker.thread` which is behind a mutable "
"reference\n"
"  --> src/lib.rs:52:13\n"
"   |\n"
"52 |             worker.thread.join().unwrap();\n"
"   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this "
"method call\n"
"   |             |\n"
"   |             move occurs because `worker.thread` has type "
"`JoinHandle<()>`, which does not implement the `Copy` trait\n"
"   |\n"
"note: this function takes ownership of the receiver `self`, which moves "
"`worker.thread`\n"
"  --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/"
"mod.rs:1581:17\n"
"\n"
"For more information about this error, try `rustc --explain E0507`.\n"
"error: could not compile `hello` due to previous error\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:134
msgid ""
"The error tells us we can‚Äôt call `join` because we only have a mutable "
"borrow\n"
"of each `worker` and `join` takes ownership of its argument. To solve this\n"
"issue, we need to move the thread out of the `Worker` instance that owns\n"
"`thread` so `join` can consume the thread. We did this in Listing 17-15: if\n"
"`Worker` holds an `Option<thread::JoinHandle<()>>` instead, we can call the\n"
"`take` method on the `Option` to move the value out of the `Some` variant "
"and\n"
"leave a `None` variant in its place. In other words, a `Worker` that is "
"running\n"
"will have a `Some` variant in `thread`, and when we want to clean up a\n"
"`Worker`, we‚Äôll replace `Some` with `None` so the `Worker` doesn‚Äôt have a\n"
"thread to run."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:145
msgid "So we know we want to update the definition of `Worker` like this:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:149
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Drop for ThreadPool {\n"
"#     fn drop(&mut self) {\n"
"#         for worker in &mut self.workers {\n"
"#             println!(\"Shutting down worker {}\", worker.id);\n"
"# \n"
"#             worker.thread.join().unwrap();\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"struct Worker {\n"
"    id: usize,\n"
"    thread: Option<thread::JoinHandle<()>>,\n"
"}\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"#         let thread = thread::spawn(move || loop {\n"
"#             let job = receiver.lock().unwrap().recv().unwrap();\n"
"# \n"
"#             println!(\"Worker {id} got a job; executing.\");\n"
"# \n"
"#             job();\n"
"#         });\n"
"# \n"
"#         Worker { id, thread }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:226
msgid ""
"Now let‚Äôs lean on the compiler to find the other places that need to "
"change.\n"
"Checking this code, we get two errors:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:229
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0599]: no method named `join` found for enum `Option` in the current "
"scope\n"
"  --> src/lib.rs:52:27\n"
"   |\n"
"52 |             worker.thread.join().unwrap();\n"
"   |                           ^^^^ method not found in "
"`Option<JoinHandle<()>>`\n"
"   |\n"
"note: the method `join` exists on the type `JoinHandle<()>`\n"
"  --> /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/"
"mod.rs:1581:5\n"
"help: consider using `Option::expect` to unwrap the `JoinHandle<()>` value, "
"panicking if the value is an `Option::None`\n"
"   |\n"
"52 |             worker.thread.expect(\"REASON\").join().unwrap();\n"
"   |                          +++++++++++++++++\n"
"\n"
"error[E0308]: mismatched types\n"
"  --> src/lib.rs:72:22\n"
"   |\n"
"72 |         Worker { id, thread }\n"
"   |                      ^^^^^^ expected enum `Option`, found struct "
"`JoinHandle`\n"
"   |\n"
"   = note: expected enum `Option<JoinHandle<()>>`\n"
"            found struct `JoinHandle<_>`\n"
"help: try wrapping the expression in `Some`\n"
"   |\n"
"72 |         Worker { id, thread: Some(thread) }\n"
"   |                      +++++++++++++      +\n"
"\n"
"Some errors have detailed explanations: E0308, E0599.\n"
"For more information about an error, try `rustc --explain E0308`.\n"
"error: could not compile `hello` due to 2 previous errors\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:263
msgid ""
"Let‚Äôs address the second error, which points to the code at the end of\n"
"`Worker::new`; we need to wrap the `thread` value in `Some` when we create "
"a\n"
"new `Worker`. Make the following changes to fix this error:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:269
msgid ""
"```rust,ignore,does_not_compile\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Drop for ThreadPool {\n"
"#     fn drop(&mut self) {\n"
"#         for worker in &mut self.workers {\n"
"#             println!(\"Shutting down worker {}\", worker.id);\n"
"# \n"
"#             worker.thread.join().unwrap();\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: Option<thread::JoinHandle<()>>,\n"
"# }\n"
"# \n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        // --snip--\n"
"\n"
"#         let thread = thread::spawn(move || loop {\n"
"#             let job = receiver.lock().unwrap().recv().unwrap();\n"
"# \n"
"#             println!(\"Worker {id} got a job; executing.\");\n"
"# \n"
"#             job();\n"
"#         });\n"
"# \n"
"        Worker {\n"
"            id,\n"
"            thread: Some(thread),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:351
msgid ""
"The first error is in our `Drop` implementation. We mentioned earlier that "
"we\n"
"intended to call `take` on the `Option` value to move `thread` out of "
"`worker`.\n"
"The following changes will do so:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:357
msgid ""
"```rust,ignore,not_desired_behavior\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: mpsc::Sender<Job>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool { workers, sender }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"impl Drop for ThreadPool {\n"
"    fn drop(&mut self) {\n"
"        for worker in &mut self.workers {\n"
"            println!(\"Shutting down worker {}\", worker.id);\n"
"\n"
"            if let Some(thread) = worker.thread.take() {\n"
"                thread.join().unwrap();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: Option<thread::JoinHandle<()>>,\n"
"# }\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"#         let thread = thread::spawn(move || loop {\n"
"#             let job = receiver.lock().unwrap().recv().unwrap();\n"
"# \n"
"#             println!(\"Worker {id} got a job; executing.\");\n"
"# \n"
"#             job();\n"
"#         });\n"
"# \n"
"#         Worker {\n"
"#             id,\n"
"#             thread: Some(thread),\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:439
msgid ""
"As discussed in Chapter 17, the `take` method on `Option` takes the `Some`\n"
"variant out and leaves `None` in its place. We‚Äôre using `if let` to "
"destructure\n"
"the `Some` and get the thread; then we call `join` on the thread. If a "
"worker‚Äôs\n"
"thread is already `None`, we know that worker has already had its thread\n"
"cleaned up, so nothing happens in that case."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:445
msgid "### Signaling to the Threads to Stop Listening for Jobs"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:447
msgid ""
"With all the changes we‚Äôve made, our code compiles without any warnings.\n"
"However, the bad news is this code doesn‚Äôt function the way we want it to "
"yet.\n"
"The key is the logic in the closures run by the threads of the `Worker`\n"
"instances: at the moment, we call `join`, but that won‚Äôt shut down the "
"threads\n"
"because they `loop` forever looking for jobs. If we try to drop our\n"
"`ThreadPool` with our current implementation of `drop`, the main thread "
"will\n"
"block forever waiting for the first thread to finish."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:455
msgid ""
"To fix this problem, we‚Äôll need a change in the `ThreadPool` `drop`\n"
"implementation and then a change in the `Worker` loop."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:458
msgid ""
"First, we‚Äôll change the `ThreadPool` `drop` implementation to explicitly "
"drop\n"
"the `sender` before waiting for the threads to finish. Listing 20-23 shows "
"the\n"
"changes to `ThreadPool` to explicitly drop `sender`. We use the same "
"`Option`\n"
"and `take` technique as we did with the thread to be able to move `sender` "
"out\n"
"of `ThreadPool`:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:466
msgid ""
"```rust,noplayground,not_desired_behavior\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"pub struct ThreadPool {\n"
"    workers: Vec<Worker>,\n"
"    sender: Option<mpsc::Sender<Job>>,\n"
"}\n"
"// --snip--\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        // --snip--\n"
"\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"        ThreadPool {\n"
"            workers,\n"
"            sender: Some(sender),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn execute<F>(&self, f: F)\n"
"    where\n"
"        F: FnOnce() + Send + 'static,\n"
"    {\n"
"        let job = Box::new(f);\n"
"\n"
"        self.sender.as_ref().unwrap().send(job).unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Drop for ThreadPool {\n"
"    fn drop(&mut self) {\n"
"        drop(self.sender.take());\n"
"\n"
"        for worker in &mut self.workers {\n"
"            println!(\"Shutting down worker {}\", worker.id);\n"
"\n"
"            if let Some(thread) = worker.thread.take() {\n"
"                thread.join().unwrap();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: Option<thread::JoinHandle<()>>,\n"
"# }\n"
"# \n"
"# impl Worker {\n"
"#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"#         let thread = thread::spawn(move || loop {\n"
"#             let job = receiver.lock().unwrap().recv().unwrap();\n"
"# \n"
"#             println!(\"Worker {id} got a job; executing.\");\n"
"# \n"
"#             job();\n"
"#         });\n"
"# \n"
"#         Worker {\n"
"#             id,\n"
"#             thread: Some(thread),\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:556
msgid ""
"<span class=\"caption\">Listing 20-23: Explicitly drop `sender` before "
"joining\n"
"the worker threads</span>"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:559
msgid ""
"Dropping `sender` closes the channel, which indicates no more messages will "
"be\n"
"sent. When that happens, all the calls to `recv` that the workers do in the\n"
"infinite loop will return an error. In Listing 20-24, we change the "
"`Worker`\n"
"loop to gracefully exit the loop in that case, which means the threads will\n"
"finish when the `ThreadPool` `drop` implementation calls `join` on them."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:567
msgid ""
"```rust,noplayground\n"
"# use std::{\n"
"#     sync::{mpsc, Arc, Mutex},\n"
"#     thread,\n"
"# };\n"
"# \n"
"# pub struct ThreadPool {\n"
"#     workers: Vec<Worker>,\n"
"#     sender: Option<mpsc::Sender<Job>>,\n"
"# }\n"
"# \n"
"# type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"# \n"
"# impl ThreadPool {\n"
"#     /// Create a new ThreadPool.\n"
"#     ///\n"
"#     /// The size is the number of threads in the pool.\n"
"#     ///\n"
"#     /// # Panics\n"
"#     ///\n"
"#     /// The `new` function will panic if the size is zero.\n"
"#     pub fn new(size: usize) -> ThreadPool {\n"
"#         assert!(size > 0);\n"
"# \n"
"#         let (sender, receiver) = mpsc::channel();\n"
"# \n"
"#         let receiver = Arc::new(Mutex::new(receiver));\n"
"# \n"
"#         let mut workers = Vec::with_capacity(size);\n"
"# \n"
"#         for id in 0..size {\n"
"#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"#         }\n"
"# \n"
"#         ThreadPool {\n"
"#             workers,\n"
"#             sender: Some(sender),\n"
"#         }\n"
"#     }\n"
"# \n"
"#     pub fn execute<F>(&self, f: F)\n"
"#     where\n"
"#         F: FnOnce() + Send + 'static,\n"
"#     {\n"
"#         let job = Box::new(f);\n"
"# \n"
"#         self.sender.as_ref().unwrap().send(job).unwrap();\n"
"#     }\n"
"# }\n"
"# \n"
"# impl Drop for ThreadPool {\n"
"#     fn drop(&mut self) {\n"
"#         drop(self.sender.take());\n"
"# \n"
"#         for worker in &mut self.workers {\n"
"#             println!(\"Shutting down worker {}\", worker.id);\n"
"# \n"
"#             if let Some(thread) = worker.thread.take() {\n"
"#                 thread.join().unwrap();\n"
"#             }\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# struct Worker {\n"
"#     id: usize,\n"
"#     thread: Option<thread::JoinHandle<()>>,\n"
"# }\n"
"# \n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        let thread = thread::spawn(move || loop {\n"
"            let message = receiver.lock().unwrap().recv();\n"
"\n"
"            match message {\n"
"                Ok(job) => {\n"
"                    println!(\"Worker {id} got a job; executing.\");\n"
"\n"
"                    job();\n"
"                }\n"
"                Err(_) => {\n"
"                    println!(\"Worker {id} disconnected; shutting down.\");\n"
"                    break;\n"
"                }\n"
"            }\n"
"        });\n"
"\n"
"        Worker {\n"
"            id,\n"
"            thread: Some(thread),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:662
msgid ""
"<span class=\"caption\">Listing 20-24: Explicitly break out of the loop "
"when\n"
"`recv` returns an error</span>"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:665
msgid ""
"To see this code in action, let‚Äôs modify `main` to accept only two requests\n"
"before gracefully shutting down the server, as shown in Listing 20-25."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:670
msgid ""
"```rust,ignore\n"
"# use hello::ThreadPool;\n"
"# use std::fs;\n"
"# use std::io::prelude::*;\n"
"# use std::net::TcpListener;\n"
"# use std::net::TcpStream;\n"
"# use std::thread;\n"
"# use std::time::Duration;\n"
"# \n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"    let pool = ThreadPool::new(4);\n"
"\n"
"    for stream in listener.incoming().take(2) {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        pool.execute(|| {\n"
"            handle_connection(stream);\n"
"        });\n"
"    }\n"
"\n"
"    println!(\"Shutting down.\");\n"
"}\n"
"# \n"
"# fn handle_connection(mut stream: TcpStream) {\n"
"#     let mut buffer = [0; 1024];\n"
"#     stream.read(&mut buffer).unwrap();\n"
"# \n"
"#     let get = b\"GET / HTTP/1.1\\r\\n\";\n"
"#     let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n"
"# \n"
"#     let (status_line, filename) = if buffer.starts_with(get) {\n"
"#         (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"#     } else if buffer.starts_with(sleep) {\n"
"#         thread::sleep(Duration::from_secs(5));\n"
"#         (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"#     } else {\n"
"#         (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n"
"#     };\n"
"# \n"
"#     let contents = fs::read_to_string(filename).unwrap();\n"
"# \n"
"#     let response = format!(\n"
"#         \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n"
"#         status_line,\n"
"#         contents.len(),\n"
"#         contents\n"
"#     );\n"
"# \n"
"#     stream.write_all(response.as_bytes()).unwrap();\n"
"#     stream.flush().unwrap();\n"
"# }\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:724
msgid ""
"<span class=\"caption\">Listing 20-25: Shut down the server after serving "
"two\n"
"requests by exiting the loop</span>"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:727
msgid ""
"You wouldn‚Äôt want a real-world web server to shut down after serving only "
"two\n"
"requests. This code just demonstrates that the graceful shutdown and cleanup "
"is\n"
"in working order."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:731
msgid ""
"The `take` method is defined in the `Iterator` trait and limits the "
"iteration\n"
"to the first two items at most. The `ThreadPool` will go out of scope at "
"the\n"
"end of `main`, and the `drop` implementation will run."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:735
msgid ""
"Start the server with `cargo run`, and make three requests. The third "
"request\n"
"should error, and in your terminal you should see output similar to this:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:738
msgid ""
"<!-- manual-regeneration\n"
"cd listings/ch20-web-server/listing-20-25\n"
"cargo run\n"
"curl http://127.0.0.1:7878\n"
"curl http://127.0.0.1:7878\n"
"curl http://127.0.0.1:7878\n"
"third request will error because server will have shut down\n"
"copy output below\n"
"Can't automate because the output depends on making requests\n"
"-->"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:749
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 1.0s\n"
"     Running `target/debug/hello`\n"
"Worker 0 got a job; executing.\n"
"Shutting down.\n"
"Shutting down worker 0\n"
"Worker 3 got a job; executing.\n"
"Worker 1 disconnected; shutting down.\n"
"Worker 2 disconnected; shutting down.\n"
"Worker 3 disconnected; shutting down.\n"
"Worker 0 disconnected; shutting down.\n"
"Shutting down worker 1\n"
"Shutting down worker 2\n"
"Shutting down worker 3\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:767
msgid ""
"You might see a different ordering of workers and messages printed. We can "
"see\n"
"how this code works from the messages: workers 0 and 3 got the first two\n"
"requests. The server stopped accepting connections after the second "
"connection,\n"
"and the `Drop` implementation on `ThreadPool` starts executing before worker "
"3\n"
"even starts its job. Dropping the `sender` disconnects all the workers and\n"
"tells them to shut down. The workers each print a message when they "
"disconnect,\n"
"and then the thread pool calls `join` to wait for each worker thread to "
"finish."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:775
msgid ""
"Notice one interesting aspect of this particular execution: the "
"`ThreadPool`\n"
"dropped the `sender`, and before any worker received an error, we tried to "
"join\n"
"worker 0. Worker 0 had not yet gotten an error from `recv`, so the main "
"thread\n"
"blocked waiting for worker 0 to finish. In the meantime, worker 3 received "
"a\n"
"job and then all threads received an error. When worker 0 finished, the "
"main\n"
"thread waited for the rest of the workers to finish. At that point, they "
"had\n"
"all exited their loops and stopped."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:783
msgid ""
"Congrats! We‚Äôve now completed our project; we have a basic web server that "
"uses\n"
"a thread pool to respond asynchronously. We‚Äôre able to perform a graceful\n"
"shutdown of the server, which cleans up all the threads in the pool."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:787
msgid "Here‚Äôs the full code for reference:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:791
msgid ""
"```rust,ignore\n"
"use hello::ThreadPool;\n"
"use std::fs;\n"
"use std::io::prelude::*;\n"
"use std::net::TcpListener;\n"
"use std::net::TcpStream;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n"
"    let pool = ThreadPool::new(4);\n"
"\n"
"    for stream in listener.incoming().take(2) {\n"
"        let stream = stream.unwrap();\n"
"\n"
"        pool.execute(|| {\n"
"            handle_connection(stream);\n"
"        });\n"
"    }\n"
"\n"
"    println!(\"Shutting down.\");\n"
"}\n"
"\n"
"fn handle_connection(mut stream: TcpStream) {\n"
"    let mut buffer = [0; 1024];\n"
"    stream.read(&mut buffer).unwrap();\n"
"\n"
"    let get = b\"GET / HTTP/1.1\\r\\n\";\n"
"    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n"
"\n"
"    let (status_line, filename) = if buffer.starts_with(get) {\n"
"        (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"    } else if buffer.starts_with(sleep) {\n"
"        thread::sleep(Duration::from_secs(5));\n"
"        (\"HTTP/1.1 200 OK\", \"hello.html\")\n"
"    } else {\n"
"        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n"
"    };\n"
"\n"
"    let contents = fs::read_to_string(filename).unwrap();\n"
"\n"
"    let response = format!(\n"
"        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n"
"        status_line,\n"
"        contents.len(),\n"
"        contents\n"
"    );\n"
"\n"
"    stream.write_all(response.as_bytes()).unwrap();\n"
"    stream.flush().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:847
msgid ""
"```rust,noplayground\n"
"use std::{\n"
"    sync::{mpsc, Arc, Mutex},\n"
"    thread,\n"
"};\n"
"\n"
"pub struct ThreadPool {\n"
"    workers: Vec<Worker>,\n"
"    sender: Option<mpsc::Sender<Job>>,\n"
"}\n"
"\n"
"type Job = Box<dyn FnOnce() + Send + 'static>;\n"
"\n"
"impl ThreadPool {\n"
"    /// Create a new ThreadPool.\n"
"    ///\n"
"    /// The size is the number of threads in the pool.\n"
"    ///\n"
"    /// # Panics\n"
"    ///\n"
"    /// The `new` function will panic if the size is zero.\n"
"    pub fn new(size: usize) -> ThreadPool {\n"
"        assert!(size > 0);\n"
"\n"
"        let (sender, receiver) = mpsc::channel();\n"
"\n"
"        let receiver = Arc::new(Mutex::new(receiver));\n"
"\n"
"        let mut workers = Vec::with_capacity(size);\n"
"\n"
"        for id in 0..size {\n"
"            workers.push(Worker::new(id, Arc::clone(&receiver)));\n"
"        }\n"
"\n"
"        ThreadPool {\n"
"            workers,\n"
"            sender: Some(sender),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn execute<F>(&self, f: F)\n"
"    where\n"
"        F: FnOnce() + Send + 'static,\n"
"    {\n"
"        let job = Box::new(f);\n"
"\n"
"        self.sender.as_ref().unwrap().send(job).unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Drop for ThreadPool {\n"
"    fn drop(&mut self) {\n"
"        drop(self.sender.take());\n"
"\n"
"        for worker in &mut self.workers {\n"
"            println!(\"Shutting down worker {}\", worker.id);\n"
"\n"
"            if let Some(thread) = worker.thread.take() {\n"
"                thread.join().unwrap();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Worker {\n"
"    id: usize,\n"
"    thread: Option<thread::JoinHandle<()>>,\n"
"}\n"
"\n"
"impl Worker {\n"
"    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker "
"{\n"
"        let thread = thread::spawn(move || loop {\n"
"            let message = receiver.lock().unwrap().recv();\n"
"\n"
"            match message {\n"
"                Ok(job) => {\n"
"                    println!(\"Worker {id} got a job; executing.\");\n"
"\n"
"                    job();\n"
"                }\n"
"                Err(_) => {\n"
"                    println!(\"Worker {id} disconnected; shutting down.\");\n"
"                    break;\n"
"                }\n"
"            }\n"
"        });\n"
"\n"
"        Worker {\n"
"            id,\n"
"            thread: Some(thread),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:942
msgid ""
"We could do more here! If you want to continue enhancing this project, here "
"are\n"
"some ideas:"
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:945
msgid ""
"* Add more documentation to `ThreadPool` and its public methods.\n"
"* Add tests of the library‚Äôs functionality.\n"
"* Change calls to `unwrap` to more robust error handling.\n"
"* Use `ThreadPool` to perform some task other than serving web requests.\n"
"* Find a thread pool crate on [crates.io](https://crates.io/) and implement "
"a\n"
"  similar web server using the crate instead. Then compare its API and\n"
"  robustness to the thread pool we implemented."
msgstr ""

#: src/ch20-03-graceful-shutdown-and-cleanup.md:955
msgid ""
"Well done! You‚Äôve made it to the end of the book! We want to thank you for\n"
"joining us on this tour of Rust. You‚Äôre now ready to implement your own "
"Rust\n"
"projects and help with other peoples‚Äô projects. Keep in mind that there is "
"a\n"
"welcoming community of other Rustaceans who would love to help you with any\n"
"challenges you encounter on your Rust journey."
msgstr ""

#: src/appendix-00.md:1
msgid "# Appendix"
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your\n"
"Rust journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "## Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or "
"future\n"
"use by the Rust language. As such, they cannot be used as identifiers "
"(except\n"
"as raw identifiers as we‚Äôll discuss in the ‚Äú[Raw\n"
"Identifiers][raw-identifiers]<!-- ignore -->‚Äù section). Identifiers are "
"names\n"
"of functions, variables, parameters, struct fields, modules, crates, "
"constants,\n"
"macros, static values, attributes, types, traits, or lifetimes."
msgstr ""

#: src/appendix-01-keywords.md:12
msgid "### Keywords Currently in Use"
msgstr ""

#: src/appendix-01-keywords.md:14
msgid ""
"The following is a list of keywords currently in use, with their "
"functionality\n"
"described."
msgstr ""

#: src/appendix-01-keywords.md:17
msgid ""
"* `as` - perform primitive casting, disambiguate the specific trait "
"containing\n"
"  an item, or rename items in `use` statements\n"
"* `async` -  return a `Future` instead of blocking the current thread\n"
"* `await` - suspend execution until the result of a `Future` is ready\n"
"* `break` - exit a loop immediately\n"
"* `const` - define constant items or constant raw pointers\n"
"* `continue` - continue to the next loop iteration\n"
"* `crate` - in a module path, refers to the crate root\n"
"* `dyn` - dynamic dispatch to a trait object\n"
"* `else` - fallback for `if` and `if let` control flow constructs\n"
"* `enum` - define an enumeration\n"
"* `extern` - link an external function or variable\n"
"* `false` - Boolean false literal\n"
"* `fn` - define a function or the function pointer type\n"
"* `for` - loop over items from an iterator, implement a trait, or specify a\n"
"  higher-ranked lifetime\n"
"* `if` - branch based on the result of a conditional expression\n"
"* `impl` - implement inherent or trait functionality\n"
"* `in` - part of `for` loop syntax\n"
"* `let` - bind a variable\n"
"* `loop` - loop unconditionally\n"
"* `match` - match a value to patterns\n"
"* `mod` - define a module\n"
"* `move` - make a closure take ownership of all its captures\n"
"* `mut` - denote mutability in references, raw pointers, or pattern "
"bindings\n"
"* `pub` - denote public visibility in struct fields, `impl` blocks, or "
"modules\n"
"* `ref` - bind by reference\n"
"* `return` - return from function\n"
"* `Self` - a type alias for the type we are defining or implementing\n"
"* `self` - method subject or current module\n"
"* `static` - global variable or lifetime lasting the entire program "
"execution\n"
"* `struct` - define a structure\n"
"* `super` - parent module of the current module\n"
"* `trait` - define a trait\n"
"* `true` - Boolean true literal\n"
"* `type` - define a type alias or associated type\n"
"* `union` - define a [union][union]<!-- ignore -->; is only a keyword when "
"used\n"
"  in a union declaration\n"
"* `unsafe` - denote unsafe code, functions, traits, or implementations\n"
"* `use` - bring symbols into scope\n"
"* `where` - denote clauses that constrain a type\n"
"* `while` - loop conditionally based on the result of an expression"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "### Keywords Reserved for Future Use"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid ""
"The following keywords do not yet have any functionality but are reserved "
"by\n"
"Rust for potential future use."
msgstr ""

#: src/appendix-01-keywords.md:67
msgid ""
"* `abstract`\n"
"* `become`\n"
"* `box`\n"
"* `do`\n"
"* `final`\n"
"* `macro`\n"
"* `override`\n"
"* `priv`\n"
"* `try`\n"
"* `typeof`\n"
"* `unsized`\n"
"* `virtual`\n"
"* `yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "### Raw Identifiers"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid ""
"*Raw identifiers* are the syntax that lets you use keywords where they "
"wouldn‚Äôt\n"
"normally be allowed. You use a raw identifier by prefixing a keyword with "
"`r#`."
msgstr ""

#: src/appendix-01-keywords.md:86
msgid ""
"For example, `match` is a keyword. If you try to compile the following "
"function\n"
"that uses `match` as its name:"
msgstr ""

#: src/appendix-01-keywords.md:91
msgid ""
"```rust,ignore,does_not_compile\n"
"fn match(needle: &str, haystack: &str) -> bool {\n"
"    haystack.contains(needle)\n"
"}\n"
"```"
msgstr ""

#: src/appendix-01-keywords.md:97
msgid "you‚Äôll get this error:"
msgstr ""

#: src/appendix-01-keywords.md:99
msgid ""
"```text\n"
"error: expected identifier, found keyword `match`\n"
" --> src/main.rs:4:4\n"
"  |\n"
"4 | fn match(needle: &str, haystack: &str) -> bool {\n"
"  |    ^^^^^ expected identifier, found keyword\n"
"```"
msgstr ""

#: src/appendix-01-keywords.md:107
msgid ""
"The error shows that you can‚Äôt use the keyword `match` as the function\n"
"identifier. To use `match` as a function name, you need to use the raw\n"
"identifier syntax, like this:"
msgstr ""

#: src/appendix-01-keywords.md:113
msgid ""
"```rust\n"
"fn r#match(needle: &str, haystack: &str) -> bool {\n"
"    haystack.contains(needle)\n"
"}\n"
"\n"
"fn main() {\n"
"    assert!(r#match(\"foo\", \"foobar\"));\n"
"}\n"
"```"
msgstr ""

#: src/appendix-01-keywords.md:123
msgid ""
"This code will compile without any errors. Note the `r#` prefix on the "
"function\n"
"name in its definition as well as where the function is called in `main`."
msgstr ""

#: src/appendix-01-keywords.md:126
msgid ""
"Raw identifiers allow you to use any word you choose as an identifier, even "
"if\n"
"that word happens to be a reserved keyword. This gives us more freedom to\n"
"choose identifier names, as well as lets us integrate with programs written "
"in\n"
"a language where these words aren‚Äôt keywords. In addition, raw identifiers\n"
"allow you to use libraries written in a different Rust edition than your "
"crate\n"
"uses. For example, `try` isn‚Äôt a keyword in the 2015 edition but is in the "
"2018\n"
"edition. If you depend on a library that‚Äôs written using the 2015 edition "
"and\n"
"has a `try` function, you‚Äôll need to use the raw identifier syntax, `r#try` "
"in\n"
"this case, to call that function from your 2018 edition code. See [Appendix\n"
"E][appendix-e]<!-- ignore --> for more information on editions."
msgstr ""

#: src/appendix-02-operators.md:1
msgid "## Appendix B: Operators and Symbols"
msgstr ""

#: src/appendix-02-operators.md:3
msgid ""
"This appendix contains a glossary of Rust‚Äôs syntax, including operators and\n"
"other symbols that appear by themselves or in the context of paths, "
"generics,\n"
"trait bounds, macros, attributes, comments, tuples, and brackets."
msgstr ""

#: src/appendix-02-operators.md:7
msgid "### Operators"
msgstr ""

#: src/appendix-02-operators.md:9
msgid ""
"Table B-1 contains the operators in Rust, an example of how the operator "
"would\n"
"appear in context, a short explanation, and whether that operator is\n"
"overloadable. If an operator is overloadable, the relevant trait to use to\n"
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators.md:14
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr ""

#: src/appendix-02-operators.md:16
msgid ""
"| Operator | Example | Explanation | Overloadable? |\n"
"|----------|---------|-------------|---------------|\n"
"| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |\n"
"| `!` | `!expr` | Bitwise or logical complement | `Not` |\n"
"| `!=` | `expr != expr` | Nonequality comparison | `PartialEq` |\n"
"| `%` | `expr % expr` | Arithmetic remainder | `Rem` |\n"
"| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` "
"|\n"
"| `&` | `&expr`, `&mut expr` | Borrow | |\n"
"| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer "
"type | |\n"
"| `&` | `expr & expr` | Bitwise AND | `BitAnd` |\n"
"| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |\n"
"| `&&` | `expr && expr` | Short-circuiting logical AND | |\n"
"| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |\n"
"| `*=` | `var *= expr` | Arithmetic multiplication and assignment | "
"`MulAssign` |\n"
"| `*` | `*expr` | Dereference | `Deref` |\n"
"| `*` | `*const type`, `*mut type` | Raw pointer | |\n"
"| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |\n"
"| `+` | `expr + expr` | Arithmetic addition | `Add` |\n"
"| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |\n"
"| `,` | `expr, expr` | Argument and element separator | |\n"
"| `-` | `- expr` | Arithmetic negation | `Neg` |\n"
"| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |\n"
"| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` "
"|\n"
"| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function "
"and closure return type | |\n"
"| `.` | `expr.ident` | Member access | |\n"
"| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range "
"literal | `PartialOrd` |\n"
"| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | "
"`PartialOrd` |\n"
"| `..` | `..expr` | Struct literal update syntax | |\n"
"| `..` | `variant(x, ..)`, `struct_type { x, .. }` | ‚ÄúAnd the rest‚Äù pattern "
"binding | |\n"
"| `...` | `expr...expr` | (Deprecated, use `..=` instead) In a pattern: "
"inclusive range pattern | |\n"
"| `/` | `expr / expr` | Arithmetic division | `Div` |\n"
"| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |\n"
"| `:` | `pat: type`, `ident: type` | Constraints | |\n"
"| `:` | `ident: expr` | Struct field initializer | |\n"
"| `:` | `'a: loop {...}` | Loop label | |\n"
"| `;` | `expr;` | Statement and item terminator | |\n"
"| `;` | `[...; len]` | Part of fixed-size array syntax | |\n"
"| `<<` | `expr << expr` | Left-shift | `Shl` |\n"
"| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |\n"
"| `<` | `expr < expr` | Less than comparison | `PartialOrd` |\n"
"| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |\n"
"| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |\n"
"| `==` | `expr == expr` | Equality comparison | `PartialEq` |\n"
"| `=>` | `pat => expr` | Part of match arm syntax | |\n"
"| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |\n"
"| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` "
"|\n"
"| `>>` | `expr >> expr` | Right-shift | `Shr` |\n"
"| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |\n"
"| `@` | `ident @ pat` | Pattern binding | |\n"
"| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |\n"
"| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | "
"`BitXorAssign` |\n"
"| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | "
"|\n"
"| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` "
"|\n"
"| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and "
"assignment | `BitOrAssign` |\n"
"| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-"
"circuiting logical OR | |\n"
"| `?` | `expr?` | Error propagation | |"
msgstr ""

#: src/appendix-02-operators.md:73
msgid "### Non-operator Symbols"
msgstr ""

#: src/appendix-02-operators.md:75
msgid ""
"The following list contains all symbols that don‚Äôt function as operators; "
"that\n"
"is, they don‚Äôt behave like a function or method call."
msgstr ""

#: src/appendix-02-operators.md:78
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of\n"
"locations."
msgstr ""

#: src/appendix-02-operators.md:81
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr ""

#: src/appendix-02-operators.md:83
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `'ident` | Named lifetime or loop label |\n"
"| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of "
"specific type |\n"
"| `\"...\"` | String literal |\n"
"| `r\"...\"`, `r#\"...\"#`, `r##\"...\"##`, etc. | Raw string literal, "
"escape characters not processed |\n"
"| `b\"...\"` | Byte string literal; constructs an array of bytes instead of "
"a string |\n"
"| `br\"...\"`, `br#\"...\"#`, `br##\"...\"##`, etc. | Raw byte string "
"literal, combination of raw and byte string literal |\n"
"| `'...'` | Character literal |\n"
"| `b'...'` | ASCII byte literal |\n"
"| <code>&vert;...&vert; expr</code> | Closure |\n"
"| `!` | Always empty bottom type for diverging functions |\n"
"| `_` | ‚ÄúIgnored‚Äù pattern binding; also used to make integer literals "
"readable |"
msgstr ""

#: src/appendix-02-operators.md:97
msgid ""
"Table B-3 shows symbols that appear in the context of a path through the "
"module\n"
"hierarchy to an item."
msgstr ""

#: src/appendix-02-operators.md:100
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr ""

#: src/appendix-02-operators.md:102
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `ident::ident` | Namespace path |\n"
"| `::path` | Path relative to the crate root (i.e., an explicitly absolute "
"path) |\n"
"| `self::path` | Path relative to the current module (i.e., an explicitly "
"relative path).\n"
"| `super::path` | Path relative to the parent of the current module |\n"
"| `type::ident`, `<type as trait>::ident` | Associated constants, functions, "
"and types |\n"
"| `<type>::...` | Associated item for a type that cannot be directly named "
"(e.g., `<&T>::...`, `<[T]>::...`, etc.) |\n"
"| `trait::method(...)` | Disambiguating a method call by naming the trait "
"that defines it |\n"
"| `type::method(...)` | Disambiguating a method call by naming the type for "
"which it‚Äôs defined |\n"
"| `<type as trait>::method(...)` | Disambiguating a method call by naming "
"the trait and type |"
msgstr ""

#: src/appendix-02-operators.md:114
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type\n"
"parameters."
msgstr ""

#: src/appendix-02-operators.md:117
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr ""

#: src/appendix-02-operators.md:119
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `path<...>` | Specifies parameters to generic type in a type (e.g., "
"`Vec<u8>`) |\n"
"| `path::<...>`, `method::<...>` | Specifies parameters to generic type, "
"function, or method in an expression; often referred to as turbofish (e.g., "
"`\"42\".parse::<i32>()`) |\n"
"| `fn ident<...> ...` | Define generic function |\n"
"| `struct ident<...> ...` | Define generic structure |\n"
"| `enum ident<...> ...` | Define generic enumeration |\n"
"| `impl<...> ...` | Define generic implementation |\n"
"| `for<...> type` | Higher-ranked lifetime bounds |\n"
"| `type<ident=type>` | A generic type where one or more associated types "
"have specific assignments (e.g., `Iterator<Item=T>`) |"
msgstr ""

#: src/appendix-02-operators.md:130
msgid ""
"Table B-5 shows symbols that appear in the context of constraining generic "
"type\n"
"parameters with trait bounds."
msgstr ""

#: src/appendix-02-operators.md:133
msgid "<span class=\"caption\">Table B-5: Trait Bound Constraints</span>"
msgstr ""

#: src/appendix-02-operators.md:135
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `T: U` | Generic parameter `T` constrained to types that implement `U` |\n"
"| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type "
"cannot transitively contain any references with lifetimes shorter than `'a`) "
"|\n"
"| `T: 'static` | Generic type `T` contains no borrowed references other than "
"`'static` ones |\n"
"| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |\n"
"| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type "
"|\n"
"| `'a + trait`, `trait + trait` | Compound type constraint |"
msgstr ""

#: src/appendix-02-operators.md:144
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining\n"
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators.md:147
msgid "<span class=\"caption\">Table B-6: Macros and Attributes</span>"
msgstr ""

#: src/appendix-02-operators.md:149
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `#[meta]` | Outer attribute |\n"
"| `#![meta]` | Inner attribute |\n"
"| `$ident` | Macro substitution |\n"
"| `$ident:kind` | Macro capture |\n"
"| `$(‚Ä¶)‚Ä¶` | Macro repetition |\n"
"| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |"
msgstr ""

#: src/appendix-02-operators.md:158
msgid "Table B-7 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators.md:160
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr ""

#: src/appendix-02-operators.md:162
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `//` | Line comment |\n"
"| `//!` | Inner line doc comment |\n"
"| `///` | Outer line doc comment |\n"
"| `/*...*/` | Block comment |\n"
"| `/*!...*/` | Inner block doc comment |\n"
"| `/**...*/` | Outer block doc comment |"
msgstr ""

#: src/appendix-02-operators.md:171
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators.md:173
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr ""

#: src/appendix-02-operators.md:175
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `()` | Empty tuple (aka unit), both literal and type |\n"
"| `(expr)` | Parenthesized expression |\n"
"| `(expr,)` | Single-element tuple expression |\n"
"| `(type,)` | Single-element tuple type |\n"
"| `(expr, ...)` | Tuple expression |\n"
"| `(type, ...)` | Tuple type |\n"
"| `expr(expr, ...)` | Function call expression; also used to initialize "
"tuple `struct`s and tuple `enum` variants |\n"
"| `expr.0`, `expr.1`, etc. | Tuple indexing |"
msgstr ""

#: src/appendix-02-operators.md:186
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators.md:188
msgid "<span class=\"caption\">Table B-9: Curly Brackets</span>"
msgstr ""

#: src/appendix-02-operators.md:190
msgid ""
"| Context | Explanation |\n"
"|---------|-------------|\n"
"| `{...}` | Block expression |\n"
"| `Type {...}` | `struct` literal |"
msgstr ""

#: src/appendix-02-operators.md:195
msgid "Table B-10 shows the contexts in which square brackets are used."
msgstr ""

#: src/appendix-02-operators.md:197
msgid "<span class=\"caption\">Table B-10: Square Brackets</span>"
msgstr ""

#: src/appendix-02-operators.md:199
msgid ""
"| Context | Explanation |\n"
"|---------|-------------|\n"
"| `[...]` | Array literal |\n"
"| `[expr; len]` | Array literal containing `len` copies of `expr` |\n"
"| `[type; len]` | Array type containing `len` instances of `type` |\n"
"| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |\n"
"| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing "
"pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, "
"or `RangeFull` as the ‚Äúindex‚Äù |"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "## Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we‚Äôve discussed the `derive` attribute, "
"which\n"
"you can apply to a struct or enum definition. The `derive` attribute "
"generates\n"
"code that will implement a trait with its own default implementation on the\n"
"type you‚Äôve annotated with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:8
msgid ""
"In this appendix, we provide a reference of all the traits in the standard\n"
"library that you can use with `derive`. Each section covers:"
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid ""
"* What operators and methods deriving this trait will enable\n"
"* What the implementation of the trait provided by `derive` does\n"
"* What implementing the trait signifies about the type\n"
"* The conditions in which you‚Äôre allowed or not allowed to implement the "
"trait\n"
"* Examples of operations that require the trait"
msgstr ""

#: src/appendix-03-derivable-traits.md:17
msgid ""
"If you want different behavior from that provided by the `derive` "
"attribute,\n"
"consult the [standard library documentation](../std/index.html)<!-- ignore --"
">\n"
"for each trait for details of how to manually implement them."
msgstr ""

#: src/appendix-03-derivable-traits.md:21
msgid ""
"These traits listed here are the only ones defined by the standard library "
"that\n"
"can be implemented on your types using `derive`. Other traits defined in "
"the\n"
"standard library don‚Äôt have sensible default behavior, so it‚Äôs up to you to\n"
"implement them in the way that makes sense for what you‚Äôre trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:26
msgid ""
"An example of a trait that can‚Äôt be derived is `Display`, which handles\n"
"formatting for end users. You should always consider the appropriate way to\n"
"display a type to an end user. What parts of the type should an end user be\n"
"allowed to see? What parts would they find relevant? What format of the "
"data\n"
"would be most relevant to them? The Rust compiler doesn‚Äôt have this insight, "
"so\n"
"it can‚Äôt provide appropriate default behavior for you."
msgstr ""

#: src/appendix-03-derivable-traits.md:33
msgid ""
"The list of derivable traits provided in this appendix is not "
"comprehensive:\n"
"libraries can implement `derive` for their own traits, making the list of\n"
"traits you can use `derive` with truly open-ended. Implementing `derive`\n"
"involves using a procedural macro, which is covered in the\n"
"[‚ÄúMacros‚Äù][macros]<!-- ignore --> section of Chapter 19."
msgstr ""

#: src/appendix-03-derivable-traits.md:39
msgid "### `Debug` for Programmer Output"
msgstr ""

#: src/appendix-03-derivable-traits.md:41
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you\n"
"indicate by adding `:?` within `{}` placeholders."
msgstr ""

#: src/appendix-03-derivable-traits.md:44
msgid ""
"The `Debug` trait allows you to print instances of a type for debugging\n"
"purposes, so you and other programmers using your type can inspect an "
"instance\n"
"at a particular point in a program‚Äôs execution."
msgstr ""

#: src/appendix-03-derivable-traits.md:48
msgid ""
"The `Debug` trait is required, for example, in use of the `assert_eq!` "
"macro.\n"
"This macro prints the values of instances given as arguments if the "
"equality\n"
"assertion fails so programmers can see why the two instances weren‚Äôt equal."
msgstr ""

#: src/appendix-03-derivable-traits.md:52
msgid "### `PartialEq` and `Eq` for Equality Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:54
msgid ""
"The `PartialEq` trait allows you to compare instances of a type to check "
"for\n"
"equality and enables use of the `==` and `!=` operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:57
msgid ""
"Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived "
"on\n"
"structs, two instances are equal only if *all* fields are equal, and the\n"
"instances are not equal if any fields are not equal. When derived on enums,\n"
"each variant is equal to itself and not equal to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:62
msgid ""
"The `PartialEq` trait is required, for example, with the use of the\n"
"`assert_eq!` macro, which needs to be able to compare two instances of a "
"type\n"
"for equality."
msgstr ""

#: src/appendix-03-derivable-traits.md:66
msgid ""
"The `Eq` trait has no methods. Its purpose is to signal that for every value "
"of\n"
"the annotated type, the value is equal to itself. The `Eq` trait can only "
"be\n"
"applied to types that also implement `PartialEq`, although not all types "
"that\n"
"implement `PartialEq` can implement `Eq`. One example of this is floating "
"point\n"
"number types: the implementation of floating point numbers states that two\n"
"instances of the not-a-number (`NaN`) value are not equal to each other."
msgstr ""

#: src/appendix-03-derivable-traits.md:73
msgid ""
"An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the\n"
"`HashMap<K, V>` can tell whether two keys are the same."
msgstr ""

#: src/appendix-03-derivable-traits.md:76
msgid "### `PartialOrd` and `Ord` for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:78
msgid ""
"The `PartialOrd` trait allows you to compare instances of a type for "
"sorting\n"
"purposes. A type that implements `PartialOrd` can be used with the `<`, "
"`>`,\n"
"`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to "
"types\n"
"that also implement `PartialEq`."
msgstr ""

#: src/appendix-03-derivable-traits.md:83
msgid ""
"Deriving `PartialOrd` implements the `partial_cmp` method, which returns an\n"
"`Option<Ordering>` that will be `None` when the values given don‚Äôt produce "
"an\n"
"ordering. An example of a value that doesn‚Äôt produce an ordering, even "
"though\n"
"most values of that type can be compared, is the not-a-number (`NaN`) "
"floating\n"
"point value. Calling `partial_cmp` with any floating point number and the "
"`NaN`\n"
"floating point value will return `None`."
msgstr ""

#: src/appendix-03-derivable-traits.md:90
msgid ""
"When derived on structs, `PartialOrd` compares two instances by comparing "
"the\n"
"value in each field in the order in which the fields appear in the struct\n"
"definition. When derived on enums, variants of the enum declared earlier in "
"the\n"
"enum definition are considered less than the variants listed later."
msgstr ""

#: src/appendix-03-derivable-traits.md:95
msgid ""
"The `PartialOrd` trait is required, for example, for the `gen_range` method\n"
"from the `rand` crate that generates a random value in the range specified "
"by a\n"
"range expression."
msgstr ""

#: src/appendix-03-derivable-traits.md:99
msgid ""
"The `Ord` trait allows you to know that for any two values of the annotated\n"
"type, a valid ordering will exist. The `Ord` trait implements the `cmp` "
"method,\n"
"which returns an `Ordering` rather than an `Option<Ordering>` because a "
"valid\n"
"ordering will always be possible. You can only apply the `Ord` trait to "
"types\n"
"that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). "
"When\n"
"derived on structs and enums, `cmp` behaves the same way as the derived\n"
"implementation for `partial_cmp` does with `PartialOrd`."
msgstr ""

#: src/appendix-03-derivable-traits.md:107
msgid ""
"An example of when `Ord` is required is when storing values in a "
"`BTreeSet<T>`,\n"
"a data structure that stores data based on the sort order of the values."
msgstr ""

#: src/appendix-03-derivable-traits.md:110
msgid "### `Clone` and `Copy` for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:112
msgid ""
"The `Clone` trait allows you to explicitly create a deep copy of a value, "
"and\n"
"the duplication process might involve running arbitrary code and copying "
"heap\n"
"data. See the [‚ÄúWays Variables and Data Interact:\n"
"Clone‚Äù][ways-variables-and-data-interact-clone]<!-- ignore --> section in\n"
"Chapter 4 for more information on `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:118
msgid ""
"Deriving `Clone` implements the `clone` method, which when implemented for "
"the\n"
"whole type, calls `clone` on each of the parts of the type. This means all "
"the\n"
"fields or values in the type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:122
msgid ""
"An example of when `Clone` is required is when calling the `to_vec` method "
"on a\n"
"slice. The slice doesn‚Äôt own the type instances it contains, but the vector\n"
"returned from `to_vec` will need to own its instances, so `to_vec` calls\n"
"`clone` on each item. Thus, the type stored in the slice must implement "
"`Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:127
msgid ""
"The `Copy` trait allows you to duplicate a value by only copying bits stored "
"on\n"
"the stack; no arbitrary code is necessary. See the [‚ÄúStack-Only Data:\n"
"Copy‚Äù][stack-only-data-copy]<!-- ignore --> section in Chapter 4 for more\n"
"information on `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:132
msgid ""
"The `Copy` trait doesn‚Äôt define any methods to prevent programmers from\n"
"overloading those methods and violating the assumption that no arbitrary "
"code\n"
"is being run. That way, all programmers can assume that copying a value will "
"be\n"
"very fast."
msgstr ""

#: src/appendix-03-derivable-traits.md:137
msgid ""
"You can derive `Copy` on any type whose parts all implement `Copy`. A type "
"that\n"
"implements `Copy` must also implement `Clone`, because a type that "
"implements\n"
"`Copy` has a trivial implementation of `Clone` that performs the same task "
"as\n"
"`Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:142
msgid ""
"The `Copy` trait is rarely required; types that implement `Copy` have\n"
"optimizations available, meaning you don‚Äôt have to call `clone`, which "
"makes\n"
"the code more concise."
msgstr ""

#: src/appendix-03-derivable-traits.md:146
msgid ""
"Everything possible with `Copy` you can also accomplish with `Clone`, but "
"the\n"
"code might be slower or have to use `clone` in places."
msgstr ""

#: src/appendix-03-derivable-traits.md:149
msgid "### `Hash` for Mapping a Value to a Value of Fixed Size"
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid ""
"The `Hash` trait allows you to take an instance of a type of arbitrary size "
"and\n"
"map that instance to a value of fixed size using a hash function. Deriving\n"
"`Hash` implements the `hash` method. The derived implementation of the "
"`hash`\n"
"method combines the result of calling `hash` on each of the parts of the "
"type,\n"
"meaning all fields or values must also implement `Hash` to derive `Hash`."
msgstr ""

#: src/appendix-03-derivable-traits.md:157
msgid ""
"An example of when `Hash` is required is in storing keys in a `HashMap<K, "
"V>`\n"
"to store data efficiently."
msgstr ""

#: src/appendix-03-derivable-traits.md:160
msgid "### `Default` for Default Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:162
msgid ""
"The `Default` trait allows you to create a default value for a type. "
"Deriving\n"
"`Default` implements the `default` function. The derived implementation of "
"the\n"
"`default` function calls the `default` function on each part of the type,\n"
"meaning all fields or values in the type must also implement `Default` to\n"
"derive `Default`."
msgstr ""

#: src/appendix-03-derivable-traits.md:168
msgid ""
"The `Default::default` function is commonly used in combination with the "
"struct\n"
"update syntax discussed in the [‚ÄúCreating Instances From Other Instances "
"With\n"
"Struct Update\n"
"Syntax‚Äù][creating-instances-from-other-instances-with-struct-update-"
"syntax]<!-- ignore -->\n"
"section in Chapter 5. You can customize a few fields of a struct and then\n"
"set and use a default value for the rest of the fields by using\n"
"`..Default::default()`."
msgstr ""

#: src/appendix-03-derivable-traits.md:176
msgid ""
"The `Default` trait is required when you use the method `unwrap_or_default` "
"on\n"
"`Option<T>` instances, for example. If the `Option<T>` is `None`, the "
"method\n"
"`unwrap_or_default` will return the result of `Default::default` for the "
"type\n"
"`T` stored in the `Option<T>`."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "## Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Rust\n"
"project provides. We‚Äôll look at automatic formatting, quick ways to apply\n"
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "### Automatic Formatting with `rustfmt`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"The `rustfmt` tool reformats your code according to the community code "
"style.\n"
"Many collaborative projects use `rustfmt` to prevent arguments about which\n"
"style to use when writing Rust: everyone formats their code using the tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:13
msgid "To install `rustfmt`, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:15
msgid ""
"```console\n"
"$ rustup component add rustfmt\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
"This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives "
"you\n"
"both `rustc` and `cargo`. To format any Cargo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:22
msgid ""
"```console\n"
"$ cargo fmt\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:26
msgid ""
"Running this command reformats all the Rust code in the current crate. This\n"
"should only change the code style, not the code semantics. For more "
"information\n"
"on `rustfmt`, see [its documentation][rustfmt]."
msgstr ""

#: src/appendix-04-useful-development-tools.md:32
msgid "### Fix Your Code with `rustfix`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"The rustfix tool is included with Rust installations and can automatically "
"fix\n"
"compiler warnings that have a clear way to correct the problem that‚Äôs "
"likely\n"
"what you want. It‚Äôs likely you‚Äôve seen compiler warnings before. For "
"example,\n"
"consider this code:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:41
msgid ""
"```rust\n"
"fn do_something() {}\n"
"\n"
"fn main() {\n"
"    for i in 0..100 {\n"
"        do_something();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:51
msgid ""
"Here, we‚Äôre calling the `do_something` function 100 times, but we never use "
"the\n"
"variable `i` in the body of the `for` loop. Rust warns us about that:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:54
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling myprogram v0.1.0 (file:///projects/myprogram)\n"
"warning: unused variable: `i`\n"
" --> src/main.rs:4:9\n"
"  |\n"
"4 |     for i in 0..100 {\n"
"  |         ^ help: consider using `_i` instead\n"
"  |\n"
"  = note: #[warn(unused_variables)] on by default\n"
"\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.50s\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:68
msgid ""
"The warning suggests that we use `_i` as a name instead: the underscore\n"
"indicates that we intend for this variable to be unused. We can "
"automatically\n"
"apply that suggestion using the `rustfix` tool by running the command "
"`cargo\n"
"fix`:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:73
msgid ""
"```console\n"
"$ cargo fix\n"
"    Checking myprogram v0.1.0 (file:///projects/myprogram)\n"
"      Fixing src/main.rs (1 fix)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:80
msgid ""
"When we look at *src/main.rs* again, we‚Äôll see that `cargo fix` has changed "
"the\n"
"code:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:85
msgid ""
"```rust\n"
"fn do_something() {}\n"
"\n"
"fn main() {\n"
"    for _i in 0..100 {\n"
"        do_something();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:95
msgid ""
"The `for` loop variable is now named `_i`, and the warning no longer appears."
msgstr ""

#: src/appendix-04-useful-development-tools.md:97
msgid ""
"You can also use the `cargo fix` command to transition your code between\n"
"different Rust editions. Editions are covered in Appendix E."
msgstr ""

#: src/appendix-04-useful-development-tools.md:100
msgid "### More Lints with Clippy"
msgstr ""

#: src/appendix-04-useful-development-tools.md:102
msgid ""
"The Clippy tool is a collection of lints to analyze your code so you can "
"catch\n"
"common mistakes and improve your Rust code."
msgstr ""

#: src/appendix-04-useful-development-tools.md:105
msgid "To install Clippy, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:107
msgid ""
"```console\n"
"$ rustup component add clippy\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:111
msgid "To run Clippy‚Äôs lints on any Cargo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:113
msgid ""
"```console\n"
"$ cargo clippy\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:117
msgid ""
"For example, say you write a program that uses an approximation of a\n"
"mathematical constant, such as pi, as this program does:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:122
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = 3.1415;\n"
"    let r = 8.0;\n"
"    println!(\"the area of the circle is {}\", x * r * r);\n"
"}\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:130
msgid "Running `cargo clippy` on this project results in this error:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:132
msgid ""
"```text\n"
"error: approximate value of `f{32, 64}::consts::PI` found\n"
" --> src/main.rs:2:13\n"
"  |\n"
"2 |     let x = 3.1415;\n"
"  |             ^^^^^^\n"
"  |\n"
"  = note: `#[deny(clippy::approx_constant)]` on by default\n"
"  = help: consider using the constant directly\n"
"  = help: for further information visit https://rust-lang.github.io/rust-"
"clippy/master/index.html#approx_constant\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:144
msgid ""
"This error lets you know that Rust already has a more precise `PI` constant\n"
"defined, and that your program would be more correct if you used the "
"constant\n"
"instead. You would then change your code to use the `PI` constant. The\n"
"following code doesn‚Äôt result in any errors or warnings from Clippy:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:151
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = std::f64::consts::PI;\n"
"    let r = 8.0;\n"
"    println!(\"the area of the circle is {}\", x * r * r);\n"
"}\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:159
msgid "For more information on Clippy, see [its documentation][clippy]."
msgstr ""

#: src/appendix-04-useful-development-tools.md:163
msgid "### IDE Integration Using `rust-analyzer`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:165
msgid ""
"To help IDE integration, the Rust community recommends using\n"
"[`rust-analyzer`][rust-analyzer]<!-- ignore -->. This tool is a set of\n"
"compiler-centric utilities that speaks the [Language Server Protocol]"
"[lsp]<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to\n"
"communicate with each other. Different clients can use `rust-analyzer`, such "
"as\n"
"[the Rust analyzer plug-in for Visual Studio Code][vscode]."
msgstr ""

#: src/appendix-04-useful-development-tools.md:175
msgid ""
"Visit the `rust-analyzer` project‚Äôs [home page][rust-analyzer]<!-- ignore --"
">\n"
"for installation instructions, then install the language server support in "
"your\n"
"particular IDE. Your IDE will gain abilities such as autocompletion, jump "
"to\n"
"definition, and inline errors."
msgstr ""

#: src/appendix-05-editions.md:1
msgid "## Appendix E - Editions"
msgstr ""

#: src/appendix-05-editions.md:3
msgid ""
"In Chapter 1, you saw that `cargo new` adds a bit of metadata to your\n"
"*Cargo.toml* file about an edition. This appendix talks about what that "
"means!"
msgstr ""

#: src/appendix-05-editions.md:6
msgid ""
"The Rust language and compiler have a six-week release cycle, meaning users "
"get\n"
"a constant stream of new features. Other programming languages release "
"larger\n"
"changes less often; Rust releases smaller updates more frequently. After a\n"
"while, all of these tiny changes add up. But from release to release, it can "
"be\n"
"difficult to look back and say, ‚ÄúWow, between Rust 1.10 and Rust 1.31, Rust "
"has\n"
"changed a lot!‚Äù"
msgstr ""

#: src/appendix-05-editions.md:13
msgid ""
"Every two or three years, the Rust team produces a new Rust *edition*. Each\n"
"edition brings together the features that have landed into a clear package "
"with\n"
"fully updated documentation and tooling. New editions ship as part of the "
"usual\n"
"six-week release process."
msgstr ""

#: src/appendix-05-editions.md:18
msgid "Editions serve different purposes for different people:"
msgstr ""

#: src/appendix-05-editions.md:20
msgid ""
"* For active Rust users, a new edition brings together incremental changes "
"into\n"
"  an easy-to-understand package.\n"
"* For non-users, a new edition signals that some major advancements have\n"
"  landed, which might make Rust worth another look.\n"
"* For those developing Rust, a new edition provides a rallying point for "
"the\n"
"  project as a whole."
msgstr ""

#: src/appendix-05-editions.md:27
msgid ""
"At the time of this writing, three Rust editions are available: Rust 2015, "
"Rust\n"
"2018, and Rust 2021. This book is written using Rust 2021 edition idioms."
msgstr ""

#: src/appendix-05-editions.md:30
msgid ""
"The `edition` key in *Cargo.toml* indicates which edition the compiler "
"should\n"
"use for your code. If the key doesn‚Äôt exist, Rust uses `2015` as the "
"edition\n"
"value for backward compatibility reasons."
msgstr ""

#: src/appendix-05-editions.md:34
msgid ""
"Each project can opt in to an edition other than the default 2015 edition.\n"
"Editions can contain incompatible changes, such as including a new keyword "
"that\n"
"conflicts with identifiers in code. However, unless you opt in to those\n"
"changes, your code will continue to compile even as you upgrade the Rust\n"
"compiler version you use."
msgstr ""

#: src/appendix-05-editions.md:40
msgid ""
"All Rust compiler versions support any edition that existed prior to that\n"
"compiler‚Äôs release, and they can link crates of any supported editions\n"
"together. Edition changes only affect the way the compiler initially parses\n"
"code. Therefore, if you‚Äôre using Rust 2015 and one of your dependencies "
"uses\n"
"Rust 2018, your project will compile and be able to use that dependency. "
"The\n"
"opposite situation, where your project uses Rust 2018 and a dependency uses\n"
"Rust 2015, works as well."
msgstr ""

#: src/appendix-05-editions.md:48
msgid ""
"To be clear: most features will be available on all editions. Developers "
"using\n"
"any Rust edition will continue to see improvements as new stable releases "
"are\n"
"made. However, in some cases, mainly when new keywords are added, some new\n"
"features might only be available in later editions. You will need to switch\n"
"editions if you want to take advantage of such features."
msgstr ""

#: src/appendix-05-editions.md:54
msgid ""
"For more details, the [*Edition\n"
"Guide*](https://doc.rust-lang.org/stable/edition-guide/) is a complete book\n"
"about editions that enumerates the differences between editions and "
"explains\n"
"how to automatically upgrade your code to a new edition via `cargo fix`."
msgstr ""

#: src/appendix-06-translation.md:1
msgid "## Appendix F: Translations of the Book"
msgstr ""

#: src/appendix-06-translation.md:3
msgid ""
"For resources in languages other than English. Most are still in progress; "
"see\n"
"[the Translations label][label] to help or let us know about a new "
"translation!"
msgstr ""

#: src/appendix-06-translation.md:8
msgid ""
"- [Portugu√™s](https://github.com/rust-br/rust-book-pt-br) (BR)\n"
"- [Portugu√™s](https://github.com/nunojesus/rust-book-pt-pt) (PT)\n"
"- [ÁÆÄ‰Ωì‰∏≠Êñá](https://github.com/KaiserY/trpl-zh-cn)\n"
"- [Ê≠£È´î‰∏≠Êñá](https://github.com/rust-tw/book-tw)\n"
"- [–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞](https://github.com/pavloslav/rust-book-uk-ua)\n"
"- [Espa√±ol](https://github.com/thecodix/book), [alternate](https://github."
"com/ManRR/rust-book-es)\n"
"- [Italiano](https://github.com/EmanueleGurini/book_it)\n"
"- [–†—É—Å—Å–∫–∏–π](https://github.com/rust-lang-ru/book)\n"
"- [ÌïúÍµ≠Ïñ¥](https://github.com/rinthel/rust-lang-book-ko)\n"
"- [Êó•Êú¨Ë™û](https://github.com/rust-lang-ja/book-ja)\n"
"- [Fran√ßais](https://github.com/Jimskapt/rust-book-fr)\n"
"- [Polski](https://github.com/paytchoo/book-pl)\n"
"- [Cebuano](https://github.com/agentzero1/book)\n"
"- [Tagalog](https://github.com/josephace135/book)\n"
"- [Esperanto](https://github.com/psychoslave/Rust-libro)\n"
"- [ŒµŒªŒªŒ∑ŒΩŒπŒ∫ŒÆ](https://github.com/TChatzigiannakis/rust-book-greek)\n"
"- [Svenska](https://github.com/sebras/book)\n"
"- [Farsi](https://github.com/pomokhtari/rust-book-fa)\n"
"- [Deutsch](https://github.com/rust-lang-de/rustbook-de)\n"
"- [‡§π‡§ø‡§Ç‡§¶‡•Ä](https://github.com/venkatarun95/rust-book-hindi)\n"
"- [‡πÑ‡∏ó‡∏¢](https://github.com/rust-lang-th/book-th)\n"
"- [Danske](https://github.com/DanKHansen/book-dk)"
msgstr ""

#: src/appendix-07-nightly-rust.md:1
msgid "## Appendix G - How Rust is Made and ‚ÄúNightly Rust‚Äù"
msgstr ""

#: src/appendix-07-nightly-rust.md:3
msgid ""
"This appendix is about how Rust is made and how that affects you as a Rust\n"
"developer."
msgstr ""

#: src/appendix-07-nightly-rust.md:6
msgid "### Stability Without Stagnation"
msgstr ""

#: src/appendix-07-nightly-rust.md:8
msgid ""
"As a language, Rust cares a *lot* about the stability of your code. We want\n"
"Rust to be a rock-solid foundation you can build on, and if things were\n"
"constantly changing, that would be impossible. At the same time, if we "
"can‚Äôt\n"
"experiment with new features, we may not find out important flaws until "
"after\n"
"their release, when we can no longer change things."
msgstr ""

#: src/appendix-07-nightly-rust.md:14
msgid ""
"Our solution to this problem is what we call ‚Äústability without "
"stagnation‚Äù,\n"
"and our guiding principle is this: you should never have to fear upgrading "
"to a\n"
"new version of stable Rust. Each upgrade should be painless, but should "
"also\n"
"bring you new features, fewer bugs, and faster compile times."
msgstr ""

#: src/appendix-07-nightly-rust.md:19
msgid "### Choo, Choo! Release Channels and Riding the Trains"
msgstr ""

#: src/appendix-07-nightly-rust.md:21
msgid ""
"Rust development operates on a *train schedule*. That is, all development "
"is\n"
"done on the `master` branch of the Rust repository. Releases follow a "
"software\n"
"release train model, which has been used by Cisco IOS and other software\n"
"projects. There are three *release channels* for Rust:"
msgstr ""

#: src/appendix-07-nightly-rust.md:26
msgid ""
"* Nightly\n"
"* Beta\n"
"* Stable"
msgstr ""

#: src/appendix-07-nightly-rust.md:30
msgid ""
"Most Rust developers primarily use the stable channel, but those who want "
"to\n"
"try out experimental new features may use nightly or beta."
msgstr ""

#: src/appendix-07-nightly-rust.md:33
msgid ""
"Here‚Äôs an example of how the development and release process works: let‚Äôs\n"
"assume that the Rust team is working on the release of Rust 1.5. That "
"release\n"
"happened in December of 2015, but it will provide us with realistic version\n"
"numbers. A new feature is added to Rust: a new commit lands on the `master`\n"
"branch. Each night, a new nightly version of Rust is produced. Every day is "
"a\n"
"release day, and these releases are created by our release infrastructure\n"
"automatically. So as time passes, our releases look like this, once a night:"
msgstr ""

#: src/appendix-07-nightly-rust.md:41
msgid ""
"```text\n"
"nightly: * - - * - - *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:45
msgid ""
"Every six weeks, it‚Äôs time to prepare a new release! The `beta` branch of "
"the\n"
"Rust repository branches off from the `master` branch used by nightly. Now,\n"
"there are two releases:"
msgstr ""

#: src/appendix-07-nightly-rust.md:49
msgid ""
"```text\n"
"nightly: * - - * - - *\n"
"                     |\n"
"beta:                *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:55
msgid ""
"Most Rust users do not use beta releases actively, but test against beta in\n"
"their CI system to help Rust discover possible regressions. In the "
"meantime,\n"
"there‚Äôs still a nightly release every night:"
msgstr ""

#: src/appendix-07-nightly-rust.md:59
msgid ""
"```text\n"
"nightly: * - - * - - * - - * - - *\n"
"                     |\n"
"beta:                *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:65
msgid ""
"Let‚Äôs say a regression is found. Good thing we had some time to test the "
"beta\n"
"release before the regression snuck into a stable release! The fix is "
"applied\n"
"to `master`, so that nightly is fixed, and then the fix is backported to "
"the\n"
"`beta` branch, and a new release of beta is produced:"
msgstr ""

#: src/appendix-07-nightly-rust.md:70
msgid ""
"```text\n"
"nightly: * - - * - - * - - * - - * - - *\n"
"                     |\n"
"beta:                * - - - - - - - - *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:76
msgid ""
"Six weeks after the first beta was created, it‚Äôs time for a stable release! "
"The\n"
"`stable` branch is produced from the `beta` branch:"
msgstr ""

#: src/appendix-07-nightly-rust.md:79
msgid ""
"```text\n"
"nightly: * - - * - - * - - * - - * - - * - * - *\n"
"                     |\n"
"beta:                * - - - - - - - - *\n"
"                                       |\n"
"stable:                                *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:87
msgid ""
"Hooray! Rust 1.5 is done! However, we‚Äôve forgotten one thing: because the "
"six\n"
"weeks have gone by, we also need a new beta of the *next* version of Rust, "
"1.6.\n"
"So after `stable` branches off of `beta`, the next version of `beta` "
"branches\n"
"off of `nightly` again:"
msgstr ""

#: src/appendix-07-nightly-rust.md:92
msgid ""
"```text\n"
"nightly: * - - * - - * - - * - - * - - * - * - *\n"
"                     |                         |\n"
"beta:                * - - - - - - - - *       *\n"
"                                       |\n"
"stable:                                *\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:100
msgid ""
"This is called the ‚Äútrain model‚Äù because every six weeks, a release ‚Äúleaves "
"the\n"
"station‚Äù, but still has to take a journey through the beta channel before "
"it\n"
"arrives as a stable release."
msgstr ""

#: src/appendix-07-nightly-rust.md:104
msgid ""
"Rust releases every six weeks, like clockwork. If you know the date of one "
"Rust\n"
"release, you can know the date of the next one: it‚Äôs six weeks later. A "
"nice\n"
"aspect of having releases scheduled every six weeks is that the next train "
"is\n"
"coming soon. If a feature happens to miss a particular release, there‚Äôs no "
"need\n"
"to worry: another one is happening in a short time! This helps reduce "
"pressure\n"
"to sneak possibly unpolished features in close to the release deadline."
msgstr ""

#: src/appendix-07-nightly-rust.md:111
msgid ""
"Thanks to this process, you can always check out the next build of Rust and\n"
"verify for yourself that it‚Äôs easy to upgrade to: if a beta release doesn‚Äôt\n"
"work as expected, you can report it to the team and get it fixed before the\n"
"next stable release happens! Breakage in a beta release is relatively rare, "
"but\n"
"`rustc` is still a piece of software, and bugs do exist."
msgstr ""

#: src/appendix-07-nightly-rust.md:117
msgid "### Unstable Features"
msgstr ""

#: src/appendix-07-nightly-rust.md:119
msgid ""
"There‚Äôs one more catch with this release model: unstable features. Rust uses "
"a\n"
"technique called ‚Äúfeature flags‚Äù to determine what features are enabled in "
"a\n"
"given release. If a new feature is under active development, it lands on\n"
"`master`, and therefore, in nightly, but behind a *feature flag*. If you, as "
"a\n"
"user, wish to try out the work-in-progress feature, you can, but you must "
"be\n"
"using a nightly release of Rust and annotate your source code with the\n"
"appropriate flag to opt in."
msgstr ""

#: src/appendix-07-nightly-rust.md:127
msgid ""
"If you‚Äôre using a beta or stable release of Rust, you can‚Äôt use any feature\n"
"flags. This is the key that allows us to get practical use with new "
"features\n"
"before we declare them stable forever. Those who wish to opt into the "
"bleeding\n"
"edge can do so, and those who want a rock-solid experience can stick with\n"
"stable and know that their code won‚Äôt break. Stability without stagnation."
msgstr ""

#: src/appendix-07-nightly-rust.md:133
msgid ""
"This book only contains information about stable features, as in-progress\n"
"features are still changing, and surely they‚Äôll be different between when "
"this\n"
"book was written and when they get enabled in stable builds. You can find\n"
"documentation for nightly-only features online."
msgstr ""

#: src/appendix-07-nightly-rust.md:138
msgid "### Rustup and the Role of Rust Nightly"
msgstr ""

#: src/appendix-07-nightly-rust.md:140
msgid ""
"Rustup makes it easy to change between different release channels of Rust, "
"on a\n"
"global or per-project basis. By default, you‚Äôll have stable Rust installed. "
"To\n"
"install nightly, for example:"
msgstr ""

#: src/appendix-07-nightly-rust.md:144
msgid ""
"```console\n"
"$ rustup toolchain install nightly\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:148
msgid ""
"You can see all of the *toolchains* (releases of Rust and associated\n"
"components) you have installed with `rustup` as well. Here‚Äôs an example on "
"one\n"
"of your authors‚Äô Windows computer:"
msgstr ""

#: src/appendix-07-nightly-rust.md:152
msgid ""
"```powershell\n"
"> rustup toolchain list\n"
"stable-x86_64-pc-windows-msvc (default)\n"
"beta-x86_64-pc-windows-msvc\n"
"nightly-x86_64-pc-windows-msvc\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:159
msgid ""
"As you can see, the stable toolchain is the default. Most Rust users use "
"stable\n"
"most of the time. You might want to use stable most of the time, but use\n"
"nightly on a specific project, because you care about a cutting-edge "
"feature.\n"
"To do so, you can use `rustup override` in that project‚Äôs directory to set "
"the\n"
"nightly toolchain as the one `rustup` should use when you‚Äôre in that "
"directory:"
msgstr ""

#: src/appendix-07-nightly-rust.md:165
msgid ""
"```console\n"
"$ cd ~/projects/needs-nightly\n"
"$ rustup override set nightly\n"
"```"
msgstr ""

#: src/appendix-07-nightly-rust.md:170
msgid ""
"Now, every time you call `rustc` or `cargo` inside of\n"
"*~/projects/needs-nightly*, `rustup` will make sure that you are using "
"nightly\n"
"Rust, rather than your default of stable Rust. This comes in handy when you\n"
"have a lot of Rust projects!"
msgstr ""

#: src/appendix-07-nightly-rust.md:175
msgid "### The RFC Process and Teams"
msgstr ""

#: src/appendix-07-nightly-rust.md:177
msgid ""
"So how do you learn about these new features? Rust‚Äôs development model "
"follows\n"
"a *Request For Comments (RFC) process*. If you‚Äôd like an improvement in "
"Rust,\n"
"you can write up a proposal, called an RFC."
msgstr ""

#: src/appendix-07-nightly-rust.md:181
msgid ""
"Anyone can write RFCs to improve Rust, and the proposals are reviewed and\n"
"discussed by the Rust team, which is comprised of many topic subteams. "
"There‚Äôs\n"
"a full list of the teams [on Rust‚Äôs\n"
"website](https://www.rust-lang.org/governance), which includes teams for\n"
"each area of the project: language design, compiler implementation,\n"
"infrastructure, documentation, and more. The appropriate team reads the\n"
"proposal and the comments, writes some comments of their own, and "
"eventually,\n"
"there‚Äôs consensus to accept or reject the feature."
msgstr ""

#: src/appendix-07-nightly-rust.md:190
msgid ""
"If the feature is accepted, an issue is opened on the Rust repository, and\n"
"someone can implement it. The person who implements it very well may not be "
"the\n"
"person who proposed the feature in the first place! When the implementation "
"is\n"
"ready, it lands on the `master` branch behind a feature gate, as we "
"discussed\n"
"in the [‚ÄúUnstable Features‚Äù](#unstable-features)<!-- ignore --> section."
msgstr ""

#: src/appendix-07-nightly-rust.md:196
msgid ""
"After some time, once Rust developers who use nightly releases have been "
"able\n"
"to try out the new feature, team members will discuss the feature, how it‚Äôs\n"
"worked out on nightly, and decide if it should make it into stable Rust or "
"not.\n"
"If the decision is to move forward, the feature gate is removed, and the\n"
"feature is now considered stable! It rides the trains into a new stable "
"release\n"
"of Rust."
msgstr ""
